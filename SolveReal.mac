/* Examples: solvereal(a*b+c=log(a+x),x)  
factoring the input may yield different results. Factoring is only done using sqfr() since factor can timeout factor(2^(1.1*x)+1)*/

load(to_poly_solve)$

simpsum:true$

[packagefile:true,partswitch:true,domain:real]$
define_variable(AllTrig,false,boolean)$
define_variable(uselambertw,true,boolean)$
define_variable(autonsolve,false,boolean)$
define_variable(solvar,x,any)$
define_variable(solvar2,x,any)$
define_variable(solsysvars,[],list)$
define_variable(NoSigFig,7,integer)$
/* define_variable(iteind,0,integer)$
define_variable(factind,0,integer)$ */  /* Nu lokalt i solvereal*/
define_variable(solvesteps,[],list)$
/* define_variable(dissolveradicals,true,boolean)$ Incorrect math*/ 
define_variable(dissolveabs,true,boolean)$
define_variable(showassumptions,true,boolean)$
define_variable(sepsolvecontext,true,boolean)$
define_variable(solverealtopoly,true,boolean)$
define_variable(solverealmaximasolve,true,boolean)$
newcontext(solreal)$context:initial$

containx(exprq,xqz):=block([],member(xqz,listofvars(exprq)))$
containanyx(exprq,xqz):=block([],not(lfreeof(xqz,listofvars(exprq)) ))$ /* for solvesystem */

matchdeclare([aliz,aliz2,aliz3,aliz4,aliz5],all)$
matchdeclare([alizx,alizx2],lambda([z],containx(z,solvar)))$
matchdeclare(aliz1ledx,lambda([z],is(op(z)#"*") and containx(z,solvar)))$
matchdeclare([aliznotx,aliznotx2,aliznotx3,aliznotx4],lambda([z],not(containx(z,solvar))))$
matchdeclare([aliznotxy,aliznotxy2,aliznotxy3],lambda([z],not(containx(z,solvar) or containx(z,solvar2) or is(z=0)) ))$
matchdeclare([aliznotanyx,aliznotanyx2],lambda([z],not(containanyx(z,cons(solvar,solsysvars)))))$
matchdeclare(alizadd,aliz+aliz=aliz)$
matchdeclare(alizeven,evenp)$
matchdeclare(alizodd,oddp)$
matchdeclare(alizoddnum,lambda([z],oddp(num(rationalize(z)))))$
matchdeclare(alizoddnumevendenom,lambda([z], oddp(num(rationalize(z))) and evenp(denom(rationalize(z))) ))$
matchdeclare(alizevennum,lambda([z],evenp(num(rationalize(z)))))$
matchdeclare(alizinteger,lambda([z],integerp(rationalize(z))))$
matchdeclare(aliznoninteger,lambda([z],not(integerp(rationalize(z)))))$
matchdeclare(aliznonnatural,lambda([z],numberp(z) and not(integerp(rationalize(z)) and z>0 )))$
matchdeclare(alizirrational,lambda([z],constantp(z) and not(numberp(z))))$
matchdeclare(alizneginteger,lambda([z],integerp(rationalize(z) and z<0 )))$
matchdeclare(aliznegative,lambda([z],is(z<0)))$
matchdeclare(aliznegative2,lambda([z],is(op(z)="-")))$
matchdeclare([alizpositive,alizpositive2],lambda([z],not(is(is(z>0)=false))))$
matchdeclare([aliznotzero,aliznotzero2],lambda([z],not(is(is(z#0)=false))))$
matchdeclare(alizimag,lambda([z],block(if is(freeof(%i,z)) then return(false),if abs(ev(imagpart(z)/realpart(z),numer))>10^-14 then return(true),return(false) )))$
matchdeclare(alizillinvtrig,lambda([z],is(z<-1 or z>1)))$
matchdeclare(alizbelowone,lambda([z],is(z<1)))$
matchdeclare(alizilllambertw,lambda([z],is(z>1/%e)))$
matchdeclare(alizlambertw2sol,lambda([z],is(z<1/%e and z>0)))$
matchdeclare(aliznum,numberp)$
matchdeclare(aliznotnum,lambda([z],not(numberp(z))))$
matchdeclare(alizaddop,lambda([z],is(op(z)="+" and containx(z,solvar))))$
matchdeclare(aliznotaddop,lambda([z],is(op(z)#"+")))$
matchdeclare(aliznotone,lambda([z],is(z#1) and is(z#1.0)))$
matchdeclare([alizatom,alizatom2],atom)$

tellsimpafter(-((aliz + aliz2) / aliz3), (-aliz - aliz2) / aliz3)$

defrule(swaprule,aliznotx=alizx,alizx=aliznotx)$
defrule(addrule,aliz+alizx=aliz2,alizx=aliz2-aliz)$
defrule(addrule2,aliz=aliz2+alizx,aliz-alizx=aliz2)$
defrule(prodrule,aliz*alizx=aliznotzero,(assume(notequal(aliz,0)),alizx=aliznotzero/aliz))$
defrule(prodrule4,aliznotanyx*alizx=aliz2,(assume(notequal(aliznotanyx,0)),alizx=aliz2/aliznotanyx))$
/* defrule(prodrule,aliz*alizx=aliz2,(assume(notequal(aliz,0)),alizx=aliz2/aliz))$ */
/* defrule(prodrule2,aliz=aliz2*alizx,aliz/alizx=aliz2)$ duer ikke at dividere med alizx */
defrule(prodrule2,aliznotx=aliz2*alizx,(assume(notequal(aliz2,0)),alizx=aliznotx/aliz2))$ /* aliz ændret til aliznotx da ellers kunne gå i ring med doubleexp */
defrule(prodrule3,alizx2*alizx^aliz=aliznotzero,(assume(notequal(alizx2,0)),alizx^aliz=aliznotzero/alizx2))$ /* Denne kan overse løsninger hvis løsninger til solvereal(alizx,solvar) også er løsninger til ligningen. Kan egentlig ikke se hvor denne har sin berettigelse. Fjernet i v.1.06*/
defrule(divrule,aliznotx/alizx=aliznotzero,alizx=aliznotx/aliznotzero)$
defrule(divrule2,aliznotzero=aliz2/alizx,aliznotzero*alizx=aliz2)$
defrule(divrule3,aliznotaddop/alizaddop=aliznotzero,alizaddop/aliznotaddop=1/aliznotzero)$ 
defrule(divrule4,aliz/alizx=aliz2,alizx*aliz2-aliz=0)$ /* risikerer at bytter rundt og rundt hvis x i tæller og nævner, men forsøger igen efter factor2*/
defrule(divrule5,aliz*alizx^alizneginteger=aliz2,expand(aliz-alizx^-alizneginteger*aliz2)=0)$
defrule(powrulezero,alizx^aliz=0,(assume(notequal(aliz,0)),alizx=0))$
defrule(powruleoddneg,alizx^alizoddnumevendenom=aliznegative,[])$ /* removes illegal solutions */
defrule(powruleodd,alizx^alizoddnumevendenom=aliz,(assume(aliz>=0),alizx=aliz^(1/alizoddnumevendenom)))$
defrule(powruleodd2,alizx^alizoddnum=aliz,(alizx=aliz^(1/alizoddnum)))$
defrule(powruleevenneg,alizx^alizevennum=aliznegative,[])$ /* removes illegal solutions */
defrule(powruleeven,alizx^alizevennum=aliz,(assume(aliz>=0),[alizx=aliz^(1/alizevennum),alizx=-aliz^(1/alizevennum)]))$
defrule(powruleirratneg,alizx^alizirrational=aliznegative,[])$
defrule(powruleirrat,alizx^alizirrational=aliz,(assume(aliz>=0),alizx=aliz^(1/alizirrational)))$
defrule(powrulenotnum,alizx^aliznotnum=aliz,(print(sconcat("Solution unsure. Because taking inverse power depends on ",aliznotnum, " and the sign of ",aliz )),assume(aliz>0),alizx=aliz^(1/aliznotnum)))$
defrule(expremoverule,%e^alizx=0,[])$ /* no solution */
/* defrule(powrul1,(aliz^(aliz3*alizx))/(aliz2^(aliz4*alizx))=aliz5,alizx*log(aliz^aliz3/aliz2^aliz4)=log(aliz5))$ */
/* defrule(powrul2,(aliz^(alizx))/(aliz2^(aliz4*alizx))=aliz5,alizx*log(aliz/aliz2^aliz4)=log(aliz5))$ */
/* defrule(powrul3,(aliz^(alizx))/(aliz2^(alizx))=aliz5,alizx*log(aliz/aliz2)=log(aliz5))$ */
defrule(exprule,aliz^alizx=alizpositive,(assume(alizpositive>0,aliz>0),alizx=log(alizpositive)/log(aliz)))$
defrule(powrulexp,aliz^alizx,%e^(log(aliz)*alizx))$
defrule(lnrule,log(alizx)=aliz,alizx=%e^(aliz))$
defrule(sinsolruleall,sin(alizx)=aliz,[alizx=asin(aliz)+%Z*2*%pi,alizx=-asin(aliz)+%pi*(2*%Z+1)])$
defrule(cossolruleall,cos(alizx)=aliz,[alizx=acos(aliz)+%Z*2*%pi,alizx=-acos(aliz)+2*%pi*%Z])$
defrule(tansolruleall,tan(alizx)=aliz,[alizx=atan(aliz)+%Z*%pi])$
defrule(sinsolrule,sin(alizx)=aliz,alizx=asin(aliz))$
defrule(cossolrule,cos(alizx)=aliz,alizx=acos(aliz))$
defrule(tansolrule,tan(alizx)=aliz,alizx=atan(aliz))$
defrule(asinsolrule,asin(alizx)=aliz,alizx=sin(aliz))$
defrule(acossolrule,acos(alizx)=aliz,alizx=cos(aliz))$
defrule(atansolrule,atan(alizx)=aliz,alizx=tan(aliz))$
defrule(sinhsolrule,sinh(alizx)=aliz,alizx=asinh(aliz))$
defrule(coshillrule,cosh(alizx)=alizbelowone,[])$
defrule(coshsolrule,cosh(alizx)=aliz,(assume(aliz>=1),[alizx=acosh(aliz),alizx=-acosh(aliz)]))$
defrule(tanhillrule,tanh(alizx)=alizillinvtrig,[])$
defrule(tanhsolrule,tanh(alizx)=aliz,(assume(aliz>-1,aliz<1),alizx=atanh(aliz)))$
defrule(divzerorule,alizx/aliznotzero=0,(assume(notequal(aliznotzero,0)),alizx=0))$
defrule(absrule,abs(alizx)=aliz,[alizx=aliz,alizx=-aliz])$
defrule(absremoverule,abs(alizx)=aliznegative,[])$
defrule(lambertwillrule,alizx*%e^(alizx)-alizilllambertw=0,[])$
defrule(lambertwrule2sol,alizx*%e^(alizx)-alizlambertw2sol=0,([alizx=generalized_lambert_w(0,alizlambertw2sol),alizx=generalized_lambert_w(-1,alizlambertw2sol)]))$
defrule(lambertwrule1sol,alizx*%e^(alizx)-aliznegative=0,(assume(aliznegative<0),[alizx=generalized_lambert_w(0,aliznegative)]))$
defrule(lambertwrulegeneral,alizx*%e^(alizx)+aliz=0,(assume(aliz>1/%e),print("The lambert_w function is two-valued for values from -1/%e to 0"),[alizx=lambert_w(-aliz)]))$
defrule(lambertwrule2,
aliznotx*alizpositive^(aliznotzero*solvar+aliznotx2)+aliznotx3+aliznotx4*solvar=0,
block([z,numer:not(uselambertw)],z:aliznotzero*log(alizpositive)/aliznotx4*aliznotx*alizpositive^(aliznotx2-aliznotzero*aliznotx3/aliznotx4),
if z<-1/%e then return([]),if z<0 then return([solvar=-generalized_lambert_w(0,z)/(aliznotzero*log(alizpositive))-aliznotx3/aliznotx4,
solvar=-generalized_lambert_w(-1,z)/(aliznotzero*log(alizpositive))-aliznotx3/aliznotx4]),solvar=-lambert_w(z)/(aliznotzero*log(alizpositive))-aliznotx3/aliznotx4))$
defrule(fracrule,aliznotx3*(alizx+aliznotx)/(alizx+aliznotx2),aliznotx3+aliznotx3*(aliznotx-aliznotx2)/(alizx+aliznotx2))$

/* rule which expands in order to decrease the number of variables fx: 2x+3(x-2)=0 reduceres */
expandrule(exprq):=block([scq],
scq:countvar(exprq,solvar),
if scq<2 then return(false),
exprq:expand(lhs(exprq)-rhs(exprq)=0),
if countvar(exprq,solvar)<scq then return (exprq),
false
)$

logsimp:false$
defrule(toexpp,alizpositive*aliznotx^alizx,%e^(log(aliznotx)*alizx+log(alizpositive)))$
defrule(toexpm,aliznegative2*aliznotx^alizx,-%e^(log(aliznotx)*alizx+log(-aliznegative2)))$
logsimp:true$
defrule(simpdiv,(alizatom*aliznotone)/(aliznotone+aliznum),alizatom/(1+aliznum/aliznotone))$
/* defrule(simpdivexpt,(aliz2*%e^aliz)/(%e^aliz+aliznotone),aliz2/(1+aliznotone*%e^-aliz))$ kan give uendelig løkke simpdivexpt(-%e^(5*x+5*%c)/(%e^(5*x+5*%c)-1)) */

defrule(powundef,aliznegative^aliznoninteger,qundef:true)$
/* defrule(powundef,aliznegative^aliznoninteger,error("man kan ikke tage roden af et negativt tal."))$ */
defrule(sqrtundef,sqrt(aliznegative),error("man kan ikke tage kvadratroden af et negativt tal."))$
defrule(imagundef,alizimag,error("Ugyldig løsning fjernet"))$
defrule(asinundef,asin(alizillinvtrig),error("inverse trig error."))$
defrule(acosundef,acos(alizillinvtrig),error("inverse trig error."))$
defrule(ReplaceFirstRadical,alizx^aliznoninteger,(powno:powno+1,if powno>1 then alizx^aliznoninteger  else (radicalsubst:[alizx,aliznoninteger],powx)))$
/* defrule(ReplaceFirstRadical,alizx^aliznoninteger,(if powstop then alizx^aliznoninteger  else (powstop:true,radicalsubst:[alizx,aliznoninteger],powx)))$ */
defrule(ReplaceFirstAbs,abs(alizx),(absno:absno+1,if absno>1 then abs(alizx) else (abssubst:alizx,absx)))$

defrule(delogisticrule,aliznotxy*'diff(solvar,solvar2)+aliznotxy2*solvar+aliznotxy3*solvar^2=0,[solvar=0,solvar=-aliznotxy2/aliznotxy3,solvar=-(aliznotxy2/aliznotxy3)/(1+%c*%e^(aliznotxy2/aliznotxy*solvar2))])$
defrule(sinhrule,%e^aliz-%e^-aliz,2*sinh(aliz))$
defrule(coshrule,%e^aliz+%e^-aliz,2*cosh(aliz))$
defrule(tanhrule,sinh(aliz)/cosh(aliz),tanh(aliz))$

/* To compex polar notation */
infix("CVinkel",180,180)$
infix("CVinkelgrad",180,180)$
infix("CVinkelO",180,180)$
"CVinkel"(r,v):=expand(r*(cos(v)+%i*sin(v)))$
"CVinkelgrad"(r,v):=expand(r*(cos(v*%pi/180)+%i*sin(v*%pi/180)))$
ConvertToPolarAngleNotation(z,qrad):=block([qarg,qabs,qf],z:rectform(z),if qrad then qf:1 else qf:180/%pi,qabs:abs(z),qarg:carg(z)*qf,ev(qabs CVinkelO qarg,noeval))$

/* Denne sektion var tidligere i dll-filen som settingsstring og funcdefinitions*/
display2d:false$ratprint:false$numer:false$ 
dotscrules:true$ /* dotproduct -> * when scalar involved*/
numer_pbranch:true$/* (-2)^0,75 konverteres da til imaginærtal. Må gøre det lidt nemmere at identificere imag løsninger*/
ratsimpexpons:true$/*simplify exponents*/
assumescalar:all$/*variables assumes scalar if not declare(x,nonscalar) og senere kill(x)*/
logabs:true$/*integrate(1/x,x)=log(abs(x))*/
breakup:false$/*3. og 4. gradspolynomier deles ikke op i underudtryk*/
algebraic:false$/*false er default value, simplifikation af algebraiske heltal bl.a. noget med %i. Udtryk der er relle bliver ikke reduceret så %i fjernes helt hvis denne er false*/
logexpand:true$/*alle log regneregler   true: log(a^x)=x*log(a)  all: log(a*b)=log(a)+log(b)  super: log(a/b)=log(a)-log(b)*/
triginverses:all$/*noget med sin^-1(sin(x))=x altid og begge veje*/
intanalysis:false$/*Kan løse flere bestemte integraler. Noget med ikke at søge efter poler i området og altid integrere.*/
listconstvars:true$/*for at %i også kommer med blandt variable så kompleks kan findes*/
keepfloat:true$/*sørger for at der ikke omdannes fra decimaltal til brøk ved eksakt når det er nødvendigt at bruge numeriske metoder*/
fpprintprec:0$/*default*/
rootsepsilon:1E-20$ /*1E-7 default used by realroots. */
algepsilon:1E+16$/*1E+8 default used by algsys. But how?*/
errcatch(remrule("^^",all))$
ev(tellsimp(0 ^ 0, 1), simp: false)$
matchdeclare(aliznum,numberp)$
matchdeclare(alizfloat,floatnump)$
defrule(scinotrul,aliznum,scinot(aliznum))$
defrule(dectalrul,aliz,dectal(aliz))$ /* ændret i version 1.07 defrule(dectalrul,aliznum,dectal(aliznum))$ */
defrule(floatrul,alizfloat,dectal(alizfloat))$
defrule(msinrul,sin(aliz),sing(180/%pi*aliz))$
defrule(mcosrul,cos(aliz),cosg(180/%pi*aliz))$
defrule(mtanrul,tan(aliz),tang(180/%pi*aliz))$
defrule(masinrul,asin(aliz),%pi/180*asing(aliz))$
defrule(macosrul,acos(aliz),%pi/180*acosg(aliz))$
defrule(matanrul,atan(aliz),%pi/180*atang(aliz))$
defrule(mlogrul,log(aliz),lgog(aliz)/lgog(%e))$
defrule(merul,%e^aliznotnum,10^(lgog(%e)*aliznotnum))$
dectalallNum(udt):=block([qout],udt:ev(udt,lgog(x):=if x=%e then 0.4342944819032518 elseif numberp(x) then ev(log(x)/log(10),numer) else 'lgog(x),numer),qout:errcatch(apply1(udt,dectalrul)),if qout=[] then udt else qout[1])$
dectalall(udt):=block([qout],qout:errcatch(apply1(udt,floatrul)),if qout=[] then udt else qout[1])$
/* fra funcdef*/
infix("~",135,135)$
infix("×",135,135)$
"~"(qwa,qwb):=if not(scalarp(qwa) or scalarp(qwb)) then (if not(matrixp(qwa) and matrixp(qwb)) then qwa×qwb elseif length(qwa)=3 and length(qwb)=3 then matrix( qwa[2]*qwb[3]-qwa[3]*qwb[2], qwa[3]*qwb[1]-qwa[1]*qwb[3], qwa[1]*qwb[2]-qwa[2]*qwb[1]) else(error("vektorproduktet er kun defineret for vektorer af dimension 3"))) else qwa*qwb$                                                                                                                                       
infix("¤",115,115)$
"¤"(qwa,qwb):=block(if scalarp(qwa) or scalarp(qwb) then return(qwa*qwb) else return(qwa.qwb))$
vecmag(qwa):=if nonscalarp(qwa) then (if matrixp(qwa) then sqrt(conjugate(transpose(qwa)) . qwa) else 'vecmag(qwa)) else abs(qwa)$
tvvec(qwa):=if scalarp(qwa) then error("Tværvektor er ikke defineret for en skalar") else (if length(qwa)=2 then matrix(-qwa[2],qwa[1]) else error("Tværvektor er kun defineret to-dimensionelle vektorer"))$
ConvertToDegr(udt):=block([],applyb1(udt,msinrul,mcosrul,mtanrul,masinrul,macosrul,matanrul))$
ConvertLog(udt):=block([],udt:ratsimp(apply1(udt,merul,mlogrul)),ev(udt,lgog(10)=1))$
ConvertLogN(udt):=block([],udt:ratsimp(apply1(udt,merul,mlogrul)),ev(udt,lgog(10)=1,lgog(%e)=0.4342944819032518))$
scinot(udt):=block([talfakt,antbsf],if not(numberp(udt)) then return(udt),if udt=0 then return(0),if abs(udt)<1 then antbsf:NoSigFig+4 else antbsf:NoSigFig+4,if udt<0 then antbsf:antbsf+1,(if udt<-10 or (udt>-1 and udt<1) or udt>10 then return(sremove(" ",printf(false,concat("~",antbsf,"e"),udt))) else return(dectal(udt))))$
scinotall(udt):=block([],apply1(udt,scinotrul))$

dectal(udt):=block([qudt,antbsf],
if numberp(udt) then go(hop),
if atom(udt)  then return(printf(false,concat("~a"),udt)),
if not(numberp(udt)) then return(udt),
hop,
if udt=0 or udt=0.0 then return(0),qudt:abs(udt),
 if qudt<10^-4 then return(scinot(udt)) elseif qudt>10^NoSigFig then return(scinot(udt)),
if qudt>1 then antbsf:NoSigFig+1 else antbsf:NoSigFig+2-floor(log(qudt)/log(10)),
if udt<0 then antbsf:antbsf+1,
udt:printf(false,concat("~",antbsf,"f"),udt),udt:striml(" ",udt),udt:strimr("0",udt),strimr(".",udt) 
)$

funp1(fun,exp):=block([inflag],inflag:true,if mapatom(exp) then false else (if inpart(exp,0) = fun then true else member(true,maplist(lambda([q],funp1(fun,q)),exp))))$
funp2(fun,exp,var):=block([inflag],inflag:true,if mapatom(exp) then false else (if inpart(exp,0) = fun and member(var,listofvars(exp)) then true else member(true,maplist(lambda([q],funp2(fun,q,var)),exp))))$
funp(fun,exp,[var]):=if var = [] then funp1(fun,exp) else (if length(var) = 1 then funp2(fun,exp,first(var)) else error("too many arguments to funp"))$ /* test if fun is in exp */
GetReal(lign):=block([inlign,kond],
	if not(freeof(%if,lign)) then (inlign:args(lign)[2][1],kond:args(lign)[1]) else inlign:lign,
	if not(freeof(%i,carg,parg,kond)) then kond:[],
	if numberp(ev(float(ev(imagpart(rhs(inlign)),simp)),simp)) then  (if (is(abs(ev(imagpart(ev(float(ev(rhs(inlign),simp)),simp,numer)),simp))<10^(-NoSigFig))) then (if freeof(%i,inlign) then go(slutqw) else (inlign:ev(inlign,numer),go(slutqw))) else (return([]))), 
	if freeof(%i,ev(inlign,%z0:0,%z1:0)) then go(slutqw),
	inlign:trigsimp(rectform(inlign)),
	slutqw,
	if not(freeof(%if,lign)) and kond#[] then inlign:(%if(kond,[inlign],args(lign)[3])),
	if freeof(%i,inlign) then return(inlign) else return([]) 
)$
RemoveImag(lignliste):=block([iqw,outlistq],if lignliste=all then return(all),if lignliste=[] then return([]),lignliste:ev(lignliste,%z0:0,%z1:0),outlistq:[],iqw:1,startq, outlistq:append(outlistq,[GetReal(lignliste[iqw])]),iqw:iqw+1,if iqw<=length(lignliste) then go(startq),outlistq:flatten(outlistq),outlistq)$
ContainsTrig(udt):=block([],not(freeof(sin,cos,tan,acos,asin,atan,udt)))$

RealOnly(zqw):=if freeof(%i,zqw) then zqw else error()$
CheckDef(zqw,qvar):=block(if not(freeof(%i,zqw)) then error() elseif maybe(equal(parse_string(qvar),eval_string(qvar)))=false then error() else zqw)$

strtonum(exp):=if stringp(exp) then parse_string(exp) else exp$

/*Counts the number of occurences of a varible(or subexpression) in an expression */
countvar(exprq,varq):=block([qi:0,partswitch:true,varc:0],
startq,
if inpart(exprq,qi)=end then (return(varc)),
if inpart(exprq,qi)=varq then (varc:varc+1),
if not(atom(inpart(exprq,qi))) then varc:varc+countvar(inpart(exprq,qi),varq),
qi:qi+1,
go(startq)
)$

logbase(qa,qb):=simplify(log(qa)/log(qb))$ /*tidligere med radcan. Gav problemer for log(10)->log(5)+log(2): logbase(a,b):=radcan(log(a)/log(b))$ */
log10(qa):=logbase(qa,10)$

/* Performs regression on the function F(x) ex. GeneralRegr(a*x^2+b*x+c,x,[1,2,3,4,5,6],[2,4,6,8,5,3],1e-4,[a=1])*/
GeneralRegr(Fw,qvar,Xq,Yq,qeps,qguess):=block([qi,qvars,qvar2,guesslist,fom,qout,r2,qmy,lbfgs_nfeval_max:50000],
	load(lbfgs),
	Fq(qvar2):=subst(qvar2,qvar,''Fw),
	qvars:delete(x,listofvars(Fw)),
	guesslist:makelist(
		(if member(zxq,listofvars(qguess)) then (
			qi:1,
			do(
				if length(qguess)<qi then return(1),
				if lhs(qguess[qi])=zxq then return(rhs(qguess[qi])),
				qi:qi+1
			)
			)
		else
			1
		),zxq,qvars),
	fom:((1/length(Xq))*sum((Fq(Xq[i]) - Yq[i])^2, i, 1, length(Xq))),
	qout:lbfgs(fom,qvars,guesslist,qeps,[-1,0]),
	if qout=[] then( 
		print("Unable to converge. Try lowering the eps or increase lbfgs_nfeval_max")
		)
	else(
Fq(qvar2):=subst(qvar2,qvar,ev(Fw,qout)),
qmy:1/length(Xq)*sum(Yq[qi],qi,1,length(Yq)),
r2:sum((Fq(Xq[qi])-qmy)^2,qi,1,length(Xq))/sum((Yq[qi]-qmy)^2,qi,1,length(Yq)),print(concat("R^2=",r2)),
Fq(qvar))
)$


NIntegrate(udt,var,x0,x1):=block([res1,res2,numer,fpprintprec:2000],
if x0=minf or x1=inf then res1:quad_qagi(udt,var,x0,x1,'epsrel=1d-13) else res1:quad_qags(udt,var,x0,x1),
if res1[4]=0 then return (res1[1]) else res1:quad_qag(udt,var,x0,x1,1),
if res1[4]=0 then return (res1[1]) else res1:Integrate(udt,var,x0,x1),
if res1#[] then return (res1),
integrate(udt,var,x0,x1))$

Integrate(udt,var,x0,x1):=block([res1,res2,numer,qindef],numer:false,udt:rationalize(udt),
if x0#minf and x1#inf then (qindef:integrate(udt,var),if freeof(integrate,qindef) then return(subst(x1,var,qindef)-subst(x0,var,qindef))),
errcatch(res1:ev(integrate(udt,var,x0,x1),numer=false)),
if not(numberp(x0) and numberp(x1)) and x0#minf and x1#inf  then return(res1),
if numberp(ev(res1,numer)) then return(res1),res1:ev(res1,numer),if numberp(res1) then return(res1),errcatch(res2:ldefint(udt,var,x0,x1)),
if numberp(res2) then return(res2),
res2:NIntegrate(udt,var,x0,x1),
if numberp(res2) then return(res2),res1)$

zerorule(exprq):=block([indq,ledq,restq,xledq,exprq2],partswitch:true,
if op(exprq)#"=" or inpart(exprq,3)#end then return(exprq),if CheckSolved(exprq) then return(exprq),
/* exprq2:factor(lhs(exprq)-rhs(exprq))=0, */
exprq2:factoreq(exprq),
exprq2:lhs(exprq2)-rhs(exprq2),
if op(exprq2)="-" and part(exprq2,2)=end then exprq2:-exprq2,
if not(op(exprq2)="*") then 
	exprq2:sqfr(exprq2)=0 
else 
	exprq2:exprq2=0,
if rhs(exprq2)#0 then return(exprq),
if op(lhs(exprq2))="-" then exprq2:-exprq2,
if op(lhs(exprq2))#"*" then return(exprq),
restq:1,xledq:0,indq:1,
startq,
ledq:inpart(exprq2,1,indq),
if ledq=end then go (slutq),
if containx(ledq,solvar) and xledq=0 then 
	xledq:ledq 
else 
	restq:restq*ledq,
indq:indq+1,
go( startq),
slutq,
if xledq=0 then 
	return (exprq) 
elseif not(containanyx(restq,cons(solvar,solsysvars))) then 
	return(xledq=0) 
else 
	return([restq=0,xledq=0])
)$

/* logcontract that doesn't increase the size of expression enourmously*/
logcontract2(exprq):=block([exprq,exprq2,inpsiz],
inpsiz:exprsize(exprq),
exprq2:logcontract(exprq),
if exprsize(exprq2)<2*inpsiz then return(exprq2) else return(exprq)
)$

 /*algsysforsøg v1.06 pga. for få cifre med realroots*/
solvepoly(exprq):=block([exprq2,aqz,bqz,cqz,qsol,realonly:true],
exprq2:lhs(exprq)-rhs(exprq),
if not(polynomialp(exprq2,[solvar],lambda([z],atom(z) or constantp(z)),integerp)) then return (exprq),
if polynomialp(exprq2,[solvar],lambda([z],atom(z) or constantp(z)),lambda([z],is(z<2 and z>=0))) then return (exprq),
if polynomialp(exprq2,[solvar],lambda([z],atom(z) or constantp(z)),lambda([z],is(z<3 and z>=0))) then (
aqz:coeff(exprq2,solvar,2),
bqz:coeff(exprq2,solvar,1),
cqz:coeff(exprq2,solvar,0),
if aqz=0 or bqz=0 or cqz=0 then return(exprq) else return(if is(bqz^2-4*aqz*cqz<0)=true then ([]) else ([solvar=(-bqz+sqrt(bqz^2-4*aqz*cqz))/(2*aqz),solvar=(-bqz-sqrt(bqz^2-4*aqz*cqz))/(2*aqz)]))),
if polynomialp(exprq2,[solvar],'constantp,'integerp) then (
    qsol:flatten(ev(algsys([exprq2],[solvar]),numer)),
    if qsol=[] then
        return(ev(realroots(exprq2),numer))
    else return(qsol)
    ),
exprq
)$

ConvertToReal(qexpr):=block([nexpr],
if freeof(%i,qexpr) then return(qexpr),
nexpr:trigsimp(rectform(qexpr)),
if freeof(%i,nexpr) then return(nexpr),
nexpr:ev(rectform(qexpr),numer),
if ev(imagpart(nexpr)/realpart(nexpr),numer)<10^-14 then return(realpart(nexpr)),
qexpr
)$

RemoveUndefined(eqnw,sollistq):=block([indq,indq2,solq,sollistq2,delq],
if length(sollistq)=0 then return(sollistq),
if op(eqnw)=end then return(sollistq),
indq:0,sollistq2:[],
startq,
indq:indq+1,
indq2:1,
if length(sollistq)<indq then go(slutq),
solq:sollistq[indq],
if IsSolved(solq,solvar)=false then (sollistq2:append(sollistq2,[solq]),go(startq)),
if do(
	delq:inpart(eqnw,indq2),
	if delq=end then return(true),
	errcatch(if powundef(subst(solq,delq)) then return(false)),
	if errcatch(imagundef(ev(ev(delq,solq),numer)))=[] then return(false),
	if errcatch(asinundef(ev(delq,solq)))=[] then return(false),
	if errcatch(acosundef(ev(delq,solq)))=[] then return(false),
	indq2:indq2+1
	) then sollistq2:append(sollistq2,[solq]),
go(startq),
slutq,
indq:1,
do(
	sollistq2:RemoveUndefined(inpart(eqnw,indq),sollistq2),
	indq:indq+1,
	if inpart(indq,eqnw)=end then return(sollistq2)
	)
)$

RemoveIncorrect(sollistq):=block([indq,sollistq2,solq],
indq:0,sollistq2:[],
if length(sollistq)=0 then return(sollistq),
if domain=complex then return(sollistq),
do(
indq:indq+1,
solq:sollistq[indq],
/* med numer virker flg ikke assume(x>=-1/3) , is(equal(x,-3/2)),numer men det er vel af en grund*/
/* if ev(is(equal(lhs(solq),rhs(solq))),numer)#false then sollistq2:append(sollistq2,[solq]), */
if is(equal(lhs(solq),rhs(solq)))#false then sollistq2:append(sollistq2,[solq]),
if length(sollistq)=indq then return(sollistq2)
)
)$

RemoveIncorrect2(lignq,sollistq):=block([indq:0,sollistq2:[],solq],indq:0,sollistq2:[],
if length(sollistq)=0 then return(sollistq),
do(
	indq:indq+1,
	solq:sollistq[indq],
	if is(equal(subst(solq,lhs(lignq)),subst(solq,rhs(lignq))))#false then sollistq2:append(sollistq2,[solq]),
	if length(sollistq)=indq then return(sollistq2)
)
)$


IsSameOp(lignq):=block([],
if op(lhs(lignq))=op(rhs(lignq)) then 
	return(true) 
else 
	return(false)
)$

RemoveSameOp(lignq):=block([qop],
qop:op(lhs(lignq)),
if not(IsSameOp(lignq)) then 
	return(lignq),
if qop=sin then 
	return(inpart(lhs(lignq),1)=inpart(rhs(lignq),1)),
lignq
)$

ExpandIntegerSolution(eqw):=block([lisq,expqw,expqw2],
kill(%Z),
if freeof(%Z,eqw) then return(eqw),if length(GetContextFacts(initial,solvar))+length(GetContextFacts(solreal,solvar))<2 then return(eqw),
lisq:[],
expqw:lhs(eqw)-rhs(eqw),
%Z:-100,
do(
	%Z:%Z+1,
	expqw2:ev(expqw),
	if is(equal(expqw2,0))#false then 
		lisq:append(lisq,[ev(eqw)]),
	if %Z>100 then return()
),
kill(%Z),
lisq
)$

/* Returns facts about variable in context qcont */
GetContextFacts(qcont,qvar):=block([qsavecon,outp],
qsavecon:context,
context:qcont,
qutp:facts(qvar),
context:qsavecon,
qutp
)$

DoubleExp(lignq):=block([qvs,ql1,ql2,qadd,qop],qadd:0,
qvs:ev(applyb1(lhs(lignq)-rhs(lignq),toexpm,toexpp),logsimp=false),
if not (op(qvs)="+") then return(lignq),
ql1:inpart(qvs,1),
ql2:inpart(qvs,2),
if not(inpart(qvs,3)=end) then return(lignq),
if op(ql1)=end or op(ql2)=end then return(lignq),
if op(ql1)="-" and op(ql2)#"-" then (ql1:-1*ql1,go(next1)),
if op(ql2)="-" then (ql2:-1*ql2,go(next1)),
qadd:log(-1),
next1,
qop:op(ql1),
if not(qop=op(ql2)) then return(lignq),
if qop="^" and inpart(ql1,1)=inpart(ql2,1) then 
	return(inpart(ql1,2)-inpart(ql2,2)+qadd=0),
if qop="/" and part(ql1,2)=part(ql2,2) then 
	if qadd=0 then 
		return(part(ql1,1)-part(ql2,1)=0) 
	else 
		return(part(ql1,1)+part(ql2,1)=0),
if qop="^" or qop="+" or qop="-" then return(lignq),
lignq
)$

/*Used to remove %union() result from to_poly_solve. applied: scanmap(RemoveUnion,expr)*/
RemoveUnion(qexpr):=block([],
if op(qexpr)#%union then return(qexpr)
else return(args(qexpr)) 
)$

CheckSolved(lignqw):=block([],
if lhs(lignqw)#solvar then return(false),
if freeof(solvar,rhs(lignqw)) then true else false
)$

CheckAllSolved(lignql):=block([indq:0],
if not(listp(lignql)) then return(false),
do(
	indq:indq+1,
	if indq>length(lignql) then return (true),
	if not(CheckSolved(lignql[indq])) then return(false)
)
)$

CheckSolvedVar(lignqw,varq):=block([],
if lhs(lignqw)#varq then return(false),
if freeof(solvar,rhs(lignqw)) then true else false
)$

/* Checks if expression is factored eg. -2*(x+2) -(x+2)^2*/
IsFactored(exprq):=block([],
if op(exprq)="-" then 
	(if part(exprq,2)=end 
		then 
			exprq:part(exprq,1) 
		else 
			return(false)
	),
if op(exprq)="/" then exprq:part(exprq,1),
if op(exprq)="*" then return(true),
if op(exprq)="^" then (if not(containx(part(exprq,2),solvar)) then return(true)), false)$

factoreq(lignqw):=block([exprq,exprq2,inpsiz],
if CheckSolved(lignqw) then return(lignqw),
exprq:lhs(lignqw)-rhs(lignqw),
if IsFactored(exprq) then return (exprq=0),
inpsiz:exprsize(exprq),
exprq2:sqfr(exprq),
if IsFactored(exprq2) then return (exprq2=0),
exprq2:sqfr(logcontract(exprq)),
if exprq=exprq2 then return(lignqw),
if IsFactored(exprq2) then (if exprsize(exprq2)<5*inpsiz then return(exprq2=0) else return(lignqw)),
lignqw 
)$

factoreq2(lignqw):=block([exprq],
if CheckSolved(lignqw) then return(lignqw),
exprq:lhs(lignqw),
if op(exprq)="*" then return(lignqw) else (return(sqfr(exprq)=rhs(lignqw)))
)$
/* forsøg med factoreq istedet for factoreq2*/
applyfactor2(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:factoreq(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$

simplifyhyp(qudt):=block([],applyb1(qudt,sinhrule,coshrule,tanhrule))$

/* Tries to simplify the expression using different methods. Returning the expression that can be written shortest, attempt at using expand as well and simpdiv */
simplify(exprq):=block([sexprq,sexprq2,sizexpr],
sizexpr:exprsize(exprq),
if numberp(exprq) then return(exprq),
if constantp(exprq) then (sexprq:radcan(exprq),sexprq2:ev(sexprq,numer), if integerp(sexprq) then return(sexprq), if integerp(sexprq2) then return(sexprq2), if exprsize(sexprq)<sizexpr then return(sexprq)),
sexprq:expand(exprq),
if exprsize(sexprq)<exprsize(exprq) and is(equal(sexprq,exprq)) then exprq:sexprq,
sexprq:radcan(exprq),
if exprsize(sexprq)<exprsize(exprq) and is(equal(sexprq,exprq)) then exprq:sexprq,
sexprq:ratsimp(exprq),
if exprsize(sexprq)<exprsize(exprq) and is(equal(sexprq,exprq)) then exprq:sexprq,
sexprq:expand(exprq),sexprq:applyb1(exprq,fracrule),
if exprsize(sexprq)<exprsize(exprq) and is(equal(sexprq,exprq)) then exprq:sexprq,
sexprq:applyb1(exprq,simpdiv),
/* simplify(M*%e^(a*x*M+a*c*M)/(%e^(a*x*M+a*c*M)+1)) */
if sexprq#false and exprsize(sexprq)<exprsize(exprq) then exprq:sexprq,
exprq
)$/*Gemt fordi ovenstående ikke er testet helt endnu */
simplifyOld(exprq):=block([sexprq,sexprq2,sexprq3,sizexpr],
sizexpr:exprsize(exprq),
if constantp(exprq) then (sexprq:radcan(exprq),sexprq2:ev(sexprq,numer), if integerp(sexprq) then return(sexprq), if integerp(sexprq2) then return(sexprq2), if exprsize(sexprq)<sizexpr then return(sexprq)),
sexprq:radcan(exprq),
sexprq2:ratsimp(exprq),
sexprq3:expand(exprq),
if exprsize(sexprq2)<exprsize(sexprq) then sexprq:sexprq2,
if exprsize(sexprq3)<exprsize(sexprq) then sexprq:sexprq3,
if exprsize(sexprq)<sizexpr then return(sexprq),
exprq
)$

/*  ratsimp kan give mærkelig resultat #1,INF med ,numer   72*e^((0.619/0.22*(e^22-e^0.22*t )) ) , Derfor denne specielle version*/
simplifynum(exprq):=block([sexprq,sexprq2,sizexpr],
sizexpr:exprsize(exprq),
if numberp(exprq) then return(exprq),
if constantp(exprq) then (sexprq:radcan(exprq),sexprq2:ev(sexprq,numer), if integerp(sexprq) then return(sexprq), if integerp(sexprq2) then return(sexprq2), if exprsize(sexprq)<sizexpr then return(sexprq)),
sexprq:expand(exprq),
if exprsize(sexprq)<exprsize(exprq) then exprq:sexprq,
exprq
)$

simplifysol(sollist):=block([exprq2],exprq2:makelist(block([zxq2],if not(op(zxq)="=") then return(zxq),zxq2:lhs(zxq)=simplify(rhs(zxq)),if zxq2=false then return(zxq),zxq2),zxq,sollist))$

exprsize(exprq):=length(charlist(string(exprq)))$

/*Giver et tal for størrelsen af ligningen. Det er antallet af charaterer. Hvis det er polynomium i en af variablene så lægges 15 til. det er ikke godt nok med polynomialp*/
exprmetric(exprq,varlq):=block([qm],
qm:exprsize(exprq),
if polynomialp(lhs(exprq)-rhs(exprq),varlq,lambda([z],atom(z) or constantp(z)),lambda([z],is(z>1))) then qm:qm+15,
qm
)$

FunctionList(func,listpar):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:func(zxq),if zxq2=false then return(zxq),zxq2),zxq,listpar))$

/* anvender qrul på hvert element i listen, kan erstatte mange herunder*/
applyrulelist(exprq,qrul):=block([exprq2],
exprq2:delete([],
	makelist(
		block([zxq2],
			zxq2:qrul(zxq),
			if zxq2=false then 
				return(zxq),
			zxq2
			),
		zxq,exprq)
	)
)$

/* som applyrulelist, men anvendes på expand(lhs-rhs)=0, hvis reglen ikke giver bonus så returneres det oprindelige udtryk */
applyrulelistZero(exprq,qrul):=block([exprq2],
exprq2:delete([],
	makelist(
		block([zxq2],
			zxq2:qrul(expand(lhs(zxq)-rhs(zxq))=0),
			if zxq2=false then 
				return(zxq),
			zxq2),
			zxq,exprq))
)$

applyswaprule(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:swaprule(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applyzerorule(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:zerorule(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applyaddrule(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:addrule(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applyaddrule2(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:addrule2(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applyprodrule(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:prodrule(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applyprodrule2(exprq):=block([exprq2],exprq2:flatten(makelist(block([zxq2],zxq2:prodrule2(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq)))$
applyprodrule3(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:prodrule3(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applydivrule(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:divrule(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applydivrule2(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:divrule2(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applydivrule3(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:divrule3(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applydivrule4(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:divrule4(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applypowrulenotnum(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:powrulenotnum(zxq),if zxq2=false then return(zxq),assume(rhs(zxq)>=0),zxq2),zxq,exprq))$
applyexprule(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:exprule(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applylnrule(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:lnrule(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applysinrule(exprq):=block([exprq2],flatten(exprq2:makelist(block([zxq2],if AllTrig then zxq2:sinsolruleall(zxq) else zxq2:sinsolrule(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq)))$
applycosrule(exprq):=block([exprq2],flatten(exprq2:makelist(block([zxq2],if AllTrig then zxq2:cossolruleall(zxq) else zxq2:cossolrule(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq)))$
applytanrule(exprq):=block([exprq2],flatten(exprq2:makelist(block([zxq2],if AllTrig then zxq2:tansolruleall(zxq) else zxq2:tansolrule(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq)))$
applyasinrule(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:asinsolrule(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applyacosrule(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:acossolrule(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applyatanrule(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:atansolrule(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applyabsrule(exprq):=block([exprq2],if not(dissolveabs) then exprq else flatten(exprq2:makelist(block([zxq2],zxq2:absrule(zxq),if zxq2=false then return(zxq),assume(rhs(zxq)>=0),zxq2),zxq,exprq)))$

applysolvepoly(exprq):=block([exprq2],flatten(exprq2:makelist(block([zxq2],zxq2:solvepoly(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq)))$
applydoubleexp(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:DoubleExp(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applyfactor(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:factoreq(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applyexpandintsol(exprq):=block([exprq2],flatten(exprq2:makelist(ExpandIntegerSolution(zxq),zxq,exprq)))$
applylogcontract(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:logcontract(lhs(zxq))=rhs(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applyconverttoreal(exprq):=block([exprq2],exprq2:makelist(block([zxq2],if zxq=all then return(all),zxq2:lhs(zxq)=ConvertToReal(rhs(zxq)),if zxq2=false then return(zxq),zxq2),zxq,exprq))$

applyabsruleonce(exprq,supq):=block([indq,delq,delq2,qfundet],
if length(exprq)=0 then return(exprq),
if op(exprq)=end then return(exprq),
qfundet:false,
indq:0,
exprq:do(
delq:part(exprq,indq),
if delq=end then return(exprq),
if delq=abs and containx(part(exprq,indq+1),solvar) then (qfundet:true,return(substpart(supq,exprq,indq))),
indq:indq+1
),
if qfundet then return(exprq),
indq:0,
do(
delq:part(exprq,indq),
if delq=end then return(exprq),
if not(atom(delq)) then (if not(freeof(abs,delq)) then (delq2:applyabsruleonce(delq,supq),if delq#delq2 then return(substpart(delq2,exprq,indq)))),
indq:indq+1
)
)$
dissolveabsonce(lignq):=block([lignq1],
if freeof(abs,lignq) then return(lignq),
lignq1:applyabsruleonce(lignq,"+"),
if is(lignq=lignq1) then return(lignq),
flatten([lignq1,applyabsruleonce(lignq,"-")])
)$

applyabsrule2(exprq):=block([exprq2,countq],if not(dissolveabs) then return(exprq),
startq,
countq:length(exprq),
exprq:flatten(makelist(dissolveabsonce(zxq),zxq,exprq)),
if countq#length(exprq) then go(startq),
exprq
)$

applymaximasolve(exprq):=block([exprq2,tqexpr],
flatten(
	exprq2:makelist(
		if CheckSolved(zxq) then 
			zxq 
		elseif not(containx(zxq,solvar)) and containanyx(zxq,solsysvars) then 
			zxq 
		elseif polynomialp(lhs(zxq)-rhs(zxq),[solvar],numberp,numberp) then /* Hvis polynomium er det bedre at sende videre til to_poly_solve numberp til coeff nok ikke helt hensigtsmæssigt*/
			zxq
		else 
			(tqexpr:solve(zxq,solvar),
				if tqexpr=[] then (solunsure:true,print("Solution unsure")),
			tqexpr
			),
		zxq,exprq))
)$

applynsolve(exprq):=block([exprq2],
if exprq=[all] or exprq=[] then return(exprq),
exprq2:flatten(makelist(if CheckSolved(zxq) then zxq else nsolve(zxq,solvar,9),zxq,exprq)),
makelist(if freeof("=",zxq) then solvar=zxq else zxq,zxq,exprq2)
)$

/* Solves an equation for a variable or expression. The variable to solve for will have any arrays attached removed*/
solvereal([paramq]):=block([solq,tempq,lignq,varq,condq,qassum,solu_1a,solu_2b,solsteps,iteind:0,factind:0,solunsure:false],if length(paramq)<2 then (print("Too few arguments"),return()) elseif length(paramq)>3 then (print("Too many arguments"),return()),
lignq:paramq[1],varq:paramq[2],
if length(paramq)=3 then condq:paramq[3] else condq=[],
if nonscalarp(lignq) and length(lignq)>1 and freeof(at,lignq) then (print("solving system of equations"),return(solvesystem(lignq,varq))),
if sepsolvecontext then (context:solreal,activate(initial)),
if atom(varq) then (solvar:varq,remarray(''solvar)) else (solvar:solx,lignq:subst(solvar,varq,lignq)),
if lignq=all then return([all]),
if freeof(solvar,lignq) then (print(solvar," not present in equation"),if is(equal(lhs(lignq),rhs(lignq)))=true then return(all) elseif is(equal(lhs(lignq),rhs(lignq)))=false then return([]) else return(unknown)),
iteind:0,factind:0,solsteps:[],
/* solq:solverecursive(factoreq(lignq),varq,condq), kan forstyre med mærkelig faktorisering af noget der nemt kan løses*/
solq:[lignq],
/* problematisk kan føre til ugyldige løsninger solq:DissolveRadicals(solq),*/
solq:DissolveAbs(solq),
solq:solverecursive(solq,varq,condq),
if solq=[0=0] then (solq:[all],go(finishlabel)),
solq: ev(solq,logcontract2),addsolstep(solq,"logcontract2"),
solq: unique(solq),
solq:applyexpandintsol(solq),addsolstep(solq,"unique og expand integer sol"),
solq:applymaximasolve(solq),addsolstep(solq,"MaximaSolver"),
solq: unique(solq), 
/*solq:RemoveIncorrect2(lignq,solq),  Fjerner også approximative løsninger... lav checksolutions */
solq:RemoveIncorrect(solq),addsolstep(solq,"RemoveIncorrect"), /* Fjerner løsninger i henhold til assume. RemoveIncorrect([y=-234/(%e^(-2.339999875980007*x-2.339999875980007*c)-8345)]); venter ... pga. factor laver meget lang faktorisering. Løst vha. numer i removeincorrect*/
solq:RemoveUndefined(lignq,solq),addsolstep(solq,"RemoveUndefined"),
solq:applyconverttoreal(solq),addsolstep(solq,"ConvertToReal"),
solq:simplifysol(solq),
addsolstep(solq,"Simplify"),
if not(atom(varq)) then solq:subst(varq,solvar,solq),
addsolstep(solq,"subst tilbage"),
finishlabel,
if showassumptions then (
	if facts(solreal)#[] then( 
		qassum:delete([], makelist(if freeof(kind,zq) then zq else [],zq,facts(solreal))),		
solq:flatten(makelist(block([qi:1],do(if qi>length(qassum) then return([]),if is(ev(qassum[qi],numer,zq))=false then (print(sconcat("solution ",zq," removed due to assumption.")),zq:[],return([])),qi:qi+1),zq),zq,solq)),
if qassum#[] then print("Assumptions: ",qassum))
),
if sepsolvecontext then 
	errcatch(
		forget(facts(solreal)),
		deactivate(solreal),
		context:initial,
			if facts(solreal)#[] then killcontext(solreal)
			), 
solvesteps:append(solvesteps,[solsteps]),
if IsAnySolved(solq,varq) and not(solunsure) then return(solq),
solu_1a:solq,
if not(solverealmaximasolve) and not(solverealtopoly) and not(autonsolve) then return (solq),
if solu_1a=[] and not(solunsure) then return ([]),
if solu_1a#[] then(
	if IsAllSolved(solu_1a,varq) then go(slutqw),
	if nonscalarp(first(solu_1a)) then return(solu_1a)
	),
errcatch(if polynomialp(ev(lhs(lignq)-rhs(lignq),simp),[varq]) then solu_1a:flatten(algsys([lignq],[varq])) else go(nxqsol0)),
if domain=real then solu_1a:RemoveImag(solu_1a),
if IsAnySolved(solu_1a,varq) then go(slutqw) ,
nxqsol0 ,
if ContainsTrig(lignq) then go(nxqsol2),
if solverealtopoly then 
	(
	solu_1a:ev(errcatch(nicedummies(ev(to_poly_solve(lignq,varq),realonly:false)))[1]),
	if not(freeof(to_poly_solve,solu_1a)) then go(nxqsol1),
	solu_1a:flatten(errcatch(args(solu_1a))),
	if domain=real then solu_1a:RemoveImag(solu_1a),
	solu_1a:RemoveImag(solu_1a),
	solu_1a: CheckSolutions(lignq,varq,solu_1a),
	if IsAnySolved(solu_1a,varq) then go(slutqw)
	),
nxqsol1,
if solverealtopoly then (
	solu_1a:errcatch(nicedummies(ev(to_poly_solve(lignq,varq),numer,realonly:false,algexact:false)))[1],
	if not(freeof(to_poly_solve,solu_1a)) then go(nxqsol2),
	solu_1a:flatten(errcatch(args(solu_1a))),
	if domain=real then solu_1a:RemoveImag(solu_1a),
	solu_1a: CheckSolutions(lignq,varq,solu_1a), 
	if IsAnySolved(solu_1a,varq) then go(slutqw)
	),
nxqsol2,
if solverealmaximasolve then
	(
	solu_1a:ev(solve(lignq,varq),simp),
	if domain=real then solu_1a:RemoveImag(solu_1a),
	solu_1a: CheckSolutions(lignq,varq,solu_1a), 
	if IsAnySolved(solu_1a,varq) then go(slutqw),
	nxqsol3,
	solu_1a:ev(solve(lignq,varq),simp,numer,radexpand),
	if domain=real then solu_1a:RemoveImag(solu_1a),
	solu_1a: CheckSolutions(lignq,varq,solu_1a), 
	if IsAnySolved(solu_1a,varq) then go(slutqw),
	nxqsol4,
	solu_1a:ev(solve(lignq,varq),simp,radcan,numer),
	if domain=real then solu_1a:RemoveImag(solu_1a),
	solu_1a: CheckSolutions(lignq,varq,solu_1a)
),
if not(freeof(%if,solu_1a)) then solq:solu_1a else solq:RemoveIncorrect(solu_1a),
if autonsolve and not(IsAnySolved(solu_1a,varq)) then
	(
	solu_1a:nsolve(lignq,varq)
	),
slutqw,
solu_1a
)$

solverecursive(lignq,varq,condq):=block([solq],
	solq:flatten([lignq]),
	iteind:iteind+1,
	if iteind>35 then return(solq),
	addsolstep(solq,"Start"),
	solq:applyswaprule(solq),
	addsolstep(solq,"Byt side"),	solq:applyrulelist(solq,divzerorule),addsolstep(solq,"divzerorule"),
	solq:applyzerorule(solq),addsolstep(solq,"Nulregel"),
solq:applyaddrule(solq),addsolstep(solq,"addrule"),solq:applyrulelist(solq,prodrule4),addsolstep(solq,"prodrule4"),
solq:applyaddrule2(solq),addsolstep(solq,"addrule2"),
solq:applyprodrule(solq),addsolstep(solq,"prodrule"),
solq:applyprodrule2(solq),addsolstep(solq,"prodrule2"),
/* solq:applyprodrule3(solq),addsolstep(solq,"prodrule3"),  */ /* Overser løsning i fx solvereal(x^2*(x^2-1)=9*(x^2-1),x); fordi der divideres med udtryk hvor x indgår. Forhåbentlig er den ikke nødvendig. Ellers skal den ændres*/
solq:applydivrule(solq),addsolstep(solq,"divrule"),
solq:applydivrule2(solq),addsolstep(solq,"divrule2"),
solq:applydivrule3(solq),addsolstep(solq,"divrule3"),solq:applyrulelist(solq,divrule5),addsolstep(solq,"divrule5"),solq:applyrulelist(solq,expandrule),addsolstep(solq,"expandrule"),
if solq#lignq then return(solverecursive(solq,varq,condq)),
solq:applyrulelist(solq,absremoverule),addsolstep(solq,"absremoverule"),
solq:applyabsrule(solq),addsolstep(solq,"lift abs(x)"),
solq:applyrulelistZero(solq,lambertwillrule),addsolstep(solq,"lambertwillrule"),
solq:applyrulelistZero(solq,lambertwrule2sol),addsolstep(solq,"lambertwrule2sol"),
solq:applyrulelistZero(solq,lambertwrule1sol),addsolstep(solq,"lambertwrule1sol"),
solq:applyrulelistZero(solq,lambertwrulegeneral),addsolstep(solq,"lambertwrulegeneral"),
solq:applyrulelistZero(solq,lambertwrule2),addsolstep(solq,"lambertwrule2"),
solq:applyrulelist(solq,powrulezero),addsolstep(solq,"powrulezero"),
solq:applyrulelist(solq,powruleoddneg),addsolstep(solq,"powruleoddneg"),
solq:applyrulelist(solq,powruleodd),addsolstep(solq,"powruleodd"),
solq:applyrulelist(solq,powruleodd2),addsolstep(solq,"powruleodd"),
solq:applyrulelist(solq,powruleevenneg),addsolstep(solq,"powruleevenneg"),
solq:applyrulelist(solq,powruleeven),addsolstep(solq,"powruleeven"),
solq:applyrulelist(solq,powruleirratneg),addsolstep(solq,"powruleirratneg"),
solq:applyrulelist(solq,powruleirrat),addsolstep(solq,"powruleirrat"),
solq:applypowrulenotnum(solq),addsolstep(solq,"powrulenotnum"),
solq:applydoubleexp(solq),addsolstep(solq,"doubleexp"),
solq:applyexprule(solq),addsolstep(solq,"exprule"),solq:applyrulelist(solq,expremoverule),addsolstep(solq,"expremoverule"),
solq:applylnrule(solq),addsolstep(solq,"lnrule"),
solq:applysinrule(solq),addsolstep(solq,"sinrule"),
solq:applycosrule(solq),addsolstep(solq,"cosrule"),
solq:applytanrule(solq),addsolstep(solq,"tanrule"),
solq:applyasinrule(solq),addsolstep(solq,"asinrule"),
solq:applyacosrule(solq),addsolstep(solq,"acosrule"),
solq:applyatanrule(solq),addsolstep(solq,"atanrule"),
if solq#lignq then return(solverecursive(solq,varq,condq)),
solq:applysolvepoly(solq),addsolstep(solq,"solvepoly"),
if solq#lignq then return(solverecursive(solq,varq,condq)),
solq:simplifyhyp(solq),
solq:applyrulelist(solq,sinhsolrule),addsolstep(solq,"sinhsolrule"),
solq:applyrulelist(solq,coshillrule),addsolstep(solq,"coshillrule"),
solq:applyrulelist(solq,coshsolrule),addsolstep(solq,"coshsolrule"),
solq:applyrulelist(solq,tanhillrule),addsolstep(solq,"tanhillrule"),
solq:applyrulelist(solq,tanhsolrule),addsolstep(solq,"tanhsolrule"),
if solq#lignq and iteind<15 then return(solverecursive(solq,varq,condq)),
if solq=lignq and factind>1 then return(solq),
solq:applyabsrule2(solq),addsolstep(solq,"absrule2"),
solq:applylogcontract(solq),addsolstep(solq,"logcontract"),
solq:applyb1(solq,powrulexp),addsolstep(solq,"powrulexp"),
if solq#lignq then return(solverecursive(solq,varq,condq)),
if factind<3 then (factind:factind+1,solq:applyfactor(solq),addsolstep(solq,"factor")),
if factind=3 then (factind:factind+1,solq:expand(solq),addsolstep(solq,"expand")),
solq:solverecursive(solq,varq,condq),
solq)$

addsolstep(qsol,qkomm):=block([li],li:append(qsol,[qkomm]),if solsteps=[] then solsteps:[li] elseif rest(last(solsteps),-1)#qsol then solsteps:append(solsteps,[li]),return())$
/* mere simpel, men ikke god til debug
addsolstep(qsol):=block([],solsteps:unique(append(solsteps,qsol)))$
*/

/* Tries to isolate radicals one bye one and square them out, but can easily give infinite loop or very large expressions. Now limited, will only apply if one radical, since can easily grow.
Not mathematically sound. example: sqrt(x)=-1  ->(squaring) x=1 but is not a solution  
dissolveradicals:true;solvar:x;DissolveRadicals([x^2=2*sqrt(x)]);*/
DissolveRadicals(qexprl):=block([powno:0,solq,solq2:[],savevar,qind:0,qind2:0,noradicals:true],
if not(dissolveradicals) then return(qexprl),
savevar:solvar,
do(
qind2:qind2+1,
if qind2>length(qexprl) then return(),
qexpr:qexprl[qind2],
solq:apply1(qexpr,ReplaceFirstRadical),
if powno=1 then (
noradicals:false,
solq:ev(solvereal(solq,powx),dissolveradicals=false),
qind:0,
do(
qind:qind+1,
if qind>length(solq) then return(),
if CheckSolved(solq[qind]) then 
(
solq2:append(solq2,[radicalsubst[1]^num(ratsimp(radicalsubst[2]))=expand(rhs(solq[qind])^(denom(ratsimp(radicalsubst[2]))))])
)
else
(
solq2:append(solq2,[subst(radicalsubst[1]^radicalsubst[2],powx,solq[qind])]))))),
solvar:savevar,if noradicals then qexprl else solq2
)$

DissolveAbs(qexprl):=block([absno:0,solq,solq2:[],savevar,qind:0,qind2:0,noabs:true],
if not(dissolveabs) then return(qexprl),
if freeof(abs,qexprl) then return(qexprl),
do(
qind2:qind2+1,
if qind2>length(qexprl) then return(),
qexpr:qexprl[qind2],absno:0,
solq:apply1(qexpr,ReplaceFirstAbs),
if absno>0 then (
noabs:false,savevar:solvar,
solq:ev(solvereal(solq,absx),dissolveabs=false),solvar:savevar,
qind:0,
do(
qind:qind+1,
if qind>length(solq) then return(),
if CheckSolved(solq[qind]) then 
(
solq2:append(solq2,[subst(abs(abssubst),absx,solq[qind])])
)
else
(
solq2:append(solq2,[subst(abs(abssubst),absx,solq[qind])])
)))),
if noabs then return(qexprl) else solq2:applyabsrule(applyrulelist(solq2,absremoverule)),
if freeof(abs,solq2) then solq2 else DissolveAbs(solq2)
)$

nsolve([paramq]):=block([qfkt,solq,qn,qm,qti,qmaxti,qantal,qmm,qnn,qnewt,fpprec:50],
if length(paramq)<2 then (print("Too few arguments"),return()) elseif length(paramq)>9 then (print("Too many arguments"),return()),
qlign:paramq[1],qvar:paramq[2],
if length(paramq)>=3 then qn:paramq[3] else qn:-15,
if length(paramq)>=4 then qm:paramq[4] else qm:15,
if length(paramq)>=5 then qti:paramq[5] else qmaxti:15,
if length(paramq)>=6 then qantal:paramq[6] else qantal:20,
if length(paramq)>=7 then qnn:paramq[7] else qnn:30,
if length(paramq)>=8 then qmm:paramq[8] else qmm:30,
if length(paramq)>=9 then qnewt:paramq[9] else qnewt:true,
errormsg:false,
solq:[],
define(qfkt(qvar),ev(lhs(qlign)-rhs(qlign),bfloat)),
qti:absolute_real_time(),
if not(numberp(ev(qfkt(1),numer))) then (print("nsolve requires an equation with only 1 variable"),return(qlign)), 
solq:nsolverec(qfkt(qvar),qvar,[],qn,qm),
if length(solq)>=qantal then go(afslut),
errcatch(if op(qfkt(-1b1^qn))#op(qfkt(0b0)) then solq:append(solq,flatten([errcatch(bf_find_root(qfkt,qvar,-10^qn,0))]))),
if length(solq)>=qantal then go(afslut),
errcatch(if op(qfkt(0b0))#op(qfkt(1b1^qm)) then solq:append(solq,flatten([errcatch(bf_find_root(qfkt,qvar,0,10^qm))]))),
if length(solq)>=qantal then go(afslut),
if qmm>qm then errcatch(if op(qfkt(1b1^qm))#op(qfkt(1b1^qmm)) then solq:append(solq,flatten([errcatch(bf_find_root(qfkt,qvar,10^qm,10^qmm))]))),
if length(solq)>=qantal then go(afslut),
if qnn>qn then errcatch(if op(qfkt(-1b1^qnn))#op(qfkt(-1b1^qn)) then solq:append(solq,flatten([errcatch(bf_find_root(qfkt,qvar,-10^qnn,-10^qn))]))),
if qnewt then (load(newton1),solq:append(solq,bfloat(errcatch(newton(qfkt(qvar),qvar,1,10^-14))))),
afslut,
errormsg:true,
print("More solutions may exist"),
solq:ev(solq,numer),
solq:unique(solq),
solq:RemoveIncorrect(makelist(qvar=zq,zq,solq))
)$

EmptyToZero(qin):=if qin=[] then 0 else qin$

nsolverec(qfkt,qvar,sollq,qn,qm):=block([qfkt,ql,glf,qi],
qi:1,
ql:makelist((1b-1+i*1b-2)*10^qn,i,0,90),
qlf:flatten(errcatch(qfkt(ql))),
do(
if qi>=length(qlf) then return(),
if qlf[qi]=0.0b0 then (if op(qfkt(ql[qi]-10^(qn-3)))#op(qfkt(ql[qi]+10^(qn-3))) then sollq:append(sollq,flatten([errcatch(bf_find_root(qfkt,qvar,ql[qi],ql[qi+1]))]))
) elseif qlf[qi+1]=0.0b0 then (nothing)
 elseif not(freeof(%i,qlf[qi])) then (nothing)
 elseif op(qlf[qi])#op(qlf[qi+1]) then (
sollq:append(sollq,flatten([errcatch(bf_find_root(qfkt,qvar,ql[qi],ql[qi+1]))]))
), 
qi:qi+1
),
if (absolute_real_time()-qti)>qmaxti then (print("Time out"),return(sollq)), 
if length(sollq)>=qantal then (print(concat("Stopped searching because " , qantal , " solutions were found")),return(sollq)),qi:1,
qlf:flatten(errcatch(qfkt(-ql))),
do(
if qi>=length(qlf) then return(),
if qlf[qi]=0.0b0 then (if op(qfkt(-ql[qi]-10^(qn-3)))#op(qfkt(-ql[qi]+10^(qn-3))) then
(sollq:append(sollq,flatten([errcatch(bf_find_root(qfkt,qvar,-ql[qi+1],-ql[qi]))])))
)  elseif qlf[qi+1]=0.0b0 then (nothing)
   elseif not(freeof(%i,qlf[qi])) then (nothing)
   elseif op(qlf[qi])#op(qlf[qi+1]) then (
sollq:append(sollq,flatten([errcatch(bf_find_root(qfkt,qvar,-ql[qi+1],-ql[qi]))]))
),
qi:qi+1
),
slut,
if (absolute_real_time()-qti)>qmaxti then (print("Time out"),return(sollq)), 
if length(sollq)>=qantal then (print(concat("Stopped searching because " , qantal , " solutions were found")),return(sollq)),
if qn>qm then return(sollq) else nsolverec(qlign,qvar,sollq,qn+1,qm)
)$

RemoveIncorrectNum(sollistq):=block([indq,sollistq2,solq],
indq:0,sollistq2:[],
if length(sollistq)=0 then return(sollistq),
do(
indq:indq+1,
solq:sollistq[indq],
if ev(is(equal(solvar,solq)),numer)#false then sollistq2:append(sollistq2,[solq]),
if length(sollistq)=indq then return(sollistq2)
)
)$

/* converts expression to bigfloat safer than bfloat, convertbfloat(((1+1/10^12 )^(10^12 ))) */
convertbfloat(exprq)::=block([simp,qout],simp:false,qout:errcatch(bfloat(exprq)),if qout=[] then simp:true else return(qout[1]),ev(exprq,simp,bfloat))$

/* første element indsættes i resterende. Første element flyttes til slut. Hvis første element er liste indsættes de 1 efter 1 og for hvert element laves en liste*/
SplitSubst(eqnlqi):=block([indq,indq2,liq,eqnlqpart,eqnlq,eqnlq2],
eqnlq2:[],
eqnlq:eqnlqi[1],
if length(eqnlq)<2 then return([eqnlq]),
liq:first(eqnlq),
eqnlq:rest(eqnlq,1),
if nonscalarp(liq) then 
	(
	eqnlq2:append(eqnlq2,makelist(flatten([makelist(subst(liqp,zq),zq,eqnlq),liqp]),liqp,liq))
	)
else
	(
	eqnlq2:append(eqnlq2,makelist(subst(liq,zq),zq,eqnlq),[liq]),
	[eqnlq2]
	)
)$

/* løser første ligning i en liste [x+y=1,x-y=2] -> [x=1-y,x-y=2] hvis to løsninger kommer liste i liste */
SolveFirst(eqnlq,varq):=block([eqnq,autonsolve:true],
eqnq:first(eqnlq),
elq:flatten(errcatch(Solve(eqnq,varq))),
if elq=[] or elq=unknown  then return(elq),
if elq=[all] or elq=all  then (if length(eqnlq)=1 then return([all]) else return(rest(eqnlq,1))),
if length(elq)>0 then(
if CheckSolvedVar(elq[1],varq) then (if length(elq)=1 then elq:first(elq),append([elq],rest(eqnlq,1))) else (false))
)$

/*Used to sort solutions from solvesystem*/
SortSolutions(solq):=block([z],makelist(sort(z),z,solq))$

/* matrixeqtolist(matrix([x],[y])=matrix([1],[2]));    ->   [x=1,y=2]*/
matrixtolist(matq):=block([],
if op(matq)#matrix then return(matq),
flatten(args(matq))
)$

/* konverterer vektorligning til liste af ligninger*/
matrixeqtolist(mateq):=block([lq,rq,indq,listeq],
if op(lhs(mateq))#matrix then return(mateq),
listeq:[],
lq:matrixtolist(lhs(mateq)),
rq:matrixtolist(rhs(mateq)),
for indq:1 thru length(lq) step 1 
do(
listeq:append(listeq,[lq[indq]=rq[indq]])
),
listeq
)$

/* konverterer kombination af ligninger og vektorligninger til liste af ligninger */
matrixeqtolistall(mateq):=block([],
if listp(mateq) then flatten(makelist(matrixeqtolist(zxq),zxq,mateq)) else matrixeqtolist(mateq)
)$

sortlistbysize(eqnlq,varlq):=block([eqnlq2,eqn,indq,indq2,noq,noq2],
eqnlq2:[first(eqnlq)],
eqnlq:rest(eqnlq,1),
noq:length(eqnlq),
for indq2:1 thru noq step 1 
do(
	eqn:first(eqnlq),
	eqnlq:rest(eqnlq,1),
	noq2:length(eqnlq2),
	for indq:1 thru noq2 step 1 
	do(
		if exprmetric(eqnlq2[indq],varlq)>=exprmetric(eqn,varlq) then (eqnlq2:append(rest(eqnlq2,-length(eqnlq2)+indq-1),[eqn],rest(eqnlq2,indq-1)),return()),
		if indq=noq2 then (eqnlq2:append(eqnlq2,[eqn]))
		)
	),
eqnlq2
)$

/* Kan give falske løsninger, specielt ved 3+ lignigner hvor der indgår ^2 og kvadratrod, men det forsøges undgået ved at sortere ligningslisten så de korteste ligninger løses først. Måske noget med assume og removeincorrect kan forbedre*/
solvesystem(eqnlqsave,varlqsave):=block([noq,varpermut,eqnpermut,eqnq,eqnqsav,eqnlqtemp,indq,indq2,sollq,varq,varlq,iteq,iteql,elq,eqnlq,resq,sprq,sprqgo],
eqnlqsave:matrixeqtolistall(eqnlqsave),
sprqgo,
if not(nonscalarp(varlqsave)) and (symbolp(varlqsave) or listp(varlqsave)) then varlqsave:unique(append([varlqsave],listofvars(eqnlqsave))),
if not(nonscalarp(varlqsave)) then varlqsave=[],
if length(varlqsave)<length(eqnlqsave) then varlqsave:unique(append(varlqsave,listofvars(eqnlqsave))),
if length(varlqsave)>length(eqnlqsave) then 
	(
	print("Too many variables."),
	sprq:read(sconcat("Which of the ",length(eqnlqsave)," variables to solve for? ",varlqsave," (state as list eq. [x,y] or end to choose automatically)")),
	if sprq=end then 
		varlqsave:rest(varlqsave,length(eqnlqsave)-length(varlqsave)) 
	elseif not(nonscalarp(sprq)) then 
		go(sprqgo) 
	elseif length(sprq)#length(eqnlqsave) then 
		go(sprqgo) 
	else 
		varlqsave:sprq
	),
if length(varlqsave)<length(eqnlqsave) then (print("Warning too few variables, only solving for first equation(s)."),
eqnlqsave:rest(eqnlqsave,+length(varlqsave)-length(eqnlqsave))),
if length(varlqsave)#length(eqnlqsave) then (print("Must be the same number of equations as variables"),return()),
sollq:errcatch(solve(eqnlqsave,varlqsave)),
if sollq#[] then( 
	sollq:delete([],makelist(GetReal(z),z,sollq[1])),
	if sollq#[] and %rnum_list=[] then return(sollq)
),
eqnlqsave:sortlistbysize(eqnlqsave,varlqsave),
varpermut:permut(varlqsave),
eqnpermut:permut(eqnlqsave),
eqnlqsave:eqnpermut[1],
varlqsave:varpermut[1],
noq:factorial(length(varlqsave)),
iteq:1, /*Bruges til at tælle ned hvor mange gange der er forsøgt med forskellige variabelrækkefølge*/
iteql:1, /*Bruges til at tælle hvor mange gange der er forsøgt med forskellig ligningsrækkefølge.*/eqnlq:[eqnlqsave],
sollq:[],
eqnlqtemp:[],
startq,
varlq:varlqsave,
eqnq:first(eqnlq),
eqnlq:rest(eqnlq,1),
eqnqsav:eqnq,
startsolq,/* Her sendes tilbage når den første variabel er elimineret/løst */
/*print("eqnq:",eqnq,"eqnlq:",eqnlq,"varlq:",varlq,"iteq:",iteq,"iteql:",iteql),*/
indq:1,
/* løs første ligning og indsæt i andre, flyt til slutningen. Hvis løsning fejler så forsøges med næste variabel indtil ikke flere*/
resq:do
	( 
	varq:first(varlq), /* Første variable udvælges og placeres derefter i slutningen af listen*/	varlq:rest(varlq,1),
	varlq:append(varlq,[varq]),
	elq:ev(SolveFirst(eqnq,varq),solsysvars=varlqsave), /* Den første ligning i listen løses og placeres på samme sted i listen */
	if elq=[] then (
		varlq:[x],
		eqnq:[],		
		return(true))
	elseif elq#false and elq#unknown then /*Hvis første ligning blev løst*/
		( /*Den første ligning indsættes i de andre og placeres sidst. Hvis der var flere løsninger indsættes disse også i alle ligninger som gemmes i eqnlqtemp*/		elq:SplitSubst([elq]),
		eqnq:first(elq),
		if length(elq)>1 then 
			(eqnlqtemp:append(eqnlqtemp,rest(elq,1))),
		return(true)
		),
	indq:indq+1,
	if indq>length(varlq) then /*Alle variable forsøgt uden held*/
		(if iteql>=noq then return(false) else return(retry))
	),
tryagainlabel,
if resq=false then 
	(/*Hvis første ligning ikke kunne løses for nogen af variablene og alle de andre ligninger allerede er forsøgt*/
	print("Can't solve. Trying to_poly_solve"),
	eqnlq:to_poly_solve(eqnlqsave,varlqsave),
	eqnlq:scanmap(RemoveUnion,eqnlq),
	return(eqnlq)
	)
elseif resq=retry then 
	(/*Hvis første ligning ikke kunne løses for nogen af variablene, så prøves med en anden rækkefølge af variable  */
	iteq:iteq+1,
	if (iteq>=noq and iteql<noq) then (
		iteq:1,
		iteql:iteql+1,
		/* eqnqsav:append(rest(eqnqsav,1),[first(eqnqsav)]) */
		eqnq:eqnpermut[iteql]
		),
	eqnq:eqnqsav,
	/* varlqsave:append(rest(varlqsave,1),[first(varlqsave)]), */
	varlq:varpermut[iteq],
	eqnlqtemp:[],
	go(startsolq)
	),
/*Hvis første ligning blev løst så fortsættes her*/varlq:rest(varlq,-1), /*Den variabel der blev løst for fjernes fra listen*/
if length(varlq)>=1 then go(startsolq), /* Hvis de er flere variable der skal isoleres så start forfra*/
if not(IsSystemSolved(sollq,varlqsave)) and iteq<noq and iteql<noq then (resq:retry,go(tryagainlabel)),
/*Her nulstilles og gøres klar til at løse evt gemte extra løsninger*/
	iteq:1,
	iteql:1,
eqnlq:append(eqnlq,eqnlqtemp),
eqnlqtemp:[],
if eqnq#[] then sollq:append(sollq,[eqnq]),
varlq:varlqsave,
if length(eqnlq)>0 then go(startq),
SortSolutions(sollq)
)$

/*solvesystemByEliminate(eqnlq,varlq):=block([varlq1,elq,sollq,indq,varq],
sollq:[],
for indq:1 thru length(eqnlq) step 1 do(
varq:first(varlq),
varlq:rest(varlq,1),
elq:eliminate(eqnlq,varlq),
if is(elq#[1]) then sollq:append(sollq,solvereal(elq,varq)) else sollq:append(sollq,rest(eqnlq,1)),
varlq:append(varlq,[varq])
),
sollq
)$*/

solvesystemScalar(eqnlq,varlq):=block([varlq1,elq,sollq,indq,varq],sollq:[],
startq,
for indq:1 thru length(varlq) step 1 do( 
	varq:first(varlq),	varlq:rest(varlq,1),
	varlq:append(varlq,[varq]),
	eqnq:first(eqnlq),
	eqnlq:rest(eqnlq,1),
	eqnlq:append(eqnlq,[eqnq]),
	elq:Solve(eqnq,varq),
	if length(elq)>0 then(
		if CheckSolvedVar(elq[1],varq) then (sollq:append(sollq,elq),return())
		)
	),
varlq:rest(varlq,-1),eqnlq:rest(eqnlq,-1),eqnlq:makelist(subst(elq,zq),zq,eqnlq),
if length(eqnlq)>=1 then go(startq),
sollq:append(makelist(subst(last(sollq),zq),zq,rest(sollq,-1)),[last(sollq)]),
sollq
)$

/* alias(CSolve,solvereal)$ */
Solve(eqnlq,varlq):=block([qsolu],
if domain=real then return(solvereal(eqnlq,varlq)),
qsolu:solve(eqnlq,varlq),
if IsAnySolved(qsolu,varlq) then go(slutqw),
if solverealtopoly then 
	(
	qsolu:ev(errcatch(nicedummies(ev(to_poly_solve(eqnlq,varlq),realonly:false)))[1]),
	qsolu:flatten(errcatch(args(qsolu)))
	),
slutqw,
qsolu	
)$

RemoveImag(lignliste):=block([iqw,outlistq],
if lignliste=all then return(all),
if lignliste=[] then return([]),
lignliste:ev(lignliste,%z0:0,%z1:0),
outlistq:[],iqw:1,
startq,
outlistq:append(outlistq,[GetReal(lignliste[iqw])]),
iqw:iqw+1,
if iqw<=length(lignliste) then go(startq),
outlistq:flatten(outlistq),
outlistq
)$

ContainsTrig(udt):=block([],not(freeof(sin,cos,tan,acos,asin,atan,udt)))$

IsSolved(lign,varqw):=block([],
if listofvars(lhs(lign))=[] then return(false),
if funp(%if,lign) then return(true),
not(member(varqw,listofvars(rhs(lign)))) and varqw=lhs(lign)
)$

IsAnySolved(lignliste,varqw):=block([i],i:1,if lignliste=[] then return(lignliste),start,if IsSolved(lignliste[i],varqw) then return(true),i:i+1,if i<=length(lignliste) then go(start),false)$

IsAllSolved(lignliste,varqw):=block([i],i:1,
if lignliste=[all] then return(true),
if lignliste=[] then return(lignliste),
start,
if not(IsSolved(lignliste[i],varqw)) then return(false),
i:i+1,
if i<=length(lignliste) then go(start),
true)$

/* Der er to af disse som er forskellige?!
IsAllSolved(lignliste,varqw):=block([i],i:1,if lignliste=[] then return(lignliste),start,if not(IsSolved(lignliste[i],varqw)) then return(false),i:i+1,if i<=length(lignliste) then go(start),true)$
CheckSolutions(udtind,var,soluts):=block([udt,qweks,boutq],
udt:lhs(udtind)-rhs(udtind),
sublist(soluts,lambda([z],
	if not(freeof(%if,z)) then 
		z:args(z)[2][1],
	if not(numberp(ev(rhs(z),numer))) then 
		true 
	else 
		(errcatch(qweks:ceiling(log(ev(abs(ev(lhs(udtind),z,numer)),numer))/log(10))),
		if not(integerp(qweks)) then 
			qweks=1, 
		if NoSigFig>5 then 
			qweks:qweks+NoSigFig-5,
		if qweks<0 then 
			qweks:0 ,
		is(ev(abs(ev(udt,z,numer)),numer)<10^(-NoSigFig+qweks+1)) ) 
		)
	) 
)$*/

/* Checks if a system of equations has been completely solved for specified variables: IsSystemSolved([[x = -1/sqrt(5)*a,y = -2/sqrt(5)],[x = 1/sqrt(5),y = 2/sqrt(5)]],[x,y]);*/
IsSystemSolved(eqnlist,varlist):=block([rhsvars,listconstvars:false],
rhsvars:listofvars(makelist(rhs(z),z,flatten(eqnlist))),
apply(freeof,flatten([varlist,rhsvars]))
)$

/* Checks solutions. targetted at removing imag */
CheckSolutions(udtind,var,soluts):=block([udt,qweks,boutq],udt:lhs(udtind)-rhs(udtind),sublist(soluts,lambda([z],if not(freeof(%if,z)) then z:args(z)[2][1],if not(numberp(ev(rhs(z),numer))) then true else (errcatch(qweks:ceiling(log(ev(abs(ev(lhs(udtind),z,numer)),numer))/log(10))),if not(integerp(qweks)) then qweks=1, if fpprintprec>7 then qweks:qweks+fpprintprec-7,if qweks<0 then qweks:0 ,is(ev(abs(ev(udt,z,numer)),numer)<10^(-fpprintprec+qweks+3))) )))$

GetReal(lign):=block([inlign,kond],if not(freeof(%if,lign)) then (inlign:args(lign)[2][1],kond:args(lign)[1]) else inlign:lign,if not(freeof(%i,carg,parg,kond)) then kond:[],if numberp(ev(float(ev(imagpart(rhs(inlign)),simp)),simp)) then  (if (is(abs(ev(imagpart(ev(float(ev(rhs(inlign),simp)),simp,numer)),simp))<10^(-NoSigFig))) then (if freeof(%i,inlign) then go(slutqw) else (inlign:ev(inlign,numer),go(slutqw))) else (return([]))), if freeof(%i,ev(inlign,%z0:0,%z1:0)) then go(slutqw),inlign:trigsimp(rectform(inlign)),slutqw,if not(freeof(%if,lign)) and kond#[] then inlign:(%if(kond,[inlign],args(lign)[3])),if freeof(%i,inlign) then return(inlign) else return([]) )$

SolveIneq(lignq,varq):=block([soluqw],
soluqw:[],
load(solve_rat_ineq),
errcatch(soluqw:solve_rat_ineq(lignq),soluqw),
if soluqw#[] then return(soluqw),
load(fourier_elim),
errcatch(soluqw:fourier_elim([lignq],[varq])),
if soluqw#[] then return([soluqw]),
soluqw:to_poly_solve(lignq,varq),
if soluqw#[] then return(args(soluqw)),
print("kunne ikke løses")
)$

desolvereal([paramq]):=block([qdvar,qivar,qic1x,qic1y,qic2x,qic2y,qdic,solq,logabs:true,keepfloat:true,numer:false],
startq,
if length(paramq)<3 then (print("Too few arguments"),return()),
diffeqnq:paramq[1],qdvar:paramq[3],qivar:paramq[2],
solq2:ev(delogisticrule(expand(lhs(diffeqnq)-rhs(diffeqnq))=0),solvar=lhs(qdvar),solvar2=lhs(qivar)),
if solq2#false then (solq:solq2, if length(paramq)=3 and not(freeof("=",qivar) or freeof("=",qdvar)) 
then solq:makelist(if (freeof(%c,z) and numberp(rhs(z))) then (if is(ev(equal(lhs(z),rhs(z)),qivar,qdvar))#false then z else []) else z ,z,solq)) else 
(solq:[ode2(diffeqnq,lhs(qdvar),lhs(qivar))]
),
if length(paramq)=3 and not(freeof("=",qivar) or freeof("=",qdvar)) then solq:makelist(if freeof(%c,z) then (if is(ev(equal(lhs(z),rhs(z))))#false then z else []) else ic1real(z,qivar,qdvar),z,solq),
solq:flatten(solq),
if not freeof(at,solq) then (if logabs=true then (logabs:false,go(startq)) else (solq:solq2,go(nextq))),
solq:flatten(makelist(solvereal(solqe,lhs(qdvar)),solqe,solq)),
nextq,
if not(ev(CheckAllSolved(solq),solvar=lhs(qdvar))) then 
(
load(contrib_ode),solq:contrib_ode(diffeqnq,lhs(qdvar),lhs(qivar))),
if length(paramq)=3 and not(freeof("=",qivar) or freeof("=",qdvar)) then 
  solq:makelist(
    if freeof(%c,z) then z else (ic1real(z,qivar,qdvar)),z,solq), 
if length(paramq)=3 and (freeof("=",qivar) or freeof("=",qdvar)) then return(solq),
solq:delete([],solq),
solq:unique(solq),
if length(paramq)<4 then return(solq),
if length(paramq)=4 and not(freeof(%k1,solq)) then solq:makelist(ic2(z,qivar,qdvar,paramq[4]),z,solq),
if length(paramq)=5 and not(freeof(%k1,solq)) then solq:makelist(bc2(z,qivar,qdvar,paramq[4],paramq[5]),z,solq),
solq
)$

/* Tager generel løsning til differentialligning og begyndelsesbetingelser og returnerer partikulær løsning. Erstatter ic1 som kunne returnere komplekse løsninger. Først sættes punktet ind. Så isoleres %c. %c substitueres ind og ligningen løses for y. Det kan nemlig give problemer hvis y isoleres først */
ic1real(solq,qivar,qdvar):=block([cq,z2],if domain=complex then return(ic1(solq,qivar,qdvar)),
solq2:at(solq,[qivar,qdvar]),
solq2:solvereal(solq2,%c),
solq:makelist(at(solq,z),z,solq2),
solq:makelist(solvereal(z,lhs(qdvar)),z,solq),
solq:flatten(solq)
)$

/* Tester om udsagnet er sandt, falsk eller ukendt både analytisk og numerisk */
TestTF(qexpr):=block([qres,qvar],
if not(freeof("=",qexpr)) then qexpr:equal(lhs(qexpr)-rhs(qexpr),0),
qres:is(qexpr),if qres#unknown then return(qres),qres:is(trigreduce(qexpr)),
if qres#unknown then return(qres),qres:is(radcan(qexpr)),if qres#unknown then return(qres), (qvar:listofvars(qexpr),if length(qvar)>0 then qvar:first(qvar) else return(unknown),qres:zeroequiv(lhs(qexpr)-rhs(qexpr),qvar)),if qres=true or qres=false then print("Numerically tested") ,
qres)$

/* Til håndtering af dobbeltbetydning af determinant  det(matrix) eller det(vektor,vektor) */
determinant2([paramq]):=block([],
if length(paramq)<1 then (print("Too few arguments"),return()) elseif length(paramq)>2 then (print("Too many arguments"),return()),
if length(paramq)=1 then return (determinant(paramq[1])),
determinant(addcol(paramq[1],paramq[2]))
)$

/* nsolve2 er mærkeligt nok langsommere i de fleste tilfælde men ikke ved sqrt(x)=x 
nsolve2(qlign,qvar):=block([qfkt,solq,qn,qm,ql,glf,qi,qa,qb,qno],solq:[],qn:-15,qm:15,qno:1000,
define(qfkt(qvar),lhs(qlign)-rhs(qlign)),
qa:ev((10^qm/10^qn)^(1/qno),numer),qb:ev(10^qn,numer),
qi:1,
ql:makelist(i,i,0,qno),
qln:-reverse(ql),
ql:append(qln,ql),
qlf:qfkt(ql),
do(
if qlf[qi]*qlf[qi+1]<=0 then solq:append(solq,flatten([errcatch(find_root(qfkt(qvar),qvar,ql[qi],ql[qi+1]))])),
qi:qi+1,
if qi>2*qno then return()
),
print("More solutions may exist"),
unique(solq)
)$ */


/* rref row reduced echelon form */
request_rational_matrix(m, pos, fn) :=
  if every('identity, map(lambda([s], every('ratnump,s)), args(m))) then true else
    print("Some entries in the matrix are not rational numbers. The result might be wrong.")$

rowswap(m,i,j) := block([n, p, r],
  require_matrix(m, "first", "rowswap"),
  require_integer(i, "second", "rowswap"),
  require_integer(j, "third", "rowswap"),
  n : length(m),
  if (i < 1) or (i > n) or (j < 1) or (j > n) 
     then error("Array index out of bounds"),
  p : copymatrix(m),
  r : p[i],
  p[i] : p[j],
  p[j] : r,
  p)$

addrow(m,i,j,k) := block([n,p],
  require_matrix(m, "first", "addrow"),
  require_integer(i, "second", "addrow"),
  require_integer(j, "third", "addrow"),
  require_rational(k, "fourth", "addrow"),
  n : length(m),
  if (i < 1) or (i > n) or (j < 1) or (j > n) 
      then error("Array index out of bounds"),
  p : copymatrix(m),
  p [i] : p[i] + k * p[j],
  p)$

rowmul(m,i,k) := block([n,p],
  require_matrix(m, "first", "addrow"),
  require_integer(i, "second", "addrow"),
  require_rational(k, "fourth", "addrow"),
  n : length(m),
  if (i < 1) or (i > n) then error("Array index out of bounds"),
  p : copymatrix(m),
  p [i] : k * p[i],
  p)$


rref(m):= block([p,nr,nc,i,j,k,pivot,pivot_row,debug],
  debug : 0,
  request_rational_matrix(m," ","rref"),
  nc: length(first(m)),
  nr: length(m),
  if nc = 0 or nr = 0 then
    error ("The argument to 'rref' must be a matrix with one or more rows and columns"),

  p:copymatrix(m),
  ci : 1, cj : 1,
  while (ci<=nr) and (cj<=nc) do 
  (
    if (debug = 1) then (
	    disp(p),                
	    print("curseur en ligne ",ci," et colonne ",cj)),   
    pivot_row : 0, pivot : 0,
    for k : ci thru nr do (
       if ( abs(p[k,cj]) > pivot ) then (
         pivot_row : k,
         pivot : abs(p[k,cj]))),
         if (debug = 1) then 
	   print("colonne ",cj," : pivot trouve ligne ", pivot_row,", valeur : ",pivot),  
    if (pivot = 0) then (cj : cj +1)
    else (
      p : rowswap(p,ci,pivot_row),
	if (debug = 1) then      print (".. Echange : ",p),  
      p : rowmul(p,ci,1/p[ci,cj]),        
	if (debug = 1) then     print (".. Normalisation : ",p),   
      for k : 1 thru nr do (
         if not (k=ci) then (p : addrow (p,k,ci,-p[k,cj]))),
      ci : ci+1, cj : cj+1)),
  p
)$

/* Bruges i slutningen af Auto til at teste om det numeriske resultat er eksakt. De to første parametre er det eksakte udtryk. Det sidste det numeriske
 Der er to fordi det andet er kørt igennem dectalall mm. Der kan komme unknown med det første udtryk. Derfor det andet.  */
IsResultExact(qi1,qi2,qn):=block([qr1,qr2],
qi2:ev(scanmap(strtonum,qi2),nouns),
qn:ev(scanmap(strtonum,qn),nouns),
qr1:ev(is(equal(qi1,qn)),numer),
qr2:ev(is(equal(qi2,qn)),numer),
print(qr2),
if qr1=true then true
elseif qr2=true and qr1#false then true
else false
)$