prederror : false;
false;

\f\o\o\b\a\r;
foobar;

"\f\o\o\b\a\r";
"foobar";

"foo\
\
\
\
\
bar";
"foobar";

"foo\\\
\
bar";
"foo\\bar";

"foo\"\
bar\"\
baz";
"foo\"bar\"baz";

"\?foo\ bar";
"?foo bar";

1\
2\
3\
4\
5\
6;
123456;

"a\ \ \ \ b";
"a    b";

"a\\\ \\\b";
"a\\ \\b";

125\
125e-3;
125125e-3;

125125\
e-3;
125125e-3;

125125e\
-3;
125125e-3;

125125e-\
3;
125125e-3;

si\
n(1);
sin(1);

cos(\
1);
cos(1);

12!\
!;
12!!;

(infix("blurfle"), 0);
0;

a blurf\
le b;
a blurfle b;

(mnewton(FuncList,VarList,GuessList):=block(
        [nfunc,NewtonMatrix,det,Solutions,Increments,numdet,solved:false,i,j,k,
         keepfloat:true,ratprint:false],GuessList:float(GuessList),
        nfunc:length(FuncList),
        if length(VarList) # nfunc
            then (print("mnewton: incorrect number of variable names (",nfunc,
                        "functions but",length(VarList),"variable names)."),
                  return(false)),
        if length(GuessList) # nfunc
            then (print("mnewton: incorrect number of approach values (",nfunc,
                        "variables but",length(GuessList),
                        "approximation values)."),return(false)),
        apply(kill,VarList),NewtonMatrix:zeromatrix(nfunc,nfunc),
        for i thru nfunc do
            (for j thru nfunc do
                 NewtonMatrix[i][j]:diff(FuncList[i],VarList[j])),
        det:determinant(NewtonMatrix),NewtonMatrix:adjoint(NewtonMatrix),
        NewtonMatrix:NewtonMatrix . FuncList,
        for k thru NEWTONMAXITER do
            (Solutions:map("=",VarList,GuessList),
             numdet:float(sublis(Solutions,det)),
             if abs(numdet) < NEWTONEPSILON then return(0),
             Increments:float(rectform(expand(
                                        sublis(Solutions,
                                               NewtonMatrix/numdet)))),
             if atom(Increments) then Increments:matrix([Increments]),
             GuessList:GuessList-makelist(Increments[i][1],i,1,nfunc),
             solved:true,
             for i thru nfunc do
                 solved:solved and abs(Increments[i][1]) < NEWTONEPSILON,
             if solved then return(0)),
        if solved = false
            then (print("mnewton: the process doesn't converge or it converges too slowly."),
                  return([])),Solutions:map("=",VarList,GuessList),
        return([Solutions])),
mnewton_defn1: fundef (mnewton), 0);
0;

/* following is the result of (linel : 32, string (fundef (mnewton))) given the above definition. */

(mnewton(FuncList,VarList,\
GuessList):=block([nfunc,Newton\
Matrix,det,Solutions,Increments\
,numdet,solved:false,i,j,k,keep\
float:true,ratprint:false],Gues\
sList:float(GuessList),nfunc:le\
ngth(FuncList),if length(VarLis\
t) # nfunc then (print("mnewton\
: incorrect number of variable \
names (",nfunc,"functions but",\
length(VarList),"variable names\
)."),return(false)),if length(G\
uessList) # nfunc then (print("\
mnewton: incorrect number of ap\
proach values (",nfunc,"variabl\
es but",length(GuessList),"appr\
oximation values)."),return(fal\
se)),apply(kill,VarList),Newton\
Matrix:zeromatrix(nfunc,nfunc),\
for i thru nfunc do (for j thru\
 nfunc do NewtonMatrix[i][j]:di\
ff(FuncList[i],VarList[j])),det\
:determinant(NewtonMatrix),Newt\
onMatrix:adjoint(NewtonMatrix),\
NewtonMatrix:NewtonMatrix . Fun\
cList,for k thru NEWTONMAXITER \
do (Solutions:map("=",VarList,G\
uessList),numdet:float(sublis(S\
olutions,det)),if abs(numdet) <\
 NEWTONEPSILON then return(0),I\
ncrements:float(rectform(expand\
(sublis(Solutions,NewtonMatrix/\
numdet)))),if atom(Increments) \
then Increments:matrix([Increme\
nts]),GuessList:GuessList-makel\
ist(Increments[i][1],i,1,nfunc)\
,solved:true,for i thru nfunc d\
o solved:solved and abs(Increme\
nts[i][1]) < NEWTONEPSILON,if s\
olved then return(0)),if solved\
 = false then (print("mnewton: \
the process doesn't converge or\
 it converges too slowly."),ret\
urn([])),Solutions:map("=",VarL\
ist,GuessList),return([Solution\
s])),
mnewton_defn2: fundef (mnewton), 0);
0;

is (equal (mnewton_defn1, mnewton_defn2));
true;

prederror : true;
true;

