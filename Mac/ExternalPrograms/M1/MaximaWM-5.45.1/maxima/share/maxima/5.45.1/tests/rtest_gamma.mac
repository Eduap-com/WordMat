/******************************************************************************
  rtest_gamma.mac
  Test for Factorial, Gamma function and related functions ...
******************************************************************************/

kill(all);
done;

(oldfpprec:fpprec, fpprec:16, done);
done;

/* Two definitions for numerical test functions
   For big results relerror is used */

(closeto(value,compare,tol):=
  block(
    [abse],
    abse:abs(value-compare),if(abse<tol) then true else abse),
    done);
done;

(relerror(value,compare,tol):=
  block(
    [abse],
    abse:abs((value-compare)/compare),
    if(abse<tol) then true else abse),
    done);
done;

/******************************************************************************
  Factorial
******************************************************************************/

/* Factorial has mirror symmetry */

declare(z,complex);
done;

conjugate(factorial(z));
factorial(conjugate(z));

conjugate(factorial(x+%i*y));
factorial(x-%i*y);

/* some small positive integers or the real representation */

fpprec:16;
16;

map(factorial, [0,1,2,3,4]);
[1,1,2,6,24];

closeto(factorial(0.0),1.0,1e-13);
true;
closeto(factorial(1.0),1.0,1e-13);
true;
closeto(factorial(2.0),2.0,1e-13);
true;
closeto(factorial(3.0),6.0,1e-13);
true;
closeto(factorial(4.0),24.0,1e-13);
true;

closeto(factorial(0.0b0),1.0b0,1e-13);
true;
closeto(factorial(1.0b0),1.0b0,1e-13);
true;
closeto(factorial(2.0b0),2.0b0,1e-13);
true;
closeto(factorial(3.0b0),6.0b0,1e-13);
true;
closeto(factorial(4.0b0),24.0b0,1e-13);
true;

/* negative integers or there real representation */

errcatch(factorial(-1));
[];

errcatch(factorial(-1.0));
[];

errcatch(factorial(-1.0b0));
[];

errcatch(factorial(-10));
[];

errcatch(factorial(-10.0));
[];

errcatch(factorial(-10.0b0));
[];

/* half integral values */

factorial(1/2);
sqrt(%pi)/2;
factorial(-1/2);
sqrt(%pi);
factorial(3/2);
3*sqrt(%pi)/4;
factorial(-3/2);
-2*sqrt(%pi);
factorial(5/2);
15*sqrt(%pi)/8;
factorial(-5/2);
4*sqrt(%pi)/3;

/* Expansion for factorial(z+n) and integer n */

factorial_expand:true;
true;

factorial(z+1);
(z+1)*factorial(z);

factorial(z+2);
(z+1)*(z+2)*factorial(z);

factorial(z+3);
(z+1)*(z+2)*(z+3)*factorial(z);

factorial(z-1);
factorial(z)/z;

factorial(z-1);
factorial(z)/z;

factorial(z-2);
factorial(z)/(z*(z-1));

factorial(z-3);
factorial(z)/(z*(z-1)*(z-2));

/* Nested factorials simplifies too, see SF[1486452] */

factorial(factorial(n)/factorial(n-1));
factorial(n);

factorial(sin(factorial(n)/factorial(n-1)));
factorial(sin(n));

factorial_expand:false;
false;

/* minfactorial does not do this job */

minfactorial(factorial(factorial(n)/factorial(n-1)));
factorial(factorial(n)/factorial(n-1));

/* factcomb is the inverse operation to minfactorial 
   factorial_expand has to be false 
*/

factcomb((n+1)*(n+2)*(n+3)*n!);
(n+3)!;

factcomb(n!/(n*(n-1)*(n-2)));
(n-3)!;

/* No simplifcation for infinities and undeterminates 
   with the exception of inf! -> inf */

map(factorial, [inf,minf,infinity,und,ind]);
[inf,factorial(minf),factorial(infinity),factorial(und),factorial(ind)];

/* factlim is set to the value 100,000. This should work.  */

fpprec:64;
64;

relerror(
  factorial(factlim),
  factorial(bfloat(factlim)),
  1b-58);                      /* We loose a lost of digits in relerror */
true;

factorial(factlim+1);
factorial(100000+1);

/* Some real values in double float and bigfloat precision */

fpprec:64;
64;

closeto(
  factorial(1.3),
  1.166711905198160345041881441202917938533994349719468893970206664b0,
  1e-14);
true;

closeto(
  factorial(2.3),
  2.683437381955768793596327314766711258628187004354778456131475327b0,
  1e-14);
true;

closeto(
  factorial(3.3),
  8.855343360454037018867880138730147153473017114370768905233868579b0,
  1e-14);
true;

closeto(
  factorial(1.3b0),
  1.166711905198160345041881441202917938533994349719468893970206664b0,
  1e-62);
true;

closeto(
  factorial(2.3b0),
  2.683437381955768793596327314766711258628187004354778456131475327b0,
  1e-62);
true;

closeto(
  factorial(3.3b0),
  8.855343360454037018867880138730147153473017114370768905233868579b0,
  1e-61);
true;

/* some complex values in double float and bigfloat precision */

closeto(
  factorial(1.3+%i),
  (0.7191409365372817791473038599462048083254863806205029128993808432b0 
  +0.5406144679098492753783510221774150545811250310680842509749769021b0*%i),
  1e-14);
true;

closeto(
  factorial(2.3+%i),
  (1.113409686125898816660447855698856004567493644359072448693599037b0 
  +1.962554212729935112517511210954259433862073952077096690141827718b0*%i),
  1e-14);
true;

closeto(
  factorial(3.3+%i),
  (1.711697751485530982461966712851965381210655074307842390547049105b0 
  +7.589838588134684687968234851847912136312337686213491526161630507b0*%i),
  5.0e-14);
true;

closeto(
  factorial(1.3b0+%i),
  (0.7191409365372817791473038599462048083254863806205029128993808432b0 
  +0.5406144679098492753783510221774150545811250310680842509749769021b0*%i),
  1e-62);
true;

closeto(
  factorial(2.3b0+%i),
  (1.113409686125898816660447855698856004567493644359072448693599037b0 
  +1.962554212729935112517511210954259433862073952077096690141827718b0*%i),
  1e-62);
true;

closeto(
  factorial(3.3b0+%i),
  (1.711697751485530982461966712851965381210655074307842390547049105b0 
  +7.589838588134684687968234851847912136312337686213491526161630507b0*%i),
  1e-61);
true;

/******************************************************************************
  General factorial: Tests for genfact(x,y,z)
******************************************************************************/

genfact(0,0,1);
1;
genfact(1,1,1);
1;
genfact(2,2,1);
2;
genfact(3,3,1);
6;
genfact(4,4,1);
24;

genfact(0,0/2,2);
1;
genfact(1,1/2,2);
1;
genfact(2,2/2,2);
2;
genfact(3,3/2,2);
3;
genfact(4,4/2,2);
8;

genfact(10,10,1);
3628800;
genfact(10,9,1);
3628800;
genfact(10,8,1);
1814400;
genfact(10,7,1);
604800;
genfact(10,6,1);
151200;
genfact(10,5,1);
30240;
genfact(10,4,1);
5040;
genfact(10,3,1);
720;
genfact(10,2,1);
90;
genfact(10,1,1);
10;
genfact(10,0,1);
1;

genfact(10,5,2);
3840;
genfact(10,4,2);
1920;
genfact(10,3,2);
480;
genfact(10,2,2);
80;
genfact(10,1,2);
10;
genfact(10,0,2);
1;

/* for non valid integers we get an error */
errcatch(genfact(-2,-2,1));
[];
errcatch(genfact(2,5,2));
[];

/* for all other numbers we get a noun form */
(3/2)!!;
genfact(3/2,0,2);
(2.5)!!;
genfact(2.5,1,2);
(2.5b0)!!;
genfact(2.5b0,1,2);

/******************************************************************************
  Double factorial
******************************************************************************/

/* Double factorial has mirror symmetry */

declare(z,complex);
done;

conjugate(double_factorial(z));
double_factorial(conjugate(z));

conjugate(double_factorial(x+%i*y));
double_factorial(x-%i*y);

/* No simplifcation for infinities and undeterminates 
   with the exception of inf: inf! -> inf */

map(factorial, [inf,minf,infinity,und,ind]);
[inf,factorial(minf),factorial(infinity),factorial(und),factorial(ind)];

/* Test the expansion of Double factorial */

double_factorial(n+1);
double_factorial(n+1);

double_factorial(n+2),factorial_expand:true;
(n+2)*double_factorial(n);

double_factorial(n+3),factorial_expand:true;
double_factorial(n+3);

double_factorial(n+4),factorial_expand:true;
(n+2)*(n+4)*double_factorial(n);

double_factorial(n-1),factorial_expand:true;
factorial(n)/double_factorial(n);

double_factorial(n-2),factorial_expand:true;
double_factorial(n)/n;

double_factorial(n-3),factorial_expand:true;
double_factorial(n-3);

double_factorial(n-4),factorial_expand:true;
double_factorial(n)/(n*(n-2));

makegamma(double_factorial(n));
(gamma(n/2+1)*2^((1-cos(%pi*n))/4+n/2))/%pi^((1-cos(%pi*n))/4);

/* Some small numbers */

double_factorial(-3);
-1;
errcatch(double_factorial(-2));
[];
double_factorial(-1);
1;
double_factorial(0);
1;
double_factorial(1);
1;
double_factorial(2);
2;
double_factorial(3);
3;
double_factorial(4);
8;
double_factorial(5);
15;
double_factorial(6);
48;
double_factorial(7);
105;
double_factorial(8);
384;
double_factorial(9);
945;
double_factorial(10);
3840;

/* The same for double float */

closeto(
  double_factorial(-3.0),
  -1.0,
  1e-13);
true;

errcatch(double_factorial(-2.0));
[];

closeto(
  double_factorial(-1.0),
  1.0,
  1e-13);
true;

closeto(
  double_factorial(0.0),
  1.0,
  1e-13);
true;

closeto(
  double_factorial(1.0),
  1.0,
  1e-13);
true;

closeto(
  double_factorial(2.0),
  2.0,
  1e-13);
true;

closeto(
  double_factorial(3.0),
  3.0,
  1e-13);
true;

closeto(
  double_factorial(4.0),
  8.0,
  1e-13);
true;

closeto(
  double_factorial(5.0),
  15.0,
  1e-13);
true;

closeto(
  double_factorial(6.0),
  48.0,
  1e-13);
true;

closeto(
  double_factorial(7.0),
  105.0,
  1.279e-13);
true;

closeto(
  double_factorial(8.0),
  384.0,
  1e-12);
true;

closeto(
  double_factorial(9.0),
  945.0,
  1e-11);
true;

closeto(
  double_factorial(10.0),
  3840.0,
  1.5E-12);
true;

/* The same with bigfloat */
fpprec:64;
64;

closeto(
  double_factorial(-3.0b0),
  -1.0b0,
  1e-13);
true;

errcatch(double_factorial(-2.0b0));
[];

closeto(
  double_factorial(-1.0b0),
  1.0b0,
  1e-13);
true;

closeto(
  double_factorial(0.0b0),
  1.0b0,
  1e-13);
true;

closeto(
  double_factorial(1.0b0),
  1.0b0,
  1e-13);
true;

closeto(
  double_factorial(2.0b0),
  2.0b0,
  1e-13);
true;

closeto(
  double_factorial(3.0b0),
  3.0b0,
  1e-13);
true;

closeto(
  double_factorial(4.0b0),
  8.0b0,
  1e-13);
true;

closeto(
  double_factorial(5.0b0),
  15.0b0,
  1e-13);
true;

closeto(
  double_factorial(6.0b0),
  48.0b0,
  1e-13);
true;

closeto(
  double_factorial(7.0b0),
  105.0b0,
  1e-13);
true;

closeto(
  double_factorial(8.0b0),
  384.0b0,
  1e-13);
true;

closeto(
  double_factorial(9.0b0),
  945.0b0,
  1e-13);
true;

closeto(
  double_factorial(10.0b0),
  3840.0b0,
  1e-13);
true;

/* Some real and complex values */

closeto(
  double_factorial(-3.5),
  -1.283770376595223397225456287264697304361344685971440894669095353b0,
  1e-13);
true;

closeto(
  double_factorial(-3.5b0),
  -1.283770376595223397225456287264697304361344685971440894669095353b0,
  1e-60);
true;

closeto(
  double_factorial(-3.5+%i),
  (-0.0026442534512730229977827874410755514695008373007370518369259413b0 
   +0.4140148090845355309500755922424659939330568167751526009311942842b0*%i),
  1e-13);
true;

closeto(
  double_factorial(3.5),
  4.832319386136852665658314936437452651454869331098044546829825309b0,
  1e-13);
true;

closeto(
  double_factorial(3.5b0),
  4.832319386136852665658314936437452651454869331098044546829825309b0,
  1e-60);
true;

closeto(
  double_factorial(3.5+%i),
  (-2.165793510810110416038389252512222520262890874310470919228355939b0 
   +4.032141259508464573377851775093179996368679285808989461893416849b0*%i),
  1e-13);
true;

closeto(
  double_factorial(-3.5b0+%i),
  (-0.0026442534512730229977827874410755514695008373007370518369259413b0 
   +0.4140148090845355309500755922424659939330568167751526009311942842b0*%i),
  1e-60);
true;

closeto(
  double_factorial(3.5b0+%i),
  (-2.165793510810110416038389252512222520262890874310470919228355939b0 
   +4.032141259508464573377851775093179996368679285808989461893416849b0*%i),
  1b-60);
true;

closeto(
  double_factorial(3.3b0+%i),
  (-0.401169963963553982868990904015984192029807700247132080411340721b0 
  + 1.778201955902329072861901606357849890890501421219437116360540910b0*%i),
  1b-60);
true;

/******************************************************************************

  Test the Gamma function

  Numerical values are taken from functions/wolfram.com.
******************************************************************************/

/* The Gamma function has mirror symmetry */

declare(z,complex);
done;

conjugate(gamma(z));
gamma(conjugate(z));

conjugate(gamma(x+%i*y));
gamma(x-%i*y);

/* Check some simple values for integer, float and bigfloat */

map('gamma,[1,2,3,4,5]);
[1,1,2,6,24];

closeto(gamma(1.0),1.0,1e-13);
true;

closeto(gamma(2.0),1.0,1e-13);
true;

closeto(gamma(3.0),2.0,1e-13);
true;

closeto(gamma(4.0),6.0,1e-13);
true;

closeto(gamma(5.0),24.0,5e-13);  
true;

closeto(gamma(1.0b0),1.0b0,1e-13);
true;

closeto(gamma(2.0b0),1.0b0,1e-13);
true;

closeto(gamma(3.0b0),2.0b0,1e-13);
true;

closeto(gamma(4.0b0),6.0b0,1e-13);
true;

closeto(gamma(5.0b0),24.0b0,1e-13);
true;

/* Check for a zero argument */

errcatch(gamma(0));
[];
errcatch(gamma(0.0));
[];
errcatch(gamma(0.0b0));
[];

/* Check test for negative integer or a representation of a negative integer */

errcatch(gamma(-2));
[];
errcatch(gamma(-2.0));
[];
errcatch(gamma(-2.b0));
[];

/* Check the correct handling of the $numer flag */

gamma(%e),numer;
1.5674682557740529;
gamma(%e),numer,%enumer;
1.5674682557740529;
gamma(a+b),numer;
gamma(a+b);
gamma(%i);
gamma(%i);
gamma(%i),numer;
gamma(1.0*%i);   /* Evaluates to a complex number */

/* Check half integral integers as values */

gamma(1/2);
sqrt(%pi);
gamma(-1/2);
-2*sqrt(%pi);
gamma(3/2);
sqrt(%pi)/2;
gamma(-3/2);
4*sqrt(%pi)/3;
gamma(5/2);
3*sqrt(%pi)/4;
gamma(-5/2);
-8*sqrt(%pi)/15;

/* Check expansion of the Gamma function */

gamma_expand:true;
true;

gamma(z+1)/gamma(z);
z;

gamma(gamma(z+1)/gamma(z));
gamma(z);

gamma(z+1)/gamma(z-1);
(z-1)*z;

gamma(z+2)/gamma(z-2);
(z-2)*(z-1)*z*(z+1);

gamma_expand:false;
false;

/* We check that the default values for $factlim:100000 and 
   $gammalim:10000 work. */

fpprec:16;
16;

relerror(
  bfloat(gamma(factlim)),
  gamma(bfloat(factlim)),
  1b-14);
true;

relerror(
  bfloat(gamma((gammalim-1)+1/2)),
  gamma(bfloat((gammalim-1)+1/2)),
  1b-15);
true;

relerror(
  bfloat(gamma(-gammalim+1/2)),
  gamma(bfloat(-gammalim+1/2)),
  1b-15);
true;

/* Check test for overflow in flonum routine gamma-lanczos */

relerror(
  gamma(170.0),          /* should not overflow. For GCL 2.6.8 and */
  float(gamma(170)),     /* and CLISP 2.44 the limit is ~171.6243  */
  1e-12);
true;       

errcatch(gamma(175.0));  /* should overflow */
[];

errcatch(gamma(250.0));  /* should overflow */
[];

/* Simplifcation for infinities and undeterminates only for inf */

map('gamma, [inf,minf,infinity,und,ind]);
[inf,gamma(minf),gamma(infinity),gamma(und),gamma(ind)];

/* Check real and complex arguments in double float precision. 
   This is a check for the numerical routine gamma-lanczos */

closeto(
  gamma(1.5),
  0.8862269254527580136490837416705725913987747280611935641069038949b0,
  1e-14);
true;

closeto(
  gamma(2.5),
  1.329340388179137020473625612505858887098162092091790346160355842b0,
  1e-14);
true;

closeto(
  gamma(3.5),
  3.323350970447842551184064031264647217745405230229475865400889606b0,
  1e-14);
true;

relerror(
  gamma(75.5),
  2.859942315653572214189951793671955438617013849084406338093590075b108,
  5e-14);
true;

closeto(
  gamma(0.5+%i),
  (0.3006946172606558162173894638352104402306759641691949986162475934b0 
  -0.4249678794331238126098496402574059704734842223340586518754297249b0*%i),
  1e-14);
true;

closeto(
  gamma(1.5+%i),
  (0.5753151880634517207185443721750111905888222044186561511835535216b0 
  +0.0882106775440939099124646437065074549939338530021656726785327309b0*%i),
  1e-14);
true;

closeto(
  gamma(2.5+%i),
  (0.7747621045510836711653519145560093308892994536258185540967975514b0 
  +0.7076312043795925855872413377347723730797229839219046602013526179b0*%i),
  1e-14);
true;

closeto(
  gamma(3.5+%i),
  (1.229274056998116592326138448655250954143525650142641725040641261b0 
  +2.543840115500065135133455258892940263588606913430580204600179096b0*%i),
  1e-14);
true;

relerror(
  gamma(75.5+%i),
  (-1.092860022497734443706055997676557155572470037327121860702819811b108 
   -2.622326961675321010452173874453854546607804545768376326095021243b108*%i),
  5.339e-14);
true;

/* Check negative real arguments in double float precision. 
   This is a check for the reflection formula of gamma-lanzos */

closeto(
  gamma(-0.5),
  -3.544907701811032054596334966682290365595098912244774256427615580b0,
  1e-14);
true;

closeto(
  gamma(-1.5),
  2.363271801207354703064223311121526910396732608163182837618410386b0,
  1e-14);
true;

closeto(
  gamma(-2.5),
  -0.9453087204829418812256893244486107641586930432652731350473641546b0,
  1e-14);
true;

/* Check real arguments up to 64 digits. 
   This is a check for the numerical routine bffac */

fpprec:64; /* we have saved the actual value at the beginning of the file */
64;

closeto(
  gamma(0.5b0),
  1.772453850905516027298167483341145182797549456122387128213807790b0,
  5.0b-64);
true;

closeto(
  gamma(1.5b0),
  0.8862269254527580136490837416705725913987747280611935641069038949b0,
  5.0b-64);
true;

closeto(
  gamma(2.5b0),
  1.329340388179137020473625612505858887098162092091790346160355842b0,
  5.0b-64);
true;

closeto(
  gamma(3.5b0),
  3.323350970447842551184064031264647217745405230229475865400889606b0,
  5.0b-64);
true;

relerror(
  gamma(75.5b0),
  2.859942315653572214189951793671955438617013849084406338093590075b108,
  5.0b-64);
true;

/* Check negative real arguments up to 64 digits. 
   This is a check for the reflection formula of bffac */

closeto(
  gamma(-0.5b0),
  -3.544907701811032054596334966682290365595098912244774256427615580b0,
  5.0b-64);
true;

closeto(
  gamma(-1.5b0),
  2.363271801207354703064223311121526910396732608163182837618410386b0,
  8.0b-64);
true;

closeto(
  gamma(-2.5b0),
  -0.9453087204829418812256893244486107641586930432652731350473641546b0,
  5.0b-64);
true;

/* Check complex arguments up to 64 digits. 
   This is a check for the numerical routine cbffac */

closeto(
  gamma(0.5b0+%i),
  (0.3006946172606558162173894638352104402306759641691949986162475934b0 
  -0.4249678794331238126098496402574059704734842223340586518754297249b0*%i),
  5.0b-64);
true;

closeto(
  gamma(1.5b0+%i),
  (0.5753151880634517207185443721750111905888222044186561511835535216b0 
  +0.0882106775440939099124646437065074549939338530021656726785327309b0*%i),
  5.0b-64);
true;

closeto(
  gamma(2.5b0+%i),
  (0.7747621045510836711653519145560093308892994536258185540967975514b0 
  +0.7076312043795925855872413377347723730797229839219046602013526179b0*%i),
  5.0b-64);
true;

closeto(
  gamma(3.5b0+%i),
  (1.229274056998116592326138448655250954143525650142641725040641261b0 
  +2.543840115500065135133455258892940263588606913430580204600179096b0*%i),
  5.0b-64);
true;

relerror(
  gamma(75.5b0+%i),
  (-1.092860022497734443706055997676557155572470037327121860702819811b108 
   -2.622326961675321010452173874453854546607804545768376326095021243b108*%i),
  5.0b-64);
true;

(fpprec:oldfpprec,done); /* Reset the value of fpprec */
done;

/******************************************************************************

  Test the Incomplete Gamma function

******************************************************************************/

(oldfpprec : fpprec,done);
done;

/* Some special values */

gamma_incomplete(a,0);
gamma_incomplete(a,0);

(assume(am < 0, ap > 0),done);
done;

errcatch(gamma_incomplete(-1,0));
[];
errcatch(gamma_incomplete(-2,0));
[];
errcatch(gamma_incomplete(am,0));
[];
gamma_incomplete(1,0);
1;
gamma_incomplete(2,0);
1;
gamma_incomplete(3,0);
2;
gamma_incomplete(ap,0);
gamma(ap);

gamma_incomplete(a,inf);
0;

/* Expansion of the Incomplete Gamma function */

gamma_expand:true;
true;

gamma_incomplete(0,z);
-expintegral_ei(-z)+1/2*(log(-z)-log(-1/z))-log(z);

gamma_incomplete(1/2,z);
sqrt(%pi)*erfc(sqrt(z));

gamma_incomplete(-1/2,z);
2*%e^(-z)/sqrt(z)-2*sqrt(%pi)*erfc(sqrt(z));

gamma_incomplete(1,z);
%e^-z;
 
gamma_incomplete(-1,z);
log(z)-(log(-z)-log(-1/z))/2+expintegral_ei(-z)+%e^-z/z;

gamma_incomplete(3/2,z);
sqrt(z)*%e^-z+sqrt(%pi)*erfc(sqrt(z))/2;

gamma_incomplete(-3/2,z);
4*sqrt(%pi)*erfc(sqrt(z))/3-(4*z/3-2/3)*%e^-z/z^(3/2);

gamma_incomplete(2,z);
(z+1)*%e^-z;

gamma_incomplete(a+1,z);
z^a*%e^-z+a*gamma_incomplete(a,z);

gamma_incomplete(a-1,z);
-z^(a-1)*%e^-z/(a-1)-gamma_incomplete(a,z)/(1-a);

gamma_incomplete(a+2,z);
z^a*(z+a+1)*%e^-z+a*(a+1)*gamma_incomplete(a,z);

gamma_incomplete(a-2,z);
gamma_incomplete(a,z)/((1-a)*(2-a))-z^(a-2)*(z/((a-2)*(a-1))+1/(a-2))*%e^-z;

gamma_expand:false;
false;

/* The Incomplete Gamma function has not mirror symmetry on the negative
   real axis. We have supported a conjugate-gamma-incomplete function */

declare(ac, complex, zc,complex);
done;

conjugate(gamma_incomplete(ac,zc));
conjugate(gamma_incomplete(ac,zc));

conjugate(gamma_incomplete(a+b*%i,x+y*%i));
conjugate(gamma_incomplete(a+b*%i,x+y*%i));

conjugate(gamma_incomplete(a+b*%i,10));
gamma_incomplete(a-b*%i,10);

conjugate(gamma_incomplete(a+b*%i,-10));
conjugate(gamma_incomplete(a+b*%i,-10));

/* Derivatives of the Incomplete Gamma function */

diff(gamma_incomplete(a,x),x);
-x^(a-1)*%e^(-x);

/* Noun form if sign of the parameter a is not known */
diff(gamma_incomplete(a,x),a);
'diff(gamma_incomplete(a,x),a);

/* The parameter a has a positive sign */
(assume(a>0),done);
done;

expand(diff(gamma_incomplete(a,x),a)-
(-(gamma(a)-gamma_incomplete(a,x))*log(x)
       +gamma(a)^2*hypergeometric_regularized([a,a],[a+1,a+1],-x)*x^a
       +psi[0](a)*gamma(a)));
0;

(forget(a>0),done);
done;

/* Numerical tests for the Incomplete Gamma function */

/* At first tests for a=0 and negative integers for a 
   For this values the numerical algorithm of gamma-incomplete do not
   work. The routines of the Exponential Integral E are used. */

closeto(
  gamma_incomplete(0,0.5),
  0.55977359477616081174679593931509b0,
  5e-15);
true;

closeto(
  gamma_incomplete(0,-0.5),
  -0.4542199048631735799205238126628b0-3.1415926535897932384626433832795b0*%i,
  5e-15);
true;

closeto(
  gamma_incomplete(0,0.5+%i),
  -0.07139471104245272355588497993684b0-0.35749377365216265125485869345732b0*%i,
  5e-15);
true;

closeto(
  gamma_incomplete(0,-0.5+%i),
  -0.92289919055678882179364241497461b0-0.81571273343182452677967141350955b0*%i,
  5e-15);
true;

/* Now for bigfloat precision */

fpprec:32;
32;

closeto(
  gamma_incomplete(0,0.5b0),
  0.55977359477616081174679593931509b0,
  1b-30);
true;

closeto(
  gamma_incomplete(0,-0.5b0),
  -0.4542199048631735799205238126628b0-3.1415926535897932384626433832795b0*%i,
  1b-30);
true;

closeto(
  gamma_incomplete(0,0.5b0+%i),
  -0.07139471104245272355588497993684b0-0.35749377365216265125485869345732b0*%i,
  1b-30);
true;

closeto(
  gamma_incomplete(0,-0.5b0+%i),
  -0.92289919055678882179364241497461b0-0.81571273343182452677967141350955b0*%i,
  1b-30);
true;

/* Tests with negative integers */

closeto(
  gamma_incomplete(-1,-0.5),
  -2.8432226365370827137767777629655b0+3.1415926535897932384626433832795b0*%i,
  5e-15);
true;

closeto(
  gamma_incomplete(-5,-0.5),
  -12.1692735494620863710665339515891b0+0.0261799387799149436538553615273b0*%i,
  8e-15);
true;

closeto(
  gamma_incomplete(-1,-0.5+%i),
  -0.54330486022427331058655939975980b0+0.65800685452922697341354545991819b0*%i,
  5e-15);
true;

closeto(
  gamma_incomplete(-5,-0.5+%i),
  0.08881923337904654547301590363812b0+0.18155943299796684573147338017934b0*%i,
  5e-15);
true;

/* Again for bigfloat precision */

closeto(
  gamma_incomplete(-1,-0.5b0),
  -2.8432226365370827137767777629655b0+3.1415926535897932384626433832795b0*%i,
  1b-30);
true;

closeto(
  gamma_incomplete(-5,-0.5b0),
  -12.1692735494620863710665339515891b0+0.0261799387799149436538553615273b0*%i,
  1b-30);
true;

closeto(
  gamma_incomplete(-1,-0.5b0+%i),
  -0.54330486022427331058655939975980b0+0.65800685452922697341354545991819b0*%i,
  1b-30);
true;

closeto(
  gamma_incomplete(-5,-0.5b0+%i),
  0.08881923337904654547301590363812b0+0.18155943299796684573147338017934b0*%i,
  1b-30);
true;

/* Test gamma_incomplete(0.25,2.5) for Float and Bigfloat */

closeto(
  gamma_incomplete(0.25,2.5),
  0.03340545777928488523612480546612030546638337899458717728445920914b0,
  1e-15);
true;

fpprec:32;
32;

closeto(
  gamma_incomplete(0.25b0,2.5b0),
  0.03340545777928488523612480546612030546638337899458717728445920914b0,
  1b-31);
true;

fpprec:64;
64;

closeto(
  gamma_incomplete(0.25b0,2.5b0),
  0.03340545777928488523612480546612030546638337899458717728445920914b0,
  1b-63);
true;

/* Test gamma_incomplete(0.25,0.25) for Float and Bigfloat */

closeto(
  gamma_incomplete(0.25,0.25),
  0.9293237832774184425973508042578251762794944752213875213176435274b0,
  5.0e-15);
true;

fpprec:32;
32;

closeto(
  gamma_incomplete(0.25b0,0.25b0),
  0.9293237832774184425973508042578251762794944752213875213176435274b0,
  1.1b-31);
true;

fpprec:64;
64;

closeto(
  gamma_incomplete(0.25b0,0.25b0),
  0.9293237832774184425973508042578251762794944752213875213176435274b0,
  1.1b-63);
true;

/* Test gamma_incomplete(0.25,0.50) for Float and Bigfloat */

closeto(
  gamma_incomplete(0.25,0.50),
  0.55658041400942713438787175086207b0,
  5.0e-15);
true;

fpprec:32;
32;

closeto(
  gamma_incomplete(0.25b0,0.50b0),
  0.55658041400942713438787175086207b0,
  1b-31);
true;

fpprec:64;
64;

closeto(
  gamma_incomplete(0.25b0,0.50b0),
  0.5565804140094271343878717508620650091658338999776480841533264361b0,
  2b-63);
true;

fpprec:128;
128;

closeto(
  gamma_incomplete(0.25b0,0.50b0),
  0.55658041400942713438787175086206500916583389997764808415332643613122015052649897833312327325822333229784708198027750127190766504b0,  
  1.0b-127);
true;

/* Test gamma_incomplete(0.25,1.50) for Float and Bigfloat */

closeto(
  gamma_incomplete(0.25,1.50),
  0.12115499104033848614860340878369b0,
  1e-15);
true;

fpprec:32;
32;

closeto(
  gamma_incomplete(0.25b0,1.50b0),
  0.12115499104033848614860340878369b0,
  1b-31);
true;

fpprec:64;
64;

closeto(
  gamma_incomplete(0.25b0,1.50b0),
  0.1211549910403384861486034087836891246955052387140720625064500006b0,
  1.5b-63);
true;

fpprec:128;
128;

closeto(
  gamma_incomplete(0.25b0,1.50b0),
  0.12115499104033848614860340878368912469550523871407206250645000059332022509505923467877887847273887882437030555876962014143410940b0,
  4b-127);
true;

closeto(
  gamma_incomplete(0.25b0,1.50b0),
  1.5b0^0.25b0*expintegral_e(1.0b0-0.25b0,1.50b0),
  5b-128);
true;

fpprec:34; /* Two extra digits to get 32 digits in the following tests */
34;

relerror(
  gamma_incomplete(1000b0,1000b0),
  1.995014933549148239529838438260433407652488769526598301696165147b2564, 
  1b-32);
true;

relerror(
  gamma_incomplete(1000b0,100b0),
  4.023872600770937735437024339230039857193748642107146325437999104b2564,
  1b-32);
true;

relerror(
  gamma_incomplete(1000b0,10b0),
  4.023872600770937735437024339230039857193748642107146325437999104b2564,
  1b-32);
true;

relerror(
  gamma_incomplete(1000b0,1b0),
  4.023872600770937735437024339230039857193748642107146325437999104b2564,
  1b-32);
true;

relerror(
  gamma_incomplete(1000b0,-1b0),
  4.023872600770937735437024339230039857193748642107146325437999104b2564,
  1b-32);
true;

relerror(
  gamma_incomplete(1000b0,-10b0),
  4.023872600770937735437024339230039857193748642107146325437999104b2564,
  1b-32);
true;

relerror(
  gamma_incomplete(1000b0,-100b0),
  4.023872600770937735437024339230039857193748642107146325437999104b2564,
  1b-32);
true;

relerror(
  gamma_incomplete(1000b0,-1000b0),
  -9.852818774470566937423668137175694874333788729537950495924821627b3430,
  1b-32);
true;

relerror(
  gamma_incomplete(100b0,100b0),
  4.542198120862669429369147083086235039624517049342017449058357596b155,
  1b-32);
true;

relerror(
  gamma_incomplete(100b0,10b0),
  9.332621544394415268169923885626670049071596826438162146859296339b155,
  1b-32);
true;

relerror(
  gamma_incomplete(100b0,1b0),
  9.332621544394415268169923885626670049071596826438162146859296390b155,
  1b-32);
true;

relerror(
  gamma_incomplete(100b0,-1b0),
  9.332621544394415268169923885626670049071596826438162146859296390b155,
  1b-32);
true;

relerror(
  gamma_incomplete(100b0,-10b0),
  9.332621544394415268169923885626670049071596826438162126818796880b155,
  1b-32);
true;

relerror(
  gamma_incomplete(100b0,-100b0),
  -1.3474270960118181325667224386845432493096383414519386259680854024b241,
  1b-32);
true;

relerror(
  gamma_incomplete(10.0+10.0*%i,10.0+10.0*%i),
  (712.747910954771249931938579893612285083502899995529160358791610b0 
  -1614.519712336984904341104157868496978481416095290952330318983747b0*%i),
  7.5e-15);
true;

relerror(
  gamma_incomplete(10b0+10b0*%i,10b0+10b0*%i),
  (712.747910954771249931938579893612285083502899995529160358791610b0 
  -1614.519712336984904341104157868496978481416095290952330318983747b0*%i),
  4b-32);
true;

relerror(
  gamma_incomplete(10.0+10*%i,10.0+5*%i),
  (3795.479456353067145208395441052660229834399956460948716792241863b0 
  -1859.399046776284485239753978633491801182777480033526406270435152b0*%i),
  6.0e-15);
true;

relerror(
  gamma_incomplete(10.0b0+10*%i,10.0b0+5*%i),
  (3795.479456353067145208395441052660229834399956460948716792241863b0 
  -1859.399046776284485239753978633491801182777480033526406270435152b0*%i),
  1b-32);
true;

relerror(
  gamma_incomplete(10.0+5*%i,10.0+5*%i),
  (22616.57428441264599471916533645601396385068769401974320192387776b0 
  -41760.26634389514228374497096679850877647381173070930602051580693b0*%i),
  5.0e-15);
true;

relerror(
  gamma_incomplete(10.0b0+5*%i,10.0b0+5*%i),
  (22616.57428441264599471916533645601396385068769401974320192387776b0 
  -41760.26634389514228374497096679850877647381173070930602051580693b0*%i),
  1b-32);
true;

relerror(
  gamma_incomplete(10+5*%i,10+2.5*%i),
  (55884.99767768350551452192526458363894624371018195106017631282130b0 
  -30587.35558698211815103119732529095917842073159139555085583572089b0*%i),
  8.0e-15);
true;

relerror(
  gamma_incomplete(10b0+5*%i,10b0+2.5*%i),
  (55884.99767768350551452192526458363894624371018195106017631282130b0 
  -30587.35558698211815103119732529095917842073159139555085583572089b0*%i),
  1b-32);
true;

relerror(
  gamma_incomplete(10.0+2.5*%i,10.0+2.5*%i),
  (98307.31859173691954817642978681043594336734907098079356276769738b0 
  -69378.82767710646665454093742183442049572498499915146277510648781b0*%i),
  7.0e-15);
true;

relerror(
  gamma_incomplete(10.0b0+2.5*%i,10.0b0+2.5*%i),
  (98307.31859173691954817642978681043594336734907098079356276769738b0 
  -69378.82767710646665454093742183442049572498499915146277510648781b0*%i),
  1b-32);
true;

relerror(
  gamma_incomplete(10.0+2.5*%i,10.0+1.5*%i),
  (119713.97958915216843109406780063078781556428789769599762881675530b0 
  -44021.05551717694140528840726282083152859527358436513276174120234b0*%i),
  9.5e-15);
true;

relerror(
  gamma_incomplete(10.0b0+2.5*%i,10.0b0+1.5*%i),
  (119713.97958915216843109406780063078781556428789769599762881675530b0 
  -44021.05551717694140528840726282083152859527358436513276174120234b0*%i),
  1b-32);
true;

relerror(
  gamma_incomplete(10.0+1.5*%i,10.0+1.5*%i),
  (-143260.5455945276009736506823530548923946268185687353440779787855b0 
  -36427.8601104063533811294405176711748076293661563594190640674077b0*%i),
  1.02e-14);
true;

relerror(
  gamma_incomplete(10.0b0+1.5*%i,10.0b0+1.5*%i),
  (-143260.5455945276009736506823530548923946268185687353440779787855b0 
  -36427.8601104063533811294405176711748076293661563594190640674077b0*%i),
  1b-32);
true;

relerror(
  gamma_incomplete(10.0+1.5*%i,10.0+0.5*%i),
  (-134422.2837349310843015830622649231296922981730868773827217434186b0 
  -76495.4696532860249045908863041952283847028641854696387454419024b0*%i),
  1.271e-14);
true;

relerror(
  gamma_incomplete(10.0b0+1.5*%i,10.0b0+0.5*%i),
  (-134422.2837349310843015830622649231296922981730868773827217434186b0 
  -76495.4696532860249045908863041952283847028641854696387454419024b0*%i),
  1b-32);
true;

relerror(
  gamma_incomplete(10+0.5*%i,10+0.5*%i),
  (70217.4190738045440197722508789471776325390496700488861347101465b0 
  +148228.5649085354026330085827685305718428914334429314381378279173b0*%i),
  6.0e-15);
true;

relerror(
  gamma_incomplete(10b0+0.5*%i,10b0+0.5*%i),
  (70217.4190738045440197722508789471776325390496700488861347101465b0 
  +148228.5649085354026330085827685305718428914334429314381378279173b0*%i),
  1b-32);
true;

relerror(
  gamma_incomplete(5.0+5*%i,5.0+5*%i),
  (-0.4806117328699535298510981197039733622773799503543787399412087606b0 
   +0.8919199556012029365414433316086474496955099800079200844577588174b0*%i),
  5.0e-15);
true;

relerror(
  gamma_incomplete(5.0b0+5*%i,5.0b0+5*%i),
  (-0.4806117328699535298510981197039733622773799503543787399412087606b0 
   +0.8919199556012029365414433316086474496955099800079200844577588174b0*%i),
  1b-32);
true;

relerror(
  gamma_incomplete(5.0+5*%i,5.0+2.5*%i),
  (-1.564618625118515702134408016446776958254116141951281337045968096b0 
   +0.763213115623024892186357289469889653460737525026968402880536542b0*%i),
  5.0e-15);
true;

relerror(
  gamma_incomplete(5.0b0+5*%i,5.0b0+2.5*%i),
  (-1.564618625118515702134408016446776958254116141951281337045968096b0 
   +0.763213115623024892186357289469889653460737525026968402880536542b0*%i),
  1b-32);
true;

relerror(
  gamma_incomplete(5.0+2.5*%i,5.0+2.5*%i),
  (-3.966094476128530812031476427059327525923710898646502835891758741b0 
   -3.843825405733108837026233752472379492035828310495276258481876760b0*%i),
  5.0e-15);
true;

relerror(
  gamma_incomplete(5.0b0+2.5*%i,5.0b0+2.5*%i),
  (-3.966094476128530812031476427059327525923710898646502835891758741b0 
   -3.843825405733108837026233752472379492035828310495276258481876760b0*%i),
  1b-32);
true;

relerror(
  gamma_incomplete(5.0+2.5*%i,5.0-2.5*%i),
  (24.28851242625584709660092800462769890376139980405107830536077980b0
  -13.30717877353455881129062577273028018783505328101266063709140224b0*%i),
  2.0e-15);
true;

relerror(
  gamma_incomplete(5.0b0+2.5*%i,5.0b0-2.5*%i),
  (24.28851242625584709660092800462769890376139980405107830536077980b0
  -13.30717877353455881129062577273028018783505328101266063709140224b0*%i),
  1b-32);
true;

relerror(
  gamma_incomplete(5.0-2.5*%i,5.0-2.5*%i),
  (-3.966094476128530812031476427059327525923710898646502835891758741b0 
   +3.843825405733108837026233752472379492035828310495276258481876760b0*%i),
  5.0e-15);
true;

relerror(
  gamma_incomplete(5.0b0-2.5*%i,5.0b0-2.5*%i),
  (-3.966094476128530812031476427059327525923710898646502835891758741b0 
   +3.843825405733108837026233752472379492035828310495276258481876760b0*%i),
  1b-32);
true;

/* Further tests after modication of the code */

fpprec:35;
35;

/* We start with values on the real negative axis */

/* Problem 6 */
relerror(
  gamma_incomplete(0.5,-10),
  1.7724538509055160272981674833 - 7388.5381938108184552671664573665*%i,
  2.0e-12);
true;

/* Problem 7 */
relerror(
  gamma_incomplete(0.5,-10b0),
  1.7724538509055160272981674833b0 - 7388.5381938108184552671664573665b0*%i,
  3.0b-32);
true;

relerror(
  gamma_incomplete(0.5,-5),
  1.772453850905516027298167483341 - 76.796224205322062453935496965541*%i,
  1.5e-14);
true;

relerror(
  gamma_incomplete(0.5,-5b0),
  1.772453850905516027298167483341b0 - 76.796224205322062453935496965541b0*%i,
  1b-32);
true;

relerror(
  gamma_incomplete(0.5,-2.5),
  1.7724538509055160272981674833411 - 9.8735082388772780413725529343873*%i,
  1e-15);
true;

relerror(
  gamma_incomplete(0.5,-2.5b0),
  1.7724538509055160272981674833411b0 - 9.8735082388772780413725529343873b0*%i,
  1b-32);
true;

relerror(
  gamma_incomplete(0.5,-0.25),
  1.7724538509055160272981674833411 - 1.0899742083672444473248402628140*%i,
  5.0e-15);
true;

relerror(
  gamma_incomplete(0.5,-0.25b0),
  1.7724538509055160272981674833411b0 - 1.0899742083672444473248402628140b0*%i,
  5.0b-32);
true;

/* We add a small imaginary part
   The continued fraction will fail, Maxima use the series expansion.
*/

relerror(
  gamma_incomplete(0.5,-10+0.1*%i),
  -693.7125259652496257225339009893 - 7355.4778982854340599489999722765*%i,
  2.0e-12);
true;

relerror(
  gamma_incomplete(0.5,-10.0b0+0.1b0*%i),
  -693.7125259652496257225339009893b0 - 7355.4778982854340599489999722765b0*%i,
  1b-32);
true;

relerror(
  gamma_incomplete(0.5,-5+0.1*%i),
  -4.855606925906958733850786731743 - 76.497762747671653356926921414108*%i,
  5.0e-15);
true;

relerror(
  gamma_incomplete(0.5,-5b0+0.1b0*%i),
  -4.855606925906958733850786731743b0 - 76.497762747671653356926921414108b0*%i,
  1b-32);
true;

relerror(
  gamma_incomplete(0.5,-2.5+0.1*%i),
  1.0028894769544495897063089678047 - 9.8427092366892270639885076130022*%i,
  1.21e-15);
true;

relerror(
  gamma_incomplete(0.5,-2.5b0+0.1b0*%i),
  1.0028894769544495897063089678047b0 - 9.8427092366892270639885076130022b0*%i,
  1b-32);
true;

relerror(
  gamma_incomplete(0.5,-0.25+0.1*%i),
  1.5192534335558569724359463295125 - 1.1019363602857804797837310045806*%i,
  2.0e-15);
true;

relerror(
  gamma_incomplete(0.5,-0.25b0+0.1b0*%i),
  1.5192534335558569724359463295125b0 - 1.1019363602857804797837310045806b0*%i,
  2.0b-32);
true;

/* We add an imaginary part above the threshold for the series expansion
*/

relerror(
  gamma_incomplete(0.5,-10+1.1*%i),
  -6334.1948696342193438649689587744 - 3741.5383594183284610691163553403*%i,
  4.0e-12);
true;

relerror(
  gamma_incomplete(0.5,-10b0+1.1b0*%i),
  -6334.1948696342193438649689587744b0 - 3741.5383594183284610691163553403b0*%i,
  5.0b-32);
true;

relerror(
  gamma_incomplete(0.5,-5b0+1.1b0*%i),
  -59.650578505004222281783394220768b0 - 43.683456195166750403224017552560b0*%i,
  5.0b-32);
true;

relerror(
  gamma_incomplete(0.5,-2.5+1.1*%i),
  -5.5335063099201920292609023851020 - 6.4351290837917628991361018359964*%i,
  5.0e-15);
true;

relerror(
  gamma_incomplete(0.5,-2.5b0+1.1b0*%i),
  -5.5335063099201920292609023851020b0 - 6.4351290837917628991361018359964b0*%i,
  1b-32);
true;

/* This is the serious expansion which works */

relerror(
  gamma_incomplete(0.5,-0.25+1.1*%i),
  -0.13794253952035726152165921998252 - 1.06583290164642973789895384973429*%i,
  2.0e-15);
true;

relerror(
  gamma_incomplete(0.5,-0.25b0+1.1b0*%i),
  -0.13794253952035726152165921998252b0 - 1.06583290164642973789895384973429b0*%i,
  1b-32);
true;

/* Values on the imaginary axis */

relerror(
  gamma_incomplete(0.5,-100*%i),
  0.096899159215326861150517776631041 + 0.024684086404223368298902429118542*%i,
  1e-15);
true;

relerror(
  gamma_incomplete(0.5,-100b0*%i),
  0.096899159215326861150517776631041b0 + 0.024684086404223368298902429118542b0*%i,
  1b-32);
true;

relerror(
  gamma_incomplete(0.5,-50*%i),
  0.123398939447119035626603437814684 + 0.069012601491650179241716316049576*%i,
  1e-15);
true;

relerror(
  gamma_incomplete(0.5,-50b0*%i),
  0.123398939447119035626603437814684b0 + 0.069012601491650179241716316049576b0*%i,
  1b-32);
true;

relerror(
  gamma_incomplete(0.5,-10*%i),
  -0.08046978022707502678937802264904 - 0.30392674968841293510316822780670*%i,
  1e-15);
true;

relerror(
  gamma_incomplete(0.5,-10b0*%i),
  -0.08046978022707502678937802264904b0 - 0.30392674968841293510316822780670b0*%i,
  2.0b-32);
true;

relerror(
  gamma_incomplete(0.5,-5*%i),
  0.36441984106355895337750863822965 - 0.24368559063811288395048612967632*%i,
  3.0e-15);
true;

relerror(
  gamma_incomplete(0.5,-5b0*%i),
  0.36441984106355895337750863822965b0 - 0.24368559063811288395048612967632b0*%i,
  1b-32);
true;

relerror(
  gamma_incomplete(0.5,-2.5*%i),
  -0.59691417904238855062194720247331 + 0.00921495731742953647951029973386*%i,
  2.81e-15);
true;

relerror(
  gamma_incomplete(0.5,-2.5b0*%i),
  -0.59691417904238855062194720247331b0 + 0.00921495731742953647951029973386b0*%i,
  1b-32);
true;

relerror(
  gamma_incomplete(0.5,-0.25*%i),
  1.01109069076165681623650036780470 + 0.64403710594044452447886365988086*%i,
  1e-15);
true;

relerror(
  gamma_incomplete(0.5,-0.25b0*%i),
  1.01109069076165681623650036780470b0 + 0.64403710594044452447886365988086b0*%i,
  1b-32);
true;

relerror(
  gamma_incomplete(0.5,0.25*%i),
  1.01109069076165681623650036780470 - 0.64403710594044452447886365988086*%i,
  1e-15);
true;

relerror(
  gamma_incomplete(0.5,0.25b0*%i),
  1.01109069076165681623650036780470b0 - 0.64403710594044452447886365988086b0*%i,
  1b-32);
true;

relerror(
  gamma_incomplete(0.5,2.5*%i),
  -0.59691417904238855062194720247331 - 0.00921495731742953647951029973386*%i,
 2.81e-15);
true;

relerror(
  gamma_incomplete(0.5,2.5b0*%i),
  -0.59691417904238855062194720247331b0 - 0.00921495731742953647951029973386b0*%i,
 1b-32);
true;

relerror(
  gamma_incomplete(0.5,5*%i),
  0.36441984106355895337750863822965 + 0.24368559063811288395048612967632*%i,
  3.0e-15);
true;

relerror(
  gamma_incomplete(0.5,5b0*%i),
  0.36441984106355895337750863822965b0 + 0.24368559063811288395048612967632b0*%i,
  1b-32);
true;

relerror(
  gamma_incomplete(0.5,50*%i),
  0.123398939447119035626603437814684 - 0.069012601491650179241716316049576*%i,
  1e-15);
true;

relerror(
  gamma_incomplete(0.5,50b0*%i),
  0.123398939447119035626603437814684b0 - 0.069012601491650179241716316049576b0*%i,
  1b-32);
true;

relerror(
  gamma_incomplete(0.5,100*%i),
  0.096899159215326861150517776631041 - 0.024684086404223368298902429118542*%i,
  1e-15);
true;

relerror(
  gamma_incomplete(0.5,100b0*%i),
  0.096899159215326861150517776631041b0 - 0.024684086404223368298902429118542b0*%i,
  1b-32);
true;

/* Along the boundary */

relerror(
  gamma_incomplete(0.5,-1+1.0*%i),
  -0.6460866463446816469727499577965 - 2.2529846180884648591828756025081*%i,
  1e-15);
true;  

relerror(
  gamma_incomplete(0.5,-2+2.0*%i),
  -4.6362149776912621823191772006210 - 0.6696404542328766212783095808086*%i,
  4.0e-15);
true;

relerror(
  gamma_incomplete(0.5,-3+3.0*%i),
  -6.2748360165336721010541674791500 + 8.2442936688139837781281990469076*%i,
  4.0e-15);
true;

relerror(
  gamma_incomplete(0.5,-4+4.0*%i),
  9.028176736353114550138088914592 + 22.441213878617781749976458917799*%i,
  5.0e-15);
true;

relerror(
  gamma_incomplete(0.5,-5+5.0*%i),
  57.540711282025537715729492821303 + 9.813229347687737256352386117430*%i,
  3.0e-15);
true;

relerror(
  gamma_incomplete(0.5,-6+6.0*%i),
  95.71761436932787302240057885539 - 107.54220609035943742021479062686*%i,
  2.0e-15);
true;

relerror(
  gamma_incomplete(0.5,-10+10.0*%i),
  921.0687349037275816861912330294 + 5931.0759029700741177372337479958*%i,
  1.072e-15);
true;

relerror(
  gamma_incomplete(0.5,-15+15.0*%i),
  -649132.21386404102825777002406965 + 315145.50427275409146151580354200*%i,
  1e-15);
true;

relerror(
  gamma_incomplete(0.5,-1+1.0*%i),
  -0.6460866463446816469727499577965 - 2.2529846180884648591828756025081*%i,
  5.0e-15);
true;

relerror(
  gamma_incomplete(0.5,-2+2.0*%i),
  -4.6362149776912621823191772006210 - 0.6696404542328766212783095808086*%i,
  4.0e-15);
true;

relerror(
  gamma_incomplete(0.5,-3+3.0*%i),
  -6.2748360165336721010541674791500 + 8.2442936688139837781281990469076*%i,
  4.0e-15);
true;

relerror(
  gamma_incomplete(0.5,-4+4.0*%i),
  9.028176736353114550138088914592 + 22.441213878617781749976458917799*%i,
  5.0e-15);
true;

relerror(
  gamma_incomplete(0.5,-5+5.0*%i),
  57.540711282025537715729492821303 + 9.813229347687737256352386117430*%i,
  3.0e-15);
true;

relerror(
  gamma_incomplete(0.5,-6+6.0*%i),
  95.71761436932787302240057885539 - 107.54220609035943742021479062686*%i,
  2.0e-15);
true;

relerror(
  gamma_incomplete(0.5,-10+10.0*%i),
  921.0687349037275816861912330294 + 5931.0759029700741177372337479958*%i,
  1.072e-15);
true;

relerror(
  gamma_incomplete(0.5,-15+15.0*%i),
  -649132.21386404102825777002406965 + 315145.50427275409146151580354200*%i,
  1e-15);
true;

/******************************************************************************
  Test gamma_incomplete against expintegral_e
******************************************************************************/

block([badpoints : [], 
       ratprint : false,
       abserr : 0,
       maxerr : -1,
       zlimit : 5,
       eps    : 1e-12],
  for a:1 thru 2 step 0.1 do
  (
    for z: -zlimit thru zlimit step 1.0 do
    (
      if is(notequal(z,0.0) and notequal(a,0.0)) then
      (
        zf : float(z),
        af : float(a),
        result : gamma_incomplete(af,zf),
        answer : rectform(zf^af*expintegral_e(1.0-af,zf)),
        abserr : abs(result - answer),
	maxerr : max(maxerr, abserr),
        if abserr > eps then
        (
          badpoints : cons([[a, z], result, answer, abserr], badpoints)
        ) 
      )
    )
  ),
  /* 
   * For debugging, if there are any bad points, return the maximum error 
   * found as the first element.
   */
  if badpoints # [] then
    cons(maxerr, badpoints)
  else
    badpoints
);
[];


/******************************************************************************
  Test Generalized Incomplete Gamma function
******************************************************************************/

/* Some special values */

(kill(a), assume(a>0), done);
done;

gamma_incomplete_generalized(a,z1,0);
gamma_incomplete(a,z1)-gamma(a);

gamma_incomplete_generalized(a,z1,0.0);
gamma_incomplete(a,z1)-gamma(a);

gamma_incomplete_generalized(a,z1,0.0b0);
gamma_incomplete(a,z1)-gamma(a);

gamma_incomplete_generalized(a,0,z2);
gamma(a)- gamma_incomplete(a,z2);

gamma_incomplete_generalized(a,0.0,z2);
gamma(a)- gamma_incomplete(a,z2);

gamma_incomplete_generalized(a,0.0b0,z2);
gamma(a)- gamma_incomplete(a,z2);

gamma_incomplete_generalized(a,z1,inf);
gamma_incomplete(a,z1);

gamma_incomplete_generalized(a,inf,z2);
-gamma_incomplete(a,z2);

gamma_incomplete_generalized(a,0,inf);
gamma(a);

gamma_incomplete_generalized(a,x,x);
0;

gamma_incomplete_generalized(a,1.0,1.0b0);
0;

/* Mirror symmetry, but not when z1 or z2 on the negative real axis */

declare(a,complex, z1,complex, z2, complex);
done;

conjugate(gamma_incomplete_generalized(a,z1,z2));
conjugate(gamma_incomplete_generalized(a,z1,z2));

conjugate(gamma_incomplete_generalized(x+%i*y,1+%i,1-%i));
gamma_incomplete_generalized(x-%i*y,1-%i,1+%i);

(kill(a,z1,z2),done);
done;

/* Test numerical evaluation for some values */

closeto(
  gamma_incomplete_generalized(0.15,0.10,0.90),
  1.285210772938496575538196624140369253496313719924712338486508252b0,
  1e-14);
true;

fpprec:64;
64;

closeto(
  gamma_incomplete_generalized(0.15b0,0.10b0,0.90b0),
  1.285210772938496575538196624140369253496313719924712338486508252b0,
  1b-62);
true;

closeto(
  gamma_incomplete_generalized(0.15+%i,0.10+%i,0.90+%i),
  (-0.03956290928621934869542750861441673192206453223955788892863857789b0 
   -0.13316249485419500645510117515710482169661446536096647384481038655b0*%i),
  1e-14);
true;

closeto(
  gamma_incomplete_generalized(0.15b0+%i,0.10b0+%i,0.90b0+%i),
  (-0.03956290928621934869542750861441673192206453223955788892863857789b0 
   -0.13316249485419500645510117515710482169661446536096647384481038655b0*%i),
  1b-62);
true;

closeto(
  gamma_incomplete_generalized(-0.15+%i,0.10+%i,0.90+%i),
  (-0.07903699552278027449948116754698066920498863638107044857029927559b0 
   -0.10615739775378488990365404098165130400907362070260244159331987806b0*%i),
  1e-14);
true;

closeto(
  gamma_incomplete_generalized(-0.15b0+%i,0.10b0+%i,0.90b0+%i),
  (-0.07903699552278027449948116754698066920498863638107044857029927559b0 
   -0.10615739775378488990365404098165130400907362070260244159331987806b0*%i),
  1b-62);
true;

/******************************************************************************

  Test Regularized Incomplete Gamma function

******************************************************************************/

/* Specialized values */

/* Check that gamma_incomplete_regularized (a, 0) just returns a noun
   form (the correct one!) */
block ([result_a0: gamma_incomplete_regularized(a,0)],
  is (not (atom (result_a0)) and
      op (result_a0) = 'gamma_incomplete_regularized and
      args (result_a0) = [a, 0]));
true$

(assume(ap>0,am<0),done);
done;

errcatch(gamma_incomplete_regularized(am,0));
[];
gamma_incomplete_regularized(ap,0);
1;
gamma_incomplete_regularized(0,z);
0;
gamma_incomplete_regularized(a,inf);
0;

/* Check that the derivative is correct. */
diff(gamma_incomplete_regularized(a,z),z);
-(z^(a-1)*%e^(-z))/gamma(a);

/* Expand gamma_incomplete_regularized */

gamma_expand:true;
true;

gamma_incomplete_regularized(1,z);
%e^(-z);

gamma_incomplete_regularized(a+1,z);
gamma_incomplete_regularized(a,z)+%e^(-z)*z^a/gamma(a+1);

gamma_incomplete_regularized(a-1,z);
gamma_incomplete_regularized(a,z)-%e^(-z)*z^(a-1)/gamma(a);

gamma_incomplete_regularized(1/2,z);
erfc(sqrt(z));
gamma_incomplete_regularized(-1/2,z);
erfc(sqrt(z))-%e^(-z)/sqrt(%pi)/sqrt(z);
gamma_incomplete_regularized(3/2,z);
erfc(sqrt(z))+2*sqrt(z)*%e^(-z)/sqrt(%pi);
gamma_incomplete_regularized(-3/2,z);
erfc(sqrt(z))-3*(4*z/3-2/3)*%e^(-z)/(4*sqrt(%pi)*z^(3/2));

/* Test expansion for half integral values against expansion of 
   gamma_incomplete 
*/

expand(gamma_incomplete_regularized(5/2,z)-gamma_incomplete(5/2,z)/gamma(5/2));
0;
expand(gamma_incomplete_regularized(-5/2,z)-gamma_incomplete(-5/2,z)/gamma(-5/2));
0;
expand(gamma_incomplete_regularized(7/2,z)-gamma_incomplete(7/2,z)/gamma(7/2));
0;
expand(gamma_incomplete_regularized(-7/2,z)-gamma_incomplete(-7/2,z)/gamma(-7/2));
0;
expand(gamma_incomplete_regularized(9/2,z)-gamma_incomplete(9/2,z)/gamma(9/2));
0;
expand(gamma_incomplete_regularized(-9/2,z)-gamma_incomplete(-9/2,z)/gamma(-9/2));
0;

gamma_expand:false;
false;

/* Some numerical tests */

fpprec:64;
64;

closeto(
  gamma_incomplete_regularized(0.25,0.15),
  0.3331718023153566353128831003164180886983644245472471410932121590b0,
  1e-15);
true;

closeto(
  gamma_incomplete_regularized(0.25b0,0.15b0),
  0.3331718023153566353128831003164180886983644245472471410932121590b0,
  1b-62);
true;

closeto(
  gamma_incomplete_regularized(-0.25,0.15),
   -0.3747953569677745583399657181155178573572870781780605755597341785b0,
  1e-15);
true;

closeto(
  gamma_incomplete_regularized(-0.25b0,0.15b0),
   -0.3747953569677745583399657181155178573572870781780605755597341785b0,
  1b-61);
true;

closeto(
  gamma_incomplete_regularized(-0.25,-0.15),
  (0.1206888313473692669850487605186163406801228067412581029970643626b0 
  +0.8793111686526307330149512394813836593198771932587418970029356374b0*%i),
  1e-15);
true;

closeto(
  gamma_incomplete_regularized(-0.25b0,-0.15b0),
  (0.1206888313473692669850487605186163406801228067412581029970643626b0 
  +0.8793111686526307330149512394813836593198771932587418970029356374b0*%i),
  1e-15);
true;

closeto(
  gamma_incomplete_regularized(0.25,0.15+%i),
  (-0.0241833450538703040924257417951024895368614341619005659619193200b0 
   -0.1759768209797086273285777898669237251900625192446301525551431309b0*%i),
  1e-15);
true;

closeto(
  gamma_incomplete_regularized(0.25b0,0.15b0+%i),
  (-0.0241833450538703040924257417951024895368614341619005659619193200b0 
   -0.1759768209797086273285777898669237251900625192446301525551431309b0*%i),
  1b-62);
true;

closeto(
  gamma_incomplete_regularized(0.25,0.15-%i),
  (-0.0241833450538703040924257417951024895368614341619005659619193200b0 
   +0.1759768209797086273285777898669237251900625192446301525551431309b0*%i),
  1e-15);
true;

closeto(
  gamma_incomplete_regularized(0.25b0,0.15b0-%i),
  (-0.0241833450538703040924257417951024895368614341619005659619193200b0 
   +0.1759768209797086273285777898669237251900625192446301525551431309b0*%i),
  1b-62);
true;

/******************************************************************************
  Test the Error functions: erf, erfc, erfi and erf_generalized
******************************************************************************/

/* Specific values */

map(erf, [0,0.0,0.0b0,inf,minf,infinity,und,ind]);
[0,0.0,0.0b0,1,-1,erf(infinity),erf(und),erf(ind)];

limit(erf(z), z, inf);
1;
limit(erf(z), z, minf);
-1;

map(erfc, [0,inf,minf,infinity,und,ind]);
[1,0,2,erfc(infinity),erfc(und),erfc(ind)];

limit(erfc(z), z, inf);
0;
limit(erfc(z), z, minf);
2;

map(erfi, [0,inf,minf,infinity,und,ind]);
[0,inf,minf,erfi(infinity),erfi(und),erfi(ind)];

limit(erfi(z), z, inf);
inf;
limit(erfi(z), z, minf);
minf;

erf_generalized(z1,0);
-erf(z1);

erf_generalized(0,z2);
erf(z2);

erf_generalized(0,0);
0;

erf_generalized(0.0,0.0);
0;

erf_generalized(0.0b0,0.0b0);
0;

erf_generalized(z1,inf);
1-erf(z1);
limit(erf_generalized(z1, z2), z2, inf);
1-erf(z1);

erf_generalized(z1,minf);
-erf(z1)-1;
limit(erf_generalized(z1, z2), z2, minf);
-erf(z1)-1;

erf_generalized(inf,z2);
erf(z2)-1;
limit(erf_generalized(z1, z2), z1, inf);
erf(z2)-1;

erf_generalized(minf,z2);
erf(z2)+1;
limit(erf_generalized(z1, z2), z1, minf);
erf(z2)+1;

/* Parity */

erf(-z);
-erf(z);

erfc(-z);
2-erfc(z);

erfi(-z);
-erfi(z);

erf_generalized(-z1,-z2);
-erf_generalized(z1,z2);

/* Mirror symmetry */

declare(z,complex);
done;

conjugate(erf(z));
erf(conjugate(z));

conjugate(erf(x+%i*y));
erf(x-%i*y);

conjugate(erfc(z));
erfc(conjugate(z));

conjugate(erfc(x+%i*y));
erfc(x-%i*y);

conjugate(erfi(z));
erfi(conjugate(z));

conjugate(erfi(x+%i*y));
erfi(x-%i*y);

declare(z1,complex,z2,complex);
done;

conjugate(erf_generalized(z1,z2));
erf_generalized(conjugate(z1),conjugate(z2));

conjugate(erf_generalized(x1+%i*y1,x2+%i*y2));
erf_generalized(x1-%i*y1,x2-%i*y2);

/* Generalized Erf is antisymmetric */

erf_generalized(x1,x2)+erf_generalized(x2,x1);
0;

/* For a pure real or imaginary argument of the error functions erf and erfi
   we get pure real or imaginary result. We test it. */

is(equal(imagpart(erf(1.0)),0));
true;

is(equal(imagpart(erfi(1.0)),0));
true;

is(equal(realpart(erf(1.0*%i)),0));
true;

is(equal(realpart(erfi(1.0*%i)),0));
true;

/* Again for bigfloats */

is(equal(imagpart(erf(1.0b0)),0));
true;

is(equal(imagpart(erfi(1.0b0)),0));
true;

is(equal(realpart(erf(1.0b0*%i)),0));
true;

is(equal(realpart(erfi(1.0b0*%i)),0));
true;

/* Taylor expansion of the Error functions */

taylor(erf(x),x,0,5) - 2/sqrt(%pi)*(x-x^3/3+x^5/10);
0;

(erf(taylor(x,x,0,5)) - 2/sqrt(%pi)*(x-x^3/3+x^5/10));
0;

taylor(erf(x),x,x0,2)
  - (erf(x0)+2*%e^(-x0^2)/sqrt(%pi)*(x-x0)-2*x0*%e^(-x0^2)/sqrt(%pi)*(x-x0)^2);
0;

taylor(erfi(x),x,0,5) - 2/sqrt(%pi)*(x+x^3/3+x^5/10);
0;

erfi(taylor(x,x,0,5)) - 2/sqrt(%pi)*(x+x^3/3+x^5/10);
0;

taylor(erfi(x),x,x0,2)
 -(erfi(x0)+2*%e^(x0^2)/sqrt(%pi)*(x-x0)+2*x0*%e^(x0^2)/sqrt(%pi)*(x-x0)^2);
0;

/* Numerical test for the Error functions 
   First check erf in double float precision */

closeto(
  erf(-0.50),
  -0.5204998778130465376827466538919645287364515757579637000588057256b0,
  1e-15);
true;

closeto(
  erf(0.50),
  0.5204998778130465376827466538919645287364515757579637000588057256b0,
  1e-15);
true;

closeto(
  erf(0.75),
  0.7111556336535151315989378345914107773742059540965372322781333971b0,
  5.0e-15);
true;

closeto(
  erf(-0.75+%i),
  (-1.372897192365736489613456241111589390954675856186764729607156305b0 
  + 0.539788632227100129936591912063260716699852732091113612337142798b0*%i),
  6.0e-15);
true;

closeto(
  erf(-0.50+%i),
  (-1.204847558314218002702112682097006717296399718277162764595960866b0 
  + 1.024400881608445881724860454410886676966127193189877583791256132b0*%i),
  1e-15);
true;

closeto(
  erf(0.50+%i),
  ( 1.204847558314218002702112682097006717296399718277162764595960866b0 
  + 1.024400881608445881724860454410886676966127193189877583791256132b0*%i),
  1e-15);
true;

closeto(
  erf(0.75+%i),
  ( 1.372897192365736489613456241111589390954675856186764729607156305b0 
  + 0.539788632227100129936591912063260716699852732091113612337142798b0*%i),
  6.0e-15);
true;

/* Bug 3587184: erf inaccurate for small float values */
relerror(
  erf(1d-10),
  float(2d-10/sqrt(%pi)),
  1d-15);
true;

/* Erf with bigfloat precision */

fpprec:64;
64;

closeto(
  erf(-0.50b0),
  -0.5204998778130465376827466538919645287364515757579637000588057256b0,
  1b-61);
true;

closeto(
  erf(0.50b0),
  0.5204998778130465376827466538919645287364515757579637000588057256b0,
  1b-61);
true;

closeto(
  erf(0.75b0),
  0.7111556336535151315989378345914107773742059540965372322781333971b0,
  1b-61);
true;

closeto(
  erf(-0.75b0+%i),
  (-1.372897192365736489613456241111589390954675856186764729607156305b0 
  + 0.539788632227100129936591912063260716699852732091113612337142798b0*%i),
  1b-61);
true;

closeto(
  erf(-0.50b0+%i),
  (-1.204847558314218002702112682097006717296399718277162764595960866b0 
  + 1.024400881608445881724860454410886676966127193189877583791256132b0*%i),
  1b-61);
true;

closeto(
  erf(0.50b0+%i),
  ( 1.204847558314218002702112682097006717296399718277162764595960866b0 
  + 1.024400881608445881724860454410886676966127193189877583791256132b0*%i),
  1b-61);
true;

closeto(
  erf(0.75b0+%i),
  ( 1.372897192365736489613456241111589390954675856186764729607156305b0 
  + 0.539788632227100129936591912063260716699852732091113612337142798b0*%i),
  1b-61);
true;

/* Bug 3587191: erf inaccurate for small bigfloat values */
relerror(
  erf(1b-40),
  bfloat(2b-40/sqrt(%pi)),
  1b-65);
true;

/* Bug 3587304 erfc(x) for x > 6 is wrong */
relerror(
  erfc(6.0),
  2.15197367124989131659335039918738463047751406e-17,
  2.005e-15);
true;

relerror(
  erfc(-4.0),
  2-erfc(4.0),
  1e-15);
true;

relerror(
  erfc(6b0),
  2.1519736712498913116593350399187384630477514061688542100527892051056337238484927860b-17,
  1b-64);
true;

relerror(
  erfc(-6b0),
  1.9999999999999999784802632875010868834066496008126153695224859383114578994b0,
  1b-64);
true;

/* Bug 3587362 inverse_erfc(1d-40) wrong */
relerror(
  inverse_erfc(1d-40),
  9.448789766720855,
  1d-15);
true;

relerror(
  inverse_erfc(1b-50),
  10.59209016952736518902166392532979911559420645541709912588406440119671044289134079569127583320351428635b0,
  1d-64);
true;

/* We have done a check for the numerical algorithm of the Erf function which
   calls the Incomplete Gamma function. 
   We do not do further numerical tests for the other Error functions, 
   but only check the correct implementation of the numercial routines
   against the Erf function
*/

/* Check Erfc against Erf for some values */

fpprec:32;
32;

closeto(
  erfc(-0.25),
  1-erf(-0.25),
  1e-15);
true;

closeto(
  erfc(0.25),
  1-erf(0.25),
  1e-15);
true;

closeto(
  erfc(-0.25+%i),
  1-erf(-0.25+%i),
  1e-15);
true;

closeto(
  erfc(0.25+%i),
  1-erf(0.25+%i),
  1e-15);
true;

closeto(
  erfc(-0.25b0),
  1-erf(-0.25b0),
  1.0b-30);
true;

closeto(
  erfc(0.25b0),
  1-erf(0.25b0),
  1b-30);
true;

closeto(
  erfc(-0.25b0+%i),
  1-erf(-0.25b0+%i),
  1b-30);
true;

closeto(
  erfc(0.25b0+%i),
  1-erf(0.25b0+%i),
  1b-30);
true;

/* Check Erfi against Erf for some values */

closeto(
  erfi(-0.15),
  -%i*erf(-0.15*%i),
  1e-15);
true;

closeto(
  erfi(0.15),
  -%i*erf(0.15*%i),
  1e-15);
true;

closeto(
  erfi(-0.15+%i),
  -%i*erf((-0.15+%i)*%i),
  1e-15);
true;

closeto(
  erfi(0.15+%i),
  -%i*erf((0.15+%i)*%i),
  1e-15);
true;

closeto(
  erfi(-0.15b0),
  -%i*erf(-0.15b0*%i),
  5.0b-30);
true;

closeto(
  erfi(0.15b0),
  -%i*erf(0.15b0*%i),
  5.0b-30);
true;

closeto(
  erfi(-0.15b0+%i),
  expand(-%i*erf((-0.15b0+%i)*%i)),
  1b-30);
true;

closeto(
  erfi(0.15b0+%i),
  expand(-%i*erf((0.15b0+%i)*%i)),
  1b-30);
true;

/* Check Generalized Erf against Erf for some values */

closeto(
  erf_generalized(0.35,1.25),
  erf(1.25)-erf(0.35),
  1e-15);
true;

closeto(
  erf_generalized(0.35+%i,1.25),
  erf(1.25)-erf(0.35+%i),
  1e-15);
true;

closeto(
  erf_generalized(0.35,1.25+%i),
  erf(1.25+%i)-erf(0.35),
  1e-15);
true;

closeto(
  erf_generalized(0.35+%i,1.25+%i),
  erf(1.25+%i)-erf(0.35+%i),
  1e-15);
true;

closeto(
  erf_generalized(0.35b0,1.25b0),
  erf(1.25b0)-erf(0.35b0),
  1b-30);
true;

closeto(
  erf_generalized(0.35b0+%i,1.25b0),
  erf(1.25b0)-erf(0.35b0+%i),
  1b-30);
true;

closeto(
  erf_generalized(0.35b0,1.25b0+%i),
  erf(1.25b0+%i)-erf(0.35b0),
  1b-30);
true;

closeto(
  erf_generalized(0.35b0+%i,1.25b0+%i),
  erf(1.25b0+%i)-erf(0.35b0+%i),
  1b-30);
true;

/* Hypergeometric representations of the erf functions */

hypergeometric_representation:true;
true;

erf(z);
2*z*'hypergeometric([1/2],[3/2],-z^2)/sqrt(%pi);

erfc(z);
1-2*z*'hypergeometric([1/2],[3/2],-z^2)/sqrt(%pi);

erfi(z);
2*z*'hypergeometric([1/2],[3/2],z^2)/sqrt(%pi);

erf_generalized(z1,z2);
2*z2*'hypergeometric([1/2],[3/2],-z2^2)/sqrt(%pi) -
2*z1*'hypergeometric([1/2],[3/2],-z1^2)/sqrt(%pi);

hypergeometric_representation:false;
false;

/******************************************************************************
   Test the Fresnel Integrals S(z) and C(z) 
******************************************************************************/

/* Specific values for the Fresnel Integrals */

map(fresnel_s,[0,0.0,0.0b0]);
[0,0.0,0.b0];

map(fresnel_c,[0,0.0,0.0b0]);
[0,0.0,0.b0];

limit(fresnel_c(x),x,inf);
1/2;

limit(fresnel_s(x),x,inf);
1/2;

limit(fresnel_c(x),x,minf);
-1/2;

limit(fresnel_s(x),x,minf);
-1/2;

/* Simplification of infinities 
   The rules for an odd function and the simplifaction for imaginary
   arguments are applied too.
*/

map(fresnel_s,[inf,-inf,minf,-minf,%i*inf,-%i*inf,%i*minf,-%i*minf]);
[1/2,-1/2,-1/2,1/2,-%i/2,%i/2,%i/2,-%i/2];

map(fresnel_c,[inf,-inf,minf,-minf,%i*inf,-%i*inf,%i*minf,-%i*minf]);
[1/2,-1/2,-1/2,1/2,%i/2,-%i/2,-%i/2,%i/2];

/* No simplification for other infinities and undeterminates */

map(fresnel_s,[infinity,und,ind]);
[fresnel_s(infinity),fresnel_s(und),fresnel_s(ind)];

map(fresnel_c,[infinity,und,ind]);
[fresnel_c(infinity),fresnel_c(und),fresnel_c(ind)];

/* The Fresnel Integrals S(z) and C(z) are odd functions 
   A reflection rule is given and the rule odd-function-reflect is applied */

map(fresnel_s,[-x, (x-1), (-x+1), (-x-1)]);
[-fresnel_s(x), fresnel_s(x-1), -fresnel_s(x-1),-fresnel_s(1+x)];

map(fresnel_c,[-x, (x-1), (-x+1), (-x-1)]);
[-fresnel_c(x), fresnel_c(x-1), -fresnel_c(x-1),-fresnel_c(1+x)];

/* The Fresnel Integals simplify imaginary arguments */

map(fresnel_s, [%i,%i*x,-%i*x,%i*(x+1)]);
[-%i*fresnel_s(1),-%i*fresnel_s(x),%i*fresnel_s(x),-%i*fresnel_s(x+1)];

map(fresnel_c, [%i,%i*x,-%i*x,%i*(x+1)]);
[%i*fresnel_c(1),%i*fresnel_c(x),-%i*fresnel_c(x),%i*fresnel_c(x+1)];

/* The Fresnel Integrals have Mirror Symmetry */

declare(z,complex);
done;

conjugate(fresnel_s(z));
fresnel_s(conjugate(z));

conjugate(fresnel_s(x+%i*y));
fresnel_s(x-%i*y);

conjugate(fresnel_c(z));
fresnel_c(conjugate(z));

conjugate(fresnel_c(x+%i*y));
fresnel_c(x-%i*y);

/* Taylor expansion of the Fresnel Integrals to order O(z^12) */

/* Expand the function */
taylor(fresnel_s(x),x,0,12);
%pi*x^3/6 - %pi^3*x^7/336 + %pi^5 *x^11/42240;

taylor(fresnel_c(x),x,0,12);
x - %pi^2*x^5/40 + %pi^4 *x^9/3456;

/* Expand the argument and apply the function */
fresnel_s(taylor(x,x,0,12));
%pi*x^3/6 - %pi^3*x^7/336 + %pi^5 *x^11/42240;

fresnel_c(taylor(x,x,0,12));
x - %pi^2*x^5/40 + %pi^4 *x^9/3456;

/* Differentiation of the Fresnel Integrals */

diff(fresnel_s(x),x);
sin(%pi*x^2/2);

diff(fresnel_c(x),x);
cos(%pi*x^2/2);

/* The elementary Integral of the Fresnel Integrals 
   More complicated integrals can be found in rtest_integrate_special.mac */

integrate(fresnel_s(x),x);
x*fresnel_s(x)+1/%pi*cos(%pi*x^2/2);

integrate(fresnel_c(x),x);
x*fresnel_c(x)-1/%pi*sin(%pi*x^2/2);

/* Representation of the Fresnel Integrals through the Error function Erf */

erf_representation:true;
true;

fresnel_s(x);
(1+%i)/4*(erf((1+%i)/2*sqrt(%pi)*x) - %i* erf((1-%i)/2*sqrt(%pi)*x));

fresnel_c(x);
(1-%i)/4*(erf((1+%i)/2*sqrt(%pi)*x) + %i* erf((1-%i)/2*sqrt(%pi)*x));

erf_representation:false;
false;

/* Representation of the Fresnel Integrals through the 
   Hypergeometric function */

hypergeometric_representation:true;
true;

fresnel_s(x);
%pi*x^3/6*hypergeometric([3/4],[3/2,7/4],-%pi^2*x^4/16);

fresnel_c(x);
x*hypergeometric([1/4],[1/2,5/4],-%pi^2*x^4/16);

hypergeometric_representation:false;
false;

/* Numerical tests for the Fresnel Integrals */

fpprec:64;
64;

/* Tests for fresnel_s
   Real argument 0.25,0.50,1.0,2.0,5.0,10.0 */

relerror(
  fresnel_s(0.25),
  0.008175600235777755778102308866942774752486734698017086013976457144b0,
  1e-15);
true;

relerror(
  fresnel_s(0.25b0),
  0.008175600235777755778102308866942774752486734698017086013976457144b0,
  1b-64);
true;

relerror(
  fresnel_s(0.50),
  0.06473243285999927761148051223061476765072591849351249278758894565b0,
  1e-15);
true;

relerror(
  fresnel_s(0.50b0),
  0.06473243285999927761148051223061476765072591849351249278758894565b0,
  1b-64);
true;

relerror(
  fresnel_s(1.0),
  0.4382591473903547660767566966251526374937865724524165673344073263b0,
  1e-15);
true;

relerror(
  fresnel_s(1.0b0),
  0.4382591473903547660767566966251526374937865724524165673344073263b0,
  2.0b-64);
true;

relerror(
  fresnel_s(2.0),
  0.3434156783636982421953008159580684568865418122025247675792689204b0,
  1e-15);
true;

relerror(
  fresnel_s(2.0b0),
  0.3434156783636982421953008159580684568865418122025247675792689204b0,
  1.5b-63);
true;

relerror(
  fresnel_s(5.0),
  0.4991913819171168867519283804659916554084319970723881534101411152b0,
  1e-15);
true;

relerror(
  fresnel_s(5.0b0),
  0.4991913819171168867519283804659916554084319970723881534101411152b0,
  1b-64);
true;

relerror(
  fresnel_s(10.0),
  0.4681699785848822404033511108104469460538427245558302799270062272b0,
  1e-15);
true;

relerror(
  fresnel_s(10.0b0),
  0.4681699785848822404033511108104469460538427245558302799270062272b0,
  1b-64);
true;

/* Complex argument 0.25+%i,0.50+%i,1.0+%i,2.0+%i,5.0+%i */

relerror(
  fresnel_s(0.25+%i),
  -0.2762104914409824591766528447060750469693825567583676638192814447b0
  - 0.4331061708987372646968782339728450577465559834165609320175098398b0*%i,
  1e-15);
true;

relerror(
  fresnel_s(0.25b0+%i),
  -0.2762104914409824591766528447060750469693825567583676638192814447b0
  - 0.4331061708987372646968782339728450577465559834165609320175098398b0*%i,
  1b-64);
true;

relerror(
  fresnel_s(0.50+%i),
   -0.7169788451833594258616872412575572495423663980107873580716959051b0
  - 0.3393082523853171783825858066689424560943675693298848574923503884b0*%i,
  1e-15);
true;

relerror(
  fresnel_s(0.50b0+%i),
   -0.7169788451833594258616872412575572495423663980107873580716959051b0
  - 0.3393082523853171783825858066689424560943675693298848574923503884b0*%i,
  1b-64);
true;

relerror(
  fresnel_s(1.0+%i),
  -2.061888219194840468080716536685708600815908323737868052048638806b0 
  + 2.061888219194840468080716536685708600815908323737868052048638806b0*%i,
  1e-15);
true;

relerror(
  fresnel_s(1.0b0+%i),
  -2.061888219194840468080716536685708600815908323737868052048638806b0 
  + 2.061888219194840468080716536685708600815908323737868052048638806b0*%i,
  2.0b-64);
true;

relerror(
  fresnel_s(2.0+%i),
  -15.58775110440458732748278797797881643198730378904101846898562610b0 
  - 36.72546488399143842838787627677917885752587065976755449373500438b0*%i,
  4.0e-13);
true;

relerror(
  fresnel_s(2.0b0+%i),
  -15.58775110440458732748278797797881643198730378904101846898562610b0 
  - 36.72546488399143842838787627677917885752587065976755449373500438b0*%i,
  4.0b-62);
true;

relerror(
  fresnel_s(5.0+%i),
  -204452.5505063210590493330126425293361797143144299005524393297869b0 
  + 38438.9093777759513198736581956757227475265101347572827364567521b0*%i,
  3.0e-14);
true;

relerror(
  fresnel_s(5.0b0+%i),
  -204452.5505063210590493330126425293361797143144299005524393297869b0 
  + 38438.9093777759513198736581956757227475265101347572827364567521b0*%i,
  4.0b-63);
true;

/* Tests for fresnel_c
   Real argument 0.25,0.50,1.0,2.0,5.0,10.0 */

relerror(
  fresnel_c(0.25),
  0.2497591503565431834592215178008857243781399770549380697377810451b0,
  1e-15);
true;

relerror(
  fresnel_c(0.25b0),
  0.2497591503565431834592215178008857243781399770549380697377810451b0,
  2.0b-64);
true;

relerror(
  fresnel_c(0.50),
  0.4923442258714463928788436651566816377660951457715012532946526193b0,
  1e-15);
true;

relerror(
  fresnel_c(0.50b0),
  0.4923442258714463928788436651566816377660951457715012532946526193b0,
  1b-64);
true;

relerror(
  fresnel_c(1.0),
  0.7798934003768228294742064136526901366306257081363209601031335832b0,
  1e-15);
true;

relerror(
  fresnel_c(1.0b0),
  0.7798934003768228294742064136526901366306257081363209601031335832b0,
  2.0b-64);
true;

relerror(
  fresnel_c(2.0),
  0.4882534060753407545002235033572610376883671545092153829475964427b0,
  1e-15);
true;

relerror(
  fresnel_c(2.0b0),
  0.4882534060753407545002235033572610376883671545092153829475964427b0,
  5.1b-64);
true;

relerror(
  fresnel_c(5.0),
  0.5636311887040122311021074044130139641207537623099921078616593412b0,
  1e-15);
true;

relerror(
  fresnel_c(5.0b0),
  0.5636311887040122311021074044130139641207537623099921078616593412b0,
  2.0b-64);
true;

relerror(
  fresnel_c(10.0),
  0.4998986942055157236141518477356211143923468402262626572074674093b0,
  1.73e-15);
true;

relerror(
  fresnel_c(10.0b0),
  0.4998986942055157236141518477356211143923468402262626572074674093b0,
  2.47b-64);
true;

/* Complex argument 0.25+%i,0.50+%i,1.0+%i,2.0+%i,5.0+%i */

relerror(
  fresnel_c(0.25+%i),
  0.0097446563393801078320153856258158947458946246448139394089371651b0 
  + 0.8830495953515316267486626148763161568578011755347662219418704558b0*%i,
  1e-15);
true;

relerror(
  fresnel_c(0.25b0+%i),
  0.0097446563393801078320153856258158947458946246448139394089371651b0 
  + 0.8830495953515316267486626148763161568578011755347662219418704558b0*%i,
  1b-64);
true;

relerror(
  fresnel_c(0.50+%i),
  0.1199549363708813724035204126626172258713764410185526201803481040b0 
  + 1.2468579809337107891237368150539206578767217615436096318514136378b0*%i,
  1e-15);
true;

relerror(
  fresnel_c(0.50b0+%i),
  0.1199549363708813724035204126626172258713764410185526201803481040b0 
  + 1.2468579809337107891237368150539206578767217615436096318514136378b0*%i,
  1b-64);
true;

relerror(
  fresnel_c(1.0+%i),
  2.555793778102439024634522388352195842156623604203584296357752992b0 
  + 2.555793778102439024634522388352195842156623604203584296357752992b0*%i,
  1e-15);
true;

relerror(
  fresnel_c(1.0b0+%i),
  2.555793778102439024634522388352195842156623604203584296357752992b0 
  + 2.555793778102439024634522388352195842156623604203584296357752992b0*%i,
  2.0b-64);
true;

relerror(
  fresnel_c(2.0+%i),
  -36.22568799288165021578757830205090012554103292231420092205271528b0
  + 16.08787137412548041729488986757594802326683407694887086741793640b0*%i,
  4.0e-13);
true;

relerror(
  fresnel_c(2.0b0+%i),
  -36.22568799288165021578757830205090012554103292231420092205271528b0
  + 16.08787137412548041729488986757594802326683407694887086741793640b0*%i,
  4.0b-62);
true;

relerror(
  fresnel_c(5.0+%i),
  38439.4093777740143202918713550472184235160647415045418329908291b0 
  + 204453.0505063119004499308897858846121088557663560705550579996093b0*%i,
  3.0e-14);
true;

relerror(
  fresnel_c(5.0b0+%i),
  38439.4093777740143202918713550472184235160647415045418329908291b0 
  + 204453.0505063119004499308897858846121088557663560705550579996093b0*%i,
  4.0b-63);
true;

/* Bug #2509 fresnel_s incorrect for small values */
relerror(
  fresnel_c(1d-20),
  1d-20,
  1d-15);
true;

relerror(
  fresnel_c(1b-40),
  1b-40,
  5b-63);
true;

relerror(
  fresnel_s(1d-20),
  float(%pi/6*(1d-20)^3),
  1d-15);
true;

relerror(
  fresnel_s(1b-40),
  bfloat(%pi/6*(1b-40)^3),
  5b-63);
true;

/******************************************************************************
   Test the Beta incomplete function 
******************************************************************************/

/* Specialized values */

(assume(am<0,ap>0,b>0),done);
done;

beta_incomplete(a,b,1);
beta(a,b);

beta_incomplete(ap,b,0);
0;

errcatch(beta_incomplete(am,b,0));
[];

(forget(am<0, ap>0,b>0),done);
done;

/* b is a positive integer */

beta_incomplete(a,1,z);
z^a/a;
beta_incomplete(a,2,z);
(a*(1-z)+1)*z^a/(a*(a+1));
beta_incomplete(1,1,z);
z;

/* b is a positive integer.
   Check the handling of float and bigfloat numbers */
fpprec:16;
16;

beta_incomplete(1.0,1,z);
1.0*z;
/* Unfortunate, but we don't get exactly 1.0b0 */
(closeto(beta_incomplete(1.0b0,1,z)/z,1b0,1b-15));
true;
beta_incomplete(1.0,1,1/2);
0.5;
beta_incomplete(1.0b0,1,1/2);
0.5b0;
beta_incomplete(1,1,1/2+%i);
%i+1/2;
beta_incomplete(1.0,1,1/2+%i);
1.0*%i+0.5;
beta_incomplete(1.0b0,1,1/2+%i);
1.0b0*%i+0.5b0;
beta_incomplete(1,2,1/2);
3/8;
beta_incomplete(1.0,2,1/2);
0.375;
beta_incomplete(1.0b0,2,1/2);
0.375b0;
beta_incomplete(1,2,1/2+%i);
(3/2-%i)*(1/2+%i)/2;
beta_incomplete(1.0,2,1/2+%i);
0.875+0.5*%i;
beta_incomplete(1.0b0,2,1/2+%i);
0.875b0+0.5b0*%i;

/* We check the expansion for b positive against the numerical evaluation */
closeto(
  float(beta_incomplete(1,1,1/2)) - beta_incomplete(1.0,1.0,0.5),
  0.0,
  1e-15);
true;
closeto(
  float(beta_incomplete(3/2,2,1/2)) - beta_incomplete(1.5,2.0,0.5),
  0.0,
  1e-15);
true;
closeto(
  float(beta_incomplete(2,3,1/2)) - beta_incomplete(2.0,3.0,0.5),
  0.0,
  1e-15);
true;
closeto(
  float(beta_incomplete(5/2,4,1/2)) - beta_incomplete(2.5,4.0,0.5),
  0.0,
  1e-15);
true;
closeto(
  float(beta_incomplete(3,5,1/2)) - beta_incomplete(3.0,5.0,0.5),
  0.0,
  1e-15);
true;
closeto(
  float(beta_incomplete(2,6,1/2+%i)) - beta_incomplete(2.0,6.0,0.5+%i),
  0.0,
  1e-15);
true;
closeto(
  /* We do this extra rectform, because of a bug in abs for expressions
     with a complex exponent */
  rectform(float(beta_incomplete(2+%i,7,1/2+%i)) 
               - beta_incomplete(2.0+%i,7.0,0.5+%i)),
  0.0,
  1e-15);
true;

/* a is a positive integer we expand */
beta_incomplete(1,b,z);
(1-(1-z)^b)/b;
beta_incomplete(2,b,z);
 (1-(1-z)^b*(b*z+1))/(b*(b+1));
beta_incomplete(3,b,z);
 2*(1-(1-z)^b*(b*(b+1)*z^2/2+b*z+1))/(b*(b+1)*(b+2));

/* a is a positive integer. 
   Check the expansion against numerically evaluation.
   First we test for b a positive value. */

closeto(
  float(beta_incomplete(1,2,3/2))-beta_incomplete(1.0,2.0,1.5),
  0.0,
  1e-15);
true;
closeto(
  float(beta_incomplete(2,5/2,3/2))-beta_incomplete(2.0,2.5,1.5),
  0.0,
  1e-15);
true;
closeto(
  float(beta_incomplete(3,3,3/2))-beta_incomplete(3.0,3.0,1.5),
  0.0,
  1e-15);
true;
closeto(
  float(beta_incomplete(2,7/2,3/2))-beta_incomplete(2.0,3.5,1.5),
  0.0,
  1e-15);
true;
closeto(
  float(beta_incomplete(2,5/2,3/2+%i))-beta_incomplete(2.0,2.5,1.5+%i),
  0.0,
  1e-15);
true;
/* I (rtoy) think the limiting accuracy of the following test is the conversion of 
 * the exact answer to floating point.  If the exact answer is converted to a 
 * bfloat 32 digits, the difference is less than 1.6e-15 or so.
*/
closeto(
  float(rectform(float(beta_incomplete(2,5/2,-3/2+%i))))
                -beta_incomplete(2.0,2.5,-1.5+%i),
  0.0,
  4.35e-15); /* we have lost accuracy. More tests necessary? */
true;

/* Incomplete Beta is definied for negative integers a and b >= (-a) 
   Add this point we have a problem. functions.wolfram.com gives different
   numerical results for this cases. When b not equal -a Maxima and 
   functions.wolfram.com differ by a factor 2. For other valid integer b
   functions.wolfram.com gives ComplexInfinity and not an expected result.
   What is wrong?
*/

beta_incomplete(-1,1,z);
-1/z;
beta_incomplete(-2,1,z);
-1/(2*z^2);
beta_incomplete(-2,2,z);
(z-1/2)/z^2;
beta_incomplete(-3,1,z);
-1/(3*z^3);
beta_incomplete(-3,2,z);
(z/2-1/3)/z^3;
beta_incomplete(-3,3,z);
(-z^2+z-1/3)/z^3;

/* Some numerical tests in double float precision */

closeto(
  beta_incomplete(0.5,1.0,0.10),
  0.6324555320336758663997787088865437067439110278650433653715009706b0,
  1e-15);
true;

closeto(
  beta_incomplete(0.5,1.0,0.15),
  0.7745966692414833770358530799564799221665843410583181653175147532b0,
  1e-15);
true;

closeto(
  beta_incomplete(0.5,1.0,0.20),
  0.8944271909999158785636694674925104941762473438446102897083588982b0,
  1e-15);
true;

closeto(
  beta_incomplete(0.5,1.0,0.25),
  1.000000000000000000000000000000000000000000000000000000000000000b0,
  1e-15);
true;

closeto(
  beta_incomplete(0.5,1.0,0.50),
  1.414213562373095048801688724209698078569671875376948073176679738b0,
  1.416e-15);
true;

closeto(
  beta_incomplete(0.5,1.0,0.75),
  1.732050807568877293527446341505872366942805253810380628055806979b0,
  2.11e-15);
true;

closeto(
  beta_incomplete(0.5,1.0,1.00),
  2.000000000000000000000000000000000000000000000000000000000000000b0,
  2.0e-15);
true;

closeto(
  beta_incomplete(0.5,1.0,1.25),
  2.236067977499789696409173668731276235440618359611525724270897245b0,
  2.0e-15);
true;

closeto(
  beta_incomplete(0.5,1.0,1.50),
  2.449489742783178098197284074705891391965947480656670128432692567b0,
  2.0e-15);
true;

closeto(
  beta_incomplete(0.5,1.0,1.75),
  2.645751311064590590501615753639260425710259183082450180368334459b0,
  1.446e-15);
true;

closeto(
  beta_incomplete(0.5,1.0,2.00),
  2.828427124746190097603377448419396157139343750753896146353359476b0,
  1.503e-15);
true;

/* Some numerical tests in bigfloat precision */

fpprec:64;
64;

closeto(
  beta_incomplete(0.5,1.0,0.10b0),
  0.6324555320336758663997787088865437067439110278650433653715009706b0,
  1b-60);
true;

closeto(
  beta_incomplete(0.5,1.0,0.15b0),
  0.7745966692414833770358530799564799221665843410583181653175147532b0,
  1b-60);
true;

closeto(
  beta_incomplete(0.5,1.0,0.20b0),
  0.8944271909999158785636694674925104941762473438446102897083588982b0,
  1b-60);
true;

closeto(
  beta_incomplete(0.5,1.0,0.25b0),
  1.000000000000000000000000000000000000000000000000000000000000000b0,
  1b-60);
true;

closeto(
  beta_incomplete(0.5,1.0,0.50b0),
  1.414213562373095048801688724209698078569671875376948073176679738b0,
  1b-60);
true;

closeto(
  beta_incomplete(0.5,1.0,0.75b0),
  1.732050807568877293527446341505872366942805253810380628055806979b0,
  1b-16);
true;

closeto(
  beta_incomplete(0.5,1.0,1.00b0),
  2.000000000000000000000000000000000000000000000000000000000000000b0,
  1b-60);
true;

closeto(
  beta_incomplete(0.5,1.0,1.25b0),
  2.236067977499789696409173668731276235440618359611525724270897245b0,
  1b-60);
true;

closeto(
  beta_incomplete(0.5,1.0,1.50b0),
  2.449489742783178098197284074705891391965947480656670128432692567b0,
  1b-60);
true;

closeto(
  beta_incomplete(0.5,1.0,1.75b0),
  2.645751311064590590501615753639260425710259183082450180368334459b0,
  1b-60);
true;

closeto(
  beta_incomplete(0.5,1.0,2.00b0),
  2.828427124746190097603377448419396157139343750753896146353359476b0,
  1b-60);
true;

/* See Bug 3220128, but this isn't really that bug */
closeto(
  gamma_incomplete(0, 200b0*%i),
  0.00437844609302782567916569771749325524128345091344187598851110680706344144459295b0
  - %i*.00241398745542678587253611621620491057595401709907514761094360488114169654741b0,
  3.4b-67);
true;

/* Make sure we don't overflow unnecessarily in gamma_incomplete_regularized */
closeto(
  gamma_incomplete_regularized(45001d0, 45000d0),
  0.5012537510700691773177801688515861486945632498553288,
  6.4e-12);
true;

/* Check accuracy on the negative real axis.
 * See Bug  3526359 - gamma_incomplete(1/5,-32.0) not accurate
 */
relerror(
  gamma_incomplete(1/5,-32.0),
  -4.0986398326716649399d12 - %i*2.9778361454160762231d12,
  2.545e-15);
true;

relerror(
  gamma_incomplete(10,-100d0),
  subst(x=-100d0, block([gamma_expand : true], gamma_incomplete(10,x))),
  8.78e-15);
true;
      
relerror(
  gamma_incomplete(10,-100b0),
  subst(x=-100b0, block([gamma_expand : true], gamma_incomplete(10,x))),
  3.57b-64);
true;
      
relerror(
  gamma_incomplete(10,-100d0+%i),
  subst(x=-100d0+%i, block([gamma_expand : true], gamma_incomplete(10,x))),
  1.046e-14);
true;
      
relerror(
  gamma_incomplete(10,-100b0+%i),
  subst(x=-100b0+%i, block([gamma_expand : true], gamma_incomplete(10,x))),
  2.04b-64);
true;

relerror(
 erf(inverse_erf(.5)),
 0.5,
 1.4d-14);
true;
      
relerror(
 erf(inverse_erf(-.5)),
 -0.5,
 1.4e-14);
true;

relerror(
 erf(inverse_erf(.5b0)),
 0.5b0,
 2b-64);
true;

relerror(
 erf(inverse_erf(-.5b0)),
 -0.5b0,
 2b-64);
true;

relerror(
 erf(inverse_erf(2.0)),
 2.0,
 7.9d-15);
true;

relerror(
 erf(inverse_erf(-2.0)),
 -2.0,
 7.9d-15);
true;

/* These are a bit slow if fpprec is large.  Make fpprec a bit smaller */
fpprec:24;
24;

relerror(
 erf(inverse_erf(2b0)),
 2b0,
 5.9b-24);
true;

relerror(
 erf(inverse_erf(-2b0)),
 -2b0,
 5.9b-24);
true;

relerror(
 erf(inverse_erf(2b0+2b0*%i)),
 2b0+2b0*%i,
 6.6b-25);
true;

relerror(
 erf(inverse_erf(-2b0-2b0*%i)),
 -2b0-2b0*%i,
 6.6b-25);
true;

relerror(
 erf(inverse_erf(10b0+1000b0*%i)),
 10b0+1000b0*%i,
 2b-23);
true;


/* From the mailing list.  This should not signal an error and should give a simplifed answer */
relerror(
 expand(bfloat(erf((sqrt(2)*%i-sqrt(2))/2))),
 4.74147636640994245161681b-1 * %i - 9.69264211944215930381491b-1,
 1b-23);
true;

/* Bug #2619
 * Function inverse_erf - error in numerical evaluation 
 */
relerror(inverse_erf(0.7715),
 .8515204685911937,
 1d-15);
true;

relerror(inverse_erf(- .9763545580611441 ),
 -1.600070795398459,
 1d-15);
true;

/* Bug #2668 Bigfloat Gamma inaccurae for small inputs
 *
 * For these small values, gamma(z) = gamma(z+1)/z = 1/z
 * since 1+z = 1 and gamma(1) = 1.
 */
relerror(gamma(2.0^-256), 2.0^256, 1d-14);
true;

relerror(gamma(2b0^-256), 2b0^256, 10^(-fpprec+1));
true;

relerror(
  gamma(2.0^-256 + 1d-200*%i),
  rectform(1/(2.0^-256 + 1d-200*%i)),
  2d-15);
true;

closeto(
  gamma(2b0^-256 + 1b-500*%i),
  rectform(1/(2b0^-256 + 1b-500*%i)),
  2d-15);
true;

(fpprec:oldfpprec,done);
done;

/* SF bug #3090: "erfi switches sign at approximately -0.476 and 0.476" */

block
  (kill (x, L1, L2),
   x : makelist (i/10.0, i, -20, 20),
   L1 : makelist (erfi (x1), x1, x),
   L2 : makelist (-%i*erf (%i*x1), x1, x),
   every (lambda ([x1, x2], x1 = x2), L1, L2));
true;

every (lambda ([x1, e1], sign(x1) = sign(e1)), x, L1);
true;

every (lambda ([x1, e1], sign(x1) = sign(e1)), x, L2);
true;

/* SF bug #3277: "no numerical evaluation for gamma_greek" */

block([gamma_expand: true], gamma_incomplete_lower(10, 1));
362880-986410*%e^-1;

/* numerical value not very accurate; perhaps it is being computed naively via preceding formula? */
closeto (ev (gamma_incomplete_lower(10, 1), numer), 4.043407757955496e-2, 1e-10);
true;

/* this one is way off the mark ... sheesh. */
closeto (gamma_incomplete_lower(10, 1.0), 4.043407757955496e-2, 1e-8);
true;

(reset (fpprec),
 closeto (gamma_incomplete_lower(10, 1b0), 4.043407757955496b-2, 1b-10));
true;

block([gamma_expand: true], gamma_incomplete_lower(1, 10));
1 - %e^-10;

closeto (ev (gamma_incomplete_lower(1, 10), numer), 0.9999546000702375e0, 1e-15);
true;

closeto (gamma_incomplete_lower(1.0, 10), 0.9999546000702375e0, 1e-15);
true;

closeto (gamma_incomplete_lower(1b0, 10), 0.9999546000702375b0, 1b-15);
true;

/* complex float and complex bfloat */

/* yikes */
closeto (ev (gamma_incomplete_lower(10, 1 + %i), numer), 7.992250288513467e-1*%i + 1.011121671734864e0, 1e-7);
true;

/* ditto */
closeto (gamma_incomplete_lower(10, 1.0 + %i), 7.992250288513467e-1*%i + 1.011121671734864e0, 1e-7);
true;

closeto (gamma_incomplete_lower(10, 1b0 + %i), 7.992250288513467b-1*%i + 1.011121671734864b0, 1b-10);
true;

/* mailing list 2018-02-04: "Bug in beta_incomplete_regularized." */

(kill(f, g, x, y),
 f(x) := beta_incomplete_regularized(2,2,x/(1+x)),
 g(x) := beta_incomplete(2,2,x),
 should_be_equal(a, b) := if equal(a, b) then true else notequal(a, b),
 0);
0;

f(1/y);
(2*(1-1/((1/y+1)*y))+1)/((1/y+1)^2*y^2);

f(1/x);
(2*(1-1/((1/x+1)*x))+1)/((1/x+1)^2*x^2);

should_be_equal (f(1/x), subst (y = 1/x, f(y)));
true;

g(-y);
(y^2*(2*(y+1)+1))/6;

g(-x);
(x^2*(2*(x+1)+1))/6;

should_be_equal (g(-x), subst (y = -x, g(y)));
true;

(kill(a, h, i, j, k, u, v, w),
 h(u) := gamma_incomplete(3, u),
 i(v, w) := gamma_incomplete_generalized(3 + a, v, w),
 j(u) := gamma_incomplete_regularized(4, u),
 k(v, w) := beta_incomplete_regularized(2, v, w),
 0);
0;

gamma_expand : true;
true;

should_be_equal (h(u), integrate (t^2*exp(-t),t,u,inf));
true;

[h(u), h(-u)];
[2*(u^2/2+u+1)*%e^-u,2*(u^2/2-u+1)*%e^u];

should_be_equal (h(-u), subst (v = -u, h(v)));
true;

should_be_equal (i(2*v, 4*w), a*(a+1)*(a+2)
                               *((-((4^(a+2)*w^(a+2))/(a*(a+1)*(a+2))+(4^(a+1)*w^(a+1))/(a*(a+1))
                                                                     +(4^a*w^a)/a)
                                *%e^-(4*w))
                                +((2^(a+2)*v^(a+2))/(a*(a+1)*(a+2))+(2^(a+1)*v^(a+1))/(a*(a+1))+(2^a*v^a)/a)
                                 *%e^-(2*v)+gamma_incomplete_generalized(a,2*v,4*w))); /* FOR SURE ?? */
true;

should_be_equal (i(2*v, 4*w), subst ([x = 2*v, y = 4*w], i(x, y)));
true;

should_be_equal (j(u), integrate (t^3*exp(-t),t,u,inf)/gamma(4));
true;

should_be_equal (j(1 + u), ((u+1)^3/6+(u+1)^2/2+u+2)*%e^((-u)-1));
true;

should_be_equal (j(1 + u), subst (v = 1 + u, j(v)));
true;

block ([foo, bar, l:[0.1, 0.25, 0.5, 0.8, 0.9, 0.95]],
       foo : makelist (k(4, x), x, l),
       bar : ev (makelist (first (quad_qags (t^(a-1)*(1-t)^(b-1), t, 0, x))/beta(a, b), x, l), a=2, b=4),
       if lmax (abs (foo - bar)) < 1e-8 then true else notequal (foo, bar));
true;

k(1 - w, 2*v);
1-(1-2*v)^(1-w)*(2*v*(1-w)+1); /* assuming k(v, w) = 1-(1-w)^v*(v*w+1) */

should_be_equal (k(1 - v, 2*w), subst ([x = 1 - v, y = 2*w], k(x, y)));
true;

/*
 * From the mailing list, 2020/01/20, Richard Fateman.  The integrand here is
 * the derivative of exp(-x^3)/x^4.  Without gamma_expand, we get an expression
 * involving gamma_incomplete of orders -1/3 and -4/3.  By having
 * gamma_expand:true, these are expressed in terms of order 2/3.  These nicely
 * cancel to produce the original expression.
 */
expand(integrate((-(3*%e^-x^3)/x^2)-(4*%e^-x^3)/x^5, x));
exp(-x^3)/x^4;

/*
 * Test expansion of gamma_incomplete_lower
 */
gamma_incomplete_lower(a+2,z);
a*(a+1)*gamma_incomplete_lower(a,z)-z^a*(z+a+1)*%e^-z;

gamma_incomplete_lower(1/3+2,z);
(4*gamma_incomplete_lower(1/3,z))/9-z^(1/3)*(z+4/3)*%e^-z;

gamma_incomplete_lower(a-2,z);
(1/((a-2)*z)+1/((a-2)*(a-1)))*z^(a-1)*%e^-z +gamma_incomplete_lower(a,z)/((a-2)*(a-1));

gamma_incomplete_lower(1/3-2,z);
((9/10-3/(5*z))*%e^-z)/z^(2/3)+(9*''gamma_incomplete_lower(1/3,z))/10;

/*
 * Test expansion of gamma_incomplete_regularized.
 */
gamma_incomplete_regularized(3,z) - gamma_incomplete(3,z)/gamma(3);
0;

gamma_incomplete_regularized(3/2,z);
(2*sqrt(z)*%e^-z)/sqrt(%pi)+erfc(sqrt(z));

gamma_incomplete_regularized(-3/2,z);
erfc(sqrt(z))-(3*((4*z)/3-2/3)*%e^-z)/(4*sqrt(%pi)*z^(3/2));

gamma_incomplete_regularized(2+a,z);
(z^a*(z+a+1)*%e^-z)/(a*(a+1)*gamma(a))+gamma_incomplete_regularized(a,z);

gamma_incomplete_regularized(-2+a,z);
gamma_incomplete_regularized(a,z)-(z^(a-2)*(z+a-1)*%e^-z)/gamma(a);

gamma_incomplete_regularized(2+1/3,z);
(9*z^(1/3)*(z+4/3)*%e^-z)/(4*gamma(1/3))+gamma_incomplete_regularized(1/3,z);

gamma_incomplete_regularized(-2+1/3,z);
gamma_incomplete_regularized(1/3,z)-((z-2/3)*%e^-z)/(gamma(1/3)*z^(5/3));

integrate(log_gamma(z),z);
psi[-2](z)$

integrate(log_gamma(1-s),s);
-psi[-2](1-s)$

integrate(2*x*log_gamma(x^2),x);
psi[-2](x^2)$

reset (gamma_expand);
[gamma_expand];

/* tests for derivative of binomial */
ratsimp(makegamma(diff(binomial(a,b) - makegamma(binomial(a,b)),a)));
0$

ratsimp(makegamma(diff(binomial(a,b) - makegamma(binomial(a,b)),b)));
0$

ratsimp(makegamma(diff(binomial(a^2,a) - makegamma(binomial(a^2,a)),a,2)));
0$

/* tests for sign of gamma expressions */
sign(gamma(exp(x)));
pos$

/* since x might be zero, making gamma(x) undefined, return pnz */
sign(gamma(x));
pnz$

/* since sign(1/x) = pn, we have sign(gamma(1/x)) = pn */
sign(gamma(1/x));
pn$

sign(gamma(x^2 +1));
pos$

sign(gamma(-(1 + x^2)));
pn$

/* since sign(sqrt(x)) = pz, we have sign(gamma(sqrt(x)) = pnz */
sign(gamma(sqrt(x)));
pnz$



