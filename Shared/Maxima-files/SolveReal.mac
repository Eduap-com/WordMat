/* Examples: solvereal(a*b+c=log(a+x),x)  
factoring the input may yield different results. Factoring is only done using sqfr() since factor can timeout factor(2^(1.1*x)+1)*/

/*load(to_poly_solve)$*/

simpsum:true$

[packagefile:true,partswitch:true,domain:real]$
define_variable(AllTrig,false,boolean)$
define_variable(uselambertw,true,boolean)$
define_variable(autonsolve,true,boolean)$
define_variable(solvar,x,any)$
define_variable(solvar2,x,any)$
define_variable(solsysvars,[],list)$
define_variable(NoSigFig,7,integer)$
fpprintprec:NoSigFig$
define_variable(DecOutType,1,integer)$ /* 0: decimals  1: decimal with significant figures,  2: scientific notation, */
/* define_variable(iteind,0,integer)$
define_variable(factind,0,integer)$ */  /* Nu lokalt i solvereal*/
define_variable(solvesteps,[],list)$
/* define_variable(dissolveradicals,true,boolean)$ Incorrect math*/ 
define_variable(dissolveabs,true,boolean)$
define_variable(showassumptions,true,boolean)$
define_variable(sepsolvecontext,true,boolean)$
define_variable(solverealtopoly,false,boolean)$
define_variable(solverealmaximasolve,true,boolean)$
newcontext(solreal)$context:initial$

containx(exprq,xqz):=block([],member(xqz,listofvars(exprq)))$
containanyx(exprq,xqz):=block([],not(lfreeof(xqz,listofvars(exprq)) ))$ /* for solvesystem */

ToFrac(exprq):=block([zq],zq:ev(rat(exprq),keepfloat=false),
   if ratnump(zq) then zq else rationalize(exprq) 
)$

matchdeclare([aliz,aliz2,aliz3,aliz4,aliz5],all)$
matchdeclare([alizx,alizx2],lambda([z],containx(z,solvar)))$
matchdeclare(aliz1ledx,lambda([z],is(op(z)#"*") and containx(z,solvar)))$
matchdeclare([aliznotx,aliznotx2,aliznotx3,aliznotx4],lambda([z],not(containx(z,solvar))))$
matchdeclare([aliznotxy,aliznotxy2,aliznotxy3],lambda([z],not(containx(z,solvar) or containx(z,solvar2) or is(z=0)) ))$
matchdeclare([aliznotanyx,aliznotanyx2],lambda([z],not(containanyx(z,cons(solvar,solsysvars)))))$
matchdeclare(alizadd,aliz+aliz=aliz)$
matchdeclare(alizeven,evenp)$
matchdeclare(alizodd,oddp)$
/*matchdeclare(alizoddnum,lambda([z],oddp(num(rationalize(z)))))$ */
matchdeclare(alizoddnum,lambda([z],oddp(num(ev(rat(z),keepfloat=false)))))$ 
matchdeclare(alizodddenom,lambda([z],oddp(denom(ToFrac(z)))))$
matchdeclare(alizoddnumevendenom,lambda([z], oddp(num(ToFrac(z))) and evenp(denom(ToFrac(z))) ))$
/* matchdeclare(alizevennum,lambda([z],evenp(num(rationalize(z)))))$, replaced by rat below to counter inaccurate binary conversions like 0.4 */
matchdeclare(alizevennum,lambda([z],evenp(num(ToFrac(z)))))$
matchdeclare(alizinteger,lambda([z],integerp(ToFrac(z))))$
matchdeclare(aliznoninteger,lambda([z],not(integerp(ToFrac(z)))))$
matchdeclare(aliznonnatural,lambda([z],numberp(z) and not(integerp(ToFrac(z)) and z>0 )))$
matchdeclare(alizirrational,lambda([z],constantp(z) and not(numberp(z))))$
matchdeclare(alizneginteger,lambda([z],integerp(ToFrac(z) and z<0 )))$
matchdeclare(aliznegative,lambda([z],is(z<0)))$
matchdeclare(aliznegative0,lambda([z],is(z<=0)))$
matchdeclare(aliznegative2,lambda([z],is(op(z)="-")))$
matchdeclare([alizpositive,alizpositive2],lambda([z],not(is(is(z>0)=false))))$
matchdeclare([aliznotzero,aliznotzero2],lambda([z],not(is(is(z#0)=false))))$
matchdeclare(alizimag,lambda([z],block(if is(freeof(%i,z)) then return(false),if abs(ev(imagpart(z)/realpart(z),numer))>10^-14 then return(true),return(false) )))$
matchdeclare(alizillinvtrig,lambda([z],is(z<-1 or z>1)))$
matchdeclare(alizbelowone,lambda([z],is(z<1)))$
matchdeclare(alizilllambertw,lambda([z],is(z<-1/%e)))$
matchdeclare(alizlambertw2sol,lambda([z],is(z>-1/%e and z<0)))$
matchdeclare(aliznum,numberp)$
matchdeclare(aliznotnum,lambda([z],not(numberp(z))))$
matchdeclare(alizaddop,lambda([z],is(op(z)="+" and containx(z,solvar))))$
matchdeclare(aliznotaddop,lambda([z],is(op(z)#"+")))$
matchdeclare(aliznotone,lambda([z],is(z#1) and is(z#1.0)))$
matchdeclare([alizatom,alizatom2],atom)$

tellsimpafter(-((aliz + aliz2) / aliz3), (-aliz - aliz2) / aliz3)$
tellsimpafter(aliznegative^aliznum,ev(aliznegative^rat(aliznum),keepfloat=false))$
tellsimpafter((-1)^alizoddnumevendenom,ev((-1)^alizoddnumevendenom,domain=complex))$

defrule(swaprule,aliznotx=alizx,alizx=aliznotx)$
defrule(addrule,aliz+alizx=aliz2,alizx=aliz2-aliz)$
defrule(addrule2,aliz=aliz2+alizx,aliz-alizx=aliz2)$
defrule(prodrule,aliz*alizx=aliznotzero,(assume(notequal(aliz,0)),alizx=aliznotzero/aliz))$
defrule(prodrule4,aliznotanyx*alizx=aliz2,(assume(notequal(aliznotanyx,0)),alizx=aliz2/aliznotanyx))$
/* defrule(prodrule,aliz*alizx=aliz2,(assume(notequal(aliz,0)),alizx=aliz2/aliz))$ */
/* defrule(prodrule2,aliz=aliz2*alizx,aliz/alizx=aliz2)$ duer ikke at dividere med alizx */
defrule(prodrule2,aliznotx=aliz2*alizx,(assume(notequal(aliz2,0)),alizx=aliznotx/aliz2))$ /* aliz aendret til aliznotx da ellers kunne gaa i ring med doubleexp */
defrule(prodrule3,alizx2*alizx^aliz=aliznotzero,(assume(notequal(alizx2,0)),alizx^aliz=aliznotzero/alizx2))$ /* Denne kan overse loesninger hvis loesninger til solvereal(alizx,solvar) ogsaa er loesninger til ligningen. Kan egentlig ikke se hvor denne har sin berettigelse. Fjernet i v.1.06*/
defrule(divrule,aliznotx/alizx=aliznotzero,alizx=aliznotx/aliznotzero)$
defrule(divrule2,aliznotzero=aliz2/alizx,aliznotzero*alizx=aliz2)$
defrule(divrule3,aliznotaddop/alizaddop=aliznotzero,alizaddop/aliznotaddop=1/aliznotzero)$ 
defrule(divrule4,aliz/alizx=aliz2,alizx*aliz2-aliz=0)$ /* risikerer at bytter rundt og rundt hvis x i taeller og naevner, men forsoeger igen efter factor2*/
defrule(divrule5,aliz*alizx^alizneginteger=aliz2,expand(aliz-alizx^-alizneginteger*aliz2)=0)$
defrule(powrulezero,alizx^aliz=0,(assume(notequal(aliz,0)),alizx=0))$
defrule(powruleoddneg,alizx^alizoddnumevendenom=aliznegative,[])$ /* removes illegal solutions */
defrule(powruleodd,alizx^alizoddnumevendenom=aliz,(assume(aliz>=0),alizx=aliz^(1/alizoddnumevendenom)))$
defrule(powruleodd2,alizx^alizoddnum=aliz,(alizx=aliz^(1/alizoddnum)))$
defrule(powruleevenneg,alizx^alizevennum=aliznegative,[])$ /* removes illegal solutions */
defrule(powruleeven,alizx^alizevennum=aliz,(assume(aliz>=0),[alizx=aliz^(1/alizevennum),alizx=-aliz^(1/alizevennum)]))$
defrule(powruleirratneg,alizx^alizirrational=aliznegative,[])$
defrule(powruleirrat,alizx^alizirrational=aliz,(assume(aliz>=0),alizx=aliz^(1/alizirrational)))$
defrule(powrulenotnum,alizx^aliznotnum=aliz,(print(sconcat("Solution unsure. Because taking inverse power depends on ",aliznotnum, " and the sign of ",aliz )),assume(aliz>0),alizx=aliz^(1/aliznotnum)))$
defrule(expremoverule,%e^alizx=aliznegative0,[])$ /* no solution */
/* defrule(powrul1,(aliz^(aliz3*alizx))/(aliz2^(aliz4*alizx))=aliz5,alizx*log(aliz^aliz3/aliz2^aliz4)=log(aliz5))$ */
/* defrule(powrul2,(aliz^(alizx))/(aliz2^(aliz4*alizx))=aliz5,alizx*log(aliz/aliz2^aliz4)=log(aliz5))$ */
/* defrule(powrul3,(aliz^(alizx))/(aliz2^(alizx))=aliz5,alizx*log(aliz/aliz2)=log(aliz5))$ */
defrule(exprule,aliz^alizx=alizpositive,(assume(alizpositive>0,aliz>0),alizx=log(alizpositive)/log(aliz)))$
defrule(powrulexp,aliz^alizx,%e^(log(aliz)*alizx))$
defrule(lnrule,log(alizx)=aliz,alizx=%e^(aliz))$
defrule(sinsolruleall,sin(alizx)=aliz,[alizx=asin(aliz)+%Z*2*%pi,alizx=-asin(aliz)+%pi*(2*%Z+1)])$
defrule(cossolruleall,cos(alizx)=aliz,[alizx=acos(aliz)+%Z*2*%pi,alizx=-acos(aliz)+2*%pi*%Z])$
defrule(tansolruleall,tan(alizx)=aliz,[alizx=atan(aliz)+%Z*%pi])$
defrule(sinsolrule,sin(alizx)=aliz,alizx=asin(aliz))$
defrule(cossolrule,cos(alizx)=aliz,alizx=acos(aliz))$
defrule(tansolrule,tan(alizx)=aliz,alizx=atan(aliz))$
defrule(asinsolrule,asin(alizx)=aliz,alizx=sin(aliz))$
defrule(acossolrule,acos(alizx)=aliz,alizx=cos(aliz))$
defrule(atansolrule,atan(alizx)=aliz,alizx=tan(aliz))$
defrule(sinhsolrule,sinh(alizx)=aliz,alizx=asinh(aliz))$
defrule(coshillrule,cosh(alizx)=alizbelowone,[])$
defrule(coshsolrule,cosh(alizx)=aliz,(assume(aliz>=1),[alizx=acosh(aliz),alizx=-acosh(aliz)]))$
defrule(tanhillrule,tanh(alizx)=alizillinvtrig,[])$
defrule(tanhsolrule,tanh(alizx)=aliz,(assume(aliz>-1,aliz<1),alizx=atanh(aliz)))$
defrule(divzerorule,alizx/aliznotzero=0,(assume(notequal(aliznotzero,0)),alizx=0))$
defrule(absrule,abs(alizx)=aliz,[alizx=aliz,alizx=-aliz])$
defrule(absremoverule,abs(alizx)=aliznegative,[])$
defrule(lambertwillrule,alizx*%e^(alizx)-alizilllambertw=0,[])$
defrule(lambertwrule2sol,alizx*%e^(alizx)-alizlambertw2sol=0,([alizx=generalized_lambert_w(0,alizlambertw2sol),alizx=generalized_lambert_w(-1,alizlambertw2sol)]))$
defrule(lambertwrule1sol,alizx*%e^(alizx)-alizpositive=0,(assume(alizpositive>0),[alizx=generalized_lambert_w(0,alizpositive)]))$
defrule(lambertwrulegeneral,alizx*%e^(alizx)+aliz=0,(assume(aliz>1/%e),print("The lambert_w function is two-valued for values from -1/%e to 0"),[alizx=lambert_w(-aliz)]))$
defrule(lambertwrule2,
aliznotx*alizpositive^(aliznotzero*solvar+aliznotx2)+aliznotx3+aliznotx4*solvar=0,
block([z,numer:not(uselambertw)],if errcatch(z:aliznotzero*log(alizpositive)/aliznotx4*aliznotx*alizpositive^(aliznotx2-aliznotzero*aliznotx3/aliznotx4))=[] then return(aliznotx*alizpositive^(aliznotzero*solvar+aliznotx2)+aliznotx3+aliznotx4*solvar=0),
if z<-1/%e then return([]),if z<0 then return([solvar=-generalized_lambert_w(0,z)/(aliznotzero*log(alizpositive))-aliznotx3/aliznotx4,
solvar=-generalized_lambert_w(-1,z)/(aliznotzero*log(alizpositive))-aliznotx3/aliznotx4]),solvar=-lambert_w(z)/(aliznotzero*log(alizpositive))-aliznotx3/aliznotx4))$
defrule(fracrule,aliznotx3*(alizx+aliznotx)/(alizx+aliznotx2),aliznotx3+aliznotx3*(aliznotx-aliznotx2)/(alizx+aliznotx2))$

/* rule which expands in order to decrease the number of variables fx: 2x+3(x-2)=0 reduceres */
expandrule(exprq):=block([scq],
scq:countvar(exprq,solvar),
if scq<2 then return(false),
exprq:expand(lhs(exprq)-rhs(exprq)=0),
if countvar(exprq,solvar)<scq then return (exprq),
false
)$

logsimp:false$
defrule(toexpp,alizpositive*aliznotx^alizx,%e^(log(aliznotx)*alizx+log(alizpositive)))$
defrule(toexpm,aliznegative2*aliznotx^alizx,-%e^(log(aliznotx)*alizx+log(-aliznegative2)))$
logsimp:true$
defrule(simpdiv,(alizatom*aliznotone)/(aliznotone+aliznum),alizatom/(1+aliznum/aliznotone))$
/* defrule(simpdivexpt,(aliz2*%e^aliz)/(%e^aliz+aliznotone),aliz2/(1+aliznotone*%e^-aliz))$ kan give uendelig loekke simpdivexpt(-%e^(5*x+5*%c)/(%e^(5*x+5*%c)-1)) */

defrule(powundef,aliznegative^aliznoninteger,qundef:true)$
/* defrule(powundef,aliznegative^aliznoninteger,error("man kan ikke tage roden af et negativt tal."))$ */
defrule(sqrtundef,sqrt(aliznegative),error("man kan ikke tage kvadratroden af et negativt tal."))$
defrule(imagundef,alizimag,error("Ugyldig loesning fjernet"))$
defrule(asinundef,asin(alizillinvtrig),error("inverse trig error."))$
defrule(acosundef,acos(alizillinvtrig),error("inverse trig error."))$
defrule(ReplaceFirstRadical,alizx^aliznoninteger,(powno:powno+1,if powno>1 then alizx^aliznoninteger  else (radicalsubst:[alizx,aliznoninteger],powx)))$
/* defrule(ReplaceFirstRadical,alizx^aliznoninteger,(if powstop then alizx^aliznoninteger  else (powstop:true,radicalsubst:[alizx,aliznoninteger],powx)))$ */
defrule(ReplaceFirstAbs,abs(alizx),(absno:absno+1,if absno>1 then abs(alizx) else (abssubst:alizx,absx)))$

defrule(delogisticrule,aliznotxy*'diff(solvar,solvar2)+aliznotxy2*solvar+aliznotxy3*solvar^2=0,[solvar=0,solvar=-aliznotxy2/aliznotxy3,solvar=-(aliznotxy2/aliznotxy3)/(1+%c*%e^(aliznotxy2/aliznotxy*solvar2))])$
defrule(sinhrule,%e^aliz-%e^-aliz,2*sinh(aliz))$
defrule(coshrule,%e^aliz+%e^-aliz,2*cosh(aliz))$
defrule(tanhrule,sinh(aliz)/cosh(aliz),tanh(aliz))$

/* To compex polar notation */
infix("CVinkel",180,180)$
infix("CVinkelgrad",180,180)$
infix("CVinkelO",180,180)$
"CVinkel"(r,v):=expand(r*(cos(v)+%i*sin(v)))$
"CVinkelgrad"(r,v):=expand(r*(cos(v*%pi/180)+%i*sin(v*%pi/180)))$
ConvertToPolarAngleNotation(z,qrad):=block([qarg,qabs,qf],z:rectform(z),if qrad then qf:1 else qf:180/%pi,qabs:abs(z),qarg:carg(z)*qf,ev(qabs CVinkelO qarg,noeval))$

/* Denne sektion var tidligere i dll-filen som settingsstring og funcdefinitions*/
display2d:false$ratprint:false$numer:false$ 
dotscrules:true$ /* dotproduct -> * when scalar involved*/
numer_pbranch:false$/*Changed to false with new tellsimpafter. true: (-2)^0,75 konverteres da til imaginaertal. Maa goere det lidt nemmere at identificere imag loesninger. Dog problem at (-2)^0.4 giver imaginaert. Den har reel rod*/
ratsimpexpons:true$/*simplify exponents*/
assumescalar:all$/*variables assumes scalar if not declare(x,nonscalar) og senere kill(x)*/
logabs:true$/*integrate(1/x,x)=log(abs(x))*/
breakup:false$/*3. og 4. gradspolynomier deles ikke op i underudtryk*/
algebraic:false$/*false er default value, simplifikation af algebraiske heltal bl.a. noget med %i. Udtryk der er relle bliver ikke reduceret saa %i fjernes helt hvis denne er false*/
logexpand:true$/*alle log regneregler   true: log(a^x)=x*log(a)  all: log(a*b)=log(a)+log(b)  super: log(a/b)=log(a)-log(b)*/
triginverses:all$/*noget med sin^-1(sin(x))=x altid og begge veje*/
intanalysis:false$/*Kan loese flere bestemte integraler. Noget med ikke at soege efter poler i omraadet og altid integrere.*/
listconstvars:true$/*for at %i ogsaa kommer med blandt variable saa kompleks kan findes*/
keepfloat:true$/*soerger for at der ikke omdannes fra decimaltal til broek ved eksakt naar det er noedvendigt at bruge numeriske metoder*/
fpprintprec:0$/*default*/
rootsepsilon:1E-20$ /*1E-7 default used by realroots. */
algepsilon:1E+16$/*1E+8 default used by algsys. But how?*/
ordergreat(x,y,z,a,b,c,d)$ /* ensures that variables are output in a more familiar way*/
errcatch(remrule("^^",all))$
ev(tellsimp(0 ^ 0, 1), simp: false)$
matchdeclare(aliznum,numberp)$
matchdeclare(alizfloat,floatnump)$
defrule(scinotrul,aliznum,scinot(aliznum))$
defrule(dectalrul,aliz,dectal(aliz))$ /* aendret i version 1.07 defrule(dectalrul,aliznum,dectal(aliznum))$ */
defrule(dectalnumrul,aliznum,dectal(aliznum))$
defrule(floatrul,alizfloat,dectal(alizfloat))$
defrule(msinrul,sin(aliz),sing(180/%pi*aliz))$
defrule(mcosrul,cos(aliz),cosg(180/%pi*aliz))$
defrule(mtanrul,tan(aliz),tang(180/%pi*aliz))$
defrule(masinrul,asin(aliz),%pi/180*asing(aliz))$
defrule(macosrul,acos(aliz),%pi/180*acosg(aliz))$
defrule(matanrul,atan(aliz),%pi/180*atang(aliz))$
defrule(mlogrul,log(aliz),lgog(aliz)/lgog(%e))$
defrule(merul,%e^aliznotnum,10^(lgog(%e)*aliznotnum))$

dectalallNum(udt):=block([qout],
udt:ev(udt,lgog(x):=if x=%e then 0.4342944819032518 elseif numberp(x) then ev(log(x)/log(10),numer) else 'lgog(x),numer),
qout:errcatch(apply1(udt,dectalrul)),
if qout#[] then return(qout[1]),
qout:errcatch(apply1(udt,dectalnumrul)),
if qout=[] then udt else qout[1])$ /* Justeret i 1.19 dectalrul giver desvaerre fejl nu. gjorde den ikke foer. dectalnumrul virker, men der kan vaere noget med raekkefoelgen, saa den er andet valg*/

dectalall(udt):=block([qout],qout:errcatch(apply1(udt,floatrul)),if qout=[] then udt else qout[1])$

/* fra funcdef*/
infix("~",135,135)$
infix("�",135,135)$
"~"(qwa,qwb):=if not(scalarp(qwa) or scalarp(qwb)) then (if not(matrixp(qwa) and matrixp(qwb)) then qwa�qwb elseif length(qwa)=3 and length(qwb)=3 then matrix( qwa[2]*qwb[3]-qwa[3]*qwb[2], qwa[3]*qwb[1]-qwa[1]*qwb[3], qwa[1]*qwb[2]-qwa[2]*qwb[1]) else(error("vektorproduktet er kun defineret for vektorer af dimension 3"))) else qwa*qwb$                                                                                                                                       
infix("##",115,115)$
"##"(qwa,qwb):=block(if scalarp(qwa) or scalarp(qwb) then return(qwa*qwb) else return(qwa.qwb))$

vecmag(qwa):=if nonscalarp(qwa) then (if matrixp(qwa) then sqrt(conjugate(transpose(qwa)) . qwa) else 'vecmag(qwa)) else abs(qwa)$
tvvec(qwa):=if scalarp(qwa) then error("Tvaervektor er ikke defineret for en skalar") else (if length(qwa)=2 then matrix(-qwa[2],qwa[1]) else error("Tvaervektor er kun defineret to-dimensionelle vektorer"))$
ConvertToDegr(udt):=block([],applyb1(udt,msinrul,mcosrul,mtanrul,masinrul,macosrul,matanrul))$
ConvertLog(udt):=block([],udt:ratsimp(apply1(udt,merul,mlogrul)),ev(udt,lgog(10)=1))$
ConvertLogN(udt):=block([],udt:ratsimp(apply1(udt,merul,mlogrul)),ev(udt,lgog(10)=1,lgog(%e)=0.4342944819032518))$

scinot(udt):=block([talfakt,antbsf],if not(numberp(udt)) then return(udt),
    antbsf:NoSigFig+4,
    if udt<0 then antbsf:antbsf+1,
    if udt>1e10 or udt <-1e10 then antbsf:antbsf+1, 
    if abs(udt)<1e-9 then antbsf:antbsf+1, 
    (if udt<-10 or (udt>-1 and udt<1) or udt>10 then return(sremove(" ",printf(false,concat("~",antbsf,"e"),udt))) else return(dectaldec(udt))))$

scinotall(udt):=block([],apply1(udt,scinotrul))$

/*bruges ved bc. Kaldes på alle udtrykket og alle undertryk*/
dectalbc(udt):=block([qudt,antbsf],
    if numberp(udt) then go(hop),
    if atom(udt) then 
        return(udt),
/*        return(printf(false,concat("~a"),udt)),synes ikke denne giver mening. concat på eet argument?  */
    if not(numberp(udt)) then 
        return(udt),
hop,
    if udt=0 or udt=0.0 then
        return(0),
    qudt:abs(udt),
    if qudt<10^-4 then 
        return(scinot(udt)) 
    elseif qudt>10^NoSigFig then
        return(scinot(udt)),
    antbsf:NoSigFig+1,
    if qudt<1 then
        antbsf:antbsf-1-floor(log(qudt)/log(10)),
    if udt<0 then 
        antbsf:antbsf+1,
    udt:printf(false,concat("~",antbsf,"f"),udt),
    udt:striml(" ",udt),
    udt:strimr("0",udt),
    udt:strimr(".",udt),
    parse_string(udt) 
)$

/* bruges ved antal decimaler og ikke betydende cifre */
dectaldec(udt):=block([qudt,antbsf],
if numberp(udt) then go(hop),
if atom(udt)  then return(printf(false,concat("~a"),udt)),
if not(numberp(udt)) then return(udt),
hop,
udt:printf(false,concat("~,",NoSigFig,"f"),udt),udt:striml(" ",udt),udt:strimr("0",udt),udt:strimr(".",udt),parse_string(udt) 
)$

/*Bruger dectalbc, dectaldec eller scinot afh af indstilling af DecOutType*/
dectal(udt):=block([],if DecOutType=0 then dectaldec(udt) else (if DecOutType=1 then dectalbc(udt) else scinotall(udt)))$

funp1(fun,exp):=block([inflag],inflag:true,if mapatom(exp) then false else (if inpart(exp,0) = fun then true else member(true,maplist(lambda([q],funp1(fun,q)),exp))))$
funp2(fun,exp,var):=block([inflag],inflag:true,if mapatom(exp) then false else (if inpart(exp,0) = fun and member(var,listofvars(exp)) then true else member(true,maplist(lambda([q],funp2(fun,q,var)),exp))))$
funp(fun,exp,[var]):=if var = [] then funp1(fun,exp) else (if length(var) = 1 then funp2(fun,exp,first(var)) else error("too many arguments to funp"))$ /* test if fun is in exp */
GetReal(lign):=block([inlign,kond],
	if not(freeof(%if,lign)) then (inlign:args(lign)[2][1],kond:args(lign)[1]) else inlign:lign,
	if not(freeof(%i,carg,parg,kond)) then kond:[],
	if numberp(ev(float(ev(imagpart(rhs(inlign)),simp)),simp)) then  (if (is(abs(ev(imagpart(ev(float(ev(rhs(inlign),simp)),simp,numer)),simp))<10^(-NoSigFig))) then (if freeof(%i,inlign) then go(slutqw) else (inlign:ev(inlign,numer),go(slutqw))) else (return([]))), 
	if freeof(%i,ev(inlign,%z0:0,%z1:0)) then go(slutqw),
	inlign:trigsimp(rectform(inlign)),
	slutqw,
	if not(freeof(%if,lign)) and kond#[] then inlign:(%if(kond,[inlign],args(lign)[3])),
	if freeof(%i,inlign) then return(inlign) else return([]) 
)$
RemoveImag(lignliste):=block([iqw,outlistq],if lignliste=all then return(all),if lignliste=[] then return([]),lignliste:ev(lignliste,%z0:0,%z1:0),outlistq:[],iqw:1,startq, outlistq:append(outlistq,[GetReal(lignliste[iqw])]),iqw:iqw+1,if iqw<=length(lignliste) then go(startq),outlistq:flatten(outlistq),outlistq)$
ContainsTrig(udt):=block([],not(freeof(sin,cos,tan,acos,asin,atan,udt)))$

RealOnly(zqw):=if freeof(%i,zqw) then zqw else error()$
CheckDef(zqw,qvar):=block(if not(freeof(%i,zqw)) then error() elseif maybe(equal(parse_string(qvar),eval_string(qvar)))=false then error() else zqw)$

strtonum(exp):=if stringp(exp) then parse_string(exp) else exp$

/*Counts the number of occurences of a varible(or subexpression) in an expression */
countvar(exprq,varq):=block([qi:0,partswitch:true,varc:0],
startq,
if inpart(exprq,qi)=end then (return(varc)),
if inpart

(exprq,qi)=varq then (varc:varc+1),
if not(atom(inpart(exprq,qi))) then varc:varc+countvar(inpart(exprq,qi),varq),
qi:qi+1,
go(startq)
)$

logbase(qa,qb):=simplify(log(qa)/log(qb))$ /*tidligere med radcan. Gav problemer for log(10)->log(5)+log(2): logbase(a,b):=radcan(log(a)/log(b))$ */
log10(qa):=logbase(qa,10)$

/* Performs regression on the function F(x) ex. GeneralRegr(a*x^2+b*x+c,x,[1,2,3,4,5,6],[2,4,6,8,5,3],1e-4,[a=1])*/
GeneralRegr(Fw,qvar,Xq,Yq,qeps,qguess):=block([qi,qvars,qvar2,guesslist,fom,qout,r2,qmy,lbfgs_nfeval_max:50000],
	load(lbfgs),
	Fq(qvar2):=subst(qvar2,qvar,''Fw),
	qvars:delete(x,listofvars(Fw)),
	guesslist:makelist(
		(if member(zxq,listofvars(qguess)) then (
			qi:1,
			do(
				if length(qguess)<qi then return(1),
				if lhs(qguess[qi])=zxq then return(rhs(qguess[qi])),
				qi:qi+1
			)
			)
		else
			1
		),zxq,qvars),
	fom:((1/length(Xq))*sum((Fq(Xq[i]) - Yq[i])^2, i, 1, length(Xq))),
	qout:lbfgs(fom,qvars,guesslist,qeps,[-1,0]),
	if qout=[] then( 
		print("Unable to converge. Try lowering the eps or increase lbfgs_nfeval_max")
		)
	else(
Fq(qvar2):=subst(qvar2,qvar,ev(Fw,qout)),
qmy:1/length(Xq)*sum(Yq[qi],qi,1,length(Yq)),
r2:sum((Fq(Xq[qi])-qmy)^2,qi,1,length(Xq))/sum((Yq[qi]-qmy)^2,qi,1,length(Yq)),print(concat("R^2=",r2)),
Fq(qvar))
)$


NIntegrate(udt,var,x0,x1):=block([res1,res2,numer,fpprintprec:2000],
if x0=minf or x1=inf then res1:errcatch(quad_qagi(udt,var,x0,x1,'epsrel=1d-13)) else res1:errcatch(quad_qags(udt,var,x0,x1)),
if length(res1[1])=4 then res1:res1[1] else go(slutq),
if res1[4]=0 then return (res1[1]) else res1:quad_qag(udt,var,x0,x1,1),
if res1[4]=0 then return (res1[1]) else res1:Integrate(udt,var,x0,x1),
if res1#[] then return (res1),
slutq,
integrate(udt,var,x0,x1))$

Integrate(udt,var,x0,x1):=block([res1,res2,numer,qindef],numer:false,udt:rationalize(udt),
if x0#minf and x1#inf then (qindef:integrate(udt,var),if freeof(integrate,qindef) then return(subst(x1,var,qindef)-subst(x0,var,qindef))),
errcatch(res1:ev(integrate(udt,var,x0,x1),numer=false)),
if not(numberp(x0) and numberp(x1)) and x0#minf and x1#inf  then return(res1),
if numberp(ev(res1,numer)) then return(res1),res1:ev(res1,numer),if numberp(res1) then return(res1),
res2:NIntegrate(udt,var,x0,x1), if numberp(res2) then return(res2),
errcatch(res2:ldefint(udt,var,x0,x1)), if numberp(res2) then return(res2),
res1)$

zerorule(exprq):=block([indq,ledq,restq,xledq,exprq2],partswitch:true,
if op(exprq)#"=" or inpart(exprq,3)#end then return(exprq),
if CheckSolved(exprq) then return(exprq),
/* exprq2:factor(lhs(exprq)-rhs(exprq))=0, */
exprq2:factoreq(exprq),
exprq2:lhs(exprq2)-rhs(exprq2),
if op(exprq2)="-" and part(exprq2,2)=end then exprq2:-exprq2,
if not(op(exprq2)="*") then 
	exprq2:sqfr(exprq2)=0 
else 
	exprq2:exprq2=0,
if rhs(exprq2)#0 then return
(exprq),
if op(lhs(exprq2))="-" then exprq2:-exprq2,
if op(lhs(exprq2))#"*" then return(exprq),
restq:1,xledq:0,indq:1,
startq,
ledq:inpart(exprq2,1,indq),
if ledq=end then go (slutq),
if containx(ledq,solvar) and xledq=0 then 
	xledq:ledq 
else 
	restq:restq*ledq,
indq:indq+1,
go( startq),
slutq,
if xledq=0 then 
	return (exprq) 
elseif not(containanyx(restq,cons(solvar,solsysvars))) then 
	return(xledq=0) 
else 
	return([restq=0,xledq=0])
)$

/* logcontract that doesn't increase the size of expression enourmously*/
logcontract2(exprq):=block([exprq,exprq2,inpsiz],
inpsiz:exprsize(exprq),
exprq2:logcontract(exprq),
if exprsize(exprq2)<2*inpsiz then return(exprq2) else return(exprq)
)$

 /*algsysforsoeg v1.06 pga. for faa cifre med realroots*/
solvepoly(exprq):=block([exprq2,aqz,bqz,cqz,qsol,realonly:true],
exprq2:lhs(exprq)-rhs(exprq),
if not(polynomialp(exprq2,[solvar],lambda([z],atom(z) or constantp(z)),integerp)) then return (exprq),
if polynomialp(exprq2,[solvar],lambda([z],atom(z) or constantp(z)),lambda([z],is(z<2 and z>=0))) then return (exprq),
if polynomialp(exprq2,[solvar],lambda([z],atom(z) or constantp(z)),lambda([z],is(z<3 and z>=0))) then (
aqz:coeff(exprq2,solvar,2),
bqz:coeff(exprq2,solvar,1),
cqz:coeff(exprq2,solvar,0),
if aqz=0 or bqz=0 or cqz=0 then return(exprq) else return(if is(bqz^2-4*aqz*cqz<0)=true then ([]) else ([solvar=(-bqz+sqrt(bqz^2-4*aqz*cqz))/(2*aqz),solvar=(-bqz-sqrt(bqz^2-4*aqz*cqz))/(2*aqz)]))),
if polynomialp(exprq2,[solvar],'constantp,'integerp) then (
    qsol:flatten(ev(algsys([exprq2],[solvar]),numer)),
    if qsol=[] then
        return(ev(realroots(exprq2),numer))
    else return(qsol)
    ),
exprq
)$

ConvertToReal(qexpr):=block([nexpr],
if freeof(%i,qexpr) then return(qexpr),
nexpr:trigsimp(rectform(qexpr)),
if freeof(%i,nexpr) then return(nexpr),
nexpr:ev(rectform(qexpr),numer),
if ev(imagpart(nexpr)/realpart(nexpr),numer)<10^-14 then return(realpart(nexpr)),
qexpr
)$

RemoveUndefined(eqnw,sollistq):=block([indq,indq2,solq,sollistq2,delq],
if length(sollistq)=0 then return(sollistq),
if op(eqnw)=end then return(sollistq),
indq:0,sollistq2:[],
startq,
indq:indq+1,
indq2:1,
if length(sollistq)<indq then go(slutq),
solq:sollistq[indq],
if IsSolved(solq,solvar)=false then (sollistq2:append(sollistq2,[solq]),go(startq)),
if do(
	delq:inpart(eqnw,indq2),
	if delq=end then return(true),
	errcatch(if powundef(subst(solq,delq)) then return(false)),
	if errcatch(imagundef(ev(ev(delq,solq),numer)))=[] then return(false),
	if errcatch(asinundef(ev(delq,solq)))=[] then return(false),
	if errcatch(acosundef(ev(delq,solq)))=[] then return(false),
	indq2:indq2+1
	) then sollistq2:append(sollistq2,[solq]),
go(startq),
slutq,
indq:1,
do(
	sollistq2:RemoveUndefined(inpart(eqnw,indq),sollistq2),
	indq:indq+1,
	if inpart(indq,eqnw)=end then return(sollistq2)
	)
)$

RemoveIncorrect(sollistq):=block([indq,sollistq2,solq],
indq:0,sollistq2:[],
if length(sollistq)=0 then return(sollistq),
if domain=complex then return(sollistq),
do(
indq:indq+1,
solq:sollistq[indq],
/* med numer virker flg ikke assume(x>=-1/3) , is(equal(x,-3/2)),numer men det er vel af en grund*/
/* if ev(is(equal(lhs(solq),rhs(solq))),numer)#false then sollistq2:append(sollistq2,[solq]), */
/* if is(equal(lhs(solq),rhs(solq)))#false then sollistq2:append(sollistq2,[solq]), Denne fjernet og erstattet af næste linje i v. 1.27 pga problem med [assume(-7.5<=x,x<=7.5)]$;AllTrig:true$Solve(1.386*cos(0.61*x)=0,x); OBS: kan ikke genskabe problemet i forrige linje*/
if is(equal(lhs(solq),ev(rhs(solq),numer)))#false then sollistq2:append(sollistq2,[solq]),
if length(sollistq)=indq then return(sollistq2)
)
)$

RemoveIncorrect2(lignq,sollistq):=block([indq:0,sollistq2:[],solq],indq:0,sollistq2:[],
if length(sollistq)=0 then return(sollistq),
do(
	indq:indq+1,
	solq:sollistq[indq],
	if is(equal(subst(solq,lhs(lignq)),subst(solq,rhs(lignq))))#false then sollistq2:append(sollistq2,[solq]),
	if length(sollistq)=indq then return(sollistq2)
)
)$


IsSameOp(lignq):=block([],
if op(lhs(lignq))=op(rhs(lignq)) then 
	return(true) 
else 
	return(false)
)$

RemoveSameOp(lignq):=block([qop],
qop:op(lhs(lignq)),
if not(IsSameOp(lignq)) then 
	return(lignq),
if qop=sin then 
	return(inpart(lhs(lignq),1)=inpart(rhs(lignq),1)),
lignq
)$

ExpandIntegerSolution(eqw):=block([lisq,expqw,expqw2],
kill(%Z),
if freeof(%Z,eqw) then return(eqw),
if length(GetContextFacts(initial,solvar))+length(GetContextFacts(solreal,solvar))<2 then return(eqw),
lisq:[],
expqw:lhs(eqw)-rhs(eqw),
%Z:-100,
do(
	%Z:%Z+1,
	expqw2:ev(expqw),
	if is(equal(expqw2,0))#false then 
		lisq:append(lisq,[ev(eqw)]),
	if %Z>100 then return()
),
kill(%Z),
lisq
)$

/* Returns facts about variable in context qcont */
GetContextFacts(qcont,qvar):=block([qsavecon,outp],
qsavecon:context,
context:qcont,
qutp:facts(qvar),
context:qsavecon,
qutp
)$

DoubleExp(lignq):=block([qvs,ql1,ql2,qadd,qop],qadd:0,
qvs:ev(applyb1(lhs(lignq)-rhs(lignq),toexpm,toexpp),logsimp=false),
if not (op(qvs)="+") then return(lignq),
ql1:inpart(qvs,1),
ql2:inpart(qvs,2),
if not(inpart(qvs,3)=end) then return(lignq),
if op(ql1)=end or op(ql2)=end then return(lignq),
if op(ql1)="-" and op(ql2)#"-" then (ql1:-1*ql1,go(next1)),
if op(ql2)="-" then (ql2:-1*ql2,go(next1)),
qadd:log(-1),
next1,
qop:op(ql1),
if not(qop=op(ql2)) then return(lignq),
if qop="^" and inpart(ql1,1)=inpart(ql2,1) then 
	return(inpart(ql1,2)-inpart(ql2,2)+qadd=0),
if qop="/" and part(ql1,2)=part(ql2,2) then 
	if qadd=0 then 
		return(part(ql1,1)-part(ql2,1)=0) 
	else 
		return(part(ql1,1)+part(ql2,1)=0),
if qop="^" or qop="+" or qop="-" then return(lignq),
lignq
)$

/*Used to remove %union() result from to_poly_solve. applied: scanmap(RemoveUnion,expr)*/
RemoveUnion(qexpr):=block([],
if op(qexpr)#%union then return(qexpr)
else return(args(qexpr)) 
)$

CheckSolved(lignqw):=block([],
if lhs(lignqw)#solvar then return(false),
if freeof(solvar,rhs(lignqw)) then true else false
)$

CheckAllSolved(lignql):=block([indq:0],
if not(listp(lignql)) then return(false),
do(
	indq:indq+1,
	if indq>length(lignql) then return (true),
	if not(CheckSolved(lignql[indq])) then return(false)
)
)$

CheckSolvedVar(lignqw,varq):=block([],
if lhs(lignqw)#varq then return(false),
if freeof(solvar,rhs(lignqw)) then true else false
)$

/* Checks if expression is factored eg. -2*(x+2) -(x+2)^2*/
IsFactored(exprq):=block([],
if op(exprq)="-" then 
	(if part(exprq,2)=end 
		then 
			exprq:part(exprq,1) 
		else 
			return(false)
	),
if op(exprq)="/" then exprq:part(exprq,1),
if op(exprq)="*" then return(true),
if op(exprq)="^" then (if not(containx(part(exprq,2),solvar)) then return(true)), false)$

factoreq(lignqw):=block([exprq,exprq2,inpsiz],
if CheckSolved(lignqw) then return(lignqw),
exprq:lhs(lignqw)-rhs(lignqw),
if IsFactored(exprq) then return (exprq=0),
inpsiz:exprsize(exprq),
exprq2:sqfr(exprq),
if IsFactored(exprq2) then return (exprq2=0),
exprq2:sqfr(logcontract(exprq)),
if exprq=exprq2 then return(lignqw),
if IsFactored(exprq2) then (if exprsize(exprq2)<5*inpsiz then return(exprq2=0) else return(lignqw)),
lignqw 
)$

factoreq2(lignqw):=block([exprq],
if CheckSolved(lignqw) then return(lignqw),
exprq:lhs(lignqw),
if op(exprq)="*" then return(lignqw) else (return(sqfr(exprq)=rhs(lignqw)))
)$
/* forsoeg med factoreq istedet for factoreq2*/
applyfactor2(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:factoreq(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$

simplifyhyp(qudt):=block([],applyb1(qudt,sinhrule,coshrule,tanhrule))$

/* Tries to simplify the expression using different methods. Returning the expression that can be written shortest, attempt at using expand as well and simpdiv */
simplify(exprq):=block([sexprq,sexprq2,sizexpr],
sizexpr:exprsize(exprq),
if numberp(exprq) then return(exprq),
if constantp(exprq) then (sexprq:radcan(exprq),sexprq2:ev(sexprq,numer), if integerp(sexprq) then return(sexprq), if integerp(sexprq2) then return(sexprq2), if exprsize(sexprq)<sizexpr then return(sexprq)),
sexprq:expand(exprq),
if exprsize(sexprq)<exprsize(exprq) and is(equal(sexprq,exprq)) then exprq:sexprq,
sexprq:radcan(exprq),
if exprsize(sexprq)<exprsize(exprq) and is(equal(sexprq,exprq)) then exprq:sexprq,
sexprq:ratsimp(exprq),
if exprsize(sexprq)<exprsize(exprq) and is(equal(sexprq,exprq)) then exprq:sexprq,
sexprq:expand(exprq),
sexprq:applyb1(exprq,fracrule),
if exprsize(sexprq)<exprsize(exprq) and is(equal(sexprq,exprq)) then exprq:sexprq,
if not errcatch(applyb1(exprq,simpdiv))=[] then sexprq:applyb1(exprq,simpdiv),
/* simplify(M*%e^(a*x*M+a*c*M)/(%e^(a*x*M+a*c*M)+1)) */
if sexprq#false and exprsize(sexprq)<exprsize(exprq) then exprq:sexprq,
exprq
)$/*Gemt fordi ovenstaaende ikke er testet helt endnu */
simplifyOld(exprq):=block([sexprq,sexprq2,sexprq3,sizexpr],
sizexpr:exprsize(exprq),
if constantp(exprq) then (sexprq:radcan(exprq),sexprq2:ev(sexprq,numer), if integerp(sexprq) then return(sexprq), if integerp(sexprq2) then return(sexprq2), if exprsize(sexprq)<sizexpr then return(sexprq)),
sexprq:radcan(exprq),
sexprq2:ratsimp(exprq),
sexprq3:expand(exprq),
if exprsize(sexprq2)<exprsize(sexprq) then sexprq:sexprq2,
if exprsize(sexprq3)<exprsize(sexprq) then sexprq:sexprq3,
if exprsize(sexprq)<sizexpr then return(sexprq),
exprq
)$

/*  ratsimp kan give maerkelig resultat #1,INF med ,numer   72*e^((0.619/0.22*(e^22-e^0.22*t )) ) , Derfor denne specielle version*/
simplifynum(exprq):=block([sexprq,sexprq2,sizexpr],
sizexpr:exprsize(exprq),
if numberp(exprq) then return(exprq),
if constantp(exprq) then (sexprq:radcan(exprq),sexprq2:ev(sexprq,numer), if integerp(sexprq) then return(sexprq), if integerp(sexprq2) then return(sexprq2), if exprsize(sexprq)<sizexpr then return(sexprq)),
sexprq:expand(exprq),
if exprsize(sexprq)<exprsize(exprq) then exprq:sexprq,
exprq
)$

simplifysol(sollist):=block([exprq2],exprq2:makelist(block([zxq2],if not(op(zxq)="=") then return(zxq),zxq2:lhs(zxq)=simplify(rhs(zxq)),if zxq2=false then return(zxq),zxq2),zxq,sollist))$

exprsize(exprq):=length(charlist(string(exprq)))$



/*Giver et tal for stoerrelsen af ligningen. Det er antallet af charaterer. Hvis det er polynomium i en af variablene saa laegges 15 til. det er ikke godt nok med polynomialp*/
exprmetric(exprq,varlq):=block([qm],
qm:exprsize(exprq),
if polynomialp(lhs(exprq)-rhs(exprq),varlq,lambda([z],atom(z) or constantp(z)),lambda([z],is(z>1))) then qm:qm+15,
qm
)$

FunctionList(func,listpar):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:func(zxq),if zxq2=false then return(zxq),zxq2),zxq,listpar))$

/* anvender qrul paa hvert element i listen, kan erstatte mange herunder*/
applyrulelist(exprq,qrul):=block([exprq2],
exprq2:delete([],
	makelist(
		block([zxq2],
			zxq2:qrul(zxq),
			if zxq2=false then 
				return(zxq),
			zxq2
			),
		zxq,exprq)
	)
)$

/* som applyrulelist, men anvendes paa expand(lhs-rhs)=0, hvis reglen ikke giver bonus saa returneres det oprindelige udtryk */
applyrulelistZero(exprq,qrul):=block([exprq2],
exprq2:delete([],
	makelist(
		block([zxq2],
			zxq2:qrul(expand(lhs(zxq)-rhs(zxq))=0),
			if zxq2=false then 
				return(zxq),
			zxq2),
			zxq,exprq))
)$

applyswaprule(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:swaprule(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applyzerorule(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:zerorule(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applyaddrule(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:addrule(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applyaddrule2(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:addrule2(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applyprodrule(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:prodrule(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applyprodrule2(exprq):=block([exprq2],exprq2:flatten(makelist(block([zxq2],zxq2:prodrule2(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq)))$
applyprodrule3(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:prodrule3(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applydivrule(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:divrule(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applydivrule2(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:divrule2(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applydivrule3(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:divrule3(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applydivrule4(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:divrule4(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applypowrulenotnum(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:powrulenotnum(zxq),if zxq2=false then return(zxq),assume(rhs(zxq)>=0),zxq2),zxq,exprq))$
applyexprule(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:exprule(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applyexpremoverule(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:expremoverule(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$

applylnrule(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:lnrule(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applysinrule(exprq):=block([exprq2],flatten(exprq2:makelist(block([zxq2],if AllTrig then zxq2:sinsolruleall(zxq) else zxq2:sinsolrule(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq)))$
applycosrule(exprq):=block([exprq2],flatten(exprq2:makelist(block([zxq2],if AllTrig then zxq2:cossolruleall(zxq) else zxq2:cossolrule(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq)))$
applytanrule(exprq):=block([exprq2],flatten(exprq2:makelist(block([zxq2],if AllTrig then zxq2:tansolruleall(zxq) else zxq2:tansolrule(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq)))$
applyasinrule(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:asinsolrule(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applyacosrule(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:acossolrule(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applyatanrule(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:atansolrule(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applyabsrule(exprq):=block([exprq2],if not(dissolveabs) then exprq else flatten(exprq2:makelist(block([zxq2],zxq2:absrule(zxq),if zxq2=false then return(zxq),assume(rhs(zxq)>=0),zxq2),zxq,exprq)))$

applysolvepoly(exprq):=block([exprq2],flatten(exprq2:makelist(block([zxq2],zxq2:solvepoly(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq)))$
applydoubleexp(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:DoubleExp(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applyfactor(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:factoreq(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applyexpandintsol(exprq):=block([exprq2],flatten(exprq2:makelist(ExpandIntegerSolution(zxq),zxq,exprq)))$
applylogcontract(exprq):=block([exprq2],exprq2:makelist(block([zxq2],zxq2:logcontract(lhs(zxq))=rhs(zxq),if zxq2=false then return(zxq),zxq2),zxq,exprq))$
applyconverttoreal(exprq):=block([exprq2],exprq2:makelist(block([zxq2],if zxq=all then return(all),zxq2:lhs(zxq)=ConvertToReal(rhs(zxq)),if zxq2=false then return(zxq),zxq2),zxq,exprq))$

applyabsruleonce(exprq,supq):=block([indq,delq,delq2,qfundet],
if length(exprq)=0 then return(exprq),
if op(exprq)=end then return(exprq),
qfundet:false,
indq:0,
exprq:do(
delq:part(exprq,indq),
if delq=end then return(exprq),
if delq=abs and containx(part(exprq,indq+1),solvar) then (qfundet:true,return(substpart(supq,exprq,indq))),
indq:indq+1
),
if qfundet then return(exprq),
indq:0,
do(
delq:part(exprq,indq),
if delq=end then return(exprq),
if not(atom(delq)) then (if not(freeof(abs,delq)) then (delq2:applyabsruleonce(delq,supq),if delq#delq2 then return(substpart(delq2,exprq,indq)))),
indq:indq+1
)
)$
dissolveabsonce(lignq):=block([lignq1],
if freeof(abs,lignq) then return(lignq),
lignq1:applyabsruleonce(lignq,"+"),
if is(lignq=lignq1) then return(lignq),
flatten([lignq1,applyabsruleonce(lignq,"-")])
)$

applyabsrule2(exprq):=block([exprq2,countq],if not(dissolveabs) then return(exprq),
startq,
countq:length(exprq),
exprq:flatten(makelist(dissolveabsonce(zxq),zxq,exprq)),
if countq#length(exprq) then go(startq),
exprq
)$

applymaximasolve(exprq):=block([exprq2,tqexpr],
flatten(
	exprq2:makelist(
		if CheckSolved(zxq) then 
			zxq 
		elseif not(containx(zxq,solvar)) and containanyx(zxq,solsysvars) then 
			zxq 
		elseif polynomialp(lhs(zxq)-rhs(zxq),[solvar],numberp,numberp) then /* Hvis polynomium er det bedre at sende videre til to_poly_solve numberp til coeff nok ikke helt hensigtsmaessigt*/
			zxq
		else 
			(tqexpr:solve(zxq,solvar),
				if tqexpr=[] then (solunsure:true,print("Solution unsure")),
			tqexpr
			),
		zxq,exprq))
)$

applynsolve(exprq):=block([exprq2],
if exprq=[all] or exprq=[] then return(exprq),
exprq2:flatten(makelist(if CheckSolved(zxq) then zxq else nsolve(zxq,solvar,9),zxq,exprq)),
makelist(if freeof("=",zxq) then solvar=zxq else zxq,zxq,exprq2)
)$

/* Solves an equation for a variable or expression. The variable to solve for will have any arrays attached removed*/
solvereal([paramq]):=block([solq,tempq,lignq,varq,condq,qassum,solu_1a,solu_2b,solsteps,iteind:0,factind:0,solunsure:false],if length(paramq)<2 then (print("Too few arguments"),return()) elseif length(paramq)>3 then (print("Too many arguments"),return()),
lignq:paramq[1],varq:paramq[2],
if length(paramq)=3 then condq:paramq[3] else condq=[],
if nonscalarp(lignq) and length(lignq)>1 and freeof(at,lignq) then (print("solving system of equations"),return(solvesystem(lignq,varq))),
if sepsolvecontext then (context:solreal,
activate(initial)),
if atom(varq) then (solvar:varq,remarray(''solvar)) else (solvar:solx,lignq:subst(solvar,varq,lignq)),
if lignq=all then return([all]),
if freeof(solvar,lignq) then (print(solvar," not present in equation"),if is(equal(lhs(lignq),rhs(lignq)))=true then return(all) elseif is(equal(lhs(lignq),rhs(lignq)))=false then return([]) else return(unknown)),
iteind:0,factind:0,solsteps:[],
/* solq:solverecursive(factoreq(lignq),varq,condq), kan forstyre med maerkelig faktorisering af noget der nemt kan loeses*/
solq:[lignq],
/* problematisk kan foere til ugyldige loesninger solq:DissolveRadicals(solq),*/
solq:DissolveAbs(solq),
if autonsolve and not(freeof("if",solq)) then (solu_1a:nsolve(lignq,varq),go(slutqw)), /* solver cant handle piecewiese defintions*/
solq:solverecursive(solq,varq,condq),
if solq=[0=0] then (solq:[all],go(finishlabel)),
solq: ev(solq,logcontract2),addsolstep(solq,"logcontract2"),
solq: unique(solq),
solq:applyexpandintsol(solq),addsolstep(solq,"unique og expand integer sol"),
solq:applymaximasolve(solq),addsolstep(solq,"MaximaSolver"),
solq: unique(solq), 
/*solq:RemoveIncorrect2(lignq,solq),  Fjerner ogsaa approximative loesninger... lav checksolutions */
solq:RemoveIncorrect(solq),addsolstep(solq,"RemoveIncorrect"), /* Fjerner loesninger i henhold til assume. RemoveIncorrect([y=-234/(%e^(-2.339999875980007*x-2.339999875980007*c)-8345)]); venter ... pga. factor laver meget lang faktorisering. Loest vha. numer i removeincorrect*/
solq:RemoveUndefined(lignq,solq),addsolstep(solq,"RemoveUndefined"),
solq:applyconverttoreal(solq),addsolstep(solq,"ConvertToReal"),
solq:simplifysol(solq),
solq:applyconverttoreal(solq), /* simplifysol can introduce %i*/
addsolstep(solq,"Simplify"),
if not(atom(varq)) then solq:subst(varq,solvar,solq),
addsolstep(solq,"subst tilbage"),
finishlabel,
if showassumptions then (
	if facts(solreal)#[] then( 
		qassum:delete([], makelist(if freeof(kind,zq) then zq else [],zq,facts(solreal))),		
solq:flatten(makelist(block([qi:1],do(if qi>length(qassum) then return([]),if is(ev(qassum[qi],numer,zq))=false then (print(sconcat("solution ",zq," removed due to assumption.")),zq:[],return([])),qi:qi+1),zq),zq,solq)),
if qassum#[] then print("Assumptions: ",qassum))
),
if sepsolvecontext then 
	errcatch(
		forget(facts(solreal)),
		deactivate(solreal),
		context:initial,
			if facts(solreal)#[] then killcontext(solreal)
			), 
solvesteps:append(solvesteps,[solsteps]),
if IsAnySolved(solq,varq) and not(solunsure) then return(solq),
solu_1a:solq,
if not(solverealmaximasolve) and not(solverealtopoly) and not(autonsolve) then return (solq),
if solu_1a=[] and not(solunsure) then return ([]),
if solu_1a#[] then(
	if IsAllSolved(solu_1a,varq) then go(slutqw),
	if nonscalarp(first(solu_1a)) then return(solu_1a)
	),
errcatch(if polynomialp(ev(lhs(lignq)-rhs(lignq),simp),[varq]) then solu_1a:flatten(algsys([lignq],[varq])) else go(nxqsol0)),
if domain=real then solu_1a:RemoveImag(solu_1a),
if IsAnySolved(solu_1a,varq) then go(slutqw) ,
nxqsol0 ,
if ContainsTrig(lignq) then go(nxqsol2),
if solverealtopoly then 
	(load(to_poly_solve),
	solu_1a:ev(errcatch(nicedummies(ev(to_poly_solve(lignq,varq),realonly:false)))[1]),
	if not(freeof(to_poly_solve,solu_1a)) then go(nxqsol1),
	solu_1a:flatten(errcatch(args(solu_1a))),
	if domain=real then solu_1a:RemoveImag(solu_1a),
	solu_1a:RemoveImag(solu_1a),
	solu_1a: CheckSolutions(lignq,varq,solu_1a),
	if IsAnySolved(solu_1a,varq) then go(slutqw)
	),
nxqsol1,
if solverealtopoly then (
	solu_1a:errcatch(nicedummies(ev(to_poly_solve(lignq,varq),numer,realonly:false,algexact:false)))[1],
	if not(freeof(to_poly_solve,solu_1a)) then go(nxqsol2),
	solu_1a:flatten(errcatch(args(solu_1a))),
	if domain=real then solu_1a:RemoveImag(solu_1a),
	solu_1a: CheckSolutions(lignq,varq,solu_1a), 
	if IsAnySolved(solu_1a,varq) then go(slutqw)
	),
nxqsol2,
if solverealmaximasolve then
	(
	errcatch(solu_1a:ev(solve(lignq,varq),simp)),
	if domain=real then solu_1a:RemoveImag(solu_1a),
	solu_1a: CheckSolutions(lignq,varq,solu_1a), 
	if IsAnySolved(solu_1a,varq) then go(slutqw),
	nxqsol3,
	solu_1a:ev(solve(lignq,varq),simp,numer,radexpand),
	if domain=real then solu_1a:RemoveImag(solu_1a),
	solu_1a: CheckSolutions(lignq,varq,solu_1a), 
	if IsAnySolved(solu_1a,varq) then go(slutqw),
	nxqsol4,
	solu_1a:ev(solve(lignq,varq),simp,radcan,numer),
	if domain=real then solu_1a:RemoveImag(solu_1a),
	solu_1a: CheckSolutions(lignq,varq,solu_1a)
),
if not(freeof(%if,solu_1a)) then solq:solu_1a else solq:RemoveIncorrect(solu_1a),
if autonsolve and not(IsAnySolved(solu_1a,varq)) then
	(
	solu_1a:nsolve(lignq,varq)
	),
slutqw,
solu_1a
)$

solverecursive(lignq,varq,condq):=block([solq],
	solq:flatten([lignq]),
	iteind:iteind+1,
	if iteind>35 then return(solq),
	addsolstep(solq,"Start"),
	solq:applyswaprule(solq),addsolstep(solq,"Byt side"),
	solq:applyrulelist(solq,divzerorule),addsolstep(solq,"divzerorule"),
	solq:applyzerorule(solq),addsolstep(solq,"Nulregel"),
	solq:applyaddrule(solq),addsolstep(solq,"addrule"),
	solq:applyrulelist(solq,prodrule4),addsolstep(solq,"prodrule4"),
	solq:applyaddrule2(solq),addsolstep(solq,"addrule2"),
	solq:applyprodrule(solq),addsolstep(solq,"prodrule"),
	solq:applyprodrule2(solq),addsolstep(solq,"prodrule2"),
	/* solq:applyprodrule3(solq),addsolstep(solq,"prodrule3"),  */ /* Overser loesning i fx solvereal(x^2*(x^2-1)=9*(x^2-1),x); fordi der divideres med udtryk hvor x indgaar. Forhaabentlig er den ikke noedvendig. Ellers skal den aendres*/
	solq:applydivrule(solq),addsolstep(solq,"divrule"),
	solq:applydivrule2(solq),addsolstep(solq,"divrule2"),
	solq:applydivrule3(solq),addsolstep(solq,"divrule3"),
	solq:applyrulelist(solq,divrule5),addsolstep(solq,"divrule5"),
	solq:applyrulelist(solq,expandrule),addsolstep(solq,"expandrule"),
	if solq#lignq then return(solverecursive(solq,varq,condq)),
	solq:applyrulelist(solq,absremoverule),addsolstep(solq,"absremoverule"),
	solq:applyabsrule(solq),addsolstep(solq,"lift abs(x)"),
	solq:applyrulelistZero(solq,lambertwillrule),addsolstep(solq,"lambertwillrule"),
	solq:applyrulelistZero(solq,lambertwrule2sol),addsolstep(solq,"lambertwrule2sol"),
	solq:applyrulelistZero(solq,lambertwrule1sol),addsolstep(solq,"lambertwrule1sol"),
	solq:applyrulelistZero(solq,lambertwrulegeneral),addsolstep(solq,"lambertwrulegeneral"),
	solq:applyrulelistZero(solq,lambertwrule2),addsolstep(solq,"lambertwrule2"),
	solq:applyrulelist(solq,powrulezero),addsolstep(solq,"powrulezero"),
	solq:applyrulelist(solq,powruleoddneg),addsolstep(solq,"powruleoddneg"),
	solq:applyrulelist(solq,powruleodd),addsolstep(solq,"powruleodd"),
	solq:applyrulelist(solq,powruleodd2),addsolstep(solq,"powruleodd"),
	solq:applyrulelist(solq,powruleevenneg),addsolstep(solq,"powruleevenneg"),
	solq:applyrulelist(solq,powruleeven),addsolstep(solq,"powruleeven"),
	solq:applyrulelist(solq,powruleirratneg),addsolstep(solq,"powruleirratneg"),
	solq:applyrulelist(solq,powruleirrat),addsolstep(solq,"powruleirrat"),
	solq:applypowrulenotnum(solq),addsolstep(solq,"powrulenotnum"),
	solq:applydoubleexp(solq),addsolstep(solq,"doubleexp"),
	solq:applyexprule(solq),addsolstep(solq,"exprule"),
	solq:applyrulelist(solq,expremoverule),addsolstep(solq,"expremoverule"),
	solq:applylnrule(solq),addsolstep(solq,"lnrule"),
	solq:applysinrule(solq),addsolstep(solq,"sinrule"),
	solq:applycosrule(solq),addsolstep(solq,"cosrule"),
	solq:applytanrule(solq),addsolstep(solq,"tanrule"),
	solq:applyasinrule(solq),addsolstep(solq,"asinrule"),
	solq:applyacosrule(solq),addsolstep(solq,"acosrule"),
	solq:applyatanrule(solq),addsolstep(solq,"atanrule"),
	if solq#lignq then return(solverecursive(solq,varq,condq)),
	solq:applysolvepoly(solq),addsolstep(solq,"solvepoly"),
	if solq#lignq then return(solverecursive(solq,varq,condq)),
	solq:simplifyhyp(solq),
	solq:applyrulelist(solq,sinhsolrule),addsolstep(solq,"sinhsolrule"),
	solq:applyrulelist(solq,coshillrule),addsolstep(solq,"coshillrule"),
	solq:applyrulelist(solq,coshsolrule),addsolstep(solq,"coshsolrule"),
	solq:applyrulelist(solq,tanhillrule),addsolstep(solq,"tanhillrule"),
	solq:applyrulelist(solq,tanhsolrule),addsolstep(solq,"tanhsolrule"),
	if solq#lignq and iteind<15 then return(solverecursive(solq,varq,condq)),
	if solq=lignq and factind>1 then return(solq),
	solq:applyabsrule2(solq),addsolstep(solq,"absrule2"),
	solq:applylogcontract(solq),addsolstep(solq,"logcontract"),
	solq:applyb1(solq,powrulexp),addsolstep(solq,"powrulexp"),
	if solq#lignq then return(solverecursive(solq,varq,condq)),
	if factind<3 then (factind:factind+1,solq:applyfactor(solq),addsolstep(solq,"factor")),
	if factind=3 then (factind:factind+1,solq:expand(solq),addsolstep(solq,"expand")),
	solq:solverecursive(solq,varq,condq),
	solq
)$

addsolstep(qsol,qkomm):=block([li],li:append(qsol,[qkomm]),if solsteps=[] then solsteps:[li] elseif rest(last(solsteps),-1)#qsol then solsteps:append(solsteps,[li]),return())$
/* mere simpel, men ikke god til debug
addsolstep(qsol):=block([],solsteps:unique(append(solsteps,qsol)))$
*/

/* Tries to isolate radicals one bye one and square them out, but can easily give infinite loop or very large expressions. Now limited, will only apply if one radical, since can easily grow.
Not mathematically sound. example: sqrt(x)=-1  ->(squaring) x=1 but is not a solution  
dissolveradicals:true;solvar:x;DissolveRadicals([x^2=2*sqrt(x)]);*/
DissolveRadicals(qexprl):=block([powno:0,solq,solq2:[],savevar,qind:0,qind2:0,noradicals:true],
if not(dissolveradicals) then return(qexprl),
savevar:solvar,
do(
qind2:qind2+1,
if qind2>length(qexprl) then return(),
qexpr:qexprl[qind2],
solq:apply1(qexpr,ReplaceFirstRadical),
if powno=1 then (
noradicals:false,
solq:ev(solvereal(solq,powx),dissolveradicals=false),
qind:0,
do(
qind:qind+1,
if qind>length(solq) then return(),
if CheckSolved(solq[qind]) then 
(
solq2:append(solq2,[radicalsubst[1]^num(ratsimp(radicalsubst[2]))=expand(rhs(solq[qind])^(denom(ratsimp(radicalsubst[2]))))])
)
else
(
solq2:append(solq2,[subst(radicalsubst[1]^radicalsubst[2],powx,solq[qind])]))))),
solvar:savevar,if noradicals then qexprl else solq2
)$

DissolveAbs(qexprl):=block([absno:0,solq,solq2:[],savevar,qind:0,qind2:0,noabs:true],
if not(dissolveabs) then return(qexprl),
if freeof(abs,qexprl) then 
return(qexprl),
do(
qind2:qind2+1,
if qind2>length(qexprl) then return(),
qexpr:qexprl[qind2],absno:0,
solq:apply1(qexpr,ReplaceFirstAbs),
if absno>0 then (
noabs:false,savevar:solvar,
solq:ev(solvereal(solq,absx),dissolveabs=false),solvar:savevar,
qind:0,
do(
qind:qind+1,
if qind>length(solq) then return(),
if CheckSolved(solq[qind]) then 
(
solq2:append(solq2,[subst(abs(abssubst),absx,solq[qind])])
)
else
(
solq2:append(solq2,[subst(abs(abssubst),absx,solq[qind])])
)))),
if noabs then return(qexprl) else solq2:applyabsrule(applyrulelist(solq2,absremoverule)),
if freeof(abs,solq2) then 
solq2 else DissolveAbs(solq2)
)$

/*Checks if the two arguments have opposite sign*/
opposite_sign(a, b) := block(
	[result],
	if numberp(a) and numberp(b) then (
		result: (a > 0 and b < 0) or (a < 0 and b > 0)
	) else (
		result: false
	),
	return(result)
)$

/* Newton's method for finding roots of a function, with damping technique, and asymptotic detection
Switches to secant method if expr isnt differentiable at guess.
If guess is a bfloat, the function will use bfloats otherwise float. Float is faster.
*/
newton_method(expr, var, guess, tol, max_iter) := block(
	[x0, x1, x2, fx, dfx, pfx, pfx2, iter, solq, lmbd, sec, UseBF, fpprec],
	if bfloatp(guess) then (
		UseBF: true,
		fpprec: 50,
		lmbd: 1b0,
		pfx: 1b30,
		define(f(var), ev(expr, bfloat)), 
		define(dfunc(var), ev(diff(expr,var), bfloat))
	) else (
		UseBF: false,
		lmbd: 1.0,
		pfx: 1.0*10^30,
		guess: ev(guess, numer),
		define(f(var), ev(expr, numer)), 
		define(dfunc(var), float(ev(diff(expr,var), numer)))
	),
	x0: guess,
	iter: 0,
	solq:[],
	sec: false,
	if errcatch(dfunc(guess)) = [] then (
/*		print("Newton's method requires a differentiable function. Switching to secant method"),*/
		sec: true
	),
	while iter < max_iter do (
		if errcatch(
		if UseBF=true then (
			fx: ev(f(x0),bfloat)
		) else (
			fx: ev(f(x0),numer)
		),
/*		print(sconcat("x0=", x0, " f(x0)=",fx)),*/
		if (abs(fx) <= tol) then (			
			if (abs(x1-x0)<=tol)  and imagpart(fx)=0 then (
			solq:[x0], 
/*		 	print(sconcat("Iteration ", iter, ": x0 = ", x0, ", x1 = ", x1, ", f(x0) = ", fx ,",f'(x0) = ",dfx, ", lmbd = ", lmbd)) ,*/ 
			return()
			),
			UseBF: true,x0:bfloat(x0),lmbd:bfloat(lmbd),fpprec:30,
			if max_iter<=100 then max_iter:200
		),
		if (sec=true) then
		(
			dfx: ev((fx-f(x0-1e-9))/(1e-9))
		)
		else (
			if UseBF=true then (
				dfx: ev(dfunc(x0),bfloat)
			) else (
				dfx: ev(dfunc(x0),numer)
			)
			),
		if abs(dfx) < tol then (
			print("Derivative too small"), /* Dette er tegn paa asymptotisk gang mod 0, som vil give falsk loesning hvis det fortsaetter*/
			return()
		),
		if abs(fx)>=abs(pfx) then (
			lmbd: lmbd / 2, /* damping. Kan hjaelpe med faa den til at konvergere*/		
			if lmbd < 0.25 then lmbd:0.25
		),
		if imagpart(fx)#0 and iter>2 then (
			x0:x1,
			if lmbd=1 then lmbd:0.5
		) else (
			x2: x1,
			x1: x0
		),
		if UseBF=true then (
			x0: ev(realpart(x0 - lmbd * fx / dfx),bloat)
		) else (
			x0: ev(realpart(x0 - lmbd * fx / dfx),numer)
		),
		pfx2: pfx,
		pfx: fx
		)=[] then (sec:true,x0=x0+1),
		iter: iter + 1
	),
	/*
	if iter >= max_iter then (
		print("Maximum iterations reached"), print("x0",x0,"fx",fx,"pfx",pfx,"iter",iter,"lmbd",lmbd)
		),*/
	/*print(sconcat("Newton iterations: ",iter," L=",lmbd,"  S=",solq)),*/
	if useBF=true then (
		solq: bfloat(solq)
	) else (
		solq: float(solq)
	),
	return(solq)
)$


/*
 * nsolve([paramq]) - A function to solve a given equation numerically.
 *
 * Parameters:
 *   paramq - A list of parameters:
 *     paramq[1] (qlign) - The equation to be solved.
 *     paramq[2] (qvar) - The variable in the equation.
 *     paramq[3] (qn) - The lower bound for the search interval (default: -15) meaning 10^-15. if this value i a bfloat, the function will use bfloats.
 *     paramq[4] (qm) - The upper bound for the search interval (default: 15). meaning 10^15.
 *     paramq[5] (qti) - maximum time (default: 15 s).
 *     paramq[6] (qantal) - Maximum number of solutions to find (default: 20).
 *     paramq[7] (qnn) - Extended lower bound for the search interval (default: 30). meaning 10^-30. This extra range is only searched for 1 solution
 *     paramq[8] (qmm) - Extended upper bound for the search interval (default: 30). meaning 10^30.
 *     paramq[9] (qnewt) - Boolean to determine if Newton's method should be used (default: true).
 *
 * Returns:
 *   A list of solutions to the equation.
 *
 * Notes:
 *   - It uses various methods to find the roots of the equation within the specified bounds.
 *   - uses nsolverealrecursive to search ranges: ... [0-0.01] [0-0.1] [0-1], [0-10], [0-100] ... depending on qn and qm. Each range is divided into 91 points. and searches for different signs between neighboring points.
 *   - If the number of solutions found is less than the specified maximum, it attempts to find more solutions using extended bounds and Newton's method.
 *   - The function ensures that the solutions are unique and correct.
 */
/* Solves an equation for a variable or expression. The variable to solve for will have any arrays attached removed*/
nsolve([paramq]) := block(
	[qfkt, solq, qn, qm, qti, qmaxti, qantal, qmm, qnn, qnewt, fpprec: 50, UseBF, qtol, NewSolq, NmaxIter],
	if length(paramq) < 2 then (
		print("Too few arguments"),
		return()
	) elseif length(paramq) > 9 then (
		print("Too many arguments"),
		return()
	),
	qlign: paramq[1],
	qvar: paramq[2],
	if length(paramq) >= 3 then qn: paramq[3] else qn: -15,
	if length(paramq) >= 4 then qm: paramq[4] else qm: 15,
	if length(paramq) >= 5 then qti: paramq[5] else qmaxti: 15,
	if length(paramq) >= 6 then qantal: paramq[6] else qantal: 20,
	if length(paramq) >= 7 then qnn: paramq[7] else qnn: 30,
	if length(paramq) >= 8 then qmm: paramq[8] else qmm: 30,
	if length(paramq) >= 9 then qnewt: paramq[9] else qnewt: true,
	qtol: 10^-15,
	if bfloatp(qn) then UseBF: true else UseBF: false,
	if UseBF=true then(
		qn: bfloat(qn),
		qm: bfloat(qm),
		qnn: bfloat(qnn),
		qmm: bfloat(qmm),
		qtol: bfloat(qtol)
	) else (
		qn: float(qn),
		qm: float(qm),
		qnn: float(qnn),
		qmm: float(qmm),
		qtol: float(qtol)
	), 
	errormsg: false,
	solq: [],
	if UseBF = true then (
		define(qfkt(qvar), ev(lhs(qlign) - rhs(qlign), bfloat))
	) else (
		define(qfkt(qvar), ev(lhs(qlign) - rhs(qlign), numer))
	),
	qti: absolute_real_time(),
	/* Alternative method: length(listofvars(qfkt(x))) */
	if not(constantp(ev(qfkt(1.234), numer))) then (
		print("nsolve requires an equation with only 1 variable"),
		return(qlign)
	),
	solq: nsolverec(qfkt(qvar), qvar, solq, qn, -6, 30),
	solq: nsolverec(qfkt(qvar), qvar, solq, qn, -2, 100),
	solq: nsolverec(qfkt(qvar), qvar, solq, -1, 3, 1000),
	solq: nsolverec(qfkt(qvar), qvar, solq, 4, 5, 100),
	solq: nsolverec(qfkt(qvar), qvar, solq, 6, qm, 30),
	errcatch(
		if opposite_sign(qfkt(-10^qn),qfkt(0)) then(
			if UseBF = true then (
				solq: append(solq, flatten([errcatch(bf_find_root(qfkt, qvar, -10^qn, 0))]))
			) else (
				solq: append(solq, flatten([errcatch(find_root(qfkt, qvar, -10^qn, 0))]))
			)
		)
	),
	errcatch(
		if opposite_sign(qfkt(0),qfkt(10^qm)) then
		(
			if UseBF = true then (
				solq: append(solq, flatten([errcatch(bf_find_root(qfkt, qvar, 0, 10^qm))]))
			) else (
				solq: append(solq, flatten([errcatch(find_root(qfkt, qvar, 0, 10^qm))]))
			)
		)
	),
	if qmm > qm then errcatch(
		if opposite_sign(qfkt(10^qm),qfkt(10^qmm)) then
		(
			if UseBF = true then (
				solq: append(solq, flatten([errcatch(bf_find_root(qfkt, qvar, 10^qm, 10^qmm))]))
			) else (
				solq: append(solq, flatten([errcatch(find_root(qfkt, qvar, 10^qm, 10^qmm))]))
			)
		)
	),
	if qnn > qn then errcatch(
		if opposite_sign(qfkt(-10^qnn),qfkt(-10^qn)) then
		(
			if UseBF = true then (
				solq: append(solq, flatten([errcatch(bf_find_root(qfkt, qvar, -10^qnn, -10^qn))]))
			) else (
				solq: append(solq, flatten([errcatch(find_root(qfkt, qvar, -10^qnn, -10^qn))]))
			)
		)
	),
	if qnewt then (
/*		load(mnewton),newtonepsilon: 1*10^-30,newtonmaxiter: 1000,
		qsol:flatten(bfloat(errcatch(mnewton(qfkt(qvar), qvar, 1)))), */
		/*Find roots of taylorapprox and use these as guess for newtons method*/
		ql: [],
		for i in [1,-1,10,-10,100,-100] do (
			ql: append(ql, errcatch(flatten(makelist(ev(realroots(ev(taylor(qfkt(qvar),qvar,i,20),numer),qtol),float))))),
			if length(ql) >= 10 then return()
		),
		ql:flatten(ql),
		ql: makelist(rhs(zq), zq, ql),
		ql: append(ql, makelist(10^i, i, -6, 6)),
		ql: append(ql, [-8,-6,-4,-2,2,3,4,5,6,7,8,9]),
		ql: unique(ql),
		NmaxIter:60,
		if UseBF then (
			ql:bfloat(ql)
		) else (
			ql:float(ql)
		),
		for zq in ql do (			
			qsol:flatten(errcatch(newton_method(qfkt(qvar), qvar, zq, qtol, NmaxIter))),
			if qsol # [] then (
				errcatch(qsol:qsol[1]),
				solq: append(solq, [qsol]))
			),
			if (absolute_real_time() - qti) > qmaxti then (
				print("Time out"),
				goto(afslut)
				)
	), 
	afslut,
	errormsg: true,
	print("More solutions may exist"), 
	/*If there is an error using find_root, it will append the function to solution. These must be removed*/
	solq: block([new_solq: []],
		for zq in solq do (
			if (op(zq) # 'bf_find_root) and (op(zq) # 'find_root)  then new_solq: cons(zq, new_solq)
		),
		solq: reverse(new_solq)
	),

/*remove duplicate values from solq, where values are within qtol*/
	NewSolq:[],
	for zq in solq do (
		if flatten(makelist(if abs(zq2-zq)<qtol*10 then 1 else [] , zq2, NewSolq))=[] then
			NewSolq:cons(zq,NewSolq)
	),
	solq:NewSolq,

	/* Loesningerne er approksimative. Her forsoeges at checke om paenere afrundede vaerdier er loesninger*/
	solq: block([new_solq: []],
		for zq in solq do (
			if numberp(zq) then (
				rounded_zq: round(zq),
				if member(rounded_zq, solq) then
					new_solq: cons(zq, new_solq)
				elseif errcatch(qfkt(rounded_zq)) = [0] then
					new_solq: cons(rounded_zq, new_solq)
				else
					new_solq: cons(zq, new_solq)
			) else
				new_solq: cons(zq, new_solq)
		),
		solq: reverse(new_solq)
	), 
	if DecOutType>0 then fpprintprec:NoSigFig,
	solq: unique(solq),
	solq: sort(solq),
	solq: makelist(qvar = zq, zq, solq),
	solq: TestSolution(solq)
/*	solq: RemoveIncorrect(makelist(qvar = zq, zq, solq)) */
)$

/* Removes solutions that does not comply with the rules in the current context. Ex: Assume(x>0);TestSolution([x=-3,x=3])    ->   [x=3]*/
TestSolution(solq):=block([zq,zq2,NewSolq:[]],
	Antag:facts(),
	forget(facts()),forget(all), /*Even when changing context, facts remain, though facts return []. Problem only in function but not always. Facts are reset at the end of the function*/
	context:TestSol,
	solq:reverse(solq),
	for zq in solq do (
		assume(equal(lhs(zq),rhs(zq))),
		if flatten(makelist(if is(zq2)=false then 1 else [] , zq2, Antag))=[] then
			NewSolq:cons(zq,NewSolq),
		forget(facts())
	),
	killcontext(TestSol),
	apply(assume,Antag),
	NewSolq
)$

/* find_root_safe uses find_root, but checks if the solution is a discontinuity by checking the function's behavior around the root. missing af bf version */
find_root_safe(qfkt, qvar, a, b) := block([sol, fa, fb, fap, fbp],
	sol: errcatch(find_root(qfkt, qvar, a, b)),
	if sol = [] then return([]),
	sol: sol[1],
	fap: errcatch(subst((sol - 10^-6),qvar,qfkt)),
	fbp: errcatch(subst(sol + 10^-6,qvar,qfkt)),
	fap2: errcatch(subst((sol - 10^-5),qvar,qfkt)),
	fbp2: errcatch(subst(sol + 10^-5,qvar,qfkt)),
	if ( fap = [] or fbp = []) then
		return([]),
	if (not(freeof(%i, fa)) or not(freeof(%i, fb)) or not(freeof(%i, fap)) or not(freeof(%i, fbp))) then
		return([]),
	if fap[1]*fbp[1]<-1000 and fap2[1]*fbp2[1]<-1000 and fap[1]*fbp[1]<fap2[1]*fbp2[1] then
		return([]),
	return([sol])
)$

/*
 * Function: nsolverec
 * -------------------
 * Recursively solves a given function for real roots within a specified range and precision.
 *
 * Parameters:
 *   qfkt  - The function to be solved. it must be the name of a function, not an expression.
 *   qvar  - The variable for which the function is solved.
 *   sollq - A list to store the solutions found.
 *   qn    - The current power level.
 *   qm    - The maximum power level
 *
 * Returns:
 *   A list of solutions found for the given function.
 *
 * Description:
 *   This function attempts to find real roots of the given function `qfkt` by iterating over a range of values
 *   It uses the `bf_find_root` function to find roots within specified intervals and appends the solutions to the `sollq` list.
 *   typically start with qn=1 and qm=15. Solverec then test 91 values between 0 and 1 and then between -1 and 0. Then continues with 91 values between 1 and 10 and -1 and -10. This is repeated until
 *   a specified number of solutions `qantal` is found, or a timeout occurs or the maximum power level `qm` is reached. If two different signs are found for neighboring values, the Maxima function `bf_find_root` is used to find the root.
 */
nsolverec(qfkt, qvar, sollq, qn, qm, qp) := block([ql, glf, qi, UseBF, qV1, qV2, zl],
	qi: 1,
	if bfloatp(qn) then (
			UseBF: true,
			ql: makelist(bfloat((1+i/qp*10)*10^qn), i, 0, qp*9b-1)
		) else (
			UseBF: false,
			ql: makelist(float((1+i/qp*10)*10^qn), i, 0, qp*9e-1)
		),
	glf: flatten(makelist(
		block([res],
			res: errcatch(qfkt(zl)),
			if res = [] then false else flatten(res)
		),zl, ql
	)), 
	while qi < length(glf) do (
		if glf[qi] = 0.0 or glf[qi] = 0.0b0 then (
			if opposite_sign(qfkt(ql[qi] - 10^(qn - 3)),qfkt(ql[qi] + 10^(qn - 3))) then
			(
				if UseBF = true then (
					sollq: append(sollq, flatten([errcatch(bf_find_root(qfkt, qvar, ql[qi], ql[qi + 1]))]))
				) else (
					sollq: append(sollq, flatten([errcatch(find_root_safe(qfkt, qvar, ql[qi], ql[qi + 1]))]))
				)
			)
		) elseif glf[qi + 1] = 0.0 or glf[qi + 1] = 0.0b0 then (
			nothing
		) elseif not(freeof(%i, glf[qi])) or not(freeof(%i, glf[qi+1])) then (
			nothing
		) elseif opposite_sign(glf[qi],glf[qi + 1]) then (
			if UseBF = true then (
				sollq: append(sollq, flatten([errcatch(bf_find_root(qfkt, qvar, ql[qi], ql[qi + 1]))]))
			) else (
				sollq: append(sollq, flatten([errcatch(find_root_safe(qfkt, qvar, ql[qi], ql[qi + 1]))]))
			)
		),
		qi: qi + 1
	),
	if (absolute_real_time() - qti) > qmaxti then (
		print("Time out"),
		return(sollq)
	),
	if length(sollq) >= qantal then (
		print(concat("Stopped searching because ", qantal, " solutions were found")),
		return(sollq)
	),
	qi: 1,
	glf: flatten(errcatch(qfkt(-ql))),

	while qi < length(glf) do (
		if glf[qi] = 0.0 or glf[qi] = 0.0b0 then (
			if opposite_sign(qfkt(-ql[qi] - 10^(qn - 3)),qfkt(-ql[qi] + 10^(qn - 3))) then
			(
				if UseBF = true then (
					sollq: append(sollq, flatten([errcatch(bf_find_root(qfkt, qvar, -ql[qi + 1], -ql[qi]))]))
				) else (
					sollq: append(sollq, flatten([errcatch(find_root_safe(qfkt, qvar, -ql[qi + 1], -ql[qi]))]))
				)
			)
		) elseif glf[qi + 1] = 0.0 or glf[qi + 1] = 0.0b0 then (
			nothing
		) elseif not(freeof(%i, glf[qi])) then (
			if freeof(%i, glf[qi+1]) then (
				nothing
			) else ( /* lige op til et sted hvor funktionen ikke er defineret, måske der kan gøres noget */
				nothing
			)
		) elseif opposite_sign(glf[qi],glf[qi + 1]) then (
			if UseBF = true then (
				sollq: append(sollq, flatten([errcatch(bf_find_root(qfkt, qvar, -ql[qi + 1], -ql[qi]))]))
			) else (
				sollq: append(sollq, flatten([errcatch(find_root_safe(qfkt, qvar, -ql[qi + 1], -ql[qi]))]))
			)
		),
		qi: qi + 1
	), 
	if (absolute_real_time() - qti) > qmaxti then (
		print("Time out"),
		return(sollq)
	),
	if length(sollq) >= qantal then (
		print(concat("Stopped searching because ", qantal, " solutions were found")),
		return(sollq)
	), 
	if qn > qm then return(sollq) else nsolverec(qfkt, qvar, sollq, qn + 1, qm, qp)
)$

RemoveIncorrectNum(sollistq):=block([indq,sollistq2,solq],
indq:0,sollistq2:[],
if length(sollistq)=0 then return(sollistq),
do(
indq:indq+1,
solq:sollistq[indq],
if ev(is(equal(solvar,solq)),numer)#false then sollistq2:append(sollistq2,[solq]),
if length(sollistq)=indq then return(sollistq2)
)
)$

/* converts expression to bigfloat safer than bfloat, convertbfloat(((1+1/10^12 )^(10^12 ))) */
convertbfloat(exprq)::=block([simp,qout],simp:false,qout:errcatch(bfloat(exprq)),if qout=[] then simp:true else return(qout[1]),ev(exprq,simp,bfloat))$

/* foerste element indsaettes i resterende. Foerste element flyttes til slut. Hvis foerste element er liste indsaettes de 1 efter 1 og for hvert element laves en liste*/
SplitSubst(eqnlqi):=block([indq,indq2,liq,eqnlqpart,eqnlq,eqnlq2],
eqnlq2:[],
eqnlq:eqnlqi[1],
if length(eqnlq)<2 then return([eqnlq]),
liq:first(eqnlq),
eqnlq:rest(eqnlq,1),
if nonscalarp(liq) then 
	(
	eqnlq2:append(eqnlq2,makelist(flatten([makelist(subst(liqp,zq),zq,eqnlq),liqp]),liqp,liq))
	)
else
	(
	eqnlq2:append(eqnlq2,makelist(subst(liq,zq),zq,eqnlq),[liq]),
	[eqnlq2]
	)
)$

/* loeser foerste ligning i en liste [x+y=1,x-y=2] -> [x=1-y,x-y=2] hvis to loesninger kommer liste i liste */
SolveFirst(eqnlq,varq):=block([eqnq,autonsolve:true],
    eqnq:first(eqnlq),
    elq:flatten(errcatch(Solve(eqnq,varq))),
    if elq=[] or elq=unknown then return(elq),
    if elq=[all] or elq=all then (
        if length(eqnlq)=1 then return([all]) else return(rest(eqnlq,1))
    ),
    if length(elq)>0 then (
        if CheckSolvedVar(elq[1],varq) then (
            if length(elq)=1 then elq:first(elq),
            append([elq],rest(eqnlq,1))
        ) else (false)
    )
)$

/*Used to sort solutions from solvesystem*/
SortSolutions(solq):=block([z],makelist(sort(z),z,solq))$

/* matrixeqtolist(matrix([x],[y])=matrix([1],[2]));    ->   [x=1,y=2]*/
matrixtolist(matq):=block([],
    if op(matq)#matrix then return(matq),
    flatten(args(matq))
)$

/* konverterer vektorligning til liste af ligninger*/
matrixeqtolist(mateq):=block(
    [lq, rq, indq, listeq],
    if op(lhs(mateq)) # matrix then return(mateq),
    listeq: [],
    lq: matrixtolist(lhs(mateq)),
    rq: matrixtolist(rhs(mateq)),
    for indq: 1 thru length(lq) step 1 do (
        listeq: append(listeq, [lq[indq] = rq[indq]])
    ),
    listeq
)$

/* konverterer kombination af ligninger og vektorligninger til liste af ligninger */
matrixeqtolistall(mateq):=block([],
if listp(mateq) then flatten(makelist(matrixeqtolist(zxq),zxq,mateq)) else matrixeqtolist(mateq)
)$

sortlistbysize(eqnlq,varlq):=block([eqnlq2,eqn,indq,indq2,noq,noq2],
eqnlq2:[first(eqnlq)],
eqnlq:rest(eqnlq,1),
noq:length(eqnlq),
for indq2:1 thru noq step 1 
do(
	eqn:first(eqnlq),
	eqnlq:rest(eqnlq,1),
	noq2:length(eqnlq2),
	for indq:1 thru noq2 step 1 
	do(
		if exprmetric(eqnlq2[indq],varlq)>=exprmetric(eqn,varlq) then (eqnlq2:append(rest(eqnlq2,-length(eqnlq2)+indq-1),[eqn],rest(eqnlq2,indq-1)),return()),
		if indq=noq2 then (eqnlq2:append(eqnlq2,[eqn]))
		)
	),
eqnlq2
)$

/*Maxima has a permut funktion, but it requires loading of a large lib.*/
permuts(lst) := block(
    [result],
    if length(lst) = 0 then return([[]]),
    result: [],
    for i: 1 thru length(lst) do (
        for p in permuts(delete(lst[i], lst)) do (
            result: cons(cons(lst[i], p), result)
        )
    ),
    result
)$

/* Kan give falske loesninger, specielt ved 3+ lignigner hvor der indgaar ^2 og kvadratrod, men det forsoeges undgaaet ved at sortere ligningslisten saa de korteste ligninger loeses foerst. Maaske noget med assume og removeincorrect kan forbedre*/
/* Kan give falske loesninger, specielt ved 3+ lignigner hvor der indgaar ^2 og kvadratrod, men det forsoeges undgaaet ved at sortere ligningslisten saa de korteste ligninger loeses foerst. Maaske noget med assume og removeincorrect kan forbedre*/
solvesystem(eqnlqsave, varlqsave) := block(
    [noq, varpermut, eqnpermut, eqnq, eqnqsav, eqnlqtemp, indq, indq2, sollq, varq, varlq, iteq, iteql, elq, eqnlq, resq, sprq, sprqgo, sollq2, ql, zq],
    eqnlqsave: matrixeqtolistall(eqnlqsave),
    sprqgo,
    if not(nonscalarp(varlqsave)) and (symbolp(varlqsave) or listp(varlqsave)) then varlqsave: unique(append([varlqsave], listofvars(eqnlqsave))),
    if not(nonscalarp(varlqsave)) then varlqsave: [],
    if length(varlqsave) < length(eqnlqsave) then varlqsave: unique(append(varlqsave, listofvars(eqnlqsave))),
    if length(varlqsave) > length(eqnlqsave) then (
        print("Too many variables."),
        sprq: read(sconcat("Which of the ", length(eqnlqsave), " variables to solve for? ", varlqsave, " (state as list eq. [x,y] or end to choose automatically)")),
        if sprq = end then 
            varlqsave: rest(varlqsave, length(eqnlqsave) - length(varlqsave)) 
        elseif not(nonscalarp(sprq)) then 
            go(sprqgo) 
        elseif length(sprq) # length(eqnlqsave) then 
            go(sprqgo) 
        else 
            varlqsave: sprq
    ),
    if length(varlqsave) < length(eqnlqsave) then (
        print("Warning: More equations than variables."),
        while length(varlqsave) < length(eqnlqsave) do (
            varlqsave: append(varlqsave, [first(varlqsave)])
        )
/*        eqnlqsave: rest(eqnlqsave, +length(varlqsave) - length(eqnlqsave))*/
    ), 
    if length(varlqsave) # length(eqnlqsave) then (
        print("Must be the same number of equations as variables"),
        return()
    ),
    sollq: errcatch(solve(eqnlqsave, varlqsave)),
    if sollq # [] then (
        sollq: delete([], makelist(GetReal(z), z, sollq[1])),
        if sollq # [] and %rnum_list = [] then return(sollq)
    ),
    eqnlqsave: sortlistbysize(eqnlqsave, varlqsave),
    varpermut: reverse(permuts(varlqsave)),
    eqnpermut: reverse(permuts(eqnlqsave)),
    eqnlqsave: eqnpermut[1],
    varlqsave: varpermut[1],
    noq: factorial(length(varlqsave)),
    iteq: 1, /*Bruges til at taelle ned hvor mange gange der er forsoegt med forskellige variabelraekkefoelge*/
    iteql: 1, /*Bruges til at taelle hvor mange gange der er forsoegt med forskellig ligningsraekkefoelge.*/
    eqnlq: [eqnlqsave],
    sollq: [],
    eqnlqtemp: [],
    startq,
    varlq: varlqsave,
    eqnq: first(eqnlq),
    eqnlq: rest(eqnlq, 1),
    eqnqsav: eqnq,
    startsolq, /* Her sendes tilbage naar den foerste variabel er elimineret/loest */
    indq: 1,
    /* loes foerste ligning og indsaet i andre, flyt til slutningen. Hvis loesning fejler saa forsoeges med naeste variabel indtil ikke flere*/
    resq: do (
        varq: first(varlq), /* Foerste variabel udvaelges og placeres derefter i slutningen af listen*/
        varlq: rest(varlq, 1),
        varlq: append(varlq, [varq]),
        elq: ev(SolveFirst(eqnq, varq), solsysvars = varlqsave), /* Den foerste ligning i listen loeses og placeres paa samme sted i listen */
        if elq = [] then (
            varlq: [x],
            eqnq: [],        
            return(true)
        ) elseif elq # false and elq # unknown then ( /*Hvis foerste ligning blev loest*/
            /*Den foerste ligning indsaettes i de andre og placeres sidst. Hvis der var flere loesninger indsaettes disse ogsaa i alle ligninger som gemmes i eqnlqtemp*/
            elq: SplitSubst([elq]),
            eqnq: first(elq),
            if length(elq) > 1 then 
                (eqnlqtemp: append(eqnlqtemp, rest(elq, 1))),
            return(true)
        ),
        indq: indq + 1,
        if indq > length(varlq) then /*Alle variable forsoegt uden held*/
            (if iteql >= noq then return(false) else return(retry))
    ),
    tryagainlabel,
    if resq = false then (
        /*Hvis foerste ligning ikke kunne loeses for nogen af variablene og alle de andre ligninger allerede er forsoegt*/
        /*print("Can't solve. Trying to_poly_solve"),
        eqnlq: to_poly_solve(eqnlqsave, varlqsave),
        eqnlq: scanmap(RemoveUnion, eqnlq),*/
        return(eqnlq)
    ) elseif resq = retry then (
        /*Hvis foerste ligning ikke kunne loeses for nogen af variablene, saa proeves med en anden raekkefoelge af variable, og derefter ligninger  */
        iteq: iteq + 1,
        if (iteq >= noq and iteql < noq) then (
            iteq: 1,
            iteql: iteql + 1,
            /* eqnqsav:append(rest(eqnqsav,1),[first(eqnqsav)]) */
            eqnqsav: eqnpermut[iteql]
        ),
        eqnq: eqnqsav,
        /* varlqsave:append(rest(varlqsave,1),[first(varlqsave)]), */
        varlq: varpermut[iteq],
        eqnlqtemp: [],
        go(startsolq)
    ),
    /*Hvis foerste ligning blev loest saa fortsaettes her*/
    varlq: rest(varlq, -1), /*Den variabel der blev loest for fjernes fra listen*/
    if length(varlq) >= 1 then go(startsolq), /* Hvis de er flere variable der skal isoleres saa start forfra*/
    if not(IsSystemSolved(sollq, varlqsave)) and iteq < noq and iteql < noq then (resq: retry, go(tryagainlabel)),
    /*Her nulstilles og goeres klar til at loese evt gemte extra loesninger*/
    iteq: 1,
    iteql: 1,
    eqnlq: append(eqnlq, eqnlqtemp),
    eqnlqtemp: [],
    if eqnq # [] then sollq: append(sollq, [eqnq]),
    varlq: varlqsave,
    if length(eqnlq) > 0 then (
        eqnq: first(eqnlq),
        go(startq)
    ),
    SortSolutions(sollq),
    /*forsøg med mnewton, men kun for 2 ligninger. Desværre virker det ikke på Mac. Maxima 5.47. Der kommer en FLONUM-EPSILON is unbound error i linearalgebra/mring.lisp*/
/*    if length(varlqsave)=2 then (
        errcatch[load(mnewton)],
        ql: [[0,0],[1,1],[10,10],[100,100],[-1,-1],[-10,-10],[-100,-100],[-10,10],[10,-10]],
		for zq in ql do (			
            sollq2: errcatch(ev(mnewton(eqnlqsave, varlqsave,zq),numer)),
            if sollq2 # [] and not(member(sollq2[1],sollq)) then (
                sollq:append(sollq,[sollq2[1]])
            ),
        ),
        NewSolq:[],qtol:10^-15,
        for zq in sollq do (
            if flatten(makelist(if (abs(rhs(zq2[1])-rhs(zq[1]))<qtol*10 and abs(rhs(zq2[2])-rhs(zq[2]))<qtol*10) then 1 else [] , zq2, NewSolq))=[] then
                NewSolq:cons(zq,NewSolq)
        ),
        sollq:NewSolq
    ),*/

    /*remove solutions that are false. Typisk ved overbestemte ligningssystemer*/
    
    sollq2:[],
    for zq in sollq do (
        zq:makelist(if is(equal(lhs(zq2),rhs(zq2)))#false then zq2 else false,zq2,zq),
        if freeof(false,zq) then sollq2:append(sollq2,[zq])
    ),
    sollq:sollq2,

    SortSolutions(sollq)
)$

/*solvesystemByEliminate(eqnlq,varlq):=block([varlq1,elq,sollq,indq,varq],
sollq:[],
for indq:1 thru length(eqnlq) step 1 do(
varq:first(varlq),
varlq:rest(varlq,1),
elq:eliminate(eqnlq,varlq),
if is(elq#[1]) then sollq:append(sollq,solvereal(elq,varq)) else sollq:append(sollq,rest(eqnlq,1)),
varlq:append(varlq,[varq])
),
sollq
)$*/

solvesystemScalar(eqnlq,varlq):=block([varlq1,elq,sollq,indq,varq],sollq:[],
startq,
for indq:1 thru length(varlq) step 1 do( 
	varq:first(varlq),
	varlq:rest(varlq,1),
	varlq:append(varlq,[varq]),
	eqnq:first(eqnlq),
	eqnlq:rest(eqnlq,1),
	eqnlq:append(eqnlq,[eqnq]),
	elq:Solve(eqnq,varq),
	if length(elq)>0 then(
		if CheckSolvedVar(elq[1],varq) then (sollq:append(sollq,elq),return())
		)
	),
varlq:rest(varlq,-1),eqnlq:rest(eqnlq,-1),eqnlq:makelist(subst(elq,zq),zq,eqnlq),
if length(eqnlq)>=1 then go(startq),
sollq:append(makelist(subst(last(sollq),zq),zq,rest(sollq,-1)),[last(sollq)]),
sollq
)$

/* alias(CSolve,solvereal)$ */
Solve(eqnlq,varlq):=block([qsolu],
if domain=real then return(solvereal(eqnlq,varlq)),
qsolu:solve(eqnlq,varlq),
if IsAnySolved(qsolu,varlq) then go(slutqw),
if solverealtopoly then 
	(
	load(to_poly_solve),
	qsolu:ev(errcatch(nicedummies(ev(to_poly_solve(eqnlq,varlq),realonly:false)))[1]),
	qsolu:flatten(errcatch(args(qsolu)))
	),
slutqw,
qsolu	
)$

RemoveImag(lignliste):=block([iqw,outlistq],
if lignliste=all then return(all),
if lignliste=[] then return([]),
lignliste:ev(lignliste,%z0:0,%z1:0),
outlistq:[],iqw:1,
startq,
outlistq:append(outlistq,[GetReal(lignliste[iqw])]),
iqw:iqw+1,
if iqw<=length(lignliste) then go(startq),
outlistq:flatten(outlistq),
outlistq
)$

ContainsTrig(udt):=block([],not(freeof(sin,cos,tan,acos,asin,atan,udt)))$

IsSolved(lign,varqw):=block([],
if listofvars(lhs(lign))=[] then return(false),
if funp(%if,lign) then return(true),
not(member(varqw,listofvars(rhs(lign)))) and varqw=lhs(lign)
)$

IsAnySolved(lignliste,varqw):=block([i],i:1,if lignliste=[] then return(lignliste),start,if IsSolved(lignliste[i],varqw) then return(true),i:i+1,if i<=length(lignliste) then go(start),false)$

IsAllSolved(lignliste,varqw):=block([i],i:1,
if lignliste=[all] then return(true),
if lignliste=[] then return(lignliste),
start,
if not(IsSolved(lignliste[i],varqw)) then return(false),
i:i+1,
if i<=length(lignliste) then go(start),
true)$

/*IsAllSolved(lignliste,varqw):=block([i],i:1,if lignliste=[] then return(lignliste),start,if not(IsSolved(lignliste[i],varqw)) then return(false),i:i+1,if i<=length(lignliste) then go(start),true)$ */

CheckSolutions(udtind,var,soluts):=block([udt,qweks,boutq,pqz],
udt:lhs(udtind)-rhs(udtind),
sublist(soluts,lambda([z],
	if not(freeof(%if,z)) then 
		z:args(z)[2][1],
	if not(numberp(ev(rhs(z),numer))) then 
		true 
	else 
		(errcatch(qweks:ceiling(log(ev(abs(ev(lhs(udtind),z,numer)),numer))/log(10))),
		if not(integerp(qweks)) then 
			qweks=1, 
		if NoSigFig>5 then 
			qweks:qweks+NoSigFig-5,
		if qweks<0 then 
			qweks:0 ,
		pqz:is(ev(abs(ev(udt,z,numer)),numer)<10^(-NoSigFig+qweks+1)),
                if not(pqz) then print(sconcat("Possible solution removed: ",z )),
                pqz
                 ) 
		)
	) 
)$
/* Checks solutions. targetted at removing imag formentlig �ldre version med fppprintrec istedet for NoSigFIg
CheckSolutions(udtind,var,soluts):=block([udt,qweks,boutq],udt:lhs(udtind)-rhs(udtind),sublist(soluts,lambda([z],if not(freeof(%if,z)) then z:args(z)[2][1],if not(numberp(ev(rhs(z),numer))) then true else (errcatch(qweks:ceiling(log(ev(abs(ev(lhs(udtind),z,numer)),numer))/log(10))),if not(integerp(qweks)) then qweks=1, if fpprintprec>7 then qweks:qweks+fpprintprec-7,if qweks<0 then qweks:0 ,is(ev(abs(ev(udt,z,numer)),numer)<10^(-fpprintprec+qweks+3))) )))$
*/

/* Checks if a system of equations has been completely solved for specified variables: IsSystemSolved([[x = -1/sqrt(5)*a,y = -2/sqrt(5)],[x = 1/sqrt(5),y = 2/sqrt(5)]],[x,y]);*/
IsSystemSolved(eqnlist,varlist):=block([rhsvars,listconstvars:false],
rhsvars:listofvars(makelist(rhs(z),z,flatten(eqnlist))),
apply(freeof,flatten([varlist,rhsvars]))
)$


GetReal(lign):=block([inlign,kond],if not(freeof(%if,lign)) then (inlign:args(lign)[2][1],kond:args(lign)[1]) else inlign:lign,if not(freeof(%i,carg,parg,kond)) then kond:[],if numberp(ev(float(ev(imagpart(rhs(inlign)),simp)),simp)) then  (if (is(abs(ev(imagpart(ev(float(ev(rhs(inlign),simp)),simp,numer)),simp))<10^(-NoSigFig))) then (if freeof(%i,inlign) then go(slutqw) else (inlign:ev(inlign,numer),go(slutqw))) else (return([]))), if freeof(%i,ev(inlign,%z0:0,%z1:0)) then go(slutqw),inlign:trigsimp(rectform(inlign)),slutqw,if not(freeof(%if,lign)) and kond#[] then inlign:(%if(kond,[inlign],args(lign)[3])),if freeof(%i,inlign) then return(inlign) else return([]) )$

SolveIneq(lignq,varq):=block([soluqw],
soluqw:[],
load(solve_rat_ineq),
errcatch(soluqw:solve_rat_ineq(lignq),soluqw),
if soluqw#[] then return(soluqw),
load(fourier_elim),
errcatch(soluqw:fourier_elim([lignq],[varq])),
if soluqw#[] then return([soluqw]),
/* soluqw:to_poly_solve(lignq,varq),
if soluqw#[] then return(args(soluqw)),*/
print("kunne ikke loeses")
)$

desolvereal([paramq]):=block([qdvar,qivar,qic1x,qic1y,qic2x,qic2y,qdic,solq,logabs:true,keepfloat:true,numer:false],
startq,
if length(paramq)<3 then (print("Too few arguments"),return()),
diffeqnq:paramq[1],qdvar:paramq[3],qivar:paramq[2],
solq2:ev(delogisticrule(expand(lhs(diffeqnq)-rhs(diffeqnq))=0),solvar=lhs(qdvar),solvar2=lhs(qivar)),
if solq2#false then (solq:solq2, if length(paramq)=3 and not(freeof("=",qivar) or freeof("=",qdvar)) 
then solq:makelist(if (freeof(%c,z) and numberp(rhs(z))) then (if is(ev(equal(lhs(z),rhs(z)),qivar,qdvar))#false then z else []) else z ,z,solq)) else 
(solq:[ode2(diffeqnq,lhs(qdvar),lhs(qivar))]
),
if length(paramq)=3 and not(freeof("=",qivar) or freeof("=",qdvar)) then solq:makelist(if freeof(%c,z) then (if is(ev(equal(lhs(z),rhs(z))))#false then z else []) else ic1real(z,qivar,qdvar),z,solq),
solq:flatten(solq),
if not freeof(at,solq) then (if logabs=true then (logabs:false,go(startq)) else (solq:solq2,go(nextq))),
solq:flatten(makelist(solvereal(solqe,lhs(qdvar)),solqe,solq)),
nextq,
if not(ev(CheckAllSolved(solq),solvar=lhs(qdvar))) then 
(
load(contrib_ode),solq:contrib_ode(diffeqnq,lhs(qdvar),lhs(qivar))),
if length(paramq)=3 and not(freeof("=",qivar) or freeof("=",qdvar)) then 
  solq:makelist(
    if freeof(%c,z) then z else (ic1real(z,qivar,qdvar)),z,solq), 
if length(paramq)=3 and (freeof("=",qivar) or freeof("=",qdvar)) then return(solq),
solq:delete([],solq),
solq:unique(solq),
if length(paramq)<4 then return(solq),
if length(paramq)=4 and not(freeof(%k1,solq)) then solq:makelist(ic2(z,qivar,qdvar,paramq[4]),z,solq),
if length(paramq)=5 and not(freeof(%k1,solq)) then solq:makelist(bc2(z,qivar,qdvar,paramq[4],paramq[5]),z,solq),
solq
)$

/* Tager generel loesning til differentialligning og begyndelsesbetingelser og returnerer partikulaer loesning. Erstatter ic1 som kunne returnere komplekse loesninger. Har givet problemer i forhold til r�kkef�lgen af hvorn�r c isoloeres, nu g�res begge dele og c der findes b�de f�r og efter bruges ligesom c behandles separat for hver y-l�sning, se beskrivelse i onenote*/
ic1real(solq,qivar,qdvar):=block([z,z2,indq,indq2,solq3,solq2,solc],if domain=complex then return(ic1(solq,qivar,qdvar)),
solc:solvereal(at(solq,[qivar,qdvar]),%c),
solq:flatten(makelist(solvereal(z,lhs(qdvar)),z,[solq])),
solq3:[],
for indq:1 thru length(solq) step 1
    do(
        solq2:at(solq[indq],[qivar,qdvar]),
        solq2:solvereal(solq2,%c),
        solq2:flatten(makelist( SolExists(solc,z) ,z,solq2)),
        for indq2:1 thru length(solq2) step 1
        do(
            if solq2[indq2]#[] then solq3:append(solq3,[at(solq[indq],solq2[indq2])])
        )
    ),
    solq3
)$

/* SolExists([x=1,x=2],x=5); tester om l�sning er i listen og returnerer korteste udtryk hvis den er, ellers [] */
SolExists(SolList,Sol):=block([indq,retval],retval:[],
    for indq:1 thru length(SolList) step 1
    do(
        if TestTF(rhs(SolList[indq])=rhs(Sol))#false then (if exprsize(rhs(Sol))<exprsize(rhs(SolList[indq])) then retval:Sol else retval:SolList[indq],return())
    ), 
retval
);

/* Tester om udsagnet er sandt, falsk eller ukendt baade analytisk og numerisk. Aendret 1.22 saa der fortsaettes hvis ikke true istedet for unknown. 1.31 tilføjet numerisk ca. check*/
TestTF(qexpr):=block([qres,qvar,qweks,qsave],qsave:qexpr,
if not(freeof("=",qexpr)) then qexpr:equal(lhs(qexpr)-rhs(qexpr),0),
qres:is(qexpr),if qres=true then return(qres),qres:is(trigreduce(qexpr)),
if qres=true then return(qres),
    qres:is(radcan(qexpr)),
    if qres=true then return(qres),
    if qres=true then (print("Numerically tested"), return(qres)),
            (errcatch(qweks:ceiling(log(ev(abs(ev(lhs(qsave),numer)),numer))/log(10))),
        if not(integerp(qweks)) then 
            qweks=1, 
        if NoSigFig>5 then 
            qweks:qweks+NoSigFig-5,
        if qweks<0 then 
            qweks:0 ,
        qres:is(ev(abs(ev(lhs(qexpr)-rhs(qexpr),numer)),numer)<10^(-NoSigFig+qweks+1)),
                if not(qres) then print(sconcat("Possible solution removed: ",qsave))),
    if qres=true then return(qres),
     (qvar:listofvars(qexpr),if length(qvar)>0 then qvar:first(qvar) else return(qres),qres:zeroequiv(lhs(qexpr)-rhs(qexpr),qvar)),
qres)$

/* Til haandtering af dobbeltbetydning af determinant  det(matrix) eller det(vektor,vektor) */
determinant2([paramq]):=block([],
if length(paramq)<1 then (print("Too few arguments"),return()) elseif length(paramq)>2 then (print("Too many arguments"),return()),
if length(paramq)=1 then return (determinant(paramq[1])),
determinant(addcol(paramq[1],paramq[2]))
)$

/* nsolve2 er maerkeligt nok langsommere i de fleste tilfaelde men ikke ved sqrt(x)=x 
nsolve2(qlign,qvar):=block([qfkt,solq,qn,qm,ql,glf,qi,qa,qb,qno],solq:[],qn:-15,qm:15,qno:1000,
define(qfkt(qvar),lhs(qlign)-rhs(qlign)),
qa:ev((10^qm/10^qn)^(1/qno),numer),qb:ev(10^qn,numer),
qi:1,
ql:makelist(i,i,0,qno),
qln:-reverse(ql),
ql:append(qln,ql),
qlf:qfkt(ql),
do(
if qlf[qi]*qlf[qi+1]<=0 then solq:append(solq,flatten([errcatch(find_root(qfkt(qvar),qvar,ql[qi],ql[qi+1]))])),
qi:qi+1,
if qi>2*qno then return()
),
print("More solutions may exist"),
unique(solq)
)$ */


/* rref row reduced echelon form */
request_rational_matrix(m, pos, fn) :=
  if every('identity, map(lambda([s], every('ratnump,s)), args(m))) then true else
    print("Some entries in the matrix are not rational numbers. The result might be wrong.")$

rowswap(m,i,j) := block([n, p, r],
  require_matrix(m, "first", "rowswap"),
  require_integer(i, "second", "rowswap"),
  require_integer(j, "third", "rowswap"),
  n : length(m),
  if (i < 1) or (i > n) or (j < 1) or (j > n) 
     then error("Array index out of bounds"),
  p : copymatrix(m),
  r : p[i],
  p[i] : p[j],
  p[j] : r,
  p)$

addrow(m,i,j,k) := block([n,p],
  require_matrix(m, "first", "addrow"),
  require_integer(i, "second", "addrow"),
  require_integer(j, "third", "addrow"),
  require_rational(k, "fourth", "addrow"),
  n : length(m),
  if (i < 1) or (i > n) or (j < 1) or (j > n) 
      then error("Array index out of bounds"),
  p : copymatrix(m),
  p [i] : p[i] + k * p[j],
  p)$

rowmul(m,i,k) := block([n,p],
  require_matrix(m, "first", "addrow"),
  require_integer(i, "second", "addrow"),
  require_rational(k, "fourth", "addrow"),
  n : length(m),
  if (i < 1) or (i > n) then error("Array index out of bounds"),
  p : copymatrix(m),
  p [i] : k * p[i],
  p)$


rref(m):= block([p,nr,nc,i,j,k,pivot,pivot_row,debug],
  debug : 0,
  request_rational_matrix(m," ","rref"),
  nc: length(first(m)),
  nr: length(m),
  if nc = 0 or nr = 0 then
    error ("The argument to 'rref' must be a matrix with one or more rows and columns"),

  p:copymatrix(m),
  ci : 1, cj : 1,
  while (ci<=nr) and (cj<=nc) do 
  (
    if (debug = 1) then (
	    disp(p),                
	    print("curseur en ligne ",ci," et colonne ",cj)),   
    pivot_row : 0, pivot : 0,
    for k : ci thru nr do (
       if ( abs(p[k,cj]) > pivot ) then (
         pivot_row : k,
         pivot : abs(p[k,cj]))),
         if (debug = 1) then 
	   print("colonne ",cj," : pivot trouve ligne ", pivot_row,", valeur : ",pivot),  
    if (pivot = 0) then (cj : cj +1)
    else (
      p : rowswap(p,ci,pivot_row),
	if (debug = 1) then      print (".. Echange : ",p),  
      p : rowmul(p,ci,1/p[ci,cj]),        
	if (debug = 1) then     print (".. Normalisation : ",p),   
      for k : 1 thru nr do (
         if not (k=ci) then (p : addrow (p,k,ci,-p[k,cj]))),
      ci : ci+1, cj : cj+1)),
  p
)$

/* Bruges i slutningen af Auto til at teste om det numeriske resultat er eksakt. De to foerste parametre er det eksakte udtryk. Det sidste det numeriske
 Der er to fordi det andet er koert igennem dectalall mm. Der kan komme unknown med det foerste udtryk. Derfor det andet.  */
IsResultExact(qi1,qi2,qn):=block([qr1,qr2],
qi2:ev(scanmap(strtonum,qi2),nouns),
qn:ev(scanmap(strtonum,qn),nouns),
qr1:ev(is(equal(qi1,qn)),numer),
qr2:ev(is(equal(qi2,qn)),numer),
print(qr2),
if qr1=true then true
elseif qr2=true and qr1#false then true
else false
)$

/* Grad og div*/
prefix("gradq")$
gradq(parq)::=block([qargs,funn,varq,varq2],qargs:args(parq), funn:op(parq),
    if length(qargs)>2 then (
        if numberp(qargs[1]) then (
            matrix([subst(qargs[1],varq,diff(funn(varq,qargs[2],qargs[3]),varq,1))],[subst(qargs[2],varq2,diff(funn(qargs[1],varq2,qargs[3]),varq2,1))],[subst(qargs[3],varq2,diff(funn(qargs[1],qargs[2],varq2),varq2,1))])) else ev(matrix([diff(parq,'x,1)],[diff(parq,'y,1)],[diff(parq,'z,1)]))
    )
    else (
        if numberp(qargs[1]) then (matrix([subst(qargs[1],varq,diff(funn(varq,qargs[2]),varq,1))],[subst(qargs[2],varq2,diff(funn(qargs[1],varq2),varq2,1))])) else ev(matrix([diff(parq,'x,1)],[diff(parq,'y,1)]))))$
prefix("divq")$
divq(parq):=block(if length(parq)<2 then diff(parq,'x,1) elseif length(parq)<3 then diff(parq[1,1],'x,1)+diff(parq[2,1],'y,1) elseif length(parq)<4 then diff(parq[1,1],'x,1)+diff(parq[2,1],'y,1)+diff(parq[3,1],'z,1) else 'divq(parq))$
prefix("laplaceq")$
laplaceq(parq):=block(if member('z,listofvars(parq)) then matrix([diff(parq,'x,2)],[diff(parq,'y,2)],[diff(parq,'z,2)]) else matrix([diff(parq,'x,2)],[diff(parq,'y,2)]))$
prefix("curlq")$
curlq(parq):=block(matrix([diff(parq[3,1],'y,1)-diff(parq[2,1],'z,1)],[diff(parq[1,1],'z,1)-diff(parq[3,1],'x,1)],[diff(parq[2,1],'x,1)-diff(parq[1,1],'y,1)]))$

/*This function completes the square of an expression. Examples:
CompleteSquare(x^2+4*x+y^2+(-6)*y = 12,[x,y])
    (y-3)^2+(x+2)^2-25 = 0                   If the expression is an equation, the function will complete the square for the left hand side of the equation - the right hand side, and return an equation =0
CompleteSquare(x^2+4*x+y^2+(-6)*y+78)        If you dont specify the variables, the function will attempt to complete the square for all variables in the expression.
    (y-3)^2+(x+2)^2+65
*/
CompleteSquare([paramq]) := block(
	[completed_expr, expr, var, a, b, c, square_term, constant_term],
	expr: paramq[1],
	completed_expr: expr,
	if length(paramq) >= 2 then vars: paramq[2] else vars: listofvars(completed_expr),
	if op(expr) = "=" then completed_expr: lhs(expr) - rhs(expr),
	for var in vars do (
		if not freeof(var, completed_expr) then (
			errcatch(
			a: coeff(completed_expr, var, 2),
			b: coeff(completed_expr, var, 1),
			c: coeff(completed_expr, var, 0),
			if a#0 then (
			square_term: a * (var + b/(2*a))^2,
			constant_term: c - b^2/(4*a),
			completed_expr: subst(square_term + constant_term, a*var^2 + b*var + c, completed_expr)
			)
			)
		)
	),
	if op(expr) = "=" then completed_expr: completed_expr = 0,
	completed_expr
)$