This is maxima.info, produced by makeinfo version 4.13 from
/home/vttoth/dev/maxima/doc/info/pt//include-maxima.texi.

Este é o Manual do Maxima no formato Texinfo

Copyright 1994, 2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     Um sistema de álgebra computacional.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Depuração do Código Fonte,  Next: Comandos Palavra Chave,  Up: Depuração

41.1 Depuração do Código Fonte
==============================

Maxima tem um depurador interno de código fonte.  O utilizador pode
escolher um ponto de parada numa função, e executar o programa linha
por linha a partir daí. A pilha de chamadas pode ser examinada,
juntamente com as variáveis existentes nesse nível.

O comando `:help' ou `:h' mostra a lista de comandos de depuração.  (Em
geral, os comandos podem ser abreviados se a abreviação for única. Se
não for única, as alternativas podem ser listadas.)  Dentro do
depurador, o utilizador pode também usar quaisquer funções comuns do
Maxima para examinar, definir, e manipular variáveis e expressões.

Um ponto de parada é escolhido através do comando `:br' na linha de
comando do Maxima. Dentro do depurador, o utilizador pode avançar uma
linha de cada vez usando o comando `:n' ("next").  o comando `:bt'
("backtrace") mostra uma lista da pilha de frames.  O comando `:r'
("resume") sai do depurador e continua com a execução.  Esses comandos
são demostrados no exemplo a seguir.

     (%i1) load ("/tmp/foobar.mac");

     (%o1)                           /tmp/foobar.mac

     (%i2) :br foo
     Turning on debugging debugmode(true)
     Bkpt 0 for foo (in /tmp/foobar.mac line 1)

     (%i2) bar (2,3);
     Bkpt 0:(foobar.mac 1)
     /tmp/foobar.mac:1::

     (dbm:1) :bt                        <-- :bt digitado aqui lista os frames
     #0: foo(y=5)(foobar.mac line 1)
     #1: bar(x=2,y=3)(foobar.mac line 9)

     (dbm:1) :n                         <-- Aqui digite :n para avançar linha
     (foobar.mac 2)
     /tmp/foobar.mac:2::

     (dbm:1) :n                         <-- Aqui digite :n para avançar linha
     (foobar.mac 3)
     /tmp/foobar.mac:3::

     (dbm:1) u;                         <-- Investiga o valor de u
     28

     (dbm:1) u: 33;                     <-- Altera u para ser 33
     33

     (dbm:1) :r                         <-- Digite :r para retomar a computação

     (%o2)                                1094

O ficheiro `/tmp/foobar.mac' é o seguinte:

     foo(y) := block ([u:y^2],
       u: u+3,
       u: u^2,
       u);

     bar(x,y) := (
       x: x+2,
       y: y+2,
       x: foo(y),
       x+y);

USO DO DEPURADOR ATRAVÉS DO EMACS E DE XMAXIMA

Se o utilizador estiver a executar o código sob o GNU Emacs numa janela
shell (shel dbl), ou estiver usando a interface gráfica, `xmaxima',
então quando parar num ponto de parada, verá a sua posição actual no
ficheiro fonte apresentada na outra metade da janela, ou em vermelho
brilhante, ou com uma pequena seta apontando na direita da linha.
Poderá avançar uma linha por vez digitando M-n (Alt-n).

No Emacs pode executar o Maxima numa shell `dbl', o qual requer o
ficheiro `dbl.el' no directório elisp.  Verifique que tenha instalado
os ficheiros elisp ou adicionado o directório elisp do Maxima ao seu
caminho: e.g., adicione o seguinte ao seu ficheiro `.emacs' ou ao seu
ficheiro `site-init.el'

     (setq load-path (cons "/usr/share/maxima/5.9.1/emacs" load-path))
     (autoload 'dbl "dbl")

então no Emacs

     M-x dbl

pode iniciar uma janela shell na qual pode executar programas, por
exemplo Maxima, gcl, gdb etc. Essa janela de shell também reconhece
informações sobre depuração de código fonte, e mostra o código fonte em
outra janela.

O utilizador pode escolher um ponto de parada em certa linha do
ficheiro digitando `C-x space'. Isso encontra qual a função onde o
cursor está posicionado, e mostra qual a linha daquela função onde o
cursor está habilitado. Se o cursor estiver habilitado, digamos, na
linha 2 de `foo', então isso irá inserir na outra janela o comando,
"`:br foo 2'", para parar `foo' nessa segunda linha.  Para ter isso
habilitado, o utilizador deve ter maxima-mode.el habilitado na janela
na qual o ficheiro `foobar.mac' estiver interagindo.  Existe comandos
adicional disponíveis naquela janela de ficheiro, tais como avaliando a
função dentro do Maxima, através da digitação de `Alt-Control-x'.


File: maxima.info,  Node: Comandos Palavra Chave,  Next: Definições para Depuração,  Prev: Depuração do Código Fonte,  Up: Depuração

41.2 Comandos Palavra Chave
===========================

Comandos palavra chave são palavras chaves especiais que não são
interpretadas como expressões do Maxima.  Um comando palavra chave pode
ser inserido na linha de comando do Maxima ou na linha de comando do
depurador, embora não possa ser inserido na linha de comando de parada.
Comandos palavra chave iniciam com um dois pontos Keyword commands
start with a colon, ':'.  Por exemplo, para avaliar um comando do Lisp,
pode escrever `:lisp' seguido pelo comando a ser avaliado.

     (%i1) :lisp (+ 2 3)
     5

O número de argumentos necessários depende do comando em particular.
Também, não precisa escrever o comando completo, apenas o suficiente
para ser único no meio das palavras chave de parada. Dessa forma `:br'
será suficiente para `:break'.

Os comandos de palavra chave são listados abaixo.

`:break F n'
     Escolhe um ponto de parada em uma função `F' na linha `n' a partir
     do início da função.  Se `F' for dado como uma sequência de
     caracteres, então essa sequência de caracteres é assumida
     referir-se a um ficheiro, e `n' é o deslocamente a partir do
     início do ficheiro.  O deslocamento é opcional. Se for omitido, é
     assumido ser zero (primeira linha da função ou do ficheiro).

`:bt'
     Imprime na tela uma lista da pilha de frames

`:continue'
     Continua a computação

`:delete'
     Remove o ponto de parada seleccionado, ou todos se nenum for
     especificado

`:disable'
     Desabilita os pontos de parada seleccionados, ou todos se nenhum
     for especificado

`:enable'
     Habilita os pontos de de parada especificados, ou todos se nenhum
     for especificado

`:frame n'
     Imprime na tela a pilha de frame `n', ou o corrente frame se
     nenhum for especificado

`:help'
     Imprime na tela a ajuda sobre um comando do depurador, ou todos os
     comandos se nenhum for especificado

`:info'
     Imprime na tela informações sobre um item

`:lisp alguma-forma'
     Avalia `alguma-forma' como uma forma Lisp

`:lisp-quiet alguma-forma'
     Avalia a forma Lisp `alguma-forma' sem qualquer saída

`:next'
     Como `:step', excepto `:next' passos sobre chamadas de fução

`:quit'
     Sai do nível corrente do depurador sem concluir a computação

`:resume'
     Continua a computação

`:step'
     Continua a computação até encontraruma nova linha de códico

`:top'
     Retorne para a linha de comando do Maxima (saindo de qualquer
     nível do depurador) sem completar a computação


File: maxima.info,  Node: Definições para Depuração,  Prev: Comandos Palavra Chave,  Up: Depuração

41.3 Definições para Depuração
==============================

 -- Variável de opção: refcheck
     Valor por omissão: `false'

     Quando `refcheck' for `true', Maxima imprime uma mensagem cada vez
     que uma variável associada for usada pela primeira vez em uma
     computação.


 -- Variável de opção: setcheck
     Valor por omissão: `false'

     Se `setcheck' for escolhido para uma lista de variáveis (as quais
     podem ser subscritas), Maxima mostra uma mensagem quando as
     variáveis, ou ocorrências subscritas delas, forem associadas com o
     operador comum de atribuição `:', o operador `::' de atribuição,
     ou associando argumentos de função, mas não com o operador de
     atribuição de função `:=' nem o operador de atribuição `::=' de
     macro.  A mensagem compreende o nome das variáveis e o valor
     associado a ela.

     `setcheck' pode ser escolhida para `all' ou `true' incluindo desse
     modo todas as variáveis.

     Cada nova atribuição de `setcheck' estabelece uma nova lista de
     variáveis para verificar, e quaisquer variáveis previamente
     atribuídas a `setcheck' são esquecidas.

     Os nomes atribuídos a `setcheck' devem ter um apóstrofo no início
     se eles forem de outra forma avaliam para alguma outra coisa que
     não eles mesmo.  Por exemplo, se `x', `y', e `z' estiverem
     actualmente associados, então digite

          setcheck: ['x, 'y, 'z]$

     para colocá-los na lista de variáveis monitoradas.

     Nenhuma saída é gerada quando uma variável na lista `setcheck' for
     atribuída a sí mesma, e.g., `X: 'X'.


 -- Variável de opção: setcheckbreak
     Valor por omissão: `false'

     Quando `setcheckbreak' for `true', Maxima mostrará um ponto de
     parada quando uma variável sob a lista `setcheck' for atribuída a
     um novo valor.  A parada ocorre antes que a atribuíção seja
     concluída.  Nesse ponto, `setval' retém o valor para o qual a
     variável está para ser atribuída.  Consequentemente, se pode
     atribuir um valor diferente através da atribuição a `setval'.

     Veja também `setcheck' e `setval'.


 -- Variável de sistema: setval
     Mantém o valor para o qual a variável está para ser escolhida
     quando um `setcheckbreak' ocorrer.  Consequentemente, se pode
     atribuir um valor diferente através da atribuição a `setval'.

     Veja também `setcheck' e `setcheckbreak'.


 -- Função: timer (<f_1>, ..., <f_n>)
 -- Função: timer ()
     Dadas as funções <f_1>, ..., <f_n>, `timer' coloca cada uma na
     lista de funções para as quais cronometragens estatísticas são
     colectadas.  `timer(f)$ timer(g)$' coloca `f' e então `g' sobre a
     lista; a lista acumula de uma chamada para a chamada seguinte.

     Sem argumentos, `timer' retorna a lista das funções tempo
     estatisticamente monitoradas.

     Maxima armazena quanto tempo é empregado executando cada função na
     lista de funções tempo estatisticamente monitoradas.  `timer_info'
     retorna a coronometragem estatística, incluindo o tempo médio
     decorrido por chamada de função, o número de chamadas, e o tempo
     total decorrido.  `untimer' remove funções da lista de funções
     tempo estatisticamente monitoradas.

     `timer' não avalia seus argumentos.  `f(x) := x^2$ g:f$ timer(g)$'
     não coloca `f' na lista de funções estatisticamente monitoradas.

     Se `trace(f)' está vigorando, então `timer(f)' não tem efeito;
     `trace' e `timer' não podem ambas atuarem ao mesmo tempo.

     Veja também `timer_devalue'.


 -- Função: untimer (<f_1>, ..., <f_n>)
 -- Função: untimer ()
     Dadas as funções <f_1>, ..., <f_n>, `untimer' remove cada uma das
     funções listadas da lista de funções estatisticamente monitoradas.

     Sem argumentos, `untimer' remove todas as funções actualmente na
     lista de funções estatisticamente monitoradas.

     Após `untimer (f)' ser executada, `timer_info (f)' ainda retorna
     estatisticas de tempo previamente colectadas, embora
     `timer_info()' (sem argumentos) não retorna informações sobre
     qualquer função que não estiver actualmente na lista de funções
     tempo estatisticamente monitoradas.  `timer (f)' reposiciona todas
     as estatisticas de tempo para zero e coloca `f' na lista de
     funções estatisticamente monitoradas novamente.


 -- Variável de opção: timer_devalue
     Valor Padrão: `false'

     Quando `timer_devalue' for `true', Maxima subtrai de cada função
     estatisticamente monitorada o tempo empregado em ou funções
     estatisticamente monitoradas. De outra forma, o tempo reportado
     para cada função inclui o tempo empregado em outras funções.  Note
     que tempo empregado em funções não estatisticamente monitoradas
     não é subtraído do tempo total.

     Veja também `timer' e `timer_info'.


 -- Função: timer_info (<f_1>, ..., <f_n>)
 -- Função: timer_info ()
     Dadas as funções <f_1>, ..., <f_n>, `timer_info' retorna uma
     matriz contendo informações de cronometragem para cada função.
     Sem argumentos, `timer_info' retorna informações de cronometragem
     para todas as funções actualmente na lista de funções
     estatisticamente monitoradas.

     A matriz retornada através de `timer_info' contém o nome da função,
     tempo por chamda de função, número de chamadas a funções,tempo
     total, e `gctime', cujja forma "tempo de descarte" no Macsyma
     original mas agora é sempre zero.

     Os dados sobre os quais `timer_info' constrói seu valor de retorno
     podem também serem obtidos através da função `get':

          get(f, 'calls);  get(f, 'runtime);  get(f, 'gctime);

     Veja também `timer'.


 -- Função: trace (<f_1>, ..., <f_n>)
 -- Função: trace ()
     Dadas as funções <f_1>, ..., <f_n>, `trace' instrui Maxima para
     mostrar informações de depuração quando essas funções forem
     chamadas.  `trace(f)$ trace(g)$' coloca `f' e então `g' na lista
     de funções para serem colocadas sob a ação de `trace'; a lista
     acumula de uma chamada para a seguinte.

     Sem argumentos, `trace' retorna uma lista de todas as funções
     actualmente sob a ação de `trace'.

     A função `untrace' desabilita a ação de `trace'.  Veja também
     `trace_options'.

     `trace' não avalia seus argumentos. Dessa forma, `f(x) := x^2$
     g:f$ trace(g)$' não coloca `f' sobre a lista de funções
     monitoradas por `trace'.

     Quando uma função for redefinida, ela é removida da lista de
     `timer'.  Dessa forma após `timer(f)$ f(x) := x^2$', a função `f'
     não mais está na lista de `timer'.

     Se `timer (f)' estiver em efeito, então `trace (f)' não está
     agindo; `trace' e `timer' não podem ambas estar agindo para a
     mesma função.


 -- Função: trace_options (<f>, <option_1>, ..., <option_n>)
 -- Função: trace_options (<f>)
     Escolhe as opções de `trace' para a função <f>.  Quaisquer opções
     anteriores são substituídas.  `trace_options (<f>, ...)' não tem
     efeito a menos que `trace (<f>)' tenha sido também chamada (ou
     antes ou após `trace_options').

     `trace_options (<f>)' reposiciona todas as opções para seus
     valores padrão.

     As opções de palavra chave são:

        * `noprint' Não mostre uma mensagem na entrada da função e saia.

        * `break' Coloque um ponto de parada antes da função ser
          inserida, e após a funçãos er retirada. Veja `break'.

        * `lisp_print' Mostre argumentos e valores de retorno com
          objectos Lisp.

        * `info' Mostre `-> true' na entrada da funçào e saia.

        * `errorcatch' Capture os erros, fornecendo a opção para
          sinalizar um erro, tentar novamente a chamada de função, ou
          especificar um valor de retorno.

     Opções para `trace' são especificadas em duas formas. A presença
     da palavra chave de opção sozinha coloca a opção para ter efeito
     incondicionalmente.  (Note que opção <foo> não coloca para ter
     efeito especificando `<foo>: true' ou uma forma similar; note
     também que palavras chave não precisam estar com apóstrofo.)
     Especificando a opção palavra chave com uma função predicado torna
     a opção condicional sobre o predicado.

     A lista de argumentos para a função predicado é sempre `[level,
     direction, function, item]' onde `level' é o nível rerecursão para
     a função,  `direction' é ou `enter' ou `exit', `function' é o nome
     da função, e `item' é a lista de argumentos (sobre entrada) ou o
     valor de retorno (sobre a saída).

     Aqui está um exemplo de opções incondicionais de `trace':

          (%i1) ff(n) := if equal(n, 0) then 1 else n * ff(n - 1)$

          (%i2) trace (ff)$

          (%i3) trace_options (ff, lisp_print, break)$

          (%i4) ff(3);

     Aqui está a mesma função, com a opção `break' condicional sobre um
     predicado:

          (%i5) trace_options (ff, break(pp))$

          (%i6) pp (level, direction, function, item) := block (print (item),
              return (function = 'ff and level = 3 and direction = exit))$

          (%i7) ff(6);


 -- Função: untrace (<f_1>, ..., <f_n>)
 -- Função: untrace ()
     Dadas as funções <f_1>, ..., <f_n>, `untrace' desabilita a a
     monitoração habilitada pela função `trace'.  Sem argumentos,
     `untrace' desabilita a atuação da função `trade' para todas as
     funções.

     `untrace' retorne uma lista das funções para as quais `untrace'
     desabilita a atuação de `trace'.



File: maxima.info,  Node: augmented_lagrangian,  Next: bode,  Prev: Depuração,  Up: Top

42 augmented_lagrangian
***********************

* Menu:

* Definições para augmented_lagrangian::


File: maxima.info,  Node: Definições para augmented_lagrangian,  Prev: augmented_lagrangian,  Up: augmented_lagrangian

42.1 Definições para augmented_lagrangian
=========================================

 -- Função: augmented_lagrangian_method (<FOM>, <xx>, <C>, <yy>)
 -- Função: augmented_lagrangian_method (<FOM>, <xx>, <C>, <yy>,
          args_opcionais)
     Retorna um mínimo aproximado da expressão <FOM> com relação às
     variáveis <xx>, mantendo restrito o valor de <C> a zero.  <yy> é
     uma lista de suposições iniciais para <xx>.  O método utilizado é
     o método do Lagrangiano aumentado (veja referências [1] e [2]).

     `args_opcionais' representam argumentos adicionais, especificados
     como `<símbolo> = <valor>'.  Os argumentos opcionais que podem ser
     colocados no lugar de <símbolo>:

    `niter'
          Número de iterações do algoritmo do Langrangiano aumentado

    `lbfgs_tolerance'
          Tolerância forneceida a LBFGS (Limited-memory, Broyden,
          Fletcher, Goldfarb, Shanno)

    `iprint'
          parâmetro IPRINT (uma lista de dois inteiros que controlam o
          nível de informação) fornecido a LBFGS

    `%lambda'
          valor inicial de `%lambda' a ser usado durante o cálculo do
          Lagrangiano aumentado

     Essa implementação minimiza o Lagrangiano aumentado pela pela
     aplicação do algoritmo de memória limitada BFGS (LBFGS), que é um
     algoritmo quasi-Newton.

     `load(augmented_lagrangian)' chama essa função.

     Veja também `lbfgs'.

     References:

     [1]
     http://www-fp.mcs.anl.gov/otc/Guide/OptWeb/continuous/constrained/nonlinearcon/auglag.html

     [2] http://www.cs.ubc.ca/spider/ascher/542/chap10.pdf

     Exemplo:

          (%i1) load (lbfgs);
          (%o1) /home/robert/tmp/maxima-release-branch/maxima/share/lbfgs/\
          lbfgs.mac
          (%i2) load (augmented_lagrangian);
          (%o2) /home/robert/tmp/maxima-release-branch/maxima/share/contri\
          b/augmented_lagrangian.mac
          (%i3) FOM: x^2 + 2*y^2;
                                         2    2
          (%o3)                       2 y  + x
          (%i4) xx: [x, y];
          (%o4)                        [x, y]
          (%i5) C: [x + y - 1];
          (%o5)                      [y + x - 1]
          (%o6)                        [1, 1]
          (%i7) augmented_lagrangian_method (FOM, xx, C, yy, iprint = [-1, 0]);
          (%o7) [[x = 0.6478349888525, y = 0.32391749442625],
                                           %lambda = [- 1.267422460983745]]



File: maxima.info,  Node: bode,  Next: descriptive,  Prev: augmented_lagrangian,  Up: Top

43 bode
*******

* Menu:

* Definições para bode::


File: maxima.info,  Node: Definições para bode,  Prev: bode,  Up: bode

43.1 Definições para bode
=========================

 -- Função: bode_gain (<H>, <range>, ...<plot_opts>...)
     Função para desenhar gráficos de ganho para Bode.

     Exemplos (1 a 7 provenientes de
          http://www.swarthmore.edu/NatSci/echeeve1/Ref/Bode/BodeHow.html,
     8 proveniente de Ron Crummett):
          (%i1) load("bode")$

          (%i2) H1 (s) := 100 * (1 + s) / ((s + 10) * (s + 100))$

          (%i3) bode_gain (H1 (s), [w, 1/1000, 1000])$

          (%i4) H2 (s) := 1 / (1 + s/omega0)$

          (%i5) bode_gain (H2 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i6) H3 (s) := 1 / (1 + s/omega0)^2$

          (%i7) bode_gain (H3 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i8) H4 (s) := 1 + s/omega0$

          (%i9) bode_gain (H4 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i10) H5 (s) := 1/s$

          (%i11) bode_gain (H5 (s), [w, 1/1000, 1000])$

          (%i12) H6 (s) := 1/((s/omega0)^2 + 2 * zeta * (s/omega0) + 1)$

          (%i13) bode_gain (H6 (s), [w, 1/1000, 1000]),
                            omega0 = 10, zeta = 1/10$

          (%i14) H7 (s) := (s/omega0)^2 + 2 * zeta * (s/omega0) + 1$

          (%i15) bode_gain (H7 (s), [w, 1/1000, 1000]),
                            omega0 = 10, zeta = 1/10$

          (%i16) H8 (s) := 0.5 / (0.0001 * s^3 + 0.002 * s^2 + 0.01 * s)$

          (%i17) bode_gain (H8 (s), [w, 1/1000, 1000])$

     Para usar essa função escreva primeiramente `load("bode")'. Veja
     também `bode_phase'

 -- Função: bode_phase (<H>, <range>, ...<plot_opts>...)
     Função para desenhar gráficos de fase para Bode

     Exemplos (1 a 7 provenientes de
          http://www.swarthmore.edu/NatSci/echeeve1/Ref/Bode/BodeHow.html,
     8 proveniente de Ron Crummett):
          (%i1) load("bode")$

          (%i2) H1 (s) := 100 * (1 + s) / ((s + 10) * (s + 100))$

          (%i3) bode_phase (H1 (s), [w, 1/1000, 1000])$

          (%i4) H2 (s) := 1 / (1 + s/omega0)$

          (%i5) bode_phase (H2 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i6) H3 (s) := 1 / (1 + s/omega0)^2$

          (%i7) bode_phase (H3 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i8) H4 (s) := 1 + s/omega0$

          (%i9) bode_phase (H4 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i10) H5 (s) := 1/s$

          (%i11) bode_phase (H5 (s), [w, 1/1000, 1000])$

          (%i12) H6 (s) := 1/((s/omega0)^2 + 2 * zeta * (s/omega0) + 1)$

          (%i13) bode_phase (H6 (s), [w, 1/1000, 1000]),
                             omega0 = 10, zeta = 1/10$

          (%i14) H7 (s) := (s/omega0)^2 + 2 * zeta * (s/omega0) + 1$

          (%i15) bode_phase (H7 (s), [w, 1/1000, 1000]),
                             omega0 = 10, zeta = 1/10$

          (%i16) H8 (s) := 0.5 / (0.0001 * s^3 + 0.002 * s^2 + 0.01 * s)$

          (%i17) bode_phase (H8 (s), [w, 1/1000, 1000])$

          (%i18) block ([bode_phase_unwrap : false],
                        bode_phase (H8 (s), [w, 1/1000, 1000]));

          (%i19) block ([bode_phase_unwrap : true],
                        bode_phase (H8 (s), [w, 1/1000, 1000]));

     Para usar essa função escreva primeiramente `load("bode")'. Veja
     também `bode_gain'


File: maxima.info,  Node: descriptive,  Next: diag,  Prev: bode,  Up: Top

44 descriptive
**************

* Menu:

* Introdução ao pacote descriptive::
* Definições para manipulação da dados::
* Definições para estatística descritiva::
* Definições específicas para estatística descritiva de várias variáveis::
* Definições para gráficos estatísticos::


File: maxima.info,  Node: Introdução ao pacote descriptive,  Next: Definições para manipulação da dados,  Prev: descriptive,  Up: descriptive

44.1 Introdução ao pacote descriptive
=====================================

O pacote `descriptive' contém um conjunto de funções para fazer
cálculos de estatística descritiva e desenhar gráficos. Juntamente com
o código fonte três conjuntos de dados em suar árvore do Maxima:
`pidigits.data', `wind.data' e `biomed.data'. Eles também podem ser
baixados a partir de `www.biomates.net'.

Qualque manual de estatística pode ser usado como referência para as
funções no pacote `descriptive'.

Para comentários, erros ou sugestões, por favor entre em contato comigo
em <'mario AT edu DOT xunta DOT es'>.

Aqui está um exemplo sobre como as funções de estatística descritiva no
pacote `descriptive' fazem esse trabalho, dependendo da natureza de
seus argumentos, listas e matrizes,

     (%i1) load (descriptive)$
     (%i2) /* univariate sample */   mean ([a, b, c]);
                                 c + b + a
     (%o2)                       ---------
                                     3
     (%i3) matrix ([a, b], [c, d], [e, f]);
                                 [ a  b ]
                                 [      ]
     (%o3)                       [ c  d ]
                                 [      ]
                                 [ e  f ]
     (%i4) /* amostra de várias variáveis */ mean (%);
                           e + c + a  f + d + b
     (%o4)                [---------, ---------]
                               3          3

Note que em amostras de várias variáveis a média é calculada em cada
coluna.

No caso de muitas amostras amostras com possíveis tamanhos diferentes,
A função do Maxima `map' pode ser usada para pegar os resultados
desejados de cada amostra,

     (%i1) load (descriptive)$
     (%i2) map (mean, [[a, b, c], [d, e]]);
                             c + b + a  e + d
     (%o2)                  [---------, -----]
                                 3        2

Nesse caso, duas amostras de tamanhos 3 e 2 foram armazenadas em uma
lista.

Amostras de uma única variável devem ser armazenadas em listas como

     (%i1) s1 : [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5];
     (%o1)           [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]

e amostras de várias variáveis em matrizes como em

     (%i1) s2 : matrix ([13.17, 9.29], [14.71, 16.88], [18.50, 16.88],
                  [10.58, 6.63], [13.33, 13.25], [13.21,  8.12]);
                             [ 13.17  9.29  ]
                             [              ]
                             [ 14.71  16.88 ]
                             [              ]
                             [ 18.5   16.88 ]
     (%o1)                   [              ]
                             [ 10.58  6.63  ]
                             [              ]
                             [ 13.33  13.25 ]
                             [              ]
                             [ 13.21  8.12  ]

Nesse caso, o número de colunas é igual à dimensão (ao número) de
variáveis e o n;umero de linhas é o tamano da amostra.

Dados podem ser introduzidos manualmente, mas grandes amostras são
usualmente armazenadas em ficheiros no formato texto plano. Por
exemplo, o ficheiro `pidigits.data' contém os primeiros 100 dígitos do
número `%pi':
           3
           1
           4
           1
           5
           9
           2
           6
           5
           3 ...

Com o objectivo de chamar esses dígitos no Maxima,

     (%i1) load (numericalio)$
     (%i2) s1 : read_list (file_search ("pidigits.data"))$
     (%i3) length (s1);
     (%o3)                          100

Por outro lado, o ficheiro `wind.data' contém a média diária de
velocidades do ventoem 5 estações meteorológicas na República da
Irlanda (Esses dados são parte de um conjunto de dados tomados em 12
estações meteorológicas. O ficheiro original está disponivel livremente
para download no Repositório de Dados StatLib e sua análise é discutida
em Haslett, J., Raftery, A. E. (1989) <Space-time Modelling with
Long-memory Dependence: Assessing Ireland's Wind Power Resource, with
Discussion>. Applied Statistics 38, 1-50). As linhas seguintes mostram
como tornar os dados disponíveis para o Maxima:

     (%i1) load (numericalio)$
     (%i2) s2 : read_matrix (file_search ("wind.data"))$
     (%i3) length (s2);
     (%o3)                          100
     (%i4) s2 [%]; /* last record */
     (%o4)            [3.58, 6.0, 4.58, 7.62, 11.25]

Algumas amostras possuem dados não numéricos. Como um exemplo, o
ficheiro `biomed.data' (que é parte de outro grande ficheiro tomado do
Repósitório de Dados StatLib) contém quatro medidas sanguíneas tomadas
de dois grupos de pacientes, `A' e `B', de diferentes idades,

     (%i1) load (numericalio)$
     (%i2) s3 : read_matrix (file_search ("biomed.data"))$
     (%i3) length (s3);
     (%o3)                          100
     (%i4) s3 [1]; /* first record */
     (%o4)            [A, 30, 167.0, 89.0, 25.6, 364]

O primeiro indivíduo pertence ao grupo `A', com 30 anos de idade e suas
medidas sanguíneas foram 167.0, 89.0, 25.6 e 364.

Se deve tomar cuidado quando se trabalha com dados divididos por
categorias. no exemplo seguinte, ao símbolo `a' é atribuído um valor em
algum momento anterior e então a amostra com valores divididos por
categoria `a' é interpretada como,

     (%i1) a : 1$
     (%i2) matrix ([a, 3], [b, 5]);
                                 [ 1  3 ]
     (%o2)                       [      ]
                                 [ b  5 ]


File: maxima.info,  Node: Definições para manipulação da dados,  Next: Definições para estatística descritiva,  Prev: Introdução ao pacote descriptive,  Up: descriptive

44.2 Definições para manipulação da dados
=========================================

 -- Função: continuous_freq (<list>)
 -- Função: continuous_freq (<list>, <m>)
     O argumento de `continuous_freq' deve ser uma lista de números,
     que serão então agrupadas em intervalos e contado quantos desses
     dados pertencem a cada grupo. Opcionalmente, a função
     `continuous_freq' admite um segundo argumento indicando o número
     de classes, 10 é o valor padrão,

          (%i1) load (numericalio)$
          (%i2) load (descriptive)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) continuous_freq (s1, 5);
          (%o4) [[0, 1.8, 3.6, 5.4, 7.2, 9.0], [16, 24, 18, 17, 25]]

     A primeira lista contém os limites de intervalos e o segundo a
     correspondente contagem: existem 16 algarismos da parte decimal de
     `%pi' dentro do intervalo `[0, 1.8]', isto é 0's e 1's, 24
     algarismos em `(1.8, 3.6]', isto é 2's e 3's, e assim por diante.

 -- Função: discrete_freq (<list>)
     Conta as frequências absolutas em amostras discretas, em amostras
     numéricas e em amostras divididas em categorias. Seu único
     argumento é uma lista,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"));
          (%o3) [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9, 3, 2, 3, 8,
          4, 6, 2, 6, 4, 3, 3, 8, 3, 2, 7, 9, 5, 0, 2, 8, 8, 4, 1, 9, 7,
          1, 6, 9, 3, 9, 9, 3, 7, 5, 1, 0, 5, 8, 2, 0, 9, 7, 4, 9, 4, 4,
          5, 9, 2, 3, 0, 7, 8, 1, 6, 4, 0, 6, 2, 8, 6, 2, 0, 8, 9, 9, 8,
          6, 2, 8, 0, 3, 4, 8, 2, 5, 3, 4, 2, 1, 1, 7, 0, 6, 7]
          (%i4) discrete_freq (s1);
          (%o4) [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
                                       [8, 8, 12, 12, 10, 8, 9, 8, 12, 13]]

     A primeira lista fornece os valores da amostra e a segunda as suas
     frequências absolutas. Os comandos `? col' e `? transpose' podem
     ajudá-lo a entender o último comando de entrada.

 -- Função: subsample (<matriz_de_dados>, <expressão_lógica>)
 -- Função: subsample (<matriz_de_dados>, <expressão_lógica>,
          <col_num>, <col_num>, ...)
     Essas funções são um tipo de variação da função `submatrix' do
     Maxima. O primeiro argumento é o nome da matriz de dados, o
     segundo argumento é uma expressão lógica que recebeu apóstrofo e
     os argumentos opcionais adicionais são o número de colunas a serem
     tomadas. Esse comportamento é melhor entendido com exemplos,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) subsample (s2, '(%c[1] > 18));
                        [ 19.38  15.37  15.12  23.09  25.25 ]
                        [                                   ]
                        [ 18.29  18.66  19.08  26.08  27.63 ]
          (%o4)         [                                   ]
                        [ 20.25  21.46  19.95  27.71  23.38 ]
                        [                                   ]
                        [ 18.79  18.96  14.46  26.38  21.84 ]

     Existem registros de várias variáveis nos quais a velocidade do
     vento na primeira estação meteorológica foram maiores que 18. Veja
     que na expressão lógica que recebeu apóstrofo o <i>-ésimo
     componente é referenciado como `%c[i]'. O símbolo `%c[i]' é usado
     dentro da função `subsample', portanto quando usado como uma
     variável de uma categoria, Maxima fica confuso. No seguinte
     exemplo, requisitamos somente o primeiro, o segundo e o quinto
     componentes desses registro com velocidades de vento maiores que
     ou igual a 16 nós na estação meteorológica número 1 e menor que 25
     nós na estação meteorológica número 4,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) subsample (s2, '(%c[1] >= 16 and %c[4] < 25), 1, 2, 5);
                               [ 19.38  15.37  25.25 ]
                               [                     ]
                               [ 17.33  14.67  19.58 ]
          (%o4)                [                     ]
                               [ 16.92  13.21  21.21 ]
                               [                     ]
                               [ 17.25  18.46  23.87 ]

     Aqui está um exemplo com as variáveis divididas em categorias do
     ficheiro `biomed.data'. Queremos os registros correspondentes a
     aqueles pacientes no grupo `B' que possuem idade maior que 38 anos,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) subsample (s3, '(%c[1] = B and %c[2] > 38));
                          [ B  39  28.0  102.3  17.1  146 ]
                          [                               ]
                          [ B  39  21.0  92.4   10.3  197 ]
                          [                               ]
                          [ B  39  23.0  111.5  10.0  133 ]
                          [                               ]
                          [ B  39  26.0  92.6   12.3  196 ]
          (%o4)           [                               ]
                          [ B  39  25.0  98.7   10.0  174 ]
                          [                               ]
                          [ B  39  21.0  93.2   5.9   181 ]
                          [                               ]
                          [ B  39  18.0  95.0   11.3  66  ]
                          [                               ]
                          [ B  39  39.0  88.5   7.6   168 ]

     Probavelmente, a análise estatística irá envolver somente as
     medidas sanguíneas,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) subsample (s3, '(%c[1] = B and %c[2] > 38), 3, 4, 5, 6);
                             [ 28.0  102.3  17.1  146 ]
                             [                        ]
                             [ 21.0  92.4   10.3  197 ]
                             [                        ]
                             [ 23.0  111.5  10.0  133 ]
                             [                        ]
                             [ 26.0  92.6   12.3  196 ]
          (%o4)              [                        ]
                             [ 25.0  98.7   10.0  174 ]
                             [                        ]
                             [ 21.0  93.2   5.9   181 ]
                             [                        ]
                             [ 18.0  95.0   11.3  66  ]
                             [                        ]
                             [ 39.0  88.5   7.6   168 ]

     Essa é a média de várias variáveis de `s3',

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) mean (s3);
                 65 B + 35 A  317          6 NA + 8145.0
          (%o4) [-----------, ---, 87.178, -------------, 18.123,
                     100      10                100
                                                              3 NA + 19587
                                                              ------------]
                                                                  100
     Aqui, a primeira componente é sem sentido, uma vez que `A' e `B'
     são categorias, o segundo componente é a idade média dos
     indivíduos na forma racional, e o quarto eo último valores exibem
     um comportamento estranho. Isso ocorre porque o símbolo `NA' é
     usado aqui para indicar dado não disponível (<non available> em
     inglês), e as duas médias são certamente sem sentido. Uma solução
     possível pode ser jogar fora a matriz cujas linhas possuam
     símbolos `NA', embora isso cause alguma perda de informação,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) mean (subsample (s3, '(%c[4] # NA and %c[6] # NA), 3, 4, 5, 6));
          (%o4) [79.4923076923077, 86.2032967032967, 16.93186813186813,
                                                                      2514
                                                                      ----]
                                                                       13


File: maxima.info,  Node: Definições para estatística descritiva,  Next: Definições específicas para estatística descritiva de várias variáveis,  Prev: Definições para manipulação da dados,  Up: descriptive

44.3 Definições para estatística descritiva
===========================================

 -- Função: mean (<lista>)
 -- Função: mean (<matriz>)
     Essa função calcula a média de uma amostra, definida como
                                 n
                               ====
                       _   1   \
                       x = -    >    x
                           n   /      i
                               ====
                               i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) mean (s1);
                                         471
          (%o4)                          ---
                                         100
          (%i5) %, numer;
          (%o5)                         4.71
          (%i6) s2 : read_matrix (file_search ("wind.data"))$
          (%i7) mean (s2);
          (%o7)     [9.9485, 10.1607, 10.8685, 15.7166, 14.8441]

 -- Função: var (<list>)
 -- Função: var (<matrix>)
     This is the sample variance, defined as
                               n
                             ====
                     2   1   \          _ 2
                    s  = -    >    (x - x)
                         n   /       i
                             ====
                             i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) var (s1), numer;
          (%o4)                   8.425899999999999

     See also function `var1'.

 -- Função: var1 (<lista>)
 -- Função: var1 (<matriz>)
     Essa função calcula a variância da amostra, definida como
                               n
                             ====
                         1   \          _ 2
                        ---   >    (x - x)
                        n-1  /       i
                             ====
                             i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) var1 (s1), numer;
          (%o4)                    8.5110101010101
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) var1 (s2);
          (%o6) [17.39586540404041, 15.13912778787879, 15.63204924242424,
                                      32.50152569696971, 24.66977392929294]

     See also function `var'.

 -- Função: std (<lista>)
 -- Função: std (<matriz>)
     A raíz quadrada da função `var', a variância com denominador n.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) std (s1), numer;
          (%o4)                   2.902740084816414
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) std (s2);
          (%o6) [4.149928523480858, 3.871399812729241, 3.933920277534866,
                                      5.672434260526957, 4.941970881136392]

     Veja também as funções `var' e `std1'.

 -- Função: std1 (<lista>)
 -- Função: std1 (<matriz>)
     É a raíz quadrada da função `var1', a variância com denominador
     n-1.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) std1 (s1), numer;
          (%o4)                   2.917363553109228
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) std1 (s2);
          (%o6) [4.17083509672109, 3.89090320978032, 3.953738641137555,
                                      5.701010936401517, 4.966867617451963]

     Veja também as funções `var1' e `std'.

 -- Função: noncentral_moment (<lista>, <k>)
 -- Função: noncentral_moment (<matriz>, <k>)
     O momento não central de ordem k, definido como
                                 n
                               ====
                           1   \      k
                           -    >    x
                           n   /      i
                               ====
                               i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) noncentral_moment (s1, 1), numer; /* the mean */
          (%o4)                         4.71
          (%i6) s2 : read_matrix (file_search ("wind.data"))$
          (%i7) noncentral_moment (s2, 5);
          (%o7) [319793.8724761506, 320532.1923892463, 391249.5621381556,
                                      2502278.205988911, 1691881.797742255]

     Veja também a função `central_moment'.

 -- Função: central_moment (<lista>, <k>)
 -- Função: central_moment (<matriz>, <k>)
     O momento central de ordem k, definido como
                              n
                            ====
                        1   \          _ k
                        -    >    (x - x)
                        n   /       i
                            ====
                            i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) central_moment (s1, 2), numer; /* a variância */
          (%o4)                   8.425899999999999
          (%i6) s2 : read_matrix (file_search ("wind.data"))$
          (%i7) central_moment (s2, 3);
          (%o7) [11.29584771375004, 16.97988248298583, 5.626661952750102,
                                       37.5986572057918, 25.85981904394192]

     Veja também as funções `central_moment' e `mean'.

 -- Função: cv (<lista>)
 -- Função: cv (<matriz>)
     O coeficiente de variação é o quociente entre o desvio padrão da
     amostra (`std') e a média `mean',

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) cv (s1), numer;
          (%o4)                   .6193977819764815
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) cv (s2);
          (%o6) [.4192426091090204, .3829365309260502, 0.363779605385983,
                                      .3627381836021478, .3346021393989506]

     Veja também as funções `std' e `mean'.

 -- Função: mini (<lista>)
 -- Função: mini (<matriz>)
     É o valor mínimo da amostra <lista>,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) mini (s1);
          (%o4)                           0
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) mini (s2);
          (%o6)             [0.58, 0.5, 2.67, 5.25, 5.17]

     Veja também função `maxi'.

 -- Função: maxi (<lista>)
 -- Função: maxi (<matriz>)
     É o valor máximo da amostra <lista>,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) maxi (s1);
          (%o4)                           9
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) maxi (s2);
          (%o6)          [20.25, 21.46, 20.04, 29.63, 27.63]

     Veja também a função `mini'.

 -- Função: range (<lista>)
 -- Função: range (<matriz>)
     A amplitude é a diferença entre os valores de maximo e de mínimo.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) range (s1);
          (%o4)                           9
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) range (s2);
          (%o6)          [19.67, 20.96, 17.37, 24.38, 22.46]

 -- Função: quantile (<lista>, <p>)
 -- Função: quantile (<matriz>, <p>)
     É o <p>-`quantile' (quantil de ordem <p>), com <p> sendo um número
     em [0, 1] (intervalo fechado), da amostra <lista>.  Embora exista
     muitas Definições para quantil de uma amostra (Hyndman, R. J.,
     Fan, Y. (1996) <Sample quantiles in statistical packages>.
     American Statistician, 50, 361-365), aquela que se baseia em
     interpolação linear é a que foi implementada no pacote
     `descriptive'.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) /* 1st and 3rd quartiles */ [quantile (s1, 1/4), quantile (s1, 3/4)], numer;
          (%o4)                      [2.0, 7.25]
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) quantile (s2, 1/4);
          (%o6)    [7.2575, 7.477500000000001, 7.82, 11.28, 11.48]

 -- Função: median (<lista>)
 -- Função: median (<matriz>)
     Uma vez que a amostra está ordenada, se o tamanho da amostra for
     ímpar a mediana é o valor central, de outra forma a mediana será a
     média dos dois valores centrais.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) median (s1);
                                          9
          (%o4)                           -
                                          2
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) median (s2);
          (%o6)         [10.06, 9.855, 10.73, 15.48, 14.105]

     A mediana é o 1/2-`quantil'.

     Veja também function `quantile'.

 -- Função: qrange (<lista>)
 -- Função: qrange (<matriz>)
     A amplitude do interquartil é a diferença entre o terceiro e o
     primeiro quartil, `quantile(<lista>,3/4) - quantile(<lista>,1/4)',

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) qrange (s1);
                                         21
          (%o4)                          --
                                         4
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) qrange (s2);
          (%o6) [5.385, 5.572499999999998, 6.0225, 8.729999999999999,
                                                         6.650000000000002]

     Veja também a função `quantile'.

 -- Função: mean_deviation (<lista>)
 -- Função: mean_deviation (<matriz>)
     O desvio médio, definido como
                               n
                             ====
                         1   \          _
                         -    >    |x - x|
                         n   /       i
                             ====
                             i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) mean_deviation (s1);
                                         51
          (%o4)                          --
                                         20
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) mean_deviation (s2);
          (%o6) [3.287959999999999, 3.075342, 3.23907, 4.715664000000001,
                                                         4.028546000000002]

     Veja também a função `mean'.

 -- Função: median_deviation (<lista>)
 -- Função: median_deviation (<matriz>)
     O desvio da mediana, definido como
                           n
                         ====
                     1   \
                     -    >    |x - med|
                     n   /       i
                         ====
                         i = 1
     onde `med' é a mediana da <lista>.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) median_deviation (s1);
                                          5
          (%o4)                           -
                                          2
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) median_deviation (s2);
          (%o6)           [2.75, 2.755, 3.08, 4.315, 3.31]

     Veja também a função `mean'.

 -- Função: harmonic_mean (<lista>)
 -- Função: harmonic_mean (<matriz>)
     A média harmônica, definida como
                            n
                         --------
                          n
                         ====
                         \     1
                          >    --
                         /     x
                         ====   i
                         i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) y : [5, 7, 2, 5, 9, 5, 6, 4, 9, 2, 4, 2, 5]$
          (%i4) harmonic_mean (y), numer;
          (%o4)                   3.901858027632205
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) harmonic_mean (s2);
          (%o6) [6.948015590052786, 7.391967752360356, 9.055658197151745,
                                      13.44199028193692, 13.01439145898509]

     Veja também as funções `mean' e `geometric_mean'.

 -- Função: geometric_mean (<lista>)
 -- Função: geometric_mean (<matriz>)
     A média geométrica, definida como
                           /  n      \ 1/n
                           | /===\   |
                           |  ! !    |
                           |  ! !  x |
                           |  ! !   i|
                           | i = 1   |
                           \         /

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) y : [5, 7, 2, 5, 9, 5, 6, 4, 9, 2, 4, 2, 5]$
          (%i4) geometric_mean (y), numer;
          (%o4)                   4.454845412337012
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) geometric_mean (s2);
          (%o6) [8.82476274347979, 9.22652604739361, 10.0442675714889,
                                      14.61274126349021, 13.96184163444275]

     Veja também as funções `mean' e `harmonic_mean'.

 -- Função: kurtosis (<lista>)
 -- Função: kurtosis (<matriz>)
     O coeficiente de curtose, definido como
                              n
                            ====
                      1     \          _ 4
                     ----    >    (x - x)  - 3
                        4   /       i
                     n s    ====
                            i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) kurtosis (s1), numer;
          (%o4)                  - 1.273247946514421
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) kurtosis (s2);
          (%o6) [- .2715445622195385, 0.119998784429451,
             - .4275233490482866, - .6405361979019522, - .4952382132352935]

     Veja também as funções `mean', `var' e `skewness'.

 -- Função: skewness (<lista>)
 -- Função: skewness (<matriz>)
     O coeficiente de assimetria, definido como
                              n
                            ====
                      1     \          _ 3
                     ----    >    (x - x)
                        3   /       i
                     n s    ====
                            i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) skewness (s1), numer;
          (%o4)                  .009196180476450306
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) skewness (s2);
          (%o6) [.1580509020000979, .2926379232061854, .09242174416107717,
                                      .2059984348148687, .2142520248890832]

     Veja também as funções `mean', `var' e `kurtosis'.

 -- Função: pearson_skewness (<lista>)
 -- Função: pearson_skewness (<matriz>)
     O coeficiente de assimetria de pearson, definido como
                          _
                       3 (x - med)
                       -----------
                            s
     onde <med> é a mediana de <lista>.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) pearson_skewness (s1), numer;
          (%o4)                   .2159484029093895
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) pearson_skewness (s2);
          (%o6) [- .08019976629211892, .2357036272952649,
                   .1050904062491204, .1245042340592368, .4464181795804519]

     Veja também as funções `mean', `var' e `median'.

 -- Função: quartile_skewness (<lista>)
 -- Função: quartile_skewness (<matriz>)
     O coeficiented de assimetria do quartil, definido como
                         c    - 2 c    + c
                          3/4      1/2    1/4
                         --------------------
                             c    - c
                              3/4    1/4
     onde c_p é o quartil de ordem <p> da amostra <lista>.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) quartile_skewness (s1), numer;
          (%o4)                  .04761904761904762
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) quartile_skewness (s2);
          (%o6) [- 0.0408542246982353, .1467025572005382,
                 0.0336239103362392, .03780068728522298, 0.210526315789474]

     Veja também a função `quantile'.


File: maxima.info,  Node: Definições específicas para estatística descritiva de várias variáveis,  Next: Definições para gráficos estatísticos,  Prev: Definições para estatística descritiva,  Up: descriptive

44.4 Definições específicas para estatística descritiva de várias variáveis
===========================================================================

 -- Função: cov (<matriz>)
     A matriz de covariância da amostra de várias variáveis, definida
     como
                        n
                       ====
                    1  \           _        _
                S = -   >    (X  - X) (X  - X)'
                    n  /       j        j
                       ====
                       j = 1
     onde X_j é a j-ésima linha da matriz de amostra.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) fpprintprec : 7$  /* modifique a precisão para obter uma saída melhor */
          (%i5) cov (s2);
                [ 17.22191  13.61811  14.37217  19.39624  15.42162 ]
                [                                                  ]
                [ 13.61811  14.98774  13.30448  15.15834  14.9711  ]
                [                                                  ]
          (%o5) [ 14.37217  13.30448  15.47573  17.32544  16.18171 ]
                [                                                  ]
                [ 19.39624  15.15834  17.32544  32.17651  20.44685 ]
                [                                                  ]
                [ 15.42162  14.9711   16.18171  20.44685  24.42308 ]

     Veja também a função `cov1'.

 -- Função: cov1 (<matriz>)
     A matriz de covariância da amostra de várias variáveis, definida
     como
                        n
                       ====
                   1   \           _        _
             S  = ---   >    (X  - X) (X  - X)'
              1   n-1  /       j        j
                       ====
                       j = 1
     where X_j is the j-th row of the sample matrix.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) fpprintprec : 7$ /* modifique a precisão para obter uma saída melhor */
          (%i5) cov1 (s2);
                [ 17.39587  13.75567  14.51734  19.59216  15.5774  ]
                [                                                  ]
                [ 13.75567  15.13913  13.43887  15.31145  15.12232 ]
                [                                                  ]
          (%o5) [ 14.51734  13.43887  15.63205  17.50044  16.34516 ]
                [                                                  ]
                [ 19.59216  15.31145  17.50044  32.50153  20.65338 ]
                [                                                  ]
                [ 15.5774   15.12232  16.34516  20.65338  24.66977 ]

     Veja também a função `cov'.

 -- Função: global_variances (<matriz>)
 -- Função: global_variances (<matriz>, <valor_lógico>)
     A função `global_variances' retorna uma lista de medidas de
     variância global:

        * <variância total>: `trace(S_1)',

        * <variância média>: `trace(S_1)/p',

        * <variância generalizada>: `determinant(S_1)',

        * <desvio padrão generalizado>: `sqrt(determinant(S_1))',

        * <variância efectiva> `determinant(S_1)^(1/p)', (defined in:
          Peña, D. (2002) <Análisis de datos multivariantes>;
          McGraw-Hill, Madrid.)

        * <desvio padrão efectivo>: `determinant(S_1)^(1/(2*p))'.
     onde <p> é a dimensão das várias variáveis aleatórias e S_1 a
     matriz de covariância retornada por `cov1'.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) global_variances (s2);
          (%o4) [105.338342060606, 21.06766841212119, 12874.34690469686,
                   113.4651792608502, 6.636590811800794, 2.576158149609762]

     A função `global_variances' tem um argumento lógico opcional:
     `global_variances(x,true)' diz ao Maxima que `x' é a matriz de
     dados, fazendo o mesmo que `global_variances(x)'. Por outro lado,
     `global_variances(x,false)' significa que `x' não é a matriz de
     dados, mas a matriz de covariância, evitando a repetição seu
     cálculo,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) s : cov1 (s2)$
          (%i5) global_variances (s, false);
          (%o5) [105.338342060606, 21.06766841212119, 12874.34690469686,
                   113.4651792608502, 6.636590811800794, 2.576158149609762]

     Veja também `cov' e `cov1'.

 -- Função: cor (<matriz>)
 -- Função: cor (<matriz>, <valor_lógico>)
     A matriz de correlação da maostra de várias variáveis.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) fpprintprec:7$
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) cor (s2);
                [   1.0     .8476339  .8803515  .8239624  .7519506 ]
                [                                                  ]
                [ .8476339    1.0     .8735834  .6902622  0.782502 ]
                [                                                  ]
          (%o5) [ .8803515  .8735834    1.0     .7764065  .8323358 ]
                [                                                  ]
                [ .8239624  .6902622  .7764065    1.0     .7293848 ]
                [                                                  ]
                [ .7519506  0.782502  .8323358  .7293848    1.0    ]

     A função `cor' tem um argumento lógico opcional: `cor(x,true)' diz
     ao Maxima que `x' é a matriz de dados, fazendo o mesmo que
     `cor(x)'. Por outro lado, `cor(x,false)' significa que `x' não é a
     matriz de dados, mas a matriz de covariância, evitando a repetição
     de seu cálculo,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) fpprintprec:7$
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) s : cov1 (s2)$
          (%i6) cor (s, false); /* this is faster */
                [   1.0     .8476339  .8803515  .8239624  .7519506 ]
                [                                                  ]
                [ .8476339    1.0     .8735834  .6902622  0.782502 ]
                [                                                  ]
          (%o6) [ .8803515  .8735834    1.0     .7764065  .8323358 ]
                [                                                  ]
                [ .8239624  .6902622  .7764065    1.0     .7293848 ]
                [                                                  ]
                [ .7519506  0.782502  .8323358  .7293848    1.0    ]

     Veja também `cov' e `cov1'.

 -- Função: list_correlations (<matriz>)
 -- Função: list_correlations (<matriz>, <valor_lógico>)
     A função `list_correlations' retorna uma lista de medidas de
     correlação:

        * <matriz de precisão>: o inverso da matriz de covariância S_1,
                      -1     ij
                     S   = (s  )
                      1         i,j = 1,2,...,p

        * <vector de correlação múltipla>:  (R_1^2, R_2^2, ..., R_p^2),
          com
                      2          1
                     R  = 1 - -------
                      i        ii
                              s   s
                                   ii
          sendo um indicador do melhor do ajuste do modelo de regressão
          linear de várias variáveis dobre X_i quando o resto das
          variáveis são usados como regressores.

        * <matriz de correlação parcial>: como elemento (i, j) sendo
                                        ij
                                       s
                     r        = - ------------
                      ij.rest     / ii  jj\ 1/2
                                  |s   s  |
                                  \       /


     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) z : list_correlations (s2)$
          (%i5) fpprintprec : 5$ /* for pretty output */
          (%i6) z[1];  /* precision matrix */
                [  .38486   - .13856   - .15626   - .10239    .031179  ]
                [                                                      ]
                [ - .13856   .34107    - .15233    .038447   - .052842 ]
                [                                                      ]
          (%o6) [ - .15626  - .15233    .47296    - .024816  - .10054  ]
                [                                                      ]
                [ - .10239   .038447   - .024816   .10937    - .034033 ]
                [                                                      ]
                [ .031179   - .052842  - .10054   - .034033   .14834   ]
          (%i7) z[2];  /* multiple correlation vector */
          (%o7)       [.85063, .80634, .86474, .71867, .72675]
          (%i8) z[3];  /* partial correlation matrix */
                 [  - 1.0     .38244   .36627   .49908   - .13049 ]
                 [                                                ]
                 [  .38244    - 1.0    .37927  - .19907   .23492  ]
                 [                                                ]
          (%o8)  [  .36627    .37927   - 1.0    .10911    .37956  ]
                 [                                                ]
                 [  .49908   - .19907  .10911   - 1.0     .26719  ]
                 [                                                ]
                 [ - .13049   .23492   .37956   .26719    - 1.0   ]

     A função `list_correlations' também tem um argumento lógico
     opcional: `list_correlations(x,true)' diz ao Maxima que `x' é a
     matriz de dados, fazendo o mesmo que `list_correlations(x)'. Por
     outro lado, `list_correlations(x,false)' significa que `x' não é a
     matriz de correlação, mas a matriz de covariancia, evitando a
     repetição de seu cálculo.

     Veja também `cov' e `cov1'.


File: maxima.info,  Node: Definições para gráficos estatísticos,  Prev: Definições específicas para estatística descritiva de várias variáveis,  Up: descriptive

44.5 Definições para gráficos estatísticos
==========================================

 -- Função: dataplot (<lista>)
 -- Função: dataplot (<lista>, <opção_1>, <opção_2>, ...)
 -- Função: dataplot (<matriz>)
 -- Função: dataplot (<matriz>, <opção_1>, <opção_2>, ...)
     A função `dataplot' permite visualização directa de dados de
     amostra, ambas d uma única variável (<lista>) e de várias
     variáveis (<matriz>). Fornecendo valores para as seguintes
     <opções> que são alguns aspéctos de impressão que podem ser
     controlados:

        * `'outputdev', o valor padrão é `"x"', indica o formato de
          dispositivo/ficheiro da figura de saída; valores correctos
          são `"x"', `"eps"' e `"png"', para a tela, formato de
          ficheiro postscript e formato de ficheiro png,
          respectivamente.

        * `'maintitle', o valor padrão é `""', é o título principal
          entre aspas duplas.

        * `'axisnames', o valor padrão é `["x","y","z"]', é uma lista
          de nomes dos eixos `x', `y' e `z'.

        * `'joined', o valor padrão é `false', um valor lógico para
          seleccionar pontos em 2D para serem unidos ou isolados.

        * `'picturescales', o valor padrão é `[1.0, 1.0]', factor de
          proporcionalidade para o tamanho do gráfico.

        * `'threedim', o valor padrão é `true', diz ao Maxima se ou
          monta-se o gráfico de uma matriz de três colunas como um
          diagrama 3D ou se monta-se o gráfico como um diagrama de
          dispersão de várias variáveis. Veja exemplos abaixo.

        * `'axisrot', o valor padrão é `[60, 30]', modifica o ponto de
          visualização quando `'threedim' for escolhido para `true'
          dados forem armazenados em uma matriz de três colunas. O
          primeiro número é o ângulo de rotação do eixo <x>, e o
          segundo número é o angulo de rotação do eixo <z>-axis, ambas
          as medidas em graus.

        * `'nclasses', o valor padrão é `10', é o número de classes
          para histogramas na diagonal de gráficos de dispersão de
          várias variáveis.

        * `'pointstyle', o valor padrão é `1', é um inteiro que indica
          como mostrar pontos de amostra.


     Por exemplo, com a seguite entrada um gráfico simples dos
     primeiros vinte dígitos de `%pi' é requisitado e a saída é
     armazenada em um ficheiro no formato eps.

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) dataplot (makelist (s1[k], k, 1, 20), 'pointstyle = 3)$

     Note que dados unidimensionais são colocados no gráfico como uma
     série de tempo. No caso seguinte, ocorre a mesma coisa só que com
     mais dados e com mais configurações,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) dataplot (makelist (s1[k], k, 1, 50), 'maintitle = "Primeiros dígitos de pi",
           'axisnames = ["ordem do dígito", "valor do dígito"], 'pointstyle = 2,
           'joined = true)$

     A função `dataplot' pode ser usada para montar gráficos de pontos
     no plano. O exemplo seguinte é gráfico de dispersão de pares de
     pontos de velocidades de vento para o primeira e para o quinta
     estação meteorológica,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) dataplot (submatrix (s2, 2, 3, 4), 'pointstyle = 2,
           'maintitle = "Pares de medidas de velocidade do vento em nós",
           'axisnames = ["Velocidade do vento em A", "Velocidade do vento em E"])$

     Se pontos forem armazenados em uma matriz de duas colunas,
     `dataplot' pode montar o gráfico desses pontos directamente, mas
     se eles forem formatados em uma lista de pares, essa lista deve
     ser transformada em uma matriz como no seguinte exemplo.

          (%i1) load (descriptive)$
          (%i2) x : [[-1, 2], [5, 7], [5, -3], [-6, -9], [-4, 6]]$
          (%i3) dataplot (apply ('matrix, x), 'maintitle = "Pontos",
           'joined = true, 'axisnames = ["", ""], 'picturescales = [0.5, 1.0])$

     Pontos no espaço tridimensional podem ser vistos como uma projeção
     no plano. Nesse exemplo, o gráfico de velocidades do vento
     correspondendo a três estações meteorológicas são requisitados,
     primeiramente em um gráfico em 3D e a seguir em um gráfico de
     dispersào de várias variáveis.

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) /* 3D plot */ dataplot (submatrix (s2, 4, 5), 'pointstyle = 2,
           'maintitle = "Pares de medidas de velocidades do vento em nós",
           'axisnames = ["Estação A", "Estação B", "Estação C"])$
          (%i5) /* Gráfico de dispersão de várias variáveis */ dataplot (submatrix (s2, 4, 5),
           'nclasses = 6, 'threedim = false)$
     Note que no último exemplo, o número de classes no histogramas da
     diagonal é escolhido para 6, e aquela opção `'threedim' for
     escolhida para `false'.

     Para mais que três dimensões somente gráficos de dispersão de
     várias variáveis são possível, como em

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) dataplot (s2)$

 -- Função: histogram (<lista>)
 -- Função: histogram (<lista>, <opção_1>, <opção_2>, ...)
 -- Função: histogram (<one_column_matrix>)
 -- Função: histogram (<one_column_matrix>, <opção_1>, <opção_2>, ...)
     Essa função monta um gráfico de um histograma. Dados de amostras
     devem ser armazenados em uma lista de números ou em uma matriz de
     uma coluna. Fornecendo valores para as seguintes <opções> alguns
     aspéctos do gráfico podem ser controlados:

        * `'outputdev', o valor padrão é `"x"', indica o formato de
          ficheiro da figura de saída; valores correctos são `"x"',
          `"eps"' e `"png"', para a tela, formato de ficheiro
          postscript e formato de ficheiro png, respectivamente.

        * `'maintitle', o valor padrão é `""', é o título principal
          entre aspas duplas.

        * `'axisnames', o valor padrão é `["x", "Fr."]', é uma lista de
          nomes dos eixos `x' e `y'.

        * `'picturescales', o valor padrão é `[1.0, 1.0]', factor de
          proporcionalidade para o tamanho do gráfico.

        * `'nclasses', o valor padrão é `10', é o número de classes ou
          o número de barras.

        * `'relbarwidth', o valor padrão é `0.9', um número decimao
          entre 0 e 1 para controlar a largura das barras.

        * `'barcolor', o valor padrão é `1', um inteiro para indicar a
          cor das barras.

        * `'colorintensity', o valor padrão é `1', um número decimal
          entre 0 e 1 para estabelecer a intensidade da cor.


     Nos próximos dois exemplos, histogramas são requisitados para os
     primeiros 100 dígitos do número `%pi' e para velocidades do vento
     na terceira estação meteorológica.

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) histogram (s1, 'maintitle = "dígitos de pi", 'axisnames = ["", "Frequência absoluta"],
           'relbarwidth = 0.2, 'barcolor = 3, 'colorintensity = 0.6)$
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) histogram (col (s2, 3), 'colorintensity = 0.3)$
     Note tque no primeiro caso, `s1' é uma lista  e o segundo exemplo,
     `col(s2,3)' é uma matriz.

     Veja também a função `barsplot'.

 -- Função: barsplot (<lista>)
 -- Função: barsplot (<lista>, <opção_1>, <opção_2>, ...)
 -- Função: barsplot (<one_column_matrix>)
 -- Função: barsplot (<one_column_matrix>, <opção_1>, <opção_2>, ...)
     Similar a `histogram' mas para variáveis estatísticas, numéricas
     ou divididas em categorias. As opções estão abaixo,

        * `'outputdev', o valor padrão é `"x"', indica o formato de
          ficheiro da figura de saída; valores correctos são `"x"',
          `"eps"' e `"png"', para a tela, formato de ficheiro
          postscript e formato de ficheiro png, respectivamente.

        * `'maintitle', o valor padrão é `""', é o título principal
          entre aspas duplas.

        * `'axisnames', o valor padrão é `["x", "Fr."]', é uma lista de
          nomes dos eixos `x' e `y'.

        * `'picturescales', o valor padrão é `[1.0, 1.0]', factor de
          proporcionalidade para o tamanho do gráfico.

        * `'relbarwidth', o valor padrão é `0.9', um número decimao
          entre 0 e 1 para controlar a largura das barras.

        * `'barcolor', o valor padrão é `1', um inteiro para indicar a
          cor das barras.

        * `'colorintensity', o valor padrão é `1', um número decimal
          entre 0 e 1 para estabelecer a intensidade da cor.


     Esse exemplo monta um gráfico de barras para os grupos `A' e `B'
     de pacientes na amostra `s3',

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) barsplot (col (s3, 1), 'maintitle = "Grupos de pacientes",
           'axisnames = ["Grupo", "# de indivíduos"], 'colorintensity = 0.2)$
     A primeira coluna na amostra `s3' armazena os valores das
     categorias `A' e `B', também conhecidos algumas vezes como
     factores. Por outro lado, os números inteiros positivos na segunda
     coluna sào idades, em anos, que se comportam como variável
     discreta, então podemos montar um gráfico as freqyuências
     absolutas para esses valores,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) barsplot (col (s3, 2), 'maintitle = "Idades",
           'axisnames = ["Anos", "# dos indivíduos"], 'colorintensity = 0.2,
           'relbarwidth = 0.6)$

     Veja também a função `histogram'.

 -- Função: boxplot (<data>)
 -- Função: boxplot (<data>, <opção_1>, <opção_2>, ...)
     Essa função monta diagramas em caixas. O argumento <data> pode ser
     uma lista, que não é de grande interesse, uma vez que esses
     diagramas são principalmente usados para comparação entre
     diferentes amostras, ou uma matriz, eentão é possível comparar
     dois ou mais componentes de uma variável estatística de várias
     variáveis. Mas é também permitido <data> se uma lista de amostras
     com tamanhos diferentes de amostra, de facto essa é aa única
     função no pacote `descriptive' que admite esse tipo de estrutura
     de dados. Veja o exemplo abaixo.  Abaixo etão as opções,

        * `'outputdev', o valor padrão é `"x"', indica o formato de
          ficheiro da figura de saída; valores correctos são `"x"',
          `"eps"' e `"png"', para a tela, formato de ficheiro
          postscript e formato de ficheiro png, respectivamente.

        * `'maintitle', o valor padrão é `""', é o título principal
          entre aspas duplas.

        * `'axisnames', o valor padrão é `["sample", "y"]', é uma lista
          de nomes dos eixos `x' e `y'.

        * `'picturescales', o valor padrão é `[1.0, 1.0]', factor de
          proporcionalidade para o tamanho do gráfico.


     Examples:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) boxplot (s2, 'maintitle = "Velocidade do vento em nós",
           'axisnames = ["Estação do ano", ""])$
          (%i5) A :
           [[6, 4, 6, 2, 4, 8, 6, 4, 6, 4, 3, 2],
            [8, 10, 7, 9, 12, 8, 10],
            [16, 13, 17, 12, 11, 18, 13, 18, 14, 12]]$
          (%i6) boxplot (A)$


File: maxima.info,  Node: diag,  Next: distrib,  Prev: descriptive,  Up: Top

45 diag
*******

* Menu:

* Definições para diag::


File: maxima.info,  Node: Definições para diag,  Prev: diag,  Up: diag

45.1 Definições para diag
=========================

 -- Função: diag (<lm>)
     Constrói a matriz quadrada com as matrizes de <lm> na diagonal.
     <lm> é uma lista de matrizes ou escalares.

     Exemplo:
          (%i1) load("diag")$

          (%i2) a1:matrix([1,2,3],[0,4,5],[0,0,6])$

          (%i3) a2:matrix([1,1],[1,0])$

          (%i4) diag([a1,x,a2]);
                             [ 1  2  3  0  0  0 ]
                             [                  ]
                             [ 0  4  5  0  0  0 ]
                             [                  ]
                             [ 0  0  6  0  0  0 ]
          (%o4)              [                  ]
                             [ 0  0  0  x  0  0 ]
                             [                  ]
                             [ 0  0  0  0  1  1 ]
                             [                  ]
                             [ 0  0  0  0  1  0 ]

     Para usar essa função escreva primeiramente `load("diag")'.

 -- Função: JF (<lambda>,<n>)
     Retorna a célula de Jordan de ordem <n> com autovalor <lambda>.

     Exemplo:
          (%i1) load("diag")$

          (%i2) JF(2,5);
                              [ 2  1  0  0  0 ]
                              [               ]
                              [ 0  2  1  0  0 ]
                              [               ]
          (%o2)               [ 0  0  2  1  0 ]
                              [               ]
                              [ 0  0  0  2  1 ]
                              [               ]
                              [ 0  0  0  0  2 ]
          (%i3) JF(3,2);
                                   [ 3  1 ]
          (%o3)                    [      ]
                                   [ 0  3 ]

     Para usar essa função escreva primeiramente `load("diag")'.

 -- Função: jordan (<mat>)
     Retorna a forma de Jordan da matriz <mat>, mas codificada em uma
     lista do Maxima.  Para pegar a matriz correspondente à
     codificação, chame a função `dispJordan' sando como argumento a
     saída de `JF'.

     Exemplo:
          (%i1) load("diag")$

          (%i3) a:matrix([2,0,0,0,0,0,0,0],
                         [1,2,0,0,0,0,0,0],
                         [-4,1,2,0,0,0,0,0],
                         [2,0,0,2,0,0,0,0],
                         [-7,2,0,0,2,0,0,0],
                         [9,0,-2,0,1,2,0,0],
                         [-34,7,1,-2,-1,1,2,0],
                         [145,-17,-16,3,9,-2,0,3])$

          (%i34) jordan(a);
          (%o4)             [[2, 3, 3, 1], [3, 1]]
          (%i5) dispJordan(%);
                          [ 2  1  0  0  0  0  0  0 ]
                          [                        ]
                          [ 0  2  1  0  0  0  0  0 ]
                          [                        ]
                          [ 0  0  2  0  0  0  0  0 ]
                          [                        ]
                          [ 0  0  0  2  1  0  0  0 ]
          (%o5)           [                        ]
                          [ 0  0  0  0  2  1  0  0 ]
                          [                        ]
                          [ 0  0  0  0  0  2  0  0 ]
                          [                        ]
                          [ 0  0  0  0  0  0  2  0 ]
                          [                        ]
                          [ 0  0  0  0  0  0  0  3 ]

     Para usar essa função escreva primeiramente `load("diag")'. Veja
     também `dispJordan' e `minimalPoly'.

 -- Função: dispJordan (<l>)
     Retorna a matriz de Jordan associada à codificação fornecida pela
     lista do Maxima <l>, que é a saída fornecida pela função `jordan'.

     Exemplo:
          (%i1) load("diag")$

          (%i2) b1:matrix([0,0,1,1,1],
                          [0,0,0,1,1],
                          [0,0,0,0,1],
                          [0,0,0,0,0],
                          [0,0,0,0,0])$

          (%i3) jordan(b1);
          (%o3)                  [[0, 3, 2]]
          (%i4) dispJordan(%);
                              [ 0  1  0  0  0 ]
                              [               ]
                              [ 0  0  1  0  0 ]
                              [               ]
          (%o4)               [ 0  0  0  0  0 ]
                              [               ]
                              [ 0  0  0  0  1 ]
                              [               ]
                              [ 0  0  0  0  0 ]

     Para usar essa função escreva primeiramente `load("diag")'. Veja
     também `jordan' e `minimalPoly'.

 -- Função: minimalPoly (<l>)
     Retorna o menor polinómio associado à codificação fornecida pela
     lista do Maxima <l>, que é a saída fornecida pela função `jordan'.

     Exemplo:
          (%i1) load("diag")$

          (%i2) a:matrix([2,1,2,0],
                         [-2,2,1,2],
                         [-2,-1,-1,1],
                         [3,1,2,-1])$

          (%i3) jordan(a);
          (%o3)               [[- 1, 1], [1, 3]]
          (%i4) minimalPoly(%);
                                      3
          (%o4)                (x - 1)  (x + 1)

     Para usar essa função escreva prmeiramente `load("diag")'. Veja
     também `jordan' e `dispJordan'.

 -- Função: ModeMatrix (<A>,<l>)
     Retorna a matriz <M> tal que (M^^-1).A.M=J, onde <J> é a forma de
     Jordan de <A>. A lista do Maxima <l> é a codificação da forma de
     Jordan como retornado pela função `jordan'.

     Exemplo:
          (%i1) load("diag")$

          (%i2) a:matrix([2,1,2,0],
                    [-2,2,1,2],
                    [-2,-1,-1,1],
                    [3,1,2,-1])$

          (%i3) jordan(a);
          (%o3)               [[- 1, 1], [1, 3]]
          (%i4) M: ModeMatrix(a,%);
                            [  1    - 1   1   1 ]
                            [                   ]
                            [   1               ]
                            [ - -   - 1   0   0 ]
                            [   9               ]
                            [                   ]
          (%o4)             [   13              ]
                            [ - --   1   - 1  0 ]
                            [   9               ]
                            [                   ]
                            [  17               ]
                            [  --   - 1   1   1 ]
                            [  9                ]
          (%i5) is(  (M^^-1).a.M = dispJordan(%o3)  );
          (%o5)                      true
     Note que `dispJordan(%o3)' é a forma de Jordan da matriz `a'.

     Para usa essa função escreva primeiramente `load("diag")'. Veja
     também `jordan' e `dispJordan'.

 -- Função: mat_function (<f>,<mat>)
     Retorna f(mat), onde <f> é uma função analítica e <mat> uma
     matriz. Essa computação é baseada na fórmula da integral de
     Cauchy, que estabelece que se `f(x)' for analítica e

          mat=diag([JF(m1,n1),...,JF(mk,nk)]),

     então

          f(mat)=ModeMatrix*diag([f(JF(m1,n1)),...,f(JF(mk,nk))])*ModeMatrix^^(-1)

     Note que existem entre 6 ou 8 outros métodos para esse cálculo.

     Segue-se alguns exemplos.

     Exemplo 1:
          (%i1) load("diag")$

          (%i2) b2:matrix([0,1,0], [0,0,1], [-1,-3,-3])$

          (%i3) mat_function(exp,t*b2);
                         2   - t
                        t  %e          - t     - t
          (%o3) matrix([-------- + t %e    + %e   ,
                           2
                  - t     - t                           - t
           2    %e      %e        - t           - t   %e
          t  (- ----- - ----- + %e   ) + t (2 %e    - -----)
                  t       2                             t
                         t
                                   - t          - t     - t
                 - t       - t   %e        2  %e      %e
           + 2 %e   , t (%e    - -----) + t  (----- - -----)
                                   t            2       t
                         2   - t            - t     - t
               - t      t  %e        2    %e      %e        - t
           + %e   ], [- --------, - t  (- ----- - ----- + %e   ),
                           2                t       2
                                                   t
                  - t     - t      2   - t
             2  %e      %e        t  %e          - t
          - t  (----- - -----)], [-------- - t %e   ,
                  2       t          2
                  - t     - t                           - t
           2    %e      %e        - t           - t   %e
          t  (- ----- - ----- + %e   ) - t (2 %e    - -----),
                  t       2                             t
                         t
                - t     - t                 - t
           2  %e      %e            - t   %e
          t  (----- - -----) - t (%e    - -----)])
                2       t                   t
          (%i4) ratsimp(%);
                         [   2              - t ]
                         [ (t  + 2 t + 2) %e    ]
                         [ -------------------- ]
                         [          2           ]
                         [                      ]
                         [         2   - t      ]
          (%o4)  Col 1 = [        t  %e         ]
                         [      - --------      ]
                         [           2          ]
                         [                      ]
                         [     2          - t   ]
                         [   (t  - 2 t) %e      ]
                         [   ----------------   ]
                         [          2           ]
                   [      2        - t    ]
                   [    (t  + t) %e       ]
                   [                      ]
           Col 2 = [     2            - t ]
                   [ - (t  - t - 1) %e    ]
                   [                      ]
                   [     2          - t   ]
                   [   (t  - 3 t) %e      ]
                   [        2   - t       ]
                   [       t  %e          ]
                   [       --------       ]
                   [          2           ]
                   [                      ]
                   [      2          - t  ]
           Col 3 = [    (t  - 2 t) %e     ]
                   [  - ----------------  ]
                   [           2          ]
                   [                      ]
                   [   2              - t ]
                   [ (t  - 4 t + 2) %e    ]
                   [ -------------------- ]
                   [          2           ]

     Exemplo 2:
          (%i5) b1:matrix([0,0,1,1,1],
                          [0,0,0,1,1],
                          [0,0,0,0,1],
                          [0,0,0,0,0],
                          [0,0,0,0,0])$

          (%i6) mat_function(exp,t*b1);
                            [              2     ]
                            [             t      ]
                            [ 1  0  t  t  -- + t ]
                            [             2      ]
                            [                    ]
          (%o6)             [ 0  1  0  t    t    ]
                            [                    ]
                            [ 0  0  1  0    t    ]
                            [                    ]
                            [ 0  0  0  1    0    ]
                            [                    ]
                            [ 0  0  0  0    1    ]
          (%i7) minimalPoly(jordan(b1));
                                       3
          (%o7)                       x
          (%i8) ident(5)+t*b1+1/2*(t^2)*b1^^2;
                            [              2     ]
                            [             t      ]
                            [ 1  0  t  t  -- + t ]
                            [             2      ]
                            [                    ]
          (%o8)             [ 0  1  0  t    t    ]
                            [                    ]
                            [ 0  0  1  0    t    ]
                            [                    ]
                            [ 0  0  0  1    0    ]
                            [                    ]
                            [ 0  0  0  0    1    ]
          (%i9) mat_function(exp,%i*t*b1);
                       [                           2 ]
                       [                          t  ]
                       [ 1  0  %i t  %i t  %i t - -- ]
                       [                          2  ]
                       [                             ]
          (%o9)        [ 0  1   0    %i t    %i t    ]
                       [                             ]
                       [ 0  0   1     0      %i t    ]
                       [                             ]
                       [ 0  0   0     1        0     ]
                       [                             ]
                       [ 0  0   0     0        1     ]
          (%i10) mat_function(cos,t*b1)+%i*mat_function(sin,t*b1);
                        [                           2 ]
                        [                          t  ]
                        [ 1  0  %i t  %i t  %i t - -- ]
                        [                          2  ]
                        [                             ]
          (%o10)        [ 0  1   0    %i t    %i t    ]
                        [                             ]
                        [ 0  0   1     0      %i t    ]
                        [                             ]
                        [ 0  0   0     1        0     ]
                        [                             ]
                        [ 0  0   0     0        1     ]

     Exemplo 3:
          (%i11) a1:matrix([2,1,0,0,0,0],
                           [-1,4,0,0,0,0],
                           [-1,1,2,1,0,0],
                           [-1,1,-1,4,0,0],
                           [-1,1,-1,1,3,0],
                           [-1,1,-1,1,1,2])$

          (%i12) fpow(x):=block([k],declare(k,integer),x^k)$

          (%i13) mat_function(fpow,a1);
                          [  k      k - 1 ]         [      k - 1    ]
                          [ 3  - k 3      ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [  k      k - 1 ]
                          [  - k 3        ]         [ 3  + k 3      ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
          (%o13)  Col 1 = [               ] Col 2 = [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                   [       0       ]         [       0       ]
                   [               ]         [               ]
                   [       0       ]         [       0       ]
                   [               ]         [               ]
                   [  k      k - 1 ]         [      k - 1    ]
                   [ 3  - k 3      ]         [   k 3         ]
                   [               ]         [               ]
           Col 3 = [       k - 1   ] Col 4 = [  k      k - 1 ]
                   [  - k 3        ]         [ 3  + k 3      ]
                   [               ]         [               ]
                   [       k - 1   ]         [      k - 1    ]
                   [  - k 3        ]         [   k 3         ]
                   [               ]         [               ]
                   [       k - 1   ]         [      k - 1    ]
                   [  - k 3        ]         [   k 3         ]
                   [    0    ]
                   [         ]         [ 0  ]
                   [    0    ]         [    ]
                   [         ]         [ 0  ]
                   [    0    ]         [    ]
                   [         ]         [ 0  ]
           Col 5 = [    0    ] Col 6 = [    ]
                   [         ]         [ 0  ]
                   [    k    ]         [    ]
                   [   3     ]         [ 0  ]
                   [         ]         [    ]
                   [  k    k ]         [  k ]
                   [ 3  - 2  ]         [ 2  ]

     Para usar essa função escreva primeiramente `load("diag")'.


File: maxima.info,  Node: distrib,  Next: dynamics,  Prev: diag,  Up: Top

46 distrib
**********

* Menu:

* Introdução a distrib::
* Definições para distribuições contínuas::
* Definições para distribuições discretas::


File: maxima.info,  Node: Introdução a distrib,  Next: Definições para distribuições contínuas,  Prev: distrib,  Up: distrib

46.1 Introdução a distrib
=========================

Pacote `distrib' contém um conjunto de funções para fazer cálculos
envolvendo probabilidades de modelos de uma única variável estatística
e de ambos os tipos discreta e contínua.

O que segue é um curto resumo de definiçoes básicas relacionadas à
teoria das probabilidades.

Seja f(x) a <função densidade de probabilidade> absoluta de uma
variável aleatória contínua X. A <função distribuição de probabilidade>
é definida como
                            x
                           /
                           [
                    F(x) = I     f(u) du
                           ]
                           /
                            minf
que é igual à probabilidade <Pr(X <= x)>.

O valor <médio> é um parâmetro de localização e está definido como
                          inf
                         /
                         [
                E[X]  =  I   x f(x) dx
                         ]
                         /
                          minf

A <variância> é uma medida de variação,
                      inf
                     /
                     [                    2
              V[X] = I     f(x) (x - E[X])  dx
                     ]
                     /
                      minf
que é um número real positivo. A raíz quadrada da variância é o <desvio
padrão>, D[X]=sqrt(V[X]), e esse <desvio padrão> é outra medida de
variação.

O <coeficiente de assimetria> é uma medida de não simetria,
                      inf
                     /
                 1   [                    3
       SK[X] = ----- I     f(x) (x - E[X])  dx
                   3 ]
               D[X]  /
                      minf

E o <coeficiente de curtose> mede o grau de achatamento de uma
distribuição,
                      inf
                     /
                 1   [                    4
       KU[X] = ----- I     f(x) (x - E[X])  dx - 3
                   4 ]
               D[X]  /
                      minf
Se X for gaussiana, KU[X]=0. De facto, ambos assimetria e curtose são
parâmetros de ajuste usados para medir a não gaussianidade de uma
distribuição.

Se a variável aleatória X for discreta, a função densidade de
probabilidade, ou simplesmente <probabilidade>, f(x) toma valores
positivos dentro de certos conjuntos contáveis de números x_i, e zero
em caso contrário. Nesse caso, a função distribuição de probabilidade é
                            ====
                            \
                     F(x) =  >    f(x )
                            /        i
                            ====
                           x <= x
                            i

A média, variância, desvio padrão, coeficiente de assimetria e
coeficiente de curtose tomam a forma
                            ====
                            \
                     E[X] =  >  x  f(x ) ,
                            /    i    i
                            ====
                             x
                              i

                     ====
                     \                     2
             V[X] =   >    f(x ) (x - E[X])  ,
                     /        i    i
                     ====
                      x
                       i

                    D[X] = sqrt(V[X]),

                          ====
                   1      \                     3
       SK[X] =  -------    >    f(x ) (x - E[X])
                D[X]^3    /        i    i
                          ====
                           x
                            i
and
                          ====
                   1      \                     4
       KU[X] =  -------    >    f(x ) (x - E[X])   - 3 ,
                D[X]^4    /        i    i
                          ====
                           x
                            i
respectively.

O Pacote `distrib' inclui funções para simulação de variáveis
estatísticas pseudo-aleatórias. Algumas dessas funções fazem uso de
variáveis opcionais que indicam o algoritmo a ser usado.  O método
inverso genérico (baseado no facto que se <u> for um número aleatório
uniforme no intervalo (0,1), então <F^(-1)(u)> é uma variável
estatística pseudo-aleatória com distribuição F) está implementada para
a maioria dos casos; isso é um método subóptimo em termos de
cronometragem, mas útil para fazer comparações com outros algoritmos.
Nesse exemplo, a `perandom_formance' dos algoritmos `ahrens_cheng' e
`inverse' em simular  variáveis chi-quadradas (letra grega "chi") são
comparadas por meio de seus histogramas:

     (%i1) load(distrib)$
     (%i2) load(descriptive)$
     (%i3) showtime: true$
     Evaluation took 0.00 seconds (0.00 elapsed) using 32 bytes.
     (%i4) random_chi2_algorithm: 'ahrens_cheng$ histogram(random_chi2(10,500))$
     Evaluation took 0.00 seconds (0.00 elapsed) using 40 bytes.
     Evaluation took 0.69 seconds (0.71 elapsed) using 5.694 MB.
     (%i6) random_chi2_algorithm: 'inverse$ histogram(random_chi2(10,500))$
     Evaluation took 0.00 seconds (0.00 elapsed) using 32 bytes.
     Evaluation took 10.15 seconds (10.17 elapsed) using 322.098 MB.

Com o objectivo de fazer comparações visuais entre algoritmos para uma
variável estatística discreta, a função `barsplot' do pacote
`descriptive' pode ser usada.

Note que algum trabalho resta para ser realizado, uma vez que essas
funções de simulação não foram ainda verificadas pelos mais
rigorosamente melhores dos testes de ajuste.

Por favor, consulte um manual introdutório sobre probabilidade e
estatística para maiores informações sobre todo esse material
matemático.

Existe uma convenção de nome no pacote `distrib'. Todo nome de função
tem duas partes, a primeira faz referência à função ou ao parâmetro que
queremos calcular,
     Funções:
        função densidade de probabilidade            (pdf_*)
        função distribuição de probabilidade       (cdf_*)
        Quartil                    (quantile_*)
        Média                        (mean_*)
        Variância                    (var_*)
        Desvio padrão          (std_*)
        Coeficiente de assimetria        (skewness_*)
        Coeficiente de curtose        (kurtosis_*)
        Variável estatística pseudo-aleatória              (random_*)

A segunda parte é uma referência explícita ao modelo probabilístico,
     Distribuíções contínuas:
        Normal              (*normal)
        Student             (*student_t)
        Chi^2               (*chi2)
        F                   (*f)
        Exponencial         (*exp)
        Lognormal           (*lognormal)
        Gama               (*gamma)
        Beta                (*beta)
        contínua uniforme  (*continuous_uniform)
        Logística            (*logistic)
        Pareto              (*pareto)
        Weibull             (*weibull)
        Rayleigh            (*rayleigh)
        Laplace             (*laplace)
        Cauchy              (*cauchy)
        Gumbel              (*gumbel)

     Distribuições discretas:
        Binomial             (*binomial)
        Poisson              (*poisson)
        Bernoulli            (*bernoulli)
        Geométrica            (*geometric)
        discreta uniforme     (*discrete_uniform)
        hipergeométrica       (*hypergeometric)
        Binomial Negativa    (*negative_binomial)

Por exemplo, `pdf_student_t(x,n)' é a função densidade de probabilidade
da distribuição de Student com <n> graus de liberdade,
`std_pareto(a,b)' é o desvio padrão da distribuição de Pareto com
parâmetros <a> e <b> e `kurtosis_poisson(m)' é o coeficiente de curtose
da distribuição de Poisson com média <m>.

Para poder usar o pacote `distrib' precisa primeiro carregá-lo
escrevendo
     (%i1) load(distrib)$

Para comentários, melhorias ou sugestões, por favor contacte o autor em
<'mario AT edu DOT xunta DOT es'>.


File: maxima.info,  Node: Definições para distribuições contínuas,  Next: Definições para distribuições discretas,  Prev: Introdução a distrib,  Up: distrib

46.2 Definições para distribuições contínuas
============================================

 -- Função: pdf_normal (<x>,<m>,<s>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Normal(m,s), com s>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_normal (<x>,<m>,<s>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma  variável aleatória Normal(m,s), com s>0. Essa função é
     definida em termos de funções de erro internas do Maxima, `erf'.

          (%i1) load (distrib)$
          (%i2) assume(s>0)$ cdf_normal(x,m,s);
                                       x - m
                                 erf(---------)
                                     sqrt(2) s    1
          (%o3)                  -------------- + -
                                       2          2

     Veja também `erf'.

 -- Função: quantile_normal (<q>,<m>,<s>)
     Retorna o <q>-quantil de uma variável aleatória Normal(m,s), com
     s>0; em outras palavras, isso é o inverso de `cdf_normal'. O
     argumento <q> deve ser um elemento de [0,1]. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: mean_normal (<m>,<s>)
     Retorna a média de uma  variável aleatória Normal(m,s), com s>0, a
     saber <m>. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: var_normal (<m>,<s>)
     Retorna a variância de uma  variável aleatória Normal(m,s), com
     s>0, a saber <s^2>. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: std_normal (<m>,<s>)
     Retorna o desvio padrão de uma  variável aleatória Normal(m,s),
     com s>0, a saber <s>. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: skewness_normal (<m>,<s>)
     Retorna o coeficiente de assimetria de uma  variável aleatória
     Normal(m,s), com s>0, que é sempre igual  a 0. Para fazer uso
     dessa função,escreva primeiramente `load(distrib)'.

 -- Função: kurtosis_normal (<m>,<s>)
     Retorna o coeficiente de curtose de uma  variável aleatória
     Normal(m,s), com s>0, que é sempre igual  a 0. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Variável de opção: random_normal_algorithm
     Valor por omissão: `box_mueller'

     Esse é o algoritmo seleccionado para simular variáveis aleatórias
     normais.  O algoritmos implementados são `box_mueller' e `inverse':
        * `box_mueller', Baseado no algoritmo descrito em Knuth, D.E.
          (1981) <Seminumerical Algorithms. The Art of Computer
          Programming.> Addison-Wesley.

        * `inverse', baseado no método inverso genérico.

     Veja também `random_normal'.

 -- Função: random_normal (<m>,<s>)
 -- Função: random_normal (<m>,<s>,<n>)
     Retorna uma variável estatística pseudo-aleatória Normal(m,s), com
     s>0. Chamando `random_normal' com um terceiro argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Existem dois algoritmos implementados para essa função, e o
     algoritmo a ser usado pode ser seleccionado fornecendo um certo
     valor para a variável global `random_normal_algorithm', cujo valor
     padrão é `box_mueller'.

     Veja também `random_normal_algorithm'. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_student_t (<x>,<n>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória de Student t(n), com n>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_student_t (<x>,<n>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória de Student t(n), com n>0. Essa função não
     tem uma forma definitiva e é calculada numericamente se a variável
     global `numer' for igual a `true',  de outra froma `cdf_student_t'
     retorna uma expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_student_t(1/2, 7/3);
                                               1  7
          (%o2)                  cdf_student_t(-, -)
                                               2  3
          (%i3) %,numer;
          (%o3)                   .6698450596140417

 -- Função: quantile_student_t (<q>,<n>)
     Retorna o <q>-quantil de uma variável aleatória de Student t(n),
     com n>0; em outras palavras, `quantile_student_t' é o inverso de
     `cdf_student_t'. O argumento <q> deve ser um elemento de [0,1].
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: mean_student_t (<n>)
     Retorna a média de uma variável aleatória de Student t(n), com
     n>0, que é sempre igual a 0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: var_student_t (<n>)
     Retorna a variância de uma variável aleatória de Student t(n), com
     n>2.

          (%i1) load (distrib)$
          (%i2) assume(n>2)$  var_student_t(n);
                                          n
          (%o3)                         -----
                                        n - 2

 -- Função: std_student_t (<n>)
     Retorna o desvio padrão de uma variável aleatória de Student t(n),
     com n>2. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_student_t (<n>)
     Retorna o coeficiente de assimetria de uma variável aleatória de
     Student t(n), com n>3, que é sempre igual a 0. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: kurtosis_student_t (<n>)
     Retorna o coeficiente de curtose de uma variável aleatória de
     Student t(n), com n>4. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Variável de opção: random_student_t_algorithm
     Valor por omissão: `ratio'

     Esse é o  algoritmo seleccionado para simular variáveis
     estatísticas pseudo-aleatórias de Student. Algorítmos
     implementados são `inverse' e `ratio':
        * `inverse', baseado no método inverso genérico.

        * `ratio', baseado no facto que se <Z> for uma variável
          aleatória normal N(0,1) e S^2 for uma variável aleatória chi
          quadrada com <n> graus de liberdade, Chi^2(n), então
                                          Z
                                X = -------------
                                    /   2  \ 1/2
                                    |  S   |
                                    | ---  |
                                    \  n   /
          é uma variável aleatória de Student com <n> graus de
          liberdade, t(n).

     Veja também `random_student_t'.

 -- Função: random_student_t (<n>)
 -- Função: random_student_t (<n>,<m>)
     Retorna uma variável estatística pseudo-aleatória de Student t(n),
     com n>0. Chamando `random_student_t' com um segundo argumento <m>,
     uma amostra aleatória de tamanho <m> será simulada.

     Existem dois algoritmos implementados para essa função, se pode
     seleccionar o algoritmo a ser usado fornecendo um certo valor à
     variável global `random_student_t_algorithm', cujo valor padrão é
     `ratio'.

     Veja também `random_student_t_algorithm'. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_chi2 (<x>,<n>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Chi-quadrada Chi^2(n), com n>0.

     A  variável aleatória Chi^2(n) é equivalente a Gamma(n/2,2),
     portanto quando Maxima não tiver informação para pegar o
     resultado, uma forma nomial baseada na função de densidade
     densidade de probabilidade da função  gama é retornada.

          (%i1) load (distrib)$
          (%i2) pdf_chi2(x,n);
                                              n
          (%o2)                  pdf_gamma(x, -, 2)
                                              2
          (%i3) assume(x>0, n>0)$  pdf_chi2(x,n);
                                   n/2 - 1   - x/2
                                  x        %e
          (%o4)                   ----------------
                                    n/2       n
                                   2    gamma(-)
                                              2

 -- Função: cdf_chi2 (<x>,<n>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Chi-quadrada Chi^2(n), com n>0.

     Essa função não possui uma forma fechada e é calculada
     numericamante se a variável global `numer' for igual a `true',  de
     outra forma essa função retorna uma expressão nominal baseada na
     distribuição gama, uma vez que a variável aleatória Chi^2(n) é
     equivalente a    é equivalente a Gamma(n/2,2).

          (%i1) load (distrib)$
          (%i2) cdf_chi2(3,4);
          (%o2)                  cdf_gamma(3, 2, 2)
          (%i3) cdf_chi2(3,4),numer;
          (%o3)                   .4421745996289249

 -- Função: quantile_chi2 (<q>,<n>)
     Retorna o <q>-quantilede uma variável aleatória Chi-quadrada
     Chi^2(n), com n>0; em outras palavras, essa função é a inversa da
     função `cdf_chi2'. O argumento <q> deve ser um elemento de [0,1].

     This função não possui uma forma fechada e é calculada
     numericamante se a variável global `numer' for igual a `true',  de
     outra forma essa função retorna uma expressão nominal baseada no
     quantil da função gama, uma vez que a variável aleatória Chi^2(n)
     é equivalente a Gamma(n/2,2).

          (%i1) load (distrib)$
          (%i2) quantile_chi2(0.99,9);
          (%o2)                   21.66599433346194
          (%i3) quantile_chi2(0.99,n);
                                                  n
          (%o3)              quantile_gamma(0.99, -, 2)
                                                  2

 -- Função: mean_chi2 (<n>)
     Retorna a média de uma variável aleatória Chi-quadrada Chi^2(n),
     com n>0.

     A variável aleatória Chi^2(n) é equivalente a Gamma(n/2,2), embora
     quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na média da função gama é
     retornada.

          (%i1) load (distrib)$
          (%i2) mean_chi2(n);
                                             n
          (%o2)                   mean_gamma(-, 2)
                                             2
          (%i3) assume(n>0)$ mean_chi2(n);
          (%o4)                           n

 -- Função: var_chi2 (<n>)
     Retorna a variância de uma variável aleatória Chi-quadrada
     Chi^2(n), com n>0.

     A variável aleatória Chi^2(n) é equivalente a Gamma(n/2,2), embora
     quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na variância da função gama é
     retornada.

          (%i1) load (distrib)$
          (%i2) var_chi2(n);
                                             n
          (%o2)                    var_gamma(-, 2)
                                             2
          (%i3) assume(n>0)$ var_chi2(n);
          (%o4)                          2 n

 -- Função: std_chi2 (<n>)
     Retorna o desvio padrão de uma variável aleatória Chi-quadrada
     Chi^2(n), com n>0.

     A variável aleatória Chi^2(n) é equivalente a Gamma(n/2,2), embora
     quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no desvio padrão da função
     gama é retornada.

          (%i1) load (distrib)$
          (%i2) std_chi2(n);
                                             n
          (%o2)                    std_gamma(-, 2)
                                             2
          (%i3) assume(n>0)$ std_chi2(n);
          (%o4)                    sqrt(2) sqrt(n)

 -- Função: skewness_chi2 (<n>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Chi-quadrada Chi^2(n), com n>0.

     A variável aleatória Chi^2(n) é equivalente a Gamma(n/2,2), embora
     quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de assimetria
     da função gama é retornada.

          (%i1) load (distrib)$
          (%i2) skewness_chi2(n);
                                               n
          (%o2)                 skewness_gamma(-, 2)
                                               2
          (%i3) assume(n>0)$ skewness_chi2(n);
                                      2 sqrt(2)
          (%o4)                       ---------
                                       sqrt(n)

 -- Função: kurtosis_chi2 (<n>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Chi-quadrada Chi^2(n), com n>0.

     A variável aleatória Chi^2(n) é equivalente a Gamma(n/2,2), embora
     quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de curtose da
     função gama é retornada.

          (%i1) load (distrib)$
          (%i2) kurtosis_chi2(n);
                                               n
          (%o2)                 kurtosis_gamma(-, 2)
                                               2
          (%i3) assume(n>0)$ kurtosis_chi2(n);
                                         12
          (%o4)                          --
                                         n

 -- Variável de opção: random_chi2_algorithm
     Valor por omissão: `ahrens_cheng'

     Esse é o algoritmo seleccionado para simular variáveis estatística
     pseudo-aleatórias Chi-quadradas. Os algoritmos implementados são
     `ahrens_cheng' e `inverse':
        * `ahrens_cheng', baseado na simulação aleatória de variáveis
          gama.  Veja `random_gamma_algorithm' para mais detalhes.

        * `inverse', baseado no método inverso genérico.


     Veja também `random_chi2'.

 -- Função: random_chi2 (<n>)
 -- Função: random_chi2 (<n>,<m>)
     Retorna uma variável estatística pseudo-aleatória Chi-square
     Chi^2(n), com n>0. Chamando `random_chi2' com um segundo argumento
     <m>, uma amostra aleatória de tamanho <m> será simulada.

     Existem dois algoritmos implementados para essa função, se pode
     seleccionar o algoritmo a ser usado fornecendo um certo valor à
     variável global `random_chi2_algorithm', cujo valor padrão é
     `ahrens_cheng'.

     Veja também `random_chi2_algorithm'. Para fazer uso dessa função,
     escreva primeiramente `load(distrib)'.

 -- Função: pdf_f (<x>,<m>,<n>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória F, F(m,n), com m,n>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_f (<x>,<m>,<n>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória F, F(m,n), com m,n>0. Essa função não
     possui uma forma definitiva e é calculada numericamente se a
     variável global `numer' for igual a `true',  de outra forma
     retorna uma expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_f(2,3,9/4);
                                               9
          (%o2)                    cdf_f(2, 3, -)
                                               4
          (%i3) %,numer;
          (%o3)                   0.66756728179008

 -- Função: quantile_f (<q>,<m>,<n>)
     Retorna o <q>-quantil de uma variável aleatória F, F(m,n), com
     m,n>0; em outras palavras, essa função é o inverso de `cdf_f'. O
     argumento <q> deve ser um elemento de [0,1].

     Essa função não possui uma forma fechada e é calculada
     numericamante se a variável global `numer' for igual a `true',  de
     outra forma essa função retorna uma expressão nominal.

          (%i1) load (distrib)$
          (%i2) quantile_f(2/5,sqrt(3),5);
                                         2
          (%o2)               quantile_f(-, sqrt(3), 5)
                                         5
          (%i3) %,numer;
          (%o3)                   0.518947838573693

 -- Função: mean_f (<m>,<n>)
     Retorna a média de uma variável aleatória F, F(m,n), com m>0, n>2.
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: var_f (<m>,<n>)
     Retorna a variância de uma variável aleatória F, F(m,n), com m>0,
     n>4.  Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: std_f (<m>,<n>)
     Retorna o desvio padrão de uma variável aleatória F, F(m,n), com
     m>0, n>4.  Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_f (<m>,<n>)
     Retorna o coeficiente de assimetria de uma variável aleatória F,
     F(m,n), com m>0, n>6. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: kurtosis_f (<m>,<n>)
     Retorna o coeficiente de curtose de uma variável aleatória F,
     F(m,n), com m>0, n>8. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Variável de opção: random_f_algorithm
     Valor por omissão: `inverse'

     Esse é o algoritmo seleccionado para simular variáveis estatísticas
     pseudo-aleatórias F. Os algoritmos implementados são `ratio' e
     `inverse':
        * `ratio', baseado no facto de que se <X> for uma variável
          aleatória Chi^2(m) e Y for uma variável aleatória Chi^2(n),
          então
                                       n X
                                   F = ---
                                       m Y
          é uma variável aleatória F com <m> e <n> graus de liberdade,
          F(m,n).

        * `inverse', baseado no método inverso genérico.


     Veja também `random_f'.

 -- Função: random_f (<m>,<n>)
 -- Função: random_f (<m>,<n>,<k>)
     Retorna uma variável estatística pseudo-aleatória F, F(m,n), com
     m,n>0. Chamando `random_f' com um terceiro argumento <k>, uma
     amostra aleatória de tamanho <k> será simulada.

     Existem dois algoritmos implementados para essa função, se pode
     seleccionar o algoritmo a ser usado fornecendo um certo valor à
     variável global `random_f_algorithm', cujo valor padrão é
     `inverse'.

     Veja também `random_f_algorithm'. Para fazer uso dessa função,
     escreva primeiramente `load(distrib)'.

 -- Função: pdf_exp (<x>,<m>)
     Retorna o valor em <x> da função densidade de probabilidade
     variável aleatória Exponential(m), com m>0.

     A variável aleatória Exponential(m) é equivalente a
     Weibull(1,1/m), embora quando Maxima não tiver informação
     disponível para pegar o resultado, uma forma nominal baseada na
     função de densidade de probabilidade de Weibull éretornada.

          (%i1) load (distrib)$
          (%i2) pdf_exp(x,m);
                                                  1
          (%o2)                 pdf_weibull(x, 1, -)
                                                  m
          (%i3) assume(x>0,m>0)$  pdf_exp(x,m);
                                          - m x
          (%o4)                       m %e

 -- Função: cdf_exp (<x>,<m>)
     Retorna o valor em <x> da função distribuição de probabilidade
     variável aleatória Exponential(m), com m>0.

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na distribuição de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) cdf_exp(x,m);
                                                  1
          (%o2)                 cdf_weibull(x, 1, -)
                                                  m
          (%i3) assume(x>0,m>0)$  cdf_exp(x,m);
                                           - m x
          (%o4)                      1 - %e

 -- Função: quantile_exp (<q>,<m>)
     Retorna o <q>-quantil variável aleatória Exponential(m), com m>0;
     em outras palavras, essa função é inversa da função `cdf_exp'.  O
     argumento <q> deve ser um elemento de [0,1].

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no qualtil de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) quantile_exp(0.56,5);
          (%o2)                   .1641961104139661
          (%i3) quantile_exp(0.56,m);
                                                      1
          (%o3)             quantile_weibull(0.56, 1, -)
                                                      m

 -- Função: mean_exp (<m>)
     Retorna a média de uma variável aleatória Exponential(m), com m>0.

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na média de Weibull é
     reornada.

          (%i1) load (distrib)$
          (%i2) mean_exp(m);
                                                 1
          (%o2)                  mean_weibull(1, -)
                                                 m
          (%i3) assume(m>0)$  mean_exp(m);
                                          1
          (%o4)                           -
                                          m

 -- Função: var_exp (<m>)
     Retorna a variância de uma variável aleatória Exponential(m), com
     m>0.

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na variância de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) var_exp(m);
                                                 1
          (%o2)                   var_weibull(1, -)
                                                 m
          (%i3) assume(m>0)$  var_exp(m);
                                         1
          (%o4)                          --
                                          2
                                         m

 -- Função: std_exp (<m>)
     Retorna o desvio padrão de uma variável aleatória Exponential(m),
     com m>0.

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no desvio padrão de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) std_exp(m);
                                                 1
          (%o2)                   std_weibull(1, -)
                                                 m
          (%i3) assume(m>0)$  std_exp(m);
                                          1
          (%o4)                           -
                                          m

 -- Função: skewness_exp (<m>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Exponential(m), com m>0.

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de assimetria
     de Weibull é retornada.

          (%i1) load (distrib)$
          (%i2) skewness_exp(m);
                                                   1
          (%o2)                skewness_weibull(1, -)
                                                   m
          (%i3) assume(m>0)$  skewness_exp(m);
          (%o4)                           2

 -- Função: kurtosis_exp (<m>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Exponential(m), com m>0.

     A variável aleatória Exponential(m) é equivalente a
     Weibull(1,1/m), embora quando Maxima não tiver informação
     disponível para pegar o resultado, uma forma nominal baseada no
     coeficiente de curtose de Weibull é retornada.

          (%i1) load (distrib)$
          (%i2) kurtosis_exp(m);
                                                   1
          (%o2)                kurtosis_weibull(1, -)
                                                   m
          (%i3) assume(m>0)$  kurtosis_exp(m);
          (%o4)                           6

 -- Variável de opção: random_exp_algorithm
     Valor por omissão: `inverse'

     Esse é o algoritmo seleccionado para simular variáveis
     exponenciais estatística pseudo-aleatórias. Os algoritmos
     implementados são `inverse', `ahrens_cheng' e `ahrens_dieter'
        * `inverse', baseado no método inverso genérico.

        * `ahrens_cheng', baseado no facto de que a variável aleatória
          Exp(m) é equivalente a Gamma(1,1/m). Veja
          `random_gamma_algorithm' para maiores detalhes.

        * `ahrens_dieter', baseado no algoritmo descrito em Ahrens,
          J.H. e Dieter, U. (1972) <Computer methods for sampling from
          the exponential and normal distributions.> Comm, ACM, 15,
          Oct.,  873-882.


     Veja também `random_exp'.

 -- Função: random_exp (<m>)
 -- Função: random_exp (<m>,<k>)
     Retorna uma variável estatística pseudo-aleatória Exponential(m),
     com m>0. Chamando `random_exp' com um segundo argumento <k>, uma
     amostra aleatória de tamanho <k> será simulada.

     Existem três algoritmos implementados para essa função, se pode
     seleccionar o algoritmo a ser usado fornecendo um certo valor à
     variável global `random_exp_algorithm', cujo valor padrão é
     `inverse'.

     Veja também `random_exp_algorithm'. Para fazer uso dessa função,
     escreva primeiramente `load(distrib)'.

 -- Função: pdf_lognormal (<x>,<m>,<s>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Lognormal(m,s), com s>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_lognormal (<x>,<m>,<s>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Lognormal(m,s), com s>0. Essa função é
     definida em termos de funções `erf'de erro internas do Maxima.

          (%i1) load (distrib)$
          (%i2) assume(x>0, s>0)$  cdf_lognormal(x,m,s);
                                     log(x) - m
                                 erf(----------)
                                     sqrt(2) s     1
          (%o3)                  --------------- + -
                                        2          2

     Veja também `erf'.

 -- Função: quantile_lognormal (<q>,<m>,<s>)
     Retorna o <q>-quantil de uma variável aleatória Lognormal(m,s),
     com s>0; em outras palavras, essa função é a inversa da função
     `cdf_lognormal'. O argumento <q> deve ser um elemento de [0,1].
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: mean_lognormal (<m>,<s>)
     Retorna a média de uma variável aleatória Lognormal(m,s), com s>0.
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: var_lognormal (<m>,<s>)
     Retorna a variância de uma variável aleatória Lognormal(m,s), com
     s>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: std_lognormal (<m>,<s>)
     Retorna o desvio padrão de uma variável aleatória Lognormal(m,s),
     com s>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_lognormal (<m>,<s>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Lognormal(m,s), com s>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: kurtosis_lognormal (<m>,<s>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Lognormal(m,s), com s>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: random_lognormal (<m>,<s>)
 -- Função: random_lognormal (<m>,<s>,<n>)
     Retorna uma variável estatística pseudo-aleatória Lognormal(m,s),
     com s>0. Chamando `random_lognormal' com um terceiro argumento
     <n>, uma amostra aleatória de tamanho <n> será simulada.

     Variáveis Log-normal são simuladas por meio de variáveis
     estatísticas normais pseudo-aleatórias. Existem dois algoritmos
     implementados para essa função, se pode seleccionar o algoritmo a
     ser usado fornecendo um certo valor à variável global
     `random_normal_algorithm', cujo valor padrão é `box_mueller'.

     Veja também `random_normal_algorithm'. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_gamma (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Gamma(a,b), com a,b>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_gamma (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Gamma(a,b), com a,b>0.

     Essa função não possui uma forma fechada e é calculada
     numericamante se a variável global `numer' for igual a `true',  de
     outra forma essa função retorna uma expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_gamma(3,5,21);
          (%o2)                  cdf_gamma(3, 5, 21)
          (%i3) %,numer;
          (%o3)                 4.402663157135039E-7

 -- Função: quantile_gamma (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Gamma(a,b), com
     a,b>0; em outras palavras, essa função é a inversa da função
     `cdf_gamma'. O argumento <q> deve ser um elemento de [0,1]. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: mean_gamma (<a>,<b>)
     Retorna a média de uma variável aleatória Gamma(a,b), com a,b>0.
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: var_gamma (<a>,<b>)
     Retorna a variância de uma variável aleatória Gamma(a,b), com
     a,b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: std_gamma (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Gamma(a,b), com
     a,b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_gamma (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Gamma(a,b), com a,b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: kurtosis_gamma (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Gamma(a,b), com a,b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Variável de opção: random_gamma_algorithm
     Valor por omissão: `ahrens_cheng'

     Esse é o algoritmo seleccionado para simular variáveis estatística
     gama pseudo-aleatórias. Os algoritmos implementados são
     `ahrens_cheng' e `inverse'
        * `ahrens_cheng', essa é uma combinação de dois processos,
          dependendo do valor do parâmetro <a>:

          For a>=1, Cheng, R.C.H. e Feast, G.M. (1979). <Some simple
          gamma variate generators>. Appl. Stat., 28, 3, 290-295.

          For 0<a<1, Ahrens, J.H. e Dieter, U. (1974). <Computer
          methods for sampling from gamma, beta, poisson and binomial
          cdf_tributions>. Computing, 12, 223-246.

        * `inverse', baseado no método inverso genérico.


     Veja também `random_gamma'.

 -- Função: random_gamma (<a>,<b>)
 -- Função: random_gamma (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Gamma(a,b), com
     a,b>0. Chamando `random_gamma' com um terceiro argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Existem dois algoritmos implementados para essa função, se pode
     seleccionar o algoritmo a ser usado fornecendo um certo valor à
     variável global `random_gamma_algorithm', cujo valor padrão é
     `ahrens_cheng'.

     Veja também `random_gamma_algorithm'. Para fazer uso dessa função,
     escreva primeiramente `load(distrib)'.

 -- Função: pdf_beta (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Beta(a,b), com a,b>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_beta (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Beta(a,b), com a,b>0.

     Essa função não possui uma forma fechada e é calculada
     numericamante se a variável global `numer' for igual a `true',  de
     outra forma essa função retorna uma expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_beta(1/3,15,2);
                                           1
          (%o2)                   cdf_beta(-, 15, 2)
                                           3
          (%i3) %,numer;
          (%o3)                 7.666089131388224E-7

 -- Função: quantile_beta (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Beta(a,b), com
     a,b>0; em outras palavras, essa função é a inversa da função
     `cdf_beta'. O argumento <q> deve ser um elemento de [0,1]. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: mean_beta (<a>,<b>)
     Retorna a média de uma variável aleatória Beta(a,b), com a,b>0.
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: var_beta (<a>,<b>)
     Retorna a variância de uma variável aleatória Beta(a,b), com a,b>0.
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: std_beta (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Beta(a,b), com
     a,b>0.  Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_beta (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Beta(a,b), com a,b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: kurtosis_beta (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Beta(a,b), com a,b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Variável de opção: random_beta_algorithm
     Valor por omissão: `cheng'

     Esse é o algoritmo seleccionado para simular variáveis
     estatísticas beta pseudo-aleatórias. Os algoritmos implementados
     são `cheng', `inverse' e `ratio'
        * `cheng', esse é o algoritmo definido em Cheng, R.C.H.  (1978).
          <Generating Beta Variates with Nonintegral Shape Parameters>.
          Communications of the ACM, 21:317-322

        * `inverse', baseado no método inverso genérico.

        * `ratio', baseado no facto de que se <X> for uma variável
          aleatória Gamma(a,1) e <Y> for Gamma(b,1), então a razão
          X/(X+Y) está distribuída como Beta(a,b).


     Veja também `random_beta'.

 -- Função: random_beta (<a>,<b>)
 -- Função: random_beta (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Beta(a,b), com
     a,b>0. Chamando `random_beta' com um terceiro argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Existem três algoritmos implementados para essa função, se pode
     seleccionar o algoritmo a ser usado fornecendo um certo valor à
     variável global `random_beta_algorithm', cujo valor padrão é
     `cheng'.

     Veja também `random_beta_algorithm'. Para fazer uso dessa função,
     escreva primeiramente `load(distrib)'.

 -- Função: pdf_continuous_uniform (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Continuous Uniform(a,b), com a<b.  Para fazer
     uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_continuous_uniform (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Continuous Uniform(a,b), com a<b.  Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: quantile_continuous_uniform (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Continuous
     Uniform(a,b), com a<b; em outras palavras, essa função é a inversa
     da função `cdf_continuous_uniform'. O argumento <q> deve ser um
     elemento de [0,1].  Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: mean_continuous_uniform (<a>,<b>)
     Retorna a média de uma variável aleatória Continuous Uniform(a,b),
     com a<b. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: var_continuous_uniform (<a>,<b>)
     Retorna a variância de uma variável aleatória Continuous
     Uniform(a,b), com a<b. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: std_continuous_uniform (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Continuous
     Uniform(a,b), com a<b. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: skewness_continuous_uniform (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Continuous Uniform(a,b), com a<b. Para fazer uso dessa função,
     escreva primeiramente `load(distrib)'.

 -- Função: kurtosis_continuous_uniform (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Continuous Uniform(a,b), com a<b. Para fazer uso dessa função,
     escreva primeiramente `load(distrib)'.

 -- Função: random_continuous_uniform (<a>,<b>)
 -- Função: random_continuous_uniform (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Continuous
     Uniform(a,b), com a<b. Chamando `random_continuous_uniform' com um
     terceiro argumento <n>, uma amostra aleatória de tamanho <n> será
     simulada.

     Essa é uma aplicação directa da função `random' interna do Maxima.

     Veja também `random'. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: pdf_logistic (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Logistic(a,b) , com b>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_logistic (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Logistic(a,b), com b>0. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: quantile_logistic (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Logistic(a,b) , com
     b>0; em outras palavras, essa função é a inversa da função
     `cdf_logistic'. O argumento <q> deve ser um elemento de [0,1].
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: meanlog (<a>,<b>)
     Retorna a média de uma Logistic(a,b) variável aleatória , com b>0.
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: var_logistic (<a>,<b>)
     Retorna a variância de uma variável aleatória Logistic(a,b) , com
     b>0.  Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: std_logistic (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Logistic(a,b) ,
     com b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_logistic (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Logistic(a,b) , com b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: kurtosis_logistic (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Logistic(a,b) , com b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: random_logistic (<a>,<b>)
 -- Função: random_logistic (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Logistic(a,b),
     com b>0.  Chamando `random_logistic' com um terceiro argumento
     <n>, uma amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado. Para fazer
     uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_pareto (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Pareto(a,b), com a,b>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_pareto (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Pareto(a,b), com a,b>0. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: quantile_pareto (<q>,<a>,<b>)
     Retorna o <q>-quantile de uma variável aleatória Pareto(a,b), com
     a,b>0; em outras palavras, essa função é a inversa da função
     `cdf_pareto'. O argumento <q> deve ser um elemento de [0,1]. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: mean_pareto (<a>,<b>)
     Retorna a média de uma variável aleatória Pareto(a,b), com
     a>1,b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: var_pareto (<a>,<b>)
     Retorna a variância de uma variável aleatória Pareto(a,b), com
     a>2,b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: std_pareto (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Pareto(a,b), com
     a>2,b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_pareto (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Pareto(a,b), com a>3,b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: kurtosis_pareto (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Pareto(a,b), com a>4,b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: random_pareto (<a>,<b>)
 -- Função: random_pareto (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Pareto(a,b), com
     a>0,b>0. Chamando `random_pareto' com um terceiro argumento <n>,
     uma amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_weibull (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Weibull(a,b), com a,b>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_weibull (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Weibull(a,b), com a,b>0. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: quantile_weibull (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Weibull(a,b), com
     a,b>0; em outras palavras, essa função é a inversa da função
     `cdf_weibull'. O argumento <q> deve ser um elemento de [0,1]. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: mean_weibull (<a>,<b>)
     Retorna a média de uma variável aleatória Weibull(a,b), com a,b>0.
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: var_weibull (<a>,<b>)
     Retorna a variância de uma variável aleatória Weibull(a,b), com
     a,b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: std_weibull (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Weibull(a,b),
     com a,b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_weibull (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Weibull(a,b), com a,b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: kurtosis_weibull (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Weibull(a,b), com a,b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: random_weibull (<a>,<b>)
 -- Função: random_weibull (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Weibull(a,b),
     com a,b>0. Chamando `random_weibull' com um terceiro argumento
     <n>, uma amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado. Para fazer
     uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_rayleigh (<x>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Rayleigh(b), com b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na função densidade de
     probabilidade de Weibull é retornada.

          (%i1) load (distrib)$
          (%i2) pdf_rayleigh(x,b);
                                                  1
          (%o2)                 pdf_weibull(x, 2, -)
                                                  b
          (%i3) assume(x>0,b>0)$ pdf_rayleigh(x,b);
                                              2  2
                                     2     - b  x
          (%o4)                   2 b  x %e

 -- Função: cdf_rayleigh (<x>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Rayleigh(b), com b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na distribuição de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) cdf_rayleigh(x,b);
                                                  1
          (%o2)                 cdf_weibull(x, 2, -)
                                                  b
          (%i3) assume(x>0,b>0)$ cdf_rayleigh(x,b);
                                             2  2
                                          - b  x
          (%o4)                     1 - %e

 -- Função: quantile_rayleigh (<q>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Rayleigh(b), com
     b>0; em outras palavras, essa função é a inversa da função
     `cdf_rayleigh'. O argumento <q> deve ser um elemento de [0,1].

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no quantil de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) quantile_rayleigh(0.99,b);
                                                      1
          (%o2)             quantile_weibull(0.99, 2, -)
                                                      b
          (%i3) assume(x>0,b>0)$ quantile_rayleigh(0.99,b);
                                  2.145966026289347
          (%o4)                   -----------------
                                          b

 -- Função: mean_rayleigh (<b>)
     Retorna a média de uma variável aleatória Rayleigh(b), com b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na meia de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) mean_rayleigh(b);
                                                 1
          (%o2)                  mean_weibull(2, -)
                                                 b
          (%i3) assume(b>0)$ mean_rayleigh(b);
                                      sqrt(%pi)
          (%o4)                       ---------
                                         2 b

 -- Função: var_rayleigh (<b>)
     Retorna a variância de uma variável aleatória Rayleigh(b), com b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na variância de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) var_rayleigh(b);
                                                 1
          (%o2)                   var_weibull(2, -)
                                                 b
          (%i3) assume(b>0)$ var_rayleigh(b);
                                           %pi
                                       1 - ---
                                            4
          (%o4)                        -------
                                          2
                                         b

 -- Função: std_rayleigh (<b>)
     Retorna o desvio padrão de uma variável aleatória Rayleigh(b), com
     b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na Weibull desvio padrão é
     retornada.

          (%i1) load (distrib)$
          (%i2) std_rayleigh(b);
                                                 1
          (%o2)                   std_weibull(2, -)
                                                 b
          (%i3) assume(b>0)$ std_rayleigh(b);
                                             %pi
                                    sqrt(1 - ---)
                                              4
          (%o4)                     -------------
                                          b

 -- Função: skewness_rayleigh (<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Rayleigh(b), com b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de assimetria
     de Weibull  é retornada.

          (%i1) load (distrib)$
          (%i2) skewness_rayleigh(b);
                                                   1
          (%o2)                skewness_weibull(2, -)
                                                   b
          (%i3) assume(b>0)$ skewness_rayleigh(b);
                                   3/2
                                %pi      3 sqrt(%pi)
                                ------ - -----------
                                  4           4
          (%o4)                 --------------------
                                         %pi 3/2
                                    (1 - ---)
                                          4

 -- Função: kurtosis_rayleigh (<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Rayleigh(b), com b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de curtose de
     Weibull é retornada.

          (%i1) load (distrib)$
          (%i2) kurtosis_rayleigh(b);
                                                   1
          (%o2)                kurtosis_weibull(2, -)
                                                   b
          (%i3) assume(b>0)$ kurtosis_rayleigh(b);
                                            2
                                       3 %pi
                                   2 - ------
                                         16
          (%o4)                    ---------- - 3
                                        %pi 2
                                   (1 - ---)
                                         4

 -- Função: random_rayleigh (<b>)
 -- Função: random_rayleigh (<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Rayleigh(b), com
     b>0.  Chamando `random_rayleigh' com um segundo argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado. Para fazer
     uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_laplace (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Laplace(a,b), com b>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_laplace (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Laplace(a,b), com b>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: quantile_laplace (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Laplace(a,b), com
     b>0; em outras palavras, essa função é a inversa da função
     `cdf_laplace'. O argumento <q> deve ser um elemento de [0,1]. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: mean_laplace (<a>,<b>)
     Retorna a média de uma variável aleatória Laplace(a,b), com b>0.
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: var_laplace (<a>,<b>)
     Retorna a variância de uma variável aleatória Laplace(a,b), com
     b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: std_laplace (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Laplace(a,b),
     com b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_laplace (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Laplace(a,b), com b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: kurtosis_laplace (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Laplace(a,b), com b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: random_laplace (<a>,<b>)
 -- Função: random_laplace (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Laplace(a,b),
     com b>0.  Chamando `random_laplace' com um terceiro argumento <n>,
     uma amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado. Para fazer
     uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_cauchy (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Cauchy(a,b), com b>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_cauchy (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Cauchy(a,b), com b>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: quantile_cauchy (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Cauchy(a,b), com
     b>0; em outras palavras, essa função é a inversa da função
     `cdf_cauchy'. O argumento <q> deve ser um elemento de [0,1]. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: random_cauchy (<a>,<b>)
 -- Função: random_cauchy (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo aleatória Cauchy(a,b), com
     b>0.  Chamando `random_cauchy' com um terceiro argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado. Para fazer
     uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_gumbel (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Gumbel(a,b), com b>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_gumbel (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Gumbel(a,b), com b>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: quantile_gumbel (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Gumbel(a,b), com
     b>0; em outras palavras, essa função é a inversa da função
     `cdf_gumbel'. O argumento <q> deve ser um elemento de [0,1]. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: mean_gumbel (<a>,<b>)
     Retorna a média de uma variável aleatória Gumbel(a,b), com b>0.

          (%i1) load (distrib)$
          (%i2) assume(b>0)$  mean_gumbel(a,b);
          (%o3)                     %gamma b + a
     onde o símbolol `%gamma' representa a constante de
     Euler-Mascheroni.  Veja também `%gamma'.

 -- Função: var_gumbel (<a>,<b>)
     Retorna a variância de uma variável aleatória Gumbel(a,b), com
     b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: std_gumbel (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Gumbel(a,b), com
     b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_gumbel (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Gumbel(a,b), com b>0.

          (%i1) load (distrib)$
          (%i2) assume(b>0)$ skewness_gumbel(a,b);
                                 12 sqrt(6) zeta(3)
          (%o3)                  ------------------
                                           3
                                        %pi
          (%i4) numer:true$ skewness_gumbel(a,b);
          (%o5)                   1.139547099404649
     onde `zeta' representa a função zeta de Riemann.

 -- Função: kurtosis_gumbel (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Gumbel(a,b), com b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: random_gumbel (<a>,<b>)
 -- Função: random_gumbel (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Gumbel(a,b), com
     b>0. Chamando `random_gumbel' com um terceiro argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado. Para fazer
     uso dessa função, escreva primeiramente `load(distrib)'.


File: maxima.info,  Node: Definições para distribuições discretas,  Prev: Definições para distribuições contínuas,  Up: distrib

46.3 Definições para distribuições discretas
============================================

 -- Função: pdf_binomial (<x>,<n>,<p>)
     Retorna o valor em <x> da função de probabilidade de uma
     Binomial(n,p) variável aleatória, com 0<p<1 e n um inteiro
     positivo. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: cdf_binomial (<x>,<n>,<p>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma Binomial(n,p) variável aleatória, com 0<p<1 e n um inteiro
     positivo.

     `cdf_binomial' é calculada numéricamente se a variável global
     `numer' for igual a `true',  de outra forma `cdf_binomial' retorna
     uma expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_binomial(5,7,1/6);
                                                   1
          (%o2)                 cdf_binomial(5, 7, -)
                                                   6
          (%i3) cdf_binomial(5,7,1/6), numer;
          (%o3)                   .9998713991769548

 -- Função: quantile_binomial (<q>,<n>,<p>)
     Retorna o <q>-quantil de uma variável aleatória Binomial(n,p), com
     0<p<1 e n um inteiro positivo; em outras palavras, essa função é a
     inversa da função `cdf_binomial'. O argumento <q> deve ser um
     elemento de [0,1]. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: mean_binomial (<n>,<p>)
     Retorna a média de uma variável aleatória Binomial(n,p), com 0<p<1
     e n um inteiro positivo. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: var_binomial (<n>,<p>)
     Retorna a variância de uma variável aleatória Binomial(n,p), com
     0<p<1 e n um inteiro positivo. Para fazer uso dessa função,
     escreva primeiramente `load(distrib)'.

 -- Função: std_binomial (<n>,<p>)
     Retorna o desvio padrão de uma variável aleatória Binomial(n,p),
     com 0<p<1 e n um inteiro positivo. Para fazer uso dessa função,
     escreva primeiramente `load(distrib)'.

 -- Função: skewness_binomial (<n>,<p>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Binomial(n,p), com 0<p<1 e n um inteiro positivo. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: kurtosis_binomial (<n>,<p>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Binomial(n,p), com 0<p<1 e n um inteiro positivo. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Variável de opção: random_binomial_algorithm
     Valor por omissão: `kachit'

     Esse é o algoritmo seleccionado para simular rvariáveis
     estatísticas pseudo-aleatórias binomiais. Os algoritmos
     implementados são `kachit', `bernoulli' e `inverse':
        * `kachit', baseado no algoritmo descrito em Kachitvichyanukul,
          V. and Schmeiser, B.W. (1988) <Binomial Random Variate
          Generation>. Communications of the ACM, 31, Feb., 216.

        * `bernoulli', baseado na simulação testes de Bernoulli.

        * `inverse', baseado no método inverso genérico.


     Veja também `random_binomial'.

 -- Função: random_binomial (<n>,<p>)
 -- Função: random_binomial (<n>,<p>,<m>)
     Retorna uma variável estatística pseudo-aleatória Binomial(n,p),
     com 0<p<1 e n um inteiro positivo. Chamando `random_binomial' com
     um terceiro argumento <m>, uma amostra aleatória de tamanho <m>
     será simulada.

     Existem três algoritmos implementado para essa função, se pode
     seleccionar o algoritmo a ser usado fornecendo um certo valor à
     variável global `random_binomial_algorithm', cujo valor padrão é
     `kachit'.

     Veja também `random_binomial_algorithm'. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_poisson (<x>,<m>)
     Retorna o valor em <x> da função de probabilidade de uma variável
     aleatória Poisson(m), com m>0. Para fazer uso dessa função,
     escreva primeiramente `load(distrib)'.

 -- Função: cdf_poisson (<x>,<m>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Poisson(m), com m>0.

     Essa função é calculada numéricamente se a variável global `numer'
     for igual a `true',  de outra forma essa função retorna uma
     expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_poisson(3,5);
          (%o2)                   cdf_poisson(3, 5)
          (%i3) cdf_poisson(3,5), numer;
          (%o3)                   .2650259152973617

 -- Função: quantile_poisson (<q>,<m>)
     Retorna o <q>-quantil de uma variável aleatória Poisson(m), com
     m>0; em outras palavras, essa função é a inversa da função
     `cdf_poisson'. O argumento <q> deve ser um elemento de [0,1]. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: mean_poisson (<m>)
     Retorna a média de uma variável aleatória Poisson(m), com m>0.
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: var_poisson (<m>)
     Retorna a variância de uma variável aleatória Poisson(m), com
     m>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: std_poisson (<m>)
     Retorna o desvio padrão de uma variável aleatória Poisson(m), com
     m>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_poisson (<m>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Poisson(m), com m>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: kurtosis_poisson (<m>)
     Retorna o coeficiente de curtose de uma Poisson variável aleatória
     Poi(m), com m>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Variável de opção: random_poisson_algorithm
     Valor por omissão: `ahrens_dieter'

     Esse é o algoritmo seleccionado para simular variáveis estatísticas
     pseudo-aleatórias de Poisson.Os algoritmos implementados são
     `ahrens_dieter' e `inverse':
        * `ahrens_dieter', baseado no algoritmo descrito em Ahrens,
          J.H. and Dieter, U. (1982) <Computer Generation of Poisson
          Deviates From Modified Normal Distributions>.  ACM Trans.
          Math. Software, 8, 2, June,163-179.

        * `inverse', baseado no método inverso genérico.


     Veja também `random_poisson'.

 -- Função: random_poisson (<m>)
 -- Função: random_poisson (<m>,<n>)
     Retorna uma variável estatística pseudo-aleatória Poisson(m), com
     m>0.  Chamando `random_poisson' com um segundo argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Existem dois algoritmos implementado para essa função, se pode
     seleccionar o algoritmo a ser usado fornecendo um certo valor à
     variável global `random_poisson_algorithm', cujo valor padrão é
     `ahrens_dieter'.

     Veja também `random_poisson_algorithm'. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_bernoulli (<x>,<p>)
     Retorna o valor em <x> da função de probabilidade de uma variável
     aleatória Bernoulli(p), com 0<p<1.

     A variável aleatória Bernoulli(p) é equivalente a Binomial(1,p),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na função binomial de
     probabilidade é retornada.

          (%i1) load (distrib)$
          (%i2) pdf_bernoulli(1,p);
          (%o2)                 pdf_binomial(1, 1, p)
          (%i3) assume(0<p,p<1)$ pdf_bernoulli(1,p);
          (%o4)                           p

 -- Função: cdf_bernoulli (<x>,<p>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Bernoulli(p), com 0<p<1.  Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: quantile_bernoulli (<q>,<p>)
     Retorna o <q>-quantil de uma variável aleatória Bernoulli(p), com
     0<p<1; em outras palavras, essa função é a inversa da função
     `cdf_bernoulli'. O argumento <q> deve ser um elemento de [0,1].
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: mean_bernoulli (<p>)
     Retorna a média de uma variável aleatória Bernoulli(p), com 0<p<1.

     A variável aleatória Bernoulli(p) é equivalente a Binomial(1,p),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na média binomial é retornada.

          (%i1) load (distrib)$
          (%i2) mean_bernoulli(p);
          (%o2)                  mean_binomial(1, p)
          (%i3) assume(0<p,p<1)$ mean_bernoulli(p);
          (%o4)                           p

 -- Função: var_bernoulli (<p>)
     Retorna a variância de uma variável aleatória Bernoulli(p), com
     0<p<1.

     A variável aleatória Bernoulli(p) é equivalente a Binomial(1,p),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na variância binomial é
     retornada.

          (%i1) load (distrib)$
          (%i2) var_bernoulli(p);
          (%o2)                  var_binomial(1, p)
          (%i3) assume(0<p,p<1)$ var_bernoulli(p);
          (%o4)                       (1 - p) p

 -- Função: std_bernoulli (<p>)
     Retorna o desvio padrão de uma variável aleatória Bernoulli(p),
     com 0<p<1.

     A variável aleatória Bernoulli(p) é equivalente a Binomial(1,p),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no desvio padrão binomial é
     retornada.

          (%i1) load (distrib)$
          (%i2) std_bernoulli(p);
          (%o2)                  std_binomial(1, p)
          (%i3) assume(0<p,p<1)$ std_bernoulli(p);
          (%o4)                  sqrt(1 - p) sqrt(p)

 -- Função: skewness_bernoulli (<p>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Bernoulli(p), com 0<p<1.

     A variável aleatória Bernoulli(p) é equivalente a Binomial(1,p),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de assimetria
     binomial é retornada.

          (%i1) load (distrib)$
          (%i2) skewness_bernoulli(p);
          (%o2)                skewness_binomial(1, p)
          (%i3) assume(0<p,p<1)$ skewness_bernoulli(p);
                                       1 - 2 p
          (%o4)                  -------------------
                                 sqrt(1 - p) sqrt(p)

 -- Função: kurtosis_bernoulli (<p>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Bernoulli(p), com 0<p<1.

     A variável aleatória Bernoulli(p) é equivalente a Binomial(1,p),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de curtose
     binomial é retornada.

          (%i1) load (distrib)$
          (%i2) kurtosis_bernoulli(p);
          (%o2)                kurtosis_binomial(1, p)
          (%i3) assume(0<p,p<1)$ kurtosis_bernoulli(p);
                                   1 - 6 (1 - p) p
          (%o4)                    ---------------
                                      (1 - p) p

 -- Função: random_bernoulli (<p>)
 -- Função: random_bernoulli (<p>,<n>)
     Retorna uma variável estatística pseudo-aleatória Bernoulli(p),
     com 0<p<1. Chamando `random_bernoulli' com um segundo argumento
     <n>, uma amostra aleatória de tamanho <n> será simulada.

     Essa é uma aplicação directa da função `random' built-in função do
     Maxima.

     Veja também `random'. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: pdf_geometric (<x>,<p>)
     Retorna o valor em <x> da função de probabilidade de uma variável
     aleatória Geometric(p), com 0<p<1. Para fazer uso dessa função,
     escreva primeiramente `load(distrib)'.

 -- Função: cdf_geometric (<x>,<p>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Geometric(p), com 0<p<1. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: quantile_geometric (<q>,<p>)
     Retorna o <q>-quantil de uma variável aleatória Geometric(p), com
     0<p<1; em outras palavras, essa função é a inversa da função
     `cdf_geometric'. O argumento <q> deve ser um elemento de [0,1].
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: mean_geometric (<p>)
     Retorna a média de uma variável aleatória Geometric(p), com 0<p<1.
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: var_geometric (<p>)
     Retorna a variância de uma variável aleatória Geometric(p), com
     0<p<1. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: std_geometric (<p>)
     Retorna o desvio padrão de uma variável aleatória Geometric(p),
     com 0<p<1. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_geometric (<p>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Geometric(p), com 0<p<1. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: kurtosis_geometric (<p>)
     Retorna o coeficiente de curtose de uma geometric variável
     aleatória  Geo(p), com 0<p<1. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Variável de opção: random_geometric_algorithm
     Valor por omissão: `bernoulli'

     Esse é o algoritmo seleccionado para simular variáveis
     estatísticas pseudo-aleatórias geométricas. Algorítmos
     implementados são `bernoulli', `devroye' e `inverse':
        * `bernoulli', baseado na simulação de testes de Bernoulli.

        * `devroye', baseado no algoritmo descrito em Devroye, L. (1986)
          <Non-Uniform Random Variate Generation.> Springer Verlag, p.
          480.

        * `inverse', baseado no método inverso genérico.


     Veja também `random_geometric'.

 -- Função: random_geometric (<p>)
 -- Função: random_geometric (<p>,<n>)
     Retorna um Geometric(p) variável estatística pseudo-aleatória, com
     0<p<1.  Chamando `random_geometric' com um segundo argumento <n>,
     uma amostra aleatória de tamanho <n> será simulada.

     Existem três algoritmos implementados para essa função, se pode
     seleccionar o algoritmo a ser usado fornecendo um certo valor à
     variável global `random_geometric_algorithm', cujo valor padrão é
     `bernoulli'.

     Veja também `random_geometric_algorithm'. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_discrete_uniform (<x>,<n>)
     Retorna o valor em <x> da função de probabilidade de uma variável
     aleatória Discrete Uniform(n), com n a strictly positive integer.
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_discrete_uniform (<x>,<n>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Discrete Uniform(n), com n inteiro
     estritamente positivo. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: quantile_discrete_uniform (<q>,<n>)
     Retorna o <q>-quantil de uma variável aleatória Discrete
     Uniform(n), com n um inteiro estritamente positivo; em outras
     palavras, essa função é a inversa da função
     `cdf_discrete_uniform'. O argumento <q> deve ser um elemento de
     [0,1]. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: mean_discrete_uniform (<n>)
     Retorna a média de uma variável aleatória Discrete Uniform(n), com
     n um inteiro estritamente positivo. Para fazer uso dessa função,
     escreva primeiramente `load(distrib)'.

 -- Função: var_discrete_uniform (<n>)
     Retorna a variância de uma variável aleatória Discrete Uniform(n),
     com n um inteiro estritamente positivo. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: std_discrete_uniform (<n>)
     Retorna o desvio padrão de uma variável aleatória Discrete
     Uniform(n), com n um inteiro estritamente positivo. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: skewness_discrete_uniform (<n>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Discrete Uniform(n), com n um inteiro estritamente positivo. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: kurtosis_discrete_uniform (<n>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Discrete Uniform(n), com n um inteiro estritamente positivo. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: random_discrete_uniform (<n>)
 -- Função: random_discrete_uniform (<n>,<m>)
     Retorna uma variável estatística pseudo-aleatória Discrete
     Uniform(n), com n um inteiro estritamente positivo. Chamando
     `random_discrete_uniform' com um segundo argumento <m>, uma
     amostra aleatória de tamanho <m> será simulada.

     Isso é uma aplicação directa da função `random' built-in função do
     Maxima.

     Veja também `random'. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: pdf_hypergeometric (<x>,<n1>,<n2>,<n>)
     Retorna o valor em <x> da função de probabilidade de uma variável
     aleatória Hypergeometric(n1,n2,n), com <n1>, <n2> e <n> inteiros
     não negativos e n<=n1+n2. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: cdf_hypergeometric (<x>,<n1>,<n2>,<n>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Hypergeometric(n1,n2,n), com <n1>, <n2> e
     <n> inteiros não negativos e n<=n1+n2. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: quantile_hypergeometric (<q>,<n1>,<n2>,<n>)
     Retorna o <q>-quantil de uma variável aleatória
     Hypergeometric(n1,n2,n), com <n1>, <n2> e <n> inteiros não
     negativos e n<=n1+n2; em outras palavras, essa função é a inversa
     da função `cdf_hypergeometric'.  O argumento <q> deve ser um
     elemento de [0,1]. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: mean_hypergeometric (<n1>,<n2>,<n>)
     Retorna a média de uma variável aleatória discreta univorme
     Hyp(n1,n2,n), com <n1>, <n2> e <n> inteiros não negativos e
     n<=n1+n2. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: var_hypergeometric (<n1>,<n2>,<n>)
     Retorna a variância de uma variável aleatória hipergeométrica
     Hyp(n1,n2,n), com <n1>, <n2> e <n> inteiros não negativos e
     n<=n1+n2. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: std_hypergeometric (<n1>,<n2>,<n>)
     Retorna o desvio padrão de uma variável aleatória
     Hypergeometric(n1,n2,n), com <n1>, <n2> e <n> inteiros não
     negativos e n<=n1+n2. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: skewness_hypergeometric (<n1>,<n2>,<n>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Hypergeometric(n1,n2,n), com <n1>, <n2> e <n> inteiros não
     negativos e n<=n1+n2. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: kurtosis_hypergeometric (<n1>,<n2>,<n>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Hypergeometric(n1,n2,n), com <n1>, <n2> e <n> inteiros não
     negativos e n<=n1+n2. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Variável de opção: random_hypergeometric_algorithm
     Valor por omissão: `kachit'

     Esse é o algoritmo seleccionado para simular variáveis
     estatísticas pseudo aleatórias hipergeométricas.Os algoritmos
     implementados são `kachit' e `inverse':
        * `kachit', baseado no algoritmo descrito em Kachitvichyanukul,
          V., Schmeiser, B.W. (1985) <Computer generation of
          hypergeometric variáveis estatística pseudo-aleatórias.>
          Journal of Statistical Computation and Simulation 22, 127-145.

        * `inverse', baseado no método inverso genérico.


     Veja também `random_hypergeometric'.

 -- Função: random_hypergeometric (<n1>,<n2>,<n>)
 -- Função: random_hypergeometric (<n1>,<n2>,<n>,<m>)
     Retorna uma variável estatística pseudo-aleatória
     Hypergeometric(n1,n2,n), com <n1>, <n2> e <n> inteiros não
     negativos e n<=n1+n2. Chamando `random_hypergeometric' com um
     quarto argumento <m>, uma amostra aleatória de tamanho <m> será
     simulada.

     Existem dois algoritmos implementados para essa função, se pode
     seleccionar o algoritmo a ser usado fornecendo um certo valor à
     variável global `random_hypergeometric_algorithm', cujo valor
     padrão é `kachit'.

     Veja também `random_hypergeometric_algorithm'. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_negative_binomial (<x>,<n>,<p>)
     Retorna o valor em <x> da função de probabilidade de uma variável
     aleatória Negative Binomial(n,p), com 0<p<1 e n um inteiro
     positivo. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: cdf_negative_binomial (<x>,<n>,<p>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma Negative Binomial(n,p) variável aleatória, com 0<p<1 e n um
     inteiro positivo.

     Essa função é calculada numéricamente se a variável global `numer'
     for igual a `true',  de outra forma essa função retorna uma
     expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_negative_binomial(3,4,1/8);
                                                       1
          (%o2)            cdf_negative_binomial(3, 4, -)
                                                       8
          (%i3) cdf_negative_binomial(3,4,1/8), numer;
          (%o3)                  .006238937377929698

 -- Função: quantile_negative_binomial (<q>,<n>,<p>)
     Retorna o <q>-quantil de uma variável aleatória Negative
     Binomial(n,p), com 0<p<1 e n um inteiro positivo; em outras
     palavras, essa função é a inversa da função
     `cdf_negative_binomial'. O argumento <q> deve ser um elemento de
     [0,1]. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: mean_negative_binomial (<n>,<p>)
     Retorna a média de uma variável aleatória Negative Binomial(n,p),
     com 0<p<1 e n um inteiro positivo. Para fazer uso dessa função,
     escreva primeiramente `load(distrib)'.

 -- Função: var_negative_binomial (<n>,<p>)
     Retorna a variância de uma variável aleatória Negative
     Binomial(n,p), com 0<p<1 e n um inteiro positivo. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: std_negative_binomial (<n>,<p>)
     Retorna o desvio padrão de uma variável aleatória Negative
     Binomial(n,p), com 0<p<1 e n um inteiro positivo. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: skewness_negative_binomial (<n>,<p>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Negative Binomial(n,p), com 0<p<1 e n um inteiro positivo. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: kurtosis_negative_binomial (<n>,<p>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Negative Binomial(n,p), com 0<p<1 e n um inteiro positivo. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Variável de opção: random_negative_binomial_algorithm
     Valor por omissão: `bernoulli'

     Esse é o algoritmo seleccionado para simular variáveis
     estatísticas pseuso-aleatórias binomiais negativas. Os algoritmos
     implementados são `devroye', `bernoulli' e `inverse':
        * `devroye', baseado no algoritmo descrito em Devroye, L. (1986)
          <Non-Uniform Random Variate Generation>. Springer Verlag, p.
          480.

        * `bernoulli', baseado na simulação de testes de Bernoulli.

        * `inverse', baseado no método inverso genérico.


     Veja também `random_negative_binomial'.

 -- Função: random_negative_binomial (<n>,<p>)
 -- Função: random_negative_binomial (<n>,<p>,<m>)
     Retorna uma variável estatística pseudo-aleatória Negative
     Binomial(n,p), com 0<p<1 e n um inteiro positivo. Chamando
     `random_negative_binomial' com um terceiro argumento <m>, uma
     amostra aleatória de tamanho <m> será simulada.

     Existem três algoritmos implementados para essa função, se pode
     seleccionar o algoritmo a ser usado fornecendo um certo valor à
     variável global `random_negative_binomial_algorithm', cujo valor
     padrão é `bernoulli'.

     Veja também `random_negative_binomial_algorithm'. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.


File: maxima.info,  Node: dynamics,  Next: eval_string,  Prev: distrib,  Up: Top

47 dynamics
***********

* Menu:

* O pacote dynamics::
* Análise gráfica de sistemas dinâmicos discretos::
* Visualização usando VTK::


File: maxima.info,  Node: O pacote dynamics,  Next: Análise gráfica de sistemas dinâmicos discretos,  Prev: dynamics,  Up: dynamics

47.1 O pacote dynamics
======================

O pacote adicional `dynamics' inclui várias funções para criar diversas
representações gráficas de sistemas dinâmicos e fractais, para além
duma implementaçõ do método numérico de Runge-Kutta de quarta ordem,
para resolver sistemas de equações diferenciais.

Para usar as funções neste pacote será necessário primeiro que tudo
carregá-lo com `load("dynamics")'; as funções que criam gráficos
precisam que o Xmaxima esteja instalado.


File: maxima.info,  Node: Análise gráfica de sistemas dinâmicos discretos,  Next: Visualização usando VTK,  Prev: O pacote dynamics,  Up: dynamics

47.2 Análise gráfica de sistemas dinâmicos discretos
====================================================

 -- Função: chaosgame (`[['<x1>, <y1>`]'...`['<xm>, <ym>`]]', `['<x0>,
          <y0>`]', <b>, <n>, ...opções...);
     Usa o método designado de _jogo do caos_, para produzir fractais:
     desenha-se um ponto inicial (<x0>, <y0>) e logo escolhe-se
     aleatoriamente um dos <m> pontos `['<x1>, <y1>`]'...`['<xm>,
     <ym>`]'. A seguir, desenha-se um novo ponto que estará no segmento
     entre o último ponto desenhado e o ponto que se acabou de
     seleccionar aleatoriamente, a uma distância do ponto seleccionado
     que será <b> vezes o comprimento do segmento. O processo repete-se
     <n> vezes.


 -- Função: evolution (<F>, <y0>, <n>,...opções...);
     Desenha <n+1> pontos num gráfico bidimensional (série de tempo),
     onde as coordenadas horizontais dos pontos são os números inteiros
     0, 1, 2, ..., <n>, e as coordenadas verticais são os valores
     <y(n)> correspondentes, obtidos a partir da relação de recorrência
                  y(n+1) = F(y(n))

     Com valor inicial <y(0)> igual a <y0>. <F> deverá ser uma
     expressão que dependa unicamente da variável <y> (e não de <n>),
     <y0> deverá ser um número real e <n> um número inteiro positivo.


 -- Função: evolution2d (`['<F>, <G>`]', `['<x0>, <y0>`]', <n>,
          ...opções...);
     Mostra, num gráfico bidimensional, os primeiros <n+1> pontos da
     sucessão definida a partir do sistema dinâmico discreto com
     relações de recorrência:
                  x(n+1) = F(x(n), y(n))    y(n+1) = G(x(n), y(n))

     Com valores iniciais <x0> e <y0>. <F> e <G> deverão ser duas
     expressões que dependam unicamente de <x> e <y>.


 -- Função: ifs (`['<r1>,...,<rm>`]',`['<A1>,...,<Am>`]',
          `[['<x1>,<y1>`]'...`['<xm>, <ym>`]]', `['<x0>,<y0>`]',
     <n>, ...opções...);

     Usa o método do Sistema de Funções Iteradas (IFS, em inglês
     _Iterated Function System_). Esse método é semelhante ao método
     descrito na função `chaosgame', mas em vez de aproximar o último
     ponto para ponto seleccionado aleatoriamente, as duas coordenadas
     do último ponto multiplicam-se por uma matriz 2 por 2 <Ai>
     correspondente ao ponto que tenha sido escolhido aleatoriamente.

     A selecção aleatória de um dos <m> pontos atractivos pode se
     realizada com uma função de probabilidade não uniforme, definida
     com os pesos <r1>,...,<rm>. Pesos esses que deverão ser dados em
     forma acumulada; por exemplo, se quiser usar 3 pontos com
     probabilidades 0.2, 0.5 e 0.3, os pesos <r1>, <r2> e <r3> poderiam
     ser 2, 7 e 10, ou qualquer outro grupo de números que estejam na
     mesma proporção.


 -- Função: orbits (<F>, <y0>, <n1>, <n2>, [<x>, <x0>, <xf>, <xstep>],
          ...opções...);
     Desenha o diagrama de órbitas duma família de sistemas dinâmicos
     discretos unidimensionais, com um parâmetro <x>; esse tipo de
     diagrama usa-se para mostrar as bifurcações dum sistema discreto
     unidimensional.

     A função <F(y)> define uma sequência que começa com um valor
     inicial <y0>, igual que no caso da função `evolution', mas neste
     caso a função também dependerá do parâmetro <x>, o qual terá
     valores compreendidos no intervalo de <x0> a <xf>, com incrementos
     <xstep>. Cada valor usado para o parâmetro <x> apresenta-se no
     eixo horizontal. No eixo vertical apresentam-se <n2> valores da
     sucessão <y(n1+1)>,..., <y(n1+n2+1)>, obtidos após deixá-la
     evoluir durante <n1> iterações iniciais.


 -- Função: rk (EDO, var, inicial, dominio)
 -- Função: rk ([EDO1,...,EDOm], [v1,...,vm], [inic1,...,inicm],
          domínio)
     A primeira forma usa-se para resolver numericamente uma equação
     diferencial ordinária de primeira ordem (EDO), e a segunda forma
     resolve numericamente um sistema de <m> dessas equações, usando o
     método de Runge-Kutta de quarta ordem. <var> representa a variável
     dependente.  EDO deverá ser uma expressão que dependa unicamente
     das variáveis independente e dependente, e define a derivada da
     variável dependente em função da variável independente.

     A variável independente representa-se com <domínio>, que deverá
     ser uma lista com quatro elementos, como, por exemplo:
          [t, 0, 10, 0.1]
     o primeiro elemento da lista identifica a variável independente, os
     segundo e terceiro elementos são os valores inicial e final para
     essa variável, e o último elemento dá o valor dos incrementos que
     deverão ser usados dentro desse intervalo.

     Se se estiverem a resolver <m> equações, deverá haver <m>
     variáveis dependentes <v1>, <v2>, ..., <vm>. Os valores iniciais
     para essas variáveis serão <inic1>, <inic2>, ..., <inicm>.
     Continuará existindo apenas uma variável independente, definida
     pela lista <domain>, tal como no caso anterior. <EDO1>, ...,
     <EDOm> são as expressões que definem as derivadas de cada uma das
     variáveis dependentes, em função da variável independente. As
     únicas variáveis que podem aparecer em cada uma dessas expressões
     são a variável independente e qualquer uma das variáveis
     dependentes. É importante que as derivadas <EDO1>, ..., <EDOm>
     sejam colocadas na lista na mesma ordem em que forem agrupadas as
     variáveis dependentes; por exemplo, o terceiro elemento da lista
     será interpretado como a derivada da terceira variável dependente.

     O programa tenta integrar as equações desde o valor inicial da
     variável independente, até o valor final, usando incrementos
     fixos. Se em algum passo uma das variáveis dependentes atingir um
     valor absoluto muito elevado, a integração será interrompida nesse
     ponto. O resultado será uma lista com um número de elementos igual
     ao número de iterações realizadas. Cada elemento na lista de
     resultados é também uma lista com <m>+1 elementos: o valor da
     variável independente, seguido dos valores das variáveis
     dependentes nesse ponto.


 -- Função: staircase (<F>, <y0>, <n>, ...opções...);
     Desenha um diagrama de degraus (ou diagrama de teia de aranha)
     para a sucessão definida pela equação de recorrência
                  y(n+1) = F(y(n))

     A interpretação e valores permitidos dos parâmetros de entrada é
     igual que para a função `evolution'. Um diagrama de degraus
     consiste num gráfico da função <F(y)>, junto com a recta <G(y)> `='
     <y>. Começa-se por desenhar um segmento vertical desde o ponto
     (<y0>, <y0>) na recta, até o ponto de intersecção com a função
     <F>. A seguir, desde esse ponto desenha-se um segmento horizontal
     até o ponto de intersecção com a recta, (<y1>, <y1>); o processo
     repete-se <n> vezes até alcançar o ponto (<yn>, <yn>).


Opções

Cada opção é uma lista com dois ou mais elementos. O primeiro elemento
na lista é o nome da opção e os restantes são os argumentos para essa
opção.

As opções aceites pelas funções evolution, evolution2, staircase,
orbits, ifs e chaosgame são as seguintes:

   * "domain" especifica os valores mínimo y máximo da variável
     independente para o gráfico da função <F> representada por
     `staircase'.

   * "pointsize" define o raio de cada ponto desenhado, em unidades de
     pontos. O valor por omissão é 1.

   * "xaxislabel" é o nome que será dado ao eixo horizontal.

   * "xcenter" é a coordenada x do ponto que deverá aparecer no centro
     do gráfico. Esta opção não é usada pela função `orbits'.

   * "xradius" é metade do comprimento do intervalo de valores de x que
     serão representados. Esta opção não é usada pela função `orbits'.

   * "yaxislabel" é o nome que será dado ao eixo vertical.

   * "ycenter" é a coordenada y do ponto que deverá aparecer no centro
     do gráfico.

   * "yradius" é metade do comprimento do intervalo de valores de y que
     serão representados.


As opções aceites pelos programas juli Exemplos

Representação gráfica e diagrama de degraus da sequência: 2, cos(2),
cos(cos(2)),...

     (%i1) load("dynamics")$
     (%i2) evolution(cos(y), 2, 11, [yaxislabel, "y"], [xaxislabel,"n"]);
     (%i3) staircase(cos(y), 1, 11, [domain, 0, 1.2]);

Se o seu processador for lento, terá que reduzir o número de iterações
usado nos exemplos seguintes. E o valor de <pointsize> que dá os
melhores resultados dependerá do monitor e da resolução usada. Terá que
experimentar com diferentes valores.

Diagrama de órbitas para o mapa quadrático
             y(n+1) = x + y(n)^2

     (%i4) orbits(y^2+x, 0, 50, 200, [x, -2, 0.25, 0.01], [pointsize, 0.9]);

Para ampliar a região à volta da bifurcação na parte de baixo, perto de
x `=' -1.25, use o comando:
     (%i5) orbits(x+y^2, 0, 100, 400, [x,-1,-1.53,-0.001], [pointsize,0.9],
                  [ycenter,-1.2], [yradius,0.4]);

Evolução dum sistema em duas dimensões, que conduz a um fractal:

     (%i6) f: 0.6*x*(1+2*x)+0.8*y*(x-1)-y^2-0.9$
     (%i7) g: 0.1*x*(1-6*x+4*y)+0.1*y*(1+9*y)-0.4$
     (%i8) evolution2d([f,g],[-0.5,0],50000,[pointsize,0.7]);

E uma ampliação de uma pequena região no fractal:

     (%i9) evolution2d([f,g],[-0.5,0],300000,[pointsize,0.7], [xcenter,-0.7],
                       [ycenter,-0.3],[xradius,0.1],[yradius,0.1]);

Um gráfico do triângulo de Sierpinsky, obtido com o jogo do caos:

     (%i9) chaosgame([[0, 0], [1, 0], [0.5, sqrt(3)/2]], [0.1, 0.1], 1/2,
                      30000, [pointsize,0.7]);

O feto de Barnsley, obtido com o Sistema de Funções Iteradas:

     (%i10) a1: matrix([0.85,0.04],[-0.04,0.85])$
     (%i11) a2: matrix([0.2,-0.26],[0.23,0.22])$
     (%i12) a3: matrix([-0.15,0.28],[0.26,0.24])$
     (%i13) a4: matrix([0,0],[0,0.16])$
     (%i14) p1: [0,1.6]$
     (%i15) p2: [0,1.6]$
     (%i16) p3: [0,0.44]$
     (%i17) p4: [0,0]$
     (%i18) w: [85,92,99,100]$
     (%i19) ifs(w,[a1,a2,a3,a4],[p1,p2,p3,p4],[5,0],50000,[pointsize,0.9]);

Para resolver numericamente a equação diferencial

               dx/dt = t - x^2

Com valor inicial x(t=0) = 1, no intervalo de t desde 0 até 8, e com
incrementos de 0.1, usa-se:

     (%i20) resultados: rk(t-x^2,x,1,[t,0,8,0.1])$

os resultados ficarão armazenados na lista resultados.

Para resolver numericamente o sistema:

             dx/dt = 4-x^2-4*y^2     dy/dt = y^2-x^2+1

para t entre 0 e 4, com valores iniciais -1.25 e 0.75 para (x, y) em
t=0:

     (%i21) sol: rk([4-x^2-4*y^2,y^2-x^2+1],[x,y],[-1.25,0.75],[t,0,4,0.02])$


File: maxima.info,  Node: Visualização usando VTK,  Prev: Análise gráfica de sistemas dinâmicos discretos,  Up: dynamics

47.3 Visualização usando VTK
============================

A função scene cria imagens a três dimensões e animações, usando o
software _Visualization ToolKit_ (VTK). Para poder usar essa função é
necessário ter Xmaxima e VTK instalados no sistema (incluindo a
libraria para utilizar VTK desde TCL, que pode vir num pacote separado
em alguns sistemas).


File: maxima.info,  Node: eval_string,  Next: f90,  Prev: dynamics,  Up: Top

48 eval_string
**************

* Menu:

* Definições para eval_string::


File: maxima.info,  Node: Definições para eval_string,  Prev: eval_string,  Up: eval_string

48.1 Definições para eval_string
================================

 -- Função: eval_string (<str>)
     Entrega a sequência de caracteres do Maxima <str> como uma
     expressão do Maxima e a avalia.  <str> é uma sequência de
     caracteres do Maxima. Essa sequência pode ou não ter um marcador
     de final (sinal de dólar `$' ou ponto e vírgula `;').  Somente a
     primeira expressão é entregue e avaliada, se ouver mais de uma.

     Reclama se <str> não for uma sequência de caracteres do Maxima.

     Exemplos:
          (%i1) load("eval_string")$

          (%i2) eval_string ("foo: 42; bar: foo^2 + baz");
          (%o2)                       42
          (%i3) eval_string ("(foo: 42, bar: foo^2 + baz)");
          (%o3)                   baz + 1764

     Para usar essa função escreva primeiro `load("eval_string")'. Veja
     também `parse_string'.

 -- Função: parse_string (<str>)
     Entrega a sequência de caracteres do Maxima <str> como uma
     expressão do Maxima (sem fazer nenhuma avaliação dessa expressão).
     <str> é uma sequência de caracteres do Maxima. Essa sequência pode
     ou não ter um marcador de final (sinal de dólar `$' ou ponto e
     vírgula `;').  Somente a primeira expressão é entregue e avaliada,
     se ouver mais de uma.

     Reclama se <str> não for uma sequência de caracteres do Maxima.

     Exemplos:
          (%i1) load("eval_string")$

          (%i2) parse_string ("foo: 42; bar: foo^2 + baz");
          (%o2)                    foo : 42
          (%i3) parse_string ("(foo: 42, bar: foo^2 + baz)");
                                             2
          (%o3)          (foo : 42, bar : foo  + baz)

     Para usar essa função escreva primeiro `load("eval_string")'. Veja
     também a função `eval_string'.


File: maxima.info,  Node: f90,  Next: ggf,  Prev: eval_string,  Up: Top

49 f90
******

* Menu:

* Definições para f90::


File: maxima.info,  Node: Definições para f90,  Prev: f90,  Up: f90

49.1 Definições para f90
========================

 -- Função: f90 (<expr>)
     O comando f90 é uma actualização do comando `fortran' original do
     maxima. A principal diferença é na forma como são divididas as
     linhas muito compridas.

     No exemplo seguinte, observe como o comando `fortran' divide linhas
     no meio de símbolos. O comando `f90' nunca separa uma linha no
     meio de um símbolo.

          (%i1) load("f90")$

          (%i2) expr:expand((xxx+yyy+7)^4);
                   4            3         3        2    2
          (%o2) yyy  + 4 xxx yyy  + 28 yyy  + 6 xxx  yyy
                       2          2        3             2
           + 84 xxx yyy  + 294 yyy  + 4 xxx  yyy + 84 xxx  yyy
                                         4         3          2
           + 588 xxx yyy + 1372 yyy + xxx  + 28 xxx  + 294 xxx
           + 1372 xxx + 2401
          (%i3) fortran(expr);
                yyy**4+4*xxx*yyy**3+28*yyy**3+6*xxx**2*yyy**2+84*xxx*yyy**2+294*yy
               1   y**2+4*xxx**3*yyy+84*xxx**2*yyy+588*xxx*yyy+1372*yyy+xxx**4+28*
               2   xxx**3+294*xxx**2+1372*xxx+2401
          (%o3)                       done
          (%i4) f90(expr);
          yyy**4+4*xxx*yyy**3+28*yyy**3+6*xxx**2*yyy**2+84*xxx*yyy**2+294* &
               yyy**2+4*xxx**3*yyy+84*xxx**2*yyy+588*xxx*yyy+1372*yyy+xxx** &
               4+28*xxx**3+294*xxx**2+1372*xxx+2401
          (%o4)                       done

     A função `f90' foi criada como uma forma rápida de resolver um
     problema. Não será necessariamente um bom exemplo a seguir para
     traduções de outras linguagens de programação.

     Para usar esta função, use primeiro `load("f90")'.


File: maxima.info,  Node: ggf,  Next: impdiff,  Prev: f90,  Up: Top

50 ggf
******

* Menu:

* Definições para ggf::


File: maxima.info,  Node: Definições para ggf,  Prev: ggf,  Up: ggf

50.1 Definições para ggf
========================

 -- Variável de Opção: GGFINFINITY
     Valor por omissão: 3

     Essa é uma variável de opção para a função `ggf'.

     Quando calculando a fração contínua da função geradora, um
     quociente parcial tendo um grau (estritamente) maior que
     <GGFINFINITY> será descartado e o convergente actual será
     considerado como o valor exato da função geradora; na grande
     mioria dos casos o grau de todos os quocientes parciais será ou 0
     ou 1; se usar um valor muito grande, então poderá fornecer termos
     suficientes com o objectivo de fazer o cálculo preciso o bastante.

     Veja também `ggf'.

 -- Variável de opção: GGFCFMAX
     Valor por omissão: 3

     Essa é uma variável de opção para a função `ggf'.

     Quando calculando a fração contínua da função geradora, se nenhum
     bom resultado for encontrado (veja o sinalizador <GGFINFINITY>)
     após se ter calculado uma quantidade de <GGFCFMAX> quocientes
     parciais, a função geradora será considerada como não sendo uma
     fração de dois polinómios e a função irá terminar. Coloque
     livemente um valor muito grande para funções geradoras mais
     complicadas.

     Veja também `ggf'.

 -- Função: ggf (<l>)
     Calcula a função geradora (se for uma fração de dois polinómios)
     de uma sequência, sendo dados seus primeiros termos. <l> é uma
     lista de números.

     A solução é retornada como uma fração de dois polinómios.  Se
     nenhuma solução tiver sido encontrada, é retornado `done'.

     Essa função é controlada attravés das variáveis globais
     <GGFINFINITY> e <GGFCFMAX>. Veja também <GGFINFINITY> e <GGFCFMAX>.

     Para usar essa função primeiro escreva `load("ggf")'.


File: maxima.info,  Node: impdiff,  Next: interpol,  Prev: ggf,  Up: Top

51 impdiff
**********

* Menu:

* Definições para impdiff::


File: maxima.info,  Node: Definições para impdiff,  Prev: impdiff,  Up: impdiff

51.1 Definições para impdiff
============================

 -- Função: implicit_derivative (<f>,<indvarlist>,<orderlist>,<depvar>)
     Essa subrotina calcula derivadas implícitas de funções de várias
     variáveis.  <f> é uma função do tipo array, os índices são o grau
     da derivada na ordem <indvarlist>; <indvarlist> é a lista de
     variáveis independentes; <orderlist> é a ordem desejada; e
     <depvar> é a variável dependente.

     Para usar essa função escreva primeiro `load("impdiff")'.


File: maxima.info,  Node: interpol,  Next: lbfgs,  Prev: impdiff,  Up: Top

52 interpol
***********

* Menu:

* Introdução a interpol::
* Definições para interpol::


File: maxima.info,  Node: Introdução a interpol,  Next: Definições para interpol,  Prev: interpol,  Up: interpol

52.1 Introdução a interpol
==========================

Pacote `interpol' define os métodos Lagrangiano, linear e o de splines
cúbicos para interpolação polinomial.

Comentários, correções e sugestões, por favor contacte-me em <'mario AT
edu DOT xunta DOT es'>.


File: maxima.info,  Node: Definições para interpol,  Prev: Introdução a interpol,  Up: interpol

52.2 Definições para interpol
=============================

 -- Função: lagrange (<pontos>)
 -- Função: lagrange (<pontos>, <opção>)
     Calcula a interpolação polinomial através do método Lagrangiano. O
     argumento <pontos> deve ser um dos seguintes:

        * uma matriz de duas colunas, `p:matrix([2,4],[5,6],[9,3])',

        * uma lista de pares, `p: [[2,4],[5,6],[9,3]]',

        * uma lista de números, `p: [4,6,3]', e nesse caso as abcissas
          irão ser atribuídas automaticamente aos valores 1, 2, 3, etc.

     Nos dois primeiros casos os pares são ordenados em relação à
     primeira coordenada antes de fazer os cálculos.

     Com o argumento <opção> é possível escolher o nome da variável
     independente, o qual é `'x' por padrão; para definir qualquer
     outra, z por exemplo, escreva `varname='z'.

     Exemplos:

          (%i1) load("interpol")$
          (%i2) p:[[7,2],[8,2],[1,5],[3,2],[6,7]]$
          (%i3) lagrange(p);
                           4        3         2
                       73 x    701 x    8957 x    5288 x   186
          (%o3)        ----- - ------ + ------- - ------ + ---
                        420     210       420      105      5
          (%i4) f(x):=''%;
                               4        3         2
                           73 x    701 x    8957 x    5288 x   186
          (%o4)    f(x) := ----- - ------ + ------- - ------ + ---
                            420     210       420      105      5
          (%i5) /* Evaluate the polynomial at some points */
                map(f,[2.3,5/7,%pi]);
                                       919062
          (%o5)  [- 1.567534999999992, ------,
                                       84035
                                   4          3           2
                             73 %pi    701 %pi    8957 %pi    5288 %pi   186
                             ------- - -------- + --------- - -------- + ---]
                               420       210         420        105       5
          (%i6) %,numer;
          (%o6) [- 1.567534999999992, 10.9366573451538, 2.89319655125692]
          (%i7) /* Plot the polynomial together with points */
                plot2d([f(x),[discrete,p]],[x,0,10],
                     [gnuplot_curve_styles,
                           ["with lines","with points pointsize 3"]])$
          (%i8) /* Change variable name */
                lagrange(p, varname=w);
                           4        3         2
                       73 w    701 w    8957 w    5288 w   186
          (%o8)        ----- - ------ + ------- - ------ + ---
                        420     210       420      105      5


 -- Função: charfun2 (<x>, <a>, <b>)
     Retorna `true', i. e., verdadeiro se o número <x> pertence ao
     intervalo [a, b), e `false', i. e., falsono caso contrário.

 -- Função: linearinterpol (<pontos>)
 -- Função: linearinterpol (<pontos>, <opção>)
     Calcula a interpolação polinomial através do método linear. O
     argumento <pontos> deve ser um dos seguintes:

        * uma matriz de duas colunas, `p:matrix([2,4],[5,6],[9,3])',

        * uma lista de pares, `p: [[2,4],[5,6],[9,3]]',

        * uma lista de números, `p: [4,6,3]', e nesse caso as abcissas
          irão ser atribuídas automaticamente aos valores 1, 2, 3, etc.

     Nos dois primeiros casos os pares são ordenados em relação à
     primeira coordenada antes de fazer os cálculos.

     Com o argumento <opção> é possível escolher o nome da variável
     independente, o qual é `'x' por padrão; para definir qualquer
     outra, z por exemplo, escreva `varname='z'.

     Examples:
          (%i1) load("interpol")$
          (%i2) p: matrix([7,2],[8,3],[1,5],[3,2],[6,7])$
          (%i3) linearinterpol(p);
                  13   3 x
          (%o3)  (-- - ---) charfun2(x, minf, 3)
                  2     2
           + (x - 5) charfun2(x, 7, inf) + (37 - 5 x) charfun2(x, 6, 7)
              5 x
           + (--- - 3) charfun2(x, 3, 6)
               3

          (%i4) f(x):=''%;
                          13   3 x
          (%o4)  f(x) := (-- - ---) charfun2(x, minf, 3)
                          2     2
           + (x - 5) charfun2(x, 7, inf) + (37 - 5 x) charfun2(x, 6, 7)
              5 x
           + (--- - 3) charfun2(x, 3, 6)
               3
          (%i5)  /* Evaluate the polynomial at some points */
                 map(f,[7.3,25/7,%pi]);
                                      62  5 %pi
          (%o5)                 [2.3, --, ----- - 3]
                                      21    3
          (%i6) %,numer;
          (%o6)  [2.3, 2.952380952380953, 2.235987755982989]
          (%i7)  /* Plot the polynomial together with points */
                 plot2d(['(f(x)),[discrete,args(p)]],[x,-5,20],
                     [gnuplot_curve_styles,
                           ["with lines","with points pointsize 3"]])$
          (%i8)  /* Change variable name */
                 linearinterpol(p, varname='s);
                 13   3 s
          (%o8) (-- - ---) charfun2(s, minf, 3)
                 2     2
           + (s - 5) charfun2(s, 7, inf) + (37 - 5 s) charfun2(s, 6, 7)
              5 s
           + (--- - 3) charfun2(s, 3, 6)
               3


 -- Função: cspline (<pontos>)
 -- Função: cspline (<pontos>, <opção1>, <opção2>, ...)
     Calcula a interpolação polnomial pelo método de splines (
     polinómios de ordem k que interpolam os dados e têm k-1 derivadas
     contínuas em todo o intervalo ) cúbicos. O argumento <pontos> deve
     ser um dos seguintes:

        * uma matriz de duas colunas, `p:matrix([2,4],[5,6],[9,3])',

        * uma lista de pares, `p: [[2,4],[5,6],[9,3]]',

        * uma lista de números, `p: [4,6,3]', e nesse caso as abcissas
          irão ser atribuídas automaticamente aos valores 1, 2, 3, etc.

     Nos dois primeiros casos os pares são ordenados em relação à
     primeira coordenada antes de fazer os cálculos.

     Existem três opções para ajustar necessidades específicas:
        * `'d1', o padrão é `'unknown', é a primeira derivada em x_1;
          se essa primeira derivada for desconhecida, `'unknown', a
          segunda derivada em x_1 é igualada a 0 (o spline cúbico
          natural); se essa primeira derivada for igual a um número, a
          segunda derivada é calculada baseando-se nesse número.

        * `'dn', o padrão é `'unknown', é a primeira derivada em x_n;
          se essa primeira derivada for desconhecida, `'unknown', a
          segunda derivada em x_n é igualada a 0 (o spline cúbico
          natural); se essa primeira derivada for igual a um número, a
          segunda derivada é calculada baseando-se nesse número.

        * `'nome_var', o padrão é `'x', é o nome da variável
          independente.

     Exemplos:
          (%i1) load("interpol")$
          (%i2) p:[[7,2],[8,2],[1,5],[3,2],[6,7]]$
          (%i3) /* Unknown first derivatives at the extremes
                   is equivalent to natural cubic splines */
                cspline(p);
                        3         2
                  1159 x    1159 x    6091 x   8283
          (%o3)  (------- - ------- - ------ + ----) charfun2(x, minf, 3)
                   3288      1096      3288    1096
                      3         2
                2587 x    5174 x    494117 x   108928
           + (- ------- + ------- - -------- + ------) charfun2(x, 7, inf)
                 1644       137       1644      137
                    3          2
              4715 x    15209 x    579277 x   199575
           + (------- - -------- + -------- - ------) charfun2(x, 6, 7)
               1644       274        1644      274
                      3         2
                3287 x    2223 x    48275 x   9609
           + (- ------- + ------- - ------- + ----) charfun2(x, 3, 6)
                 4932       274      1644     274

          (%i4) f(x):=''%$
          (%i5) /* Some evaluations */
                map(f,[2.3,5/7,%pi]), numer;
          (%o5) [1.991460766423356, 5.823200187269903, 2.227405312429507]
          (%i6) /* Plotting interpolating function */
                plot2d(['(f(x)),[discrete,p]],[x,0,10],
                    [gnuplot_curve_styles,
                         ["with lines","with points pointsize 3"]])$
          (%i7) /* New call, but giving values at the derivatives */
                cspline(p,d1=0,dn=0);
                        3          2
                  1949 x    11437 x    17027 x   1247
          (%o7)  (------- - -------- + ------- + ----) charfun2(x, minf, 3)
                   2256       2256      2256     752
                      3          2
                1547 x    35581 x    68068 x   173546
           + (- ------- + -------- - ------- + ------) charfun2(x, 7, inf)
                  564       564        141      141
                   3          2
              607 x    35147 x    55706 x   38420
           + (------ - -------- + ------- - -----) charfun2(x, 6, 7)
               188       564        141      47
                      3         2
                3895 x    1807 x    5146 x   2148
           + (- ------- + ------- - ------ + ----) charfun2(x, 3, 6)
                 5076       188      141      47
          (%i8) /* Defining new interpolating function */
                g(x):=''%$
          (%i9) /* Plotting both functions together */
                plot2d(['(f(x)),'(g(x)),[discrete,p]],[x,0,10],
                     [gnuplot_curve_styles,
                        ["with lines","with lines","with points pointsize 3"]])$



File: maxima.info,  Node: lbfgs,  Next: lindstedt,  Prev: interpol,  Up: Top

53 lbfgs
********

* Menu:

* Introdução a lbfgs::
* Definições para lbfgs::


File: maxima.info,  Node: Introdução a lbfgs,  Next: Definições para lbfgs,  Prev: Top,  Up: Top

53.1 Introdução a lbfgs
=======================

`lbfgs' é uma implementação do algoritmo[1] L-BFGS
(Broyden-Fletcher-Goldfarb-Shanno) para resolver problemas de
minimização não limitada através de um algoritmo de memória limitada
quasi-Newton (BFGS).  Esse algoritmo é chamado de método de memória
limitada porque uma aproximação de baixo ranque da inverso da matriz
Hessiana é armazenado em lugar da inversa da matriz Hessiana completa.
O programa foi escrito origináriamente em Fortran [2] por Jorge Nocedal,
incorporando algumas funções originalmente escritas por Jorge J. Moré e
David J. Thuente, e traduzidas para Lisp automaticamente através do
programa `f2cl'.  O pacote do Maxima `lbfgs' compreende o código
traduzido e adicionalmente uma interface de função que gerencia alguns
detallhes.

Referências:

[1] D. Liu and J. Nocedal. "On the limited memory BFGS method for large
scale optimization". Mathematical Programming B 45:503-528 (1989)

[2] http://netlib.org/opt/lbfgs_um.shar


File: maxima.info,  Node: Definições para lbfgs,  Prev: Introdução a lbfgs,  Up: Top

53.2 Definições para lbfgs
==========================

 -- Função: lbfgs (<FOM>, <X>, <X0>, <epsilon>, <iprint>)
     Encontra uma solução aproximada da minimização não limitada de
     número de mérito <FOM> sobre a lista de variáveis <X>, começando a
     partir da estimativa inicial <X0>, tal que norm grad FOM < epsilon
     max(1, norm X).

     O algoritmo aplicado é um algoritmo de memória limitada[1]
     quasi-Newton (BFGS).  Esse algoritmo é chamado de método de
     memória limitada porque uma aproximação de baixo ranque da inverso
     da matriz Hessiana é armazenado em lugar da inversa da matriz
     Hessiana completa.

     <iprint> controla as messaens de progresso mostradas através de
     `lbfgs'.

    `iprint[1]'
          `<iprint>[1]' controla a frequência das mensagens de
          progresso.
         `iprint[1] < 0'
               Nenhuma mensagem de progresso.

         `iprint[1] = 0'
               Messagens na primeira iteração e na última iteração.

         `iprint[1] > 0'
               Mostra uma mensagem a cada `<iprint>[1]' iterações.

    `iprint[2]'
          `<iprint>[2]' controla a quantidade de informações fornecidas
          pelas mensagens de progresso (verbosidade).
         `iprint[2] = 0'
               Mostra na tela o contador de iterações, o número de
               avaliações de <FOM>, o valor de <FOM>, a norma do
               gradiente de <FOM>, e o comprimento do salto.

         `iprint[2] = 1'
               O mesmo que `<iprint>[2] = 0', adicionando <X0> e o
               gradiente de <FOM> avaliado em <X0>.

         `iprint[2] = 2'
               O mesmo que `<iprint>[2] = 1', adicionando valores de
               <X> a cada iteração.

         `iprint[2] = 3'
               O mesmo que `<iprint>[2] = 2', adicionando o gradiente
               de <FOM> a cada iteração.

     Veja também `lbfgs_nfeval_max' e `lbfgs_ncorrections'.

     Referências:

     [1] D. Liu and J. Nocedal. "On the limited memory BFGS method for
     large scale optimization". Mathematical Programming B 45:503-528
     (1989)

     Exemplo:

          (%i1) load (lbfgs);
          (%o1)   /usr/share/maxima/5.10.0cvs/share/lbfgs/lbfgs.mac
          (%i2) FOM : '((1/length(X))*sum((F(X[i]) - Y[i])^2, i, 1, length(X)));
                                         2
                         sum((F(X ) - Y ) , i, 1, length(X))
                                 i     i
          (%o2)          -----------------------------------
                                      length(X)
          (%i3) X : [1, 2, 3, 4, 5];
          (%o3)                    [1, 2, 3, 4, 5]
          (%i4) Y : [0, 0.5, 1, 1.25, 1.5];
          (%o4)                [0, 0.5, 1, 1.25, 1.5]
          (%i5) F(x) := A/(1 + exp(-B*(x - C)));
                                             A
          (%o5)            F(x) := ----------------------
                                   1 + exp((- B) (x - C))
          (%i6) ''FOM;
                          A               2            A                2
          (%o6) ((----------------- - 1.5)  + (----------------- - 1.25)
                    - B (5 - C)                  - B (4 - C)
                  %e            + 1            %e            + 1
                      A             2            A               2
           + (----------------- - 1)  + (----------------- - 0.5)
                - B (3 - C)                - B (2 - C)
              %e            + 1          %e            + 1
                       2
                      A
           + --------------------)/5
                - B (1 - C)     2
             (%e            + 1)
          (%i7) estimates : lbfgs (FOM, '[A, B, C], [1, 1, 1], 1e-4, [1, 0]);
          *************************************************
            N=    3   NUMBER OF CORRECTIONS=25
                 INITIAL VALUES
           F=  1.348738534246918D-01   GNORM=  2.000215531936760D-01
          *************************************************

             I  NFN     FUNC                    GNORM                   STEPLENGTH

             1    3     1.177820636622582D-01   9.893138394953992D-02   8.554435968992371D-01
             2    6     2.302653892214013D-02   1.180098521565904D-01   2.100000000000000D+01
             3    8     1.496348495303005D-02   9.611201567691633D-02   5.257340567840707D-01
             4    9     7.900460841091139D-03   1.325041647391314D-02   1.000000000000000D+00
             5   10     7.314495451266917D-03   1.510670810312237D-02   1.000000000000000D+00
             6   11     6.750147275936680D-03   1.914964958023047D-02   1.000000000000000D+00
             7   12     5.850716021108205D-03   1.028089194579363D-02   1.000000000000000D+00
             8   13     5.778664230657791D-03   3.676866074530332D-04   1.000000000000000D+00
             9   14     5.777818823650782D-03   3.010740179797255D-04   1.000000000000000D+00

           THE MINIMIZATION TERMINATED WITHOUT DETECTING ERRORS.
           IFLAG = 0
          (%o7) [A = 1.461933911464101, B = 1.601593973254802,
                                                     C = 2.528933072164854]
          (%i8) plot2d ([F(x), [discrete, X, Y]], [x, -1, 6]), ''estimates;
          (%o8)


 -- Variãvel: lbfgs_nfeval_max
     Valor por omissão: 100


 -- Variãvel: lbfgs_ncorrections
     Valor por omissão: 25



File: maxima.info,  Node: lindstedt,  Next: linearalgebra,  Prev: lbfgs,  Up: Top

54 lindstedt
************

* Menu:

* Definições para lindstedt::


File: maxima.info,  Node: Definições para lindstedt,  Prev: lindstedt,  Up: lindstedt

54.1 Definições para lindstedt
==============================

 -- Função: Lindstedt (<eq>,<pvar>,<torder>,<ic>)
     Esse é um primeiro passo para um código de Lindstedt.  Esse código
     pode resolver problemas com condições iniciais fornecidas, às
     quais podem ser constantes arbitrárias, (não apenas <%k1> e <%k2>)
     onde as condições iniciais sobre as equações de perturbação são
     z[i]=0, z'[i]=0 para i>0. <ic> é a lista de condições iniciais.

     Problemas ocorrem quando condições iniciais não forem dadas, como
     as constantes nas equações de perturbação são as mesmas que a
     solução da equação de ordem zero.  Também, problemas ocorrem
     quando as condições iniciais para as equações de perturbação não
     são z[i]=0, z'[i]=0 para i>0, tais como a equação de Van der Pol.

     Exemplo:
          (%i1) load("makeOrders")$

          (%i2) load("lindstedt")$

          (%i3) Lindstedt('diff(x,t,2)+x-(e*x^3)/6,e,2,[1,0]);
                    2
                   e  (cos(5 T) - 24 cos(3 T) + 23 cos(T))
          (%o3) [[[---------------------------------------
                                    36864
             e (cos(3 T) - cos(T))
           - --------------------- + cos(T)],
                      192
                    2
                 7 e    e
          T = (- ---- - -- + 1) t]]
                 3072   16

     Para usar essa função escreva primeiro `load("makeOrders")' e
     `load("lindstedt")'.


File: maxima.info,  Node: linearalgebra,  Next: lsquares,  Prev: lindstedt,  Up: Top

55 linearalgebra
****************

* Menu:

* Introdução a linearalgebra::
* Definições para linearalgebra::


File: maxima.info,  Node: Introdução a linearalgebra,  Next: Definições para linearalgebra,  Prev: linearalgebra,  Up: linearalgebra

55.1 Introdução a linearalgebra
===============================

`linearalgebra' é uma colecção de funções para álgebra linear.

Exemplo:

     (%i1) load (linearalgebra);
     Warning - you are redefining the Maxima function require_list
     Warning - you are redefining the Maxima function matrix_size
     Warning - you are redefining the Maxima function rank
     (%o1) /usr/local/share/maxima/5.9.2/share/linearalgebra/linearalgebra.mac
     (%i2) M : matrix ([1, 2], [1, 2]);
                                 [ 1  2 ]
     (%o2)                       [      ]
                                 [ 1  2 ]
     (%i3) nullspace (M);
                                    [  1  ]
                                    [     ]
     (%o3)                     span([   1 ])
                                    [ - - ]
                                    [   2 ]
     (%i4) columnspace (M);
                                     [ 1 ]
     (%o4)                      span([   ])
                                     [ 1 ]
     (%i5) ptriangularize (M - z*ident(2), z);
                              [ 1   2 - z   ]
     (%o5)                    [             ]
                              [           2 ]
                              [ 0  3 z - z  ]
     (%i6) M : matrix ([1, 2, 3], [4, 5, 6], [7, 8, 9]) - z*ident(3);
                          [ 1 - z    2      3   ]
                          [                     ]
     (%o6)                [   4    5 - z    6   ]
                          [                     ]
                          [   7      8    9 - z ]
     (%i7) MM : ptriangularize (M, z);
                   [ 4  5 - z            6            ]
                   [                                  ]
                   [                2                 ]
                   [     66        z    102 z   132   ]
                   [ 0   --      - -- + ----- + ---   ]
     (%o7)         [     49        7     49     49    ]
                   [                                  ]
                   [               3        2         ]
                   [           49 z    245 z    147 z ]
                   [ 0    0    ----- - ------ - ----- ]
                   [            264      88      44   ]
     (%i8) algebraic : true;
     (%o8)                         true
     (%i9) tellrat (MM [3, 3]);
                              3       2
     (%o9)                  [z  - 15 z  - 18 z]
     (%i10) MM : ratsimp (MM);
                    [ 4  5 - z           6           ]
                    [                                ]
                    [                2               ]
     (%o10)         [     66      7 z  - 102 z - 132 ]
                    [ 0   --    - ------------------ ]
                    [     49              49         ]
                    [                                ]
                    [ 0    0             0           ]
     (%i11) nullspace (MM);
                             [        1         ]
                             [                  ]
                             [   2              ]
                             [  z  - 14 z - 16  ]
                             [  --------------  ]
     (%o11)             span([        8         ])
                             [                  ]
                             [    2             ]
                             [   z  - 18 z - 12 ]
                             [ - -------------- ]
                             [         12       ]
     (%i12) M : matrix ([1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]);
                            [ 1   2   3   4  ]
                            [                ]
                            [ 5   6   7   8  ]
     (%o12)                 [                ]
                            [ 9   10  11  12 ]
                            [                ]
                            [ 13  14  15  16 ]
     (%i13) columnspace (M);
                                [ 1  ]  [ 2  ]
                                [    ]  [    ]
                                [ 5  ]  [ 6  ]
     (%o13)                span([    ], [    ])
                                [ 9  ]  [ 10 ]
                                [    ]  [    ]
                                [ 13 ]  [ 14 ]
     (%i14) apply ('orthogonal_complement, args (nullspace (transpose (M))));
                                [ 0 ]  [  1  ]
                                [   ]  [     ]
                                [ 1 ]  [  0  ]
     (%o14)                span([   ], [     ])
                                [ 2 ]  [ - 1 ]
                                [   ]  [     ]
                                [ 3 ]  [ - 2 ]


File: maxima.info,  Node: Definições para linearalgebra,  Prev: Introdução a linearalgebra,  Up: linearalgebra

55.2 Definições para linearalgebra
==================================

 -- Função: addmatrices (<f>, <M_1>, ..., <M_n>)
     Usando a função <f> como a função de adição, retorne a adição das
     matrizes <M_1>, ..., <M_n>. A função <f> deve aceitar qualquer
     número de argumentos (uma função enária do Maxima).

     Exemplos:

          (%i1) m1 : matrix([1,2],[3,4])$
          (%i2) m2 : matrix([7,8],[9,10])$
          (%i3) addmatrices('max,m1,m2);
          (%o3) matrix([7,8],[9,10])
          (%i4) addmatrices('max,m1,m2,5*m1);
          (%o4) matrix([7,10],[15,20])


 -- Função: blockmatrixp (<M>)
     Retorna `true' se e somente se <M> for uma matriz e toda entrada de
     <M> também for uma matriz.


 -- Função: columnop (<M>, <i>, <j>, <theta>)
     Se <M> for uma matriz, retorna a matriz que resulta de fazer a
     operação de coluna `C_i <- C_i - <theta> * C_j'. Se <M> não tiver
     uma linha <i> ou <j>, emite uma mensagem de erro.


 -- Função: columnswap (<M>, <i>, <j>)
     Se <M> for uma matriz, troca as colunas <i> e <j>.  Se <M> não
     tiver uma coluna <i> ou <j>, emite uma mensagem de erro.


 -- Função: columnspace (<M>)
     Se <M> for uma matriz, retorna `span (v_1, ..., v_n)', onde o
     conjunto `{v_1, ..., v_n}' é uma base para o espaço coluna de <M>.
     A diferença entre o maior elemento e o menor elemento do conjunto
     vazio é `{0}'. Dessa forma, quando o espaço coluna tiver somente
     um membro, retorna `span ()'.


 -- Função: copy (<e>)
     Retorna uma cópia da expressão <e> do Maxima. Embora <e> possa ser
     qualquer expressão do Maxima, Afunção `copy' é mais útil quando
     <e> for ou uma lista ou uma matriz; considere: load
     (linearalgebra); m : [1,[2,3]]$ mm : m$ mm[2][1] : x$ m; mm;
          (%i1) load("linearalgebra")$
          (%i2) m : [1,[2,3]]$
          (%i3) mm : m$
          (%i4) mm[2][1] : x$
          (%i5) m;
          (%o5) [1,[x,3]]
          (%i6) mm;
          (%o6) [1,[x,3]]
     Vamos tentar a mesma experiência, mas dessa vez tomemos <mm> como
     sendo uma cópia de <m> m : [1,[2,3]]$ mm : copy(m)$ mm[2][1] : x$
     m; mm;
          (%i7) m : [1,[2,3]]$
          (%i8) mm : copy(m)$
          (%i9) mm[2][1] : x$
          (%i10) m;
          (%o10) [1,[2,3]]
          (%i11) mm;
          (%o11) [1,[x,3]]
     Dessa vez, a atribuição a <mm> não muda o valor de <m>.


 -- Função: cholesky (<M>)
 -- Função: cholesky (<M>, <corpo>)
     Retorna factorização de Cholesky da matriz hermitiana (or
     autoadjunta) <M>. O valor padrão para o segundo argumento é
     `generalring'. Para uma descrição dos possíveis valores para
     <corpo>, veja `lu_factor'.


 -- Função: ctranspose (<M>)
     Retorna a matriz transposta conjugada complexa da matriz <M>. A
     função `ctranspose' usa `matrix_element_transpose' para transpor
     cada elemento da matriz.


 -- Função: diag_matrix (<d_1>, <d_2>,...,<d_n>)
     Retorna uma matriz diagonal matriz com entradas de diagonal <d_1>,
     <d_2>,...,<d_n>.  Quando as entradas de diagonal forem matrizes,
     as entradas zero da matriz retornada serão todas matrizes de
     tamanho apropriado; por exemplo:
          (%i1) load(linearalgebra)$

          (%i2) diag_matrix(diag_matrix(1,2),diag_matrix(3,4));

                                      [ [ 1  0 ]  [ 0  0 ] ]
                                      [ [      ]  [      ] ]
                                      [ [ 0  2 ]  [ 0  0 ] ]
          (%o2)                       [                    ]
                                      [ [ 0  0 ]  [ 3  0 ] ]
                                      [ [      ]  [      ] ]
                                      [ [ 0  0 ]  [ 0  4 ] ]
          (%i3) diag_matrix(p,q);

                                             [ p  0 ]
          (%o3)                              [      ]
                                             [ 0  q ]

 -- Função: dotproduct (<u>, <v>)
     Retorna o produto do ponto (produto escalar) dos vectores <u> e
     <v>.  Isso é o mesmo que `conjugate (transpose (<u>)) . <v>'.  Os
     argumentos <u> e <v> devem ser vectores coluna.


 -- Função: eigens_by_jacobi (<A>)
 -- Função: eigens_by_jacobi (<A>, <tipo_corpo>)
     Calculam os autovalores e autovectores de <A> pelo método de
     rotações de Jacobi.  <A> deve ser uma matriz simétrica (mas essa
     matriz simétrica precisa não ser nem definida positiva e nem
     semidefinida positiva).  <tipo_corpo> indica o corpo
     computacional, pode ser ou `floatfield' ou `bigfloatfield'.  Se
     <tipo_corpo> não for especificado, o padrão é `floatfield'.

     Os elementos de <A> devem ser números ou expressões que avaliam
     para números via `float' ou `bfloat' (dependendo do valor de
     <tipo_corpo>).

     Exemplos:

          (%i1) load (linearalgebra);
          (%o1) /home/robert/tmp/maxima-head/maxima/share/linearalgebra/li\
          nearalgebra.mac
          (%i2) S : matrix ([1/sqrt(2), 1/sqrt(2)], [- 1/sqrt(2), 1/sqrt(2)]);
                               [     1         1    ]
                               [  -------   ------- ]
                               [  sqrt(2)   sqrt(2) ]
          (%o2)                [                    ]
                               [      1        1    ]
                               [ - -------  ------- ]
                               [   sqrt(2)  sqrt(2) ]
          (%i3) L : matrix ([sqrt(3), 0], [0, sqrt(5)]);
                                [ sqrt(3)     0    ]
          (%o3)                 [                  ]
                                [    0     sqrt(5) ]
          (%i4) M : S . L . transpose (S);
                      [ sqrt(5)   sqrt(3)  sqrt(5)   sqrt(3) ]
                      [ ------- + -------  ------- - ------- ]
                      [    2         2        2         2    ]
          (%o4)       [                                      ]
                      [ sqrt(5)   sqrt(3)  sqrt(5)   sqrt(3) ]
                      [ ------- - -------  ------- + ------- ]
                      [    2         2        2         2    ]
          (%i5) eigens_by_jacobi (M);
          The largest percent change was 0.1454972243679
          The largest percent change was 0.0
          number of sweeps: 2
          number of rotations: 1
          (%o5) [[1.732050807568877, 2.23606797749979],
                                  [  0.70710678118655   0.70710678118655 ]
                                  [                                      ]]
                                  [ - 0.70710678118655  0.70710678118655 ]
          (%i6) float ([[sqrt(3), sqrt(5)], S]);
          (%o6) [[1.732050807568877, 2.23606797749979],
                                  [  0.70710678118655   0.70710678118655 ]
                                  [                                      ]]
                                  [ - 0.70710678118655  0.70710678118655 ]
          (%i7) eigens_by_jacobi (M, bigfloatfield);
          The largest percent change was 1.454972243679028b-1
          The largest percent change was 0.0b0
          number of sweeps: 2
          number of rotations: 1
          (%o7) [[1.732050807568877b0, 2.23606797749979b0],
                          [  7.071067811865475b-1   7.071067811865475b-1 ]
                          [                                              ]]
                          [ - 7.071067811865475b-1  7.071067811865475b-1 ]


 -- Função: get_lu_factors (<x>)
     Quando `<x> = lu_factor (<A>)', então `get_lu_factors' retorna uma
     lista da forma `[P, L, U]', onde <P> é uma matriz de permutação,
     <L> é triangular baixa com a diagonal preenchida com a unidade, e
     <U> é triangular alta, e `<A> = <P> <L> <U>'.


 -- Função: hankel (<col>)
 -- Função: hankel (<col>, <lin>)
     Retorna uma matriz de Hankel <H>. A primeira coluna de <H> é <col>;
     excepto para a primeira entrada, a última linha de <H> é <lin>. O
     valor padrão para <lin> é o vector nulo com o mesmo comprimento
     que <col>.


 -- Função: hessian (<f>,<vars>)
     Retorna a matriz hessiana de <f> com relação às variáveis na lista
     <vars>.  As entradas <i>,<j> da matriz hessiana são <diff(f
     vars[i],1,vars[j],1)>.


 -- Função: hilbert_matrix (<n>)
     Retorna the <n> by <n> matriz de Hilbert. Quando <n> não for um
     inteiro positivo, emite uma mensagem de erro.


 -- Função: identfor (<M>)
 -- Função: identfor (<M>, <corpo>)
     Retorna uma matriz identidade que tem o mesmo tamanho que a matriz
     <M>.  As entradas de diagonal da matriz identidade são a
     identidade multiplicativa do corpo <corpo>; o padrão para <corpo>
     é <generalring>.

     O primeiro argumento <M> pode ser uma  matriz quadrada ou um não
     matriz. Quando <M> for uma matriz, cada entrada de <M> pode ser uma
     matriz quadrada - dessa forma <M> pode ser uma matriz de bloco do
     Maxima. A matriz pode ser de bloco para qualquer (finita)
     quantidade de níveis.

     Veja também `zerofor'


 -- Função: invert_by_lu (<M>, <(rng generalring)>)
     Inverte a matriz <M> através de factorização linear alta (LU).  A
     factorização LU é concluída usando o anel <rng>.


 -- Função: kronecker_product (<A>, <B>)
     Retorna o produto de Kronecker das matrizes <A> e <B>.


 -- Função: listp (<e>, <p>)
 -- Função: listp (<e>)
     Recebendo um argumento opcional <p>, retorna `true' se <e> for uma
     lista do Maxima e <p> avalia para `true' para elemento da lista.
     Quando `listp' não recebe o argumento opcional, retorna `true' se
     <e> for uma lista do Maxima.  em todos os outros casos, retorna
     `false'.


 -- Função: locate_matrix_entry (<M>, <r_1>, <c_1>, <r_2>, <c_2>, <f>,
          <rel>)
     O primeiro argumento deve ser uma matriz; os argumentos que vão de
     <r_1> até <c_2> determinam um sub-matriz de <M> que consiste de
     linhas que vão de <r_1> até <r_2> e colunas que vão de <c_1> até
     <c_2>.

     Encontra uma entrada na sub-matriz <M> que satisfaz alguma
     propriedade.  Existem três casos:

     (1) `<rel> = 'bool' e <f> um predicado:

     Examina a sub-matriz da esquerda para a direita e de cima para
     baixo, e retorna o índice da primeira entrada que satisfizer o
     predicado <f>. Se nenhuma entrada da matriz satisfizer o predicado
     <f>, retorna `false'.

     (2) `<rel> = 'max' e <f> avaliar para um número real:

     Examina a sub-matriz procurando por uma entrada que maximize <f>.
     Retorna retorna o índice da entrada maximizada.

     (3) `<rel> = 'min' e <f> avaliar para um número real:

     Examina a sub-matriz procurando por uma entrada que minimize <f>.
     Retorna o índice de uma entrada minimizada.


 -- Função: lu_backsub (<M>, <b>)
     Quando `<M> = lu_factor (<A>, <corpo>)', então `lu_backsub (<M>,
     <b>)' resolve o sistema linear `<A> <x> = <b>'.


 -- Função: lu_factor (<M>, <corpo>)
     Retorna uma lista da forma `[<LU>, <perm>, <corpo>]', ou da forma
     `[<LU>, <perm>, <cmp>, <baixo-cnd> <alto-cnd>]', onde

     (1) A matriz <LU> contéa factorização de <M> na forma enpacotada.
     Forma       empacotada significa três coisas: Primeiro, as linhas
     de <LU> são permutadas confirme a       lista <perm>.  Se, por
     exemplo, <perm> for a lista list `[3,2,1]', a primeira linha actual
          da factorização <LU> será a terceira linha da matriz <LU>.
     Segundo,       o factor triangular baixo de m é a parte triangular
     baixa de <LU> com as       entradas de diagonal todas substituídas
     pela unidade. Terceiro, o factor triangular alto de       <M> é a
     parte triangular alta de <LU>.

     (2) Quando o corpo for ou `floatfield' ou `complexfield',       os
     números <baixo-cnd> e <alto-cnd> serão associados baixo e alto
     para o       número condicional de norma infinita de <M>.  Para
     todos os corpos (fields), o número condicional de norma infinita
        não pode ser estimado; para tais corpos, `lu_factor' retorna
     uma lista com dois itens.        Ambos o baixo e o alto associado
     podem diferir de seus verdadeiros valores de       factores
     arbitráriamente grandes. (Veja também `mat_cond'.)

     O argumento <M> deve ser a matriz quadrada.

     O argumento opcional <cmp> deve ser um símbolo que determine um
     anel ou corpo. Os corpos e anéis   predefinidos são:

     (a) `generalring' - o anel de expressões do Maxima,     (b)
     `floatfield' -  o corpo dos números em ponto flutuante do tipo de
     precisão dupla,     (c) `complexfield' -  o corpo dos números
     complexos em ponto flutuante do         tipo de precisão dupla,
     (d) `crering'  - o anel das expressões racionais canónicas (CRE)
     do Maxima,     (e) `rationalfield' - o corpo dos números racionais,
        (f) `runningerror' - rastro de todos os erros de arredondamento
     de números em ponto flutuante,      (g) `noncommutingring' - o
     anel de expressões do Maxima onde multiplicação for o
     operador ponto não comutativo.

     Quando o corpo for `floatfield', `complexfield', ou
     `runningerror', o algoritmo usa pivotagem parcial; para todos os
     outros corpos, linhas são comutadas somente quando necessário para
     evitar um pivô nulo.

     A adição aritmética em ponto flutuante não é associativa, então o
     significado de 'corpo' difere da definição matemática.

     Um membro do corpo `runningerror' é uma lista do Máxima de dois
     membros da forma `[x,n]',onde <x> é um número em onto flutuante e
     `n' é um inteiro. A diferença relativa entre o valor de
     'verdadeiro' de `x' e `x' é aproximadamente associado pelo épsilon
     da máquina vezes `n'. O erro de execução associado arrasta alguns
     termos da ordem do quadrado do épsilon da máquina.

     Não existe interface de utilizador definida um novo anel. Um
     utilizador que estiver familiazrizado com o Lisp Comum está apto
     para definir um novo corpo.  Para fazer isso, um utilizador deve
     definir funções para as operações aritméticas e funções para
     conversão para a representação de corpo do Máxima e vice-versa.
     Adicionalmente, para corpos ordenados (onde a pivotagem parcial
     será usada), um uduário deve definir funções para módulo e para
     comparar membros do corpo.  Após isso tudo que resta é definir uma
     estrutura de Lisp Comum `mring'.  O ficheiro `mring' tem muitos
     exemplos.

     Para calcular a factorização, a primeira tarefa é converter cada
     entrada de matriz para um elemento do corpo indicado. Quando a
     cnversão não for possível, a factorização encerra com uma mensagem
     de erro. Elementos do corpo não precisam ser expressões do Maxima.
     Elementos do `complexfield', por exemplo, são números complexos do
     Lisp Comum. Dessa forma após calcular a factorização, como
     entradas da matriz devem ser convertidas para expressões do Maxima.

     Veja também  `get_lu_factors'.

     Exemplos:
          (%i1) load (linearalgebra);
          Warning - you are redefining the Maxima function require_list
          Warning - you are redefining the Maxima function matrix_size
          Warning - you are redefining the Maxima function rank
          (%o1) /usr/local/share/maxima/5.9.2/share/linearalgebra/linearalgebra.mac
          (%i2) w[i,j] := random (1.0) + %i * random (1.0);
          (%o2)          w     := random(1.) + %i random(1.)
                          i, j
          (%i3) showtime : true$
          Evaluation took 0.00 seconds (0.00 elapsed)
          (%i4) M : genmatrix (w, 100, 100)$
          Evaluation took 7.40 seconds (8.23 elapsed)
          (%i5) lu_factor (M, complexfield)$
          Evaluation took 28.71 seconds (35.00 elapsed)
          (%i6) lu_factor (M, generalring)$
          Evaluation took 109.24 seconds (152.10 elapsed)
          (%i7) showtime : false$

          (%i8) M : matrix ([1 - z, 3], [3, 8 - z]);
                                  [ 1 - z    3   ]
          (%o8)                   [              ]
                                  [   3    8 - z ]
          (%i9) lu_factor (M, generalring);
                         [ 1 - z         3        ]
                         [                        ]
          (%o9)         [[   3            9       ], [1, 2]]
                         [ -----  - z - ----- + 8 ]
                         [ 1 - z        1 - z     ]
          (%i10) get_lu_factors (%);
                            [   1    0 ]  [ 1 - z         3        ]
                  [ 1  0 ]  [          ]  [                        ]
          (%o10) [[      ], [   3      ], [                9       ]]
                  [ 0  1 ]  [ -----  1 ]  [   0    - z - ----- + 8 ]
                            [ 1 - z    ]  [              1 - z     ]
          (%i11) %[1] . %[2] . %[3];
                                  [ 1 - z    3   ]
          (%o11)                  [              ]
                                  [   3    8 - z ]


 -- Função: mat_cond (<M>, 1)
 -- Função: mat_cond (<M>, inf)
     Retorna o número condiciona da norma de ordem <p> da matriz <m>.
     Os valores permitidos para <p> são 1 e <inf>.  Essa função utiliza
     a factorização linear alta para inverter a matriz <m>. Dessa forma
     o tempode execução para `mat_cond' é proporcional ao cubo do
     tamanho da matriz; `lu_factor' determina as associaçãoes baixa e
     alta para o número de condição de norma infinita em tempo
     proporcional ao quadrado do tamanho da matriz.


 -- Função: mat_norm (<M>, 1)
 -- Função: mat_norm (<M>, inf)
 -- Função: mat_norm (<M>, frobenius)
     Retorna a matriz de norma <p> da matriz <M>.  Os valores
     permitidos para <p> são 1, `inf', e `frobenius' (a norma da matriz
     de Frobenius). A matriz <M> pode ser uma matriz não de bloco.


 -- Função: matrixp (<e>, <p>)
 -- Função: matrixp (<e>)
     Fornecendo um argumento opcional <p>, `matrixp' retorna `true' se
     <e> for uma matriz e <p> avaliar para `true' para todo elemento da
     matriz.  Quando a `matrixp' não for fornecido umargumento
     opcional, retorna `true' se `e' for uma matriz.  em todos os
     outros casos, retorna `false'.

     Veja também `blockmatrixp'


 -- Função: matrix_size (<M>)
     Retorna uma lista com dois elementos que fornecem o número de
     linhas e colunas, respectivamente da matriz <M>.


 -- Função: mat_fullunblocker (<M>)
     Se <M> for uma matriz de bloco, expande todos os blocos da matriz
     em todos os níveis. Se <M> for uma matriz, retorna <M>; de outra
     forma, emite uma mensagem de erro.


 -- Função: mat_trace (<M>)
     Retorna o traço da matriz <M>. Se <M> não for uma matriz, retorna
     uma forma substantiva. Quando <M> for uma matriz de bloco,
     `mat_trace(M)' retorna o mesmo valor retornado por
     `mat_trace(mat_unblocker(m))'.


 -- Função: mat_unblocker (<M>)
     Se <M> for uma matriz de bloco, `mat_unbloker' desfaz o bloco de
     <M> um nível. Se <M> for uma matriz, `mat_unblocker (M)' retorna
     <M>; de outra forma, emite uma mensagem de erro.

     Dessa forma se cada entrada de <M> for matriz, `mat_unblocker (M)'
     retorna uma matriz "desblocada", mas se cada entrada de <M> for
     uma matriz de bloco, `mat_unblocker (M)' retorna uma matriz de
     bloco com um nível de bloco a menos.

     Se usar matrizes de bloco, muito provavelmente irá querer escolher
     `matrix_element_mult' para `"."' e `matrix_element_transpose' para
     `'transpose'. Veja também `mat_fullunblocker'.

     Exemplo:

          (%i1) load (linearalgebra);
          Warning - you are redefining the Maxima function require_list
          Warning - you are redefining the Maxima function matrix_size
          Warning - you are redefining the Maxima function rank
          (%o1) /usr/local/share/maxima/5.9.2/share/linearalgebra/linearalgebra.mac
          (%i2) A : matrix ([1, 2], [3, 4]);
                                      [ 1  2 ]
          (%o2)                       [      ]
                                      [ 3  4 ]
          (%i3) B : matrix ([7, 8], [9, 10]);
                                      [ 7  8  ]
          (%o3)                       [       ]
                                      [ 9  10 ]
          (%i4) matrix ([A, B]);
                               [ [ 1  2 ]  [ 7  8  ] ]
          (%o4)                [ [      ]  [       ] ]
                               [ [ 3  4 ]  [ 9  10 ] ]
          (%i5) mat_unblocker (%);
                                   [ 1  2  7  8  ]
          (%o5)                    [             ]
                                   [ 3  4  9  10 ]


 -- Função: nonnegintegerp (<n>)
     Retorna `true' se e somente se `<n> >= 0' e <n> for um inteiro.


 -- Função: nullspace (<M>)
     Se <M> for uma matriz, retorna `span (v_1, ..., v_n)', onde o
     conjunto `{v_1, ..., v_n}' é uma base para o espaço nulo de <M>.
     A diferença entre o maior elemento e o menor elemento do conjunto
     vazio é  `{0}'.  Dessa forma, quando o espaço nulo tiver somente
     um membro, retorna `span ()'.


 -- Função: nullity (<M>)
     Se <M> for uma matriz, retorna a dimensão do espaço nulo de <M>.


 -- Função: orthogonal_complement (<v_1>, ..., <v_n>)
     Retorna `span (u_1, ..., u_m)', onde o conjunto `{u_1, ..., u_m}'
     é uma base para o complemento ortogonal do conjunto `(v_1, ...,
     v_n)'.

     Cada vector no intervalo de <v_1> até <v_n> deve ser um vector
     coluna.


 -- Função: polynomialp (<p>, <L>, <coeffp>, <exponp>)
 -- Função: polynomialp (<p>, <L>, <coeffp>)
 -- Função: polynomialp (<p>, <L>)
     Retorna `true' se <p> for um polinómio nas variáveis da lista <L>,
     O predicado <coeffp> deve avaliar para `true' para cada
     coeficiente, e o predicado <exponp> deve avaliar para `true' para
     todos os expoentes das variáveis na lista <L>. Se quiser usar um
     valor personalizado para <exponp>, deverá fornecer <coeffp> com um
     valor mesmo se quiser o valor padrão para <coeffp>.

     `polynomialp (<p>, <L>, <coeffp>)' é equivalente a `polynomialp
     (<p>, <L>, <coeffp>, 'nonnegintegerp)'.

     `polynomialp (<p>, <L>)' é equivalente a `polynomialp (<p>, L<,>
     'constantp, 'nonnegintegerp)'.

     O polinómio não precisa ser expandido:

          (%i1) load (linearalgebra);
          Warning - you are redefining the Maxima function require_list
          Warning - you are redefining the Maxima function matrix_size
          Warning - you are redefining the Maxima function rank
          (%o1) /usr/local/share/maxima/5.9.2/share/linearalgebra/linearalgebra.mac
          (%i2) polynomialp ((x + 1)*(x + 2), [x]);
          (%o2)                         true
          (%i3) polynomialp ((x + 1)*(x + 2)^a, [x]);
          (%o3)                         false

     Um exemplo usando um valor personalizado para `coeffp' e para
     `exponp':

          (%i1) load (linearalgebra);
          Warning - you are redefining the Maxima function require_list
          Warning - you are redefining the Maxima function matrix_size
          Warning - you are redefining the Maxima function rank
          (%o1) /usr/local/share/maxima/5.9.2/share/linearalgebra/linearalgebra.mac
          (%i2) polynomialp ((x + 1)*(x + 2)^(3/2), [x], numberp, numberp);
          (%o2)                         true
          (%i3) polynomialp ((x^(1/2) + 1)*(x + 2)^(3/2), [x], numberp, numberp);
          (%o3)                         true

     Polinómios com duas variáveis:

          (%i1) load (linearalgebra);
          Warning - you are redefining the Maxima function require_list
          Warning - you are redefining the Maxima function matrix_size
          Warning - you are redefining the Maxima function rank
          (%o1) /usr/local/share/maxima/5.9.2/share/linearalgebra/linearalgebra.mac
          (%i2) polynomialp (x^2 + 5*x*y + y^2, [x]);
          (%o2)                         false
          (%i3) polynomialp (x^2 + 5*x*y + y^2, [x, y]);
          (%o3)                         true


 -- Função: polytocompanion (<p>, <x>)
     Se <p> for um polinómio em <x>, retorna a atriz companheira de
     <p>. Para um polinómio mônico <p> de grau <n>, temos `<p> =
     (-1)^<n> charpoly (polytocompanion (<p>, <x>))'.

     Quando <p> não for um polinómio em <x>, emite uma mensagem de erro.


 -- Função: ptriangularize (<M>, <v>)
     Se <M> for uma matriz onde cada entrada dessa matriz for um
     polinómio em <v>, retorna a matriz <M2> tal que

     (1) <M2> é triangular alta,

     (2) `<M2> = <E_n> ... <E_1> <M>', onde os elemetnos de <E_1> a
     <E_n> são matrizes elementares cujas entrada são polinómios em <v>,

     (3) `|det (<M>)| = |det (<M2>)|',

     Nota: Essa função não verifica se toda entrada é um polinómio em
     <v>.


 -- Função: rowop (<M>, <i>, <j>, <theta>)
     Se <M> for uma matriz, retorna a matriz que resulta de se fazer a
     operação de linha `R_i <- R_i - theta * R_j'. Se <M> não tiver uma
     linha <i> ou <j>, emite uma mensagem de erro.


 -- Função: rank (<M>)
     Retorna o ranque daquela matriz <M>. O rank é a dimensão do espaço
     coluna. Exemplo:
          (%i1) load (linearalgebra)$
          WARNING: DEFUN/DEFMACRO: redefining function $COPY in
                   /share/maxima/5.11.0/share/linearalgebra/linalg-utilities.lisp,
                   was defined in
                   /maxima-5.11.0/src/binary-clisp/comm2.fas
          (%i2) rank(matrix([1,2],[2,4]));
          (%o2)                                  1
          (%i3) rank(matrix([1,b],[c,d]));
          Proviso:  {d - b c # 0}
          (%o3)                                  2


 -- Função: rowswap (<M>, <i>, <j>)
     Se <M> for uma matriz, permuta as linha <i> e <j>. Se <M> não
     tiver uma linha <i> ou <j>, emite uma mensagem de erro.


 -- Função: toeplitz (<col>)
 -- Função: toeplitz (<col>, <lin>)
     Retorna uma matriz de Toeplitz <T>. a primeira coluna de <T> é
     <col>; excepto para a primeira entrada, a primeira linha de <T> é
     <lin>. O padrão para <lin> é o conjugado complexo de <col>.
     Exemplo:
          (%i1) load(linearalgebra)$

          (%i2)  toeplitz([1,2,3],[x,y,z]);

                                            [ 1  y  z ]
                                            [         ]
          (%o2)                             [ 2  1  y ]
                                            [         ]
                                            [ 3  2  1 ]
          (%i3)  toeplitz([1,1+%i]);

                                        [   1     1 - %I ]
          (%o3)                         [                ]
                                        [ %I + 1    1    ]


 -- Função: vandermonde_matrix ([<x_1>, ..., <x_n>])
     Retorna uma matriz <n> por <n> cuja <i>-ésima linha é `[1, <x_i>,
     <x_i>^2, ... <x_i>^(<n>-1)]'.


 -- Função: zerofor (<M>)
 -- Função: zerofor (<M>, <fld>)
     Retorna uma matriz zero que tem o mesmo tamanho da matriz <M>.
     Toda entrada da matriz zero é a identidade aditiva do anel <fld>;
     o valor padrão para <fld> é <generalring>.

     O primeiro argumento <M> pode ser uma matriz quadrada ou uma não
     matriz. Quando <M> for uma matriz, cada entrada de <M> pode ser uma
     matriz quadrada - dessa forma <M> pode ser uma matriz de bloco do
     Maxima. A matriz pode ser de bloco para qualquer nível (finito).

     Veja também `identfor'


 -- Função: zeromatrixp (<M>)
     Se <M> não for uma matriz de bloco, retorna `true' se `is (equal
     (<e>, 0))' for verdadeiro para cada elemento <e> da matriz <M>.
     Se <M> for uma matriz de bloco, retorna `true' se `zeromatrixp'
     avaliar para `true' para cada elemento de <e>.



File: maxima.info,  Node: lsquares,  Next: makeOrders,  Prev: linearalgebra,  Up: Top

56 lsquares
***********

/lsquares.texi/1.1/Mon Feb 27 22:09:17 2006//

* Menu:

* Definições para lsquares::


File: maxima.info,  Node: Definições para lsquares,  Prev: lsquares,  Up: lsquares

56.1 Definições para lsquares
=============================

 -- Variável global: DETCOEF
     Essa variável é usada pelas funções `lsquares' e `plsquares' para
     armazenar o Coeficiente de Determinação que mede o melhor ajuste.
     Esse intervalo vai de 0 (nenhuma correlação) a 1 (correlação
     exacta).

     Quando `plsquares' for chamada com uma lista de variáveis
     independentes, <DETCOEF> é escolhida para uma lista de
     Coeficientes de Determinação. Veja `plsquares' para detalhes.

     Veja também `lsquares'.

 -- Função: lsquares (<Mat>,<VarList>,<equação>,<ParamList>)
 -- Função: lsquares
          (<Mat>,<VarList>,<equação>,<ParamList>,<EsperadosList>)
     Ajuste múltiplo de equações não lineares de uma tabela de dados
     pelo método dos "mínimos quadrados". <Mat> é uma matriz contendo
     os dados, <VarList> é uma lista de nomes de variáveis (um para
     cada coluna de <Mat>), <equação> é a equação a ser ajustada (essa
     equação deve estar na forma: `depvar=f(indepvari,...,
     paramj,...)', `g(depvar)=f(indepvari,..., paramj,...)' ou na forma
     `g(depvar, paramk,...)=f(indepvari,..., paramj,...)'), <ParamList>
     é a lista de parâmetros para obter, e <EsperadosList> é uma lista
     opcional de aproximações iniciais para os parâmetros; quando esse
     último argumento estiver presente, `mnewton' é usado em lugar de
     `solve' com o objectivo de pegar os parâmetros.

     A equação pode ser completamente não linear com relação às
     variáveis independentes e à variável dependente.  Com o objectivo
     de usar `solve()', as equações devem ser lineares ou polinomiais
     com relação aos parâmetros. Equações como `y=a*b^x+c' podem ser
     ajustadas para `[a,b,c]' com `solve' se os valores de `x' forem
     inteiros positivos pequenos e existirem poucos dados (veja o
     exemplo em lsquares.dem).  `mnewton' permite ajustar uma equação
     não linear com relação aos parâmetros, mas um bom conjunto de
     aproximações iniciais deve ser fornecido.

     Se possível, a equação ajustada é retornada. Se existir mais de
     uma solução, uma lista de equações é retornada.  O Coeficiente de
     Determinação é mostrado para informar sobre o melhor ajuste, de 0
     (nenhuma correlação) a 1 (correlação exacta).  Esse valor é também
     armazenado na variável global <DETCOEF>.

     Exemplos usando `solve':
          (%i1) load("lsquares")$

          (%i2) lsquares(matrix([1,2,0],[3,5,4],[4,7,9],[5,8,10]),
                         [x,y,z], z=a*x*y+b*x+c*y+d, [a,b,c,d]);
                Determination Coefficient = 1.0
                              x y + 23 y - 29 x - 19
          (%o2)           z = ----------------------
                                        6
          (%i3) lsquares(matrix([0,0],[1,0],[2,0],[3,8],[4,44]),
                         [n,p], p=a4*n^4+a3*n^3+a2*n^2+a1*n+a0,
                   [a0,a1,a2,a3,a4]);
                Determination Coefficient = 1.0
                               4       3      2
                            3 n  - 10 n  + 9 n  - 2 n
          (%o3)         p = -------------------------
                                        6
          (%i4) lsquares(matrix([1,7],[2,13],[3,25]),
                         [x,y], (y+c)^2=a*x+b, [a,b,c]);
                Determination Coefficient = 1.0
          (%o4) [y = 28 - sqrt(657 - 216 x),
                                          y = sqrt(657 - 216 x) + 28]
          (%i5) lsquares(matrix([1,7],[2,13],[3,25],[4,49]),
                         [x,y], y=a*b^x+c, [a,b,c]);
                Determination Coefficient = 1.0
                                        x
          (%o5)                  y = 3 2  + 1

     Exemplos usando `mnewton':
          (%i6) load("lsquares")$

          (%i7) lsquares(matrix([1.1,7.1],[2.1,13.1],[3.1,25.1],[4.1,49.1]),
                         [x,y], y=a*b^x+c, [a,b,c], [5,5,5]);
                                                       x
          (%o7) y = 2.799098974610482 1.999999999999991
                                                  + 1.099999999999874
          (%i8) lsquares(matrix([1.1,4.1],[4.1,7.1],[9.1,10.1],[16.1,13.1]),
                         [x,y], y=a*x^b+c, [a,b,c], [4,1,2]);
                                       .4878659755898127
          (%o8) y = 3.177315891123101 x
                                                  + .7723843491402264
          (%i9) lsquares(matrix([0,2,4],[3,3,5],[8,6,6]),
                        [m,n,y], y=(A*m+B*n)^(1/3)+C, [A,B,C], [3,3,3]);
                                                               1/3
          (%o9) y = (3.999999999999862 n + 4.999999999999359 m)
                                                   + 2.00000000000012

     Para usar essa função escreva primeiro `load("lsquares")'. Veja
     também `DETCOEF' e `mnewton'.

 -- Função: plsquares (<Mat>,<VarList>,<depvars>)
 -- Função: plsquares (<Mat>,<VarList>,<depvars>,<maxexpon>)
 -- Função: plsquares (<Mat>,<VarList>,<depvars>,<maxexpon>,<maxdegree>)
     Ajuste de polinómios de várias variáveis de uma tabela de dados
     pelo método dos "mínimos quadrados". <Mat> é uma matriz contendo
     os dados, <VarList> é uma lista de nomes de variáveis (um nome
     para cada coluna de Mat, mas use "-" em lugar de nomes de
     variáveis para colunas de Mat), <depvars> é o nome de uma variável
     dependente ou uma lista com um ou mais nomes de variáveis
     dependentes (cujos nomes podem estar em <VarList>), <maxexpon> é o
     expoente máximo opcional para cada variável independente (1 por
     padrão), e <maxdegree> é o argumento opcional grau máximo do
     polinómio (<maxexpon> por padrão); note que a soma dos expoentes
     de cada termo deve ser menor ou igual a <maxdegree>, e se
     `maxdgree = 0' então nenhum limite é aplicado.

     Se <depvars> é o nome de uma variável dependente (fora de uma
     lista), `plsquares' retorna o polinómio ajustado. Se <depvars> for
     uma lista de uma ou mais variáveis dependentes, `plsquares'
     retorna uma lista com o(s) polinómio(s) ajustado(s). Os
     Coeficientes de Determinação são mostrados com o objectivo de
     informar sobre o melhor do ajuste, cujo intervalo vai de 0
     (nenhuma correlação) a 1 (correlação exacta). Esses valores são
     também armazenados na variável global <DETCOEF> (uma lista se
     <depvars> for tambn'uma lista).

     Um simples exemplo de ajuste linear de várias variáveis:
          (%i1) load("plsquares")$

          (%i2) plsquares(matrix([1,2,0],[3,5,4],[4,7,9],[5,8,10]),
                          [x,y,z],z);
               Determination Coefficient for z = .9897039897039897
                                 11 y - 9 x - 14
          (%o2)              z = ---------------
                                        3

     O mesmo exemplo sem restrições de grau:
          (%i3) plsquares(matrix([1,2,0],[3,5,4],[4,7,9],[5,8,10]),
                          [x,y,z],z,1,0);
               Determination Coefficient for z = 1.0
                              x y + 23 y - 29 x - 19
          (%o3)           z = ----------------------
                                        6

     Quantas diagonais possui um polígono de N lados? Que grau
     polinomial deverá ser usado?
          (%i4) plsquares(matrix([3,0],[4,2],[5,5],[6,9],[7,14],[8,20]),
                          [N,diagonais],diagonais,5);
               Determination Coefficient for diagonais = 1.0
                                          2
                                         N  - 3 N
          (%o4)              diagonais = --------
                                            2
          (%i5) ev(%, N=9);   /* Testando para um polígono de 9 lados - o eneágono */
          (%o5)                 diagonals = 27

     De quantas formas dispomos para colocar  duas raínhas sem que elas
     estejam ameaçadas num tabuleiro de xadrez n x n ?
          (%i6) plsquares(matrix([0,0],[1,0],[2,0],[3,8],[4,44]),
                          [n,posicoes],[posicoes],4);
               Determination Coefficient for [posicoes] = [1.0]
                                   4       3      2
                                3 n  - 10 n  + 9 n  - 2 n
          (%o6)    [posicoes  = -------------------------]
                                            6
          (%i7) ev(%[1], n=8); /* Testando para um tabuleiro de (8 x 8) */
          (%o7)                posicoes = 1288

     Um exemplo com seis variáveis dependentes:
          (%i8) mtrx:matrix([0,0,0,0,0,1,1,1],[0,1,0,1,1,1,0,0],
                            [1,0,0,1,1,1,0,0],[1,1,1,1,0,0,0,1])$
          (%i8) plsquares(mtrx,[a,b,_And,_Or,_Xor,_Nand,_Nor,_Nxor],
                               [_And,_Or,_Xor,_Nand,_Nor,_Nxor],1,0);
                Determination Coefficient for
          [_And, _Or, _Xor, _Nand, _Nor, _Nxor] =
          [1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
          (%o2) [_And = a b, _Or = - a b + b + a,
          _Xor = - 2 a b + b + a, _Nand = 1 - a b,
          _Nor = a b - b - a + 1, _Nxor = 2 a b - b - a + 1]

     Para usar essa função escreva primeiramente `load("lsquares")'.


File: maxima.info,  Node: makeOrders,  Next: mnewton,  Prev: lsquares,  Up: Top

57 makeOrders
*************

* Menu:

* Definições para makeOrders::


File: maxima.info,  Node: Definições para makeOrders,  Prev: makeOrders,  Up: makeOrders

57.1 Definições para makeOrders
===============================

 -- Função: makeOrders (<indvarlist>,<orderlist>)
     Retorna uma lista de todos os expoentes para um polinómio acima de
     e incluindo os argumentos.

          (%i1) load("makeOrders")$

          (%i2) makeOrders([a,b],[2,3]);
          (%o2) [[0, 0], [0, 1], [0, 2], [0, 3], [1, 0], [1, 1],
                      [1, 2], [1, 3], [2, 0], [2, 1], [2, 2], [2, 3]]
          (%i3) expand((1+a+a^2)*(1+b+b^2+b^3));
                 2  3      3    3    2  2      2    2    2
          (%o3) a  b  + a b  + b  + a  b  + a b  + b  + a  b + a b
                                                            2
                                                     + b + a  + a + 1
     onde `[0, 1]' está associado ao termo b e `[2, 3]' está associado
     ao termo a^2 b^3.

     Para usar essa função escreva primeiro `load("makeOrders")'.


File: maxima.info,  Node: mnewton,  Next: numericalio,  Prev: makeOrders,  Up: Top

58 mnewton
**********

* Menu:

* Definições para mnewton::


File: maxima.info,  Node: Definições para mnewton,  Prev: mnewton,  Up: mnewton

58.1 Definições para mnewton
============================

 -- Variável de opção: newtonepsilon
     Valor por omissão: `10.0^(-fpprec/2)'

     Precisão para determinar quando a função `mnewton' convergiu em
     direção à solução.

     Veja também `mnewton'.

 -- Variável de opção: newtonmaxiter
     Valor por omissão: `50'

     Número máximo de iterações que para a função `mnewton' caso essa
     função não seja convergente ou se convergir muito lentamente.

     Veja também `mnewton'.

 -- Função: mnewton (<FuncList>,<VarList>,<GuessList>)
     Solução de multiplas funções não lineares usando o método de
     Newton.  <FuncList> é a lista de funções a serem resolvidas,
     <VarList> é a lista dos nomes de variáveis, e <GuessList> é a
     lista de aproximações iniciais.

     A solução é retornada no mesmo formato retornado pela função
     `solve()'.  Caso a solução não seja encontrada, `[]' é retornado.

     Essa função é controlada através das variáveis globais
     `newtonepsilon' e `newtonmaxiter'.

          (%i1) load("mnewton")$

          (%i2) mnewton([x1+3*log(x1)-x2^2, 2*x1^2-x1*x2-5*x1+1],
                        [x1, x2], [5, 5]);
          (%o2) [[x1 = 3.756834008012769, x2 = 2.779849592817897]]
          (%i3) mnewton([2*a^a-5],[a],[1]);
          (%o3)             [[a = 1.70927556786144]]
          (%i4) mnewton([2*3^u-v/u-5, u+2^v-4], [u, v], [2, 2]);
          (%o4) [[u = 1.066618389595407, v = 1.552564766841786]]

     Para usar essa função primeiro escreva `load("mnewton")'. Veja
     também `newtonepsilon' e `newtonmaxiter'.


File: maxima.info,  Node: numericalio,  Next: opsubst,  Prev: mnewton,  Up: Top

59 numericalio
**************

* Menu:

* Introdução a numericalio::
* Definições para numericalio::


File: maxima.info,  Node: Introdução a numericalio,  Next: Definições para numericalio,  Prev: numericalio,  Up: numericalio

59.1 Introdução a numericalio
=============================

`numericalio' é uma colecção de funções para ler e escrever ficheiros
de dados.  O ficheiro é lido completamente para construir um objecto;
leituras parciais não são suportadas.

É assumido que cada item a ler ou escrever é atômico: um número
inteiro, número em ponto flutuante, grande número em ponto flutuante,
sequência de caracteres, ou símbolo, e não um número racional ou um
número complexo ou qualquer outro tipo de expressão não atômica.  Essas
funções podem tentar fazer alguma coisa levemente parecida com
expressões não atômicas, mas os resultados não são especificados aqui e
são sujeitos a mudanças.

Átomos em ambos os ficheiros de entrada e saída possuem o mesmo formato
que em ficheiros de lote do Maxima ou no console interativo.  Em
particular, sequência de caracteres são contidas dentro de aspas duplas,
contrabarra `\' evita qualquer interpretação especial do caractere
seguinte, e o ponto de interrogação `?' é reconhecido no início de um
símbolo para significar um símbolo do Lisp (em oposição a um símbolo do
Maxima).  Nenhum caractere de continuação (para continuar linhas
quebradas) é reconhecido.

<separator_flag> diz que caracteres separa elementos.  <separator_flag>
é um argumento opcional para todas as funções de leitura e escrita.

Para entrada, os valores de <separator_flag> reconhecidos são: `comma'
para valores separados por vírgula, `pipe' para valores separados pelo
caractere barra vertical `|', `semicolon' para valores separados por
ponto e vírgula `;', e `space' para valores separados pelos caracteres
de espaço e de tabulação.  Se o nome do ficheiro a ser lido/escrito
termina em `.csv' e <separator_flag> não for especificado, `comma' é
assumido.  Se o nome do ficheiro termina em alguma outra coisa que não
`.csv' e `separator_flag' não for especificado, `space' é assumido.

Para saída, os mesmos quatro sinalizadores são reconhecidos como na
entrada, e também `tab', para valores separados pelo caractere de
tabulaçao.

Em entrada, múltiplos espaços e múltiplas tabulações sucessivas contam
como um separador simples.  Todavia, múltiplas vírgulas, barras
verticais, ou ponto-e-vírgulas são significativos.  Sucessivas
vírgulas, barras verticais, ou ponto-e-vírgulas (com ou sem
intercalação de espaços ou tabulações) são considerados como tendo
`false' entre os separadores.  Por exemplo, `1234,,Foo' é tratado da
mesma forma que `1234,false,Foo'.  Em saídas, os átomos `false' são
escritos como tais; uma lista `[1234, false, Foo]' é escrita
`1234,false,Foo', e não é tentado colapsar a saída para `1234,,Foo'.


File: maxima.info,  Node: Definições para numericalio,  Prev: Introdução a numericalio,  Up: numericalio

59.2 Definições para numericalio
================================

 -- Função: read_matrix (<nomeficheiro>)
 -- Função: read_matrix (<nomeficheiro>, <separator_flag>)
     Lê o ficheiro <nomeficheiro> e retorna seu conteúdo completo como
     uma matriz.  Se <separator_flag> não for especificado, o ficheiro
     é assumido como delimitado por espaços em branco.

     `read_matrix' infere o tamanho da matriz dos dados de entrada.
     Cada linha do ficheiro inicia uma linha da matriz.  Se algumas
     linhas possuirem diferentes comprimentos, `read_matrix' reclama.


 -- Função: read_lisp_array (<nomeficheiro>, <A>)
 -- Função: read_lisp_array (<nomeficheiro>, <A>, <separator_flag>)
     `read_lisp_array' exige que o array seja declarado através de
     `make_array' antes de chamar a função de leitura. (Isso obviamente
     é necessário para inferir a dimensão do array, que pode ser um
     problema para arrays com múltiplas dimensões.)

     `read_lisp_array' não verifica para ver se o ficheiro de entrada
     está de acordo com as dimensãoes do array; a entrada é lida como
     uma lista monótona, então o array é preenchido usando `fillarray'.


 -- Função: read_maxima_array (<nomeficheiro>, <A>)
 -- Função: read_maxima_array (<nomeficheiro>, <A>, <separator_flag>)
     `read_maxima_array' requer que o array seja declarado através de
     `array' antes de chamar a função de leitura. (Isso obviamente é
     necessário para inferir a dimensão do array, que pode ser uma
     hassle para arrays com múltiplas dimensões.)

     `read_maxima_array' não verifica para ver se o ficheiro de entrada
     está de acordo com as dimensãoes do array; a entrada é lida como
     uma lista monótona, então o array é preenchido usando `fillarray'.


 -- Função: read_hashed_array (<nomeficheiro>, <A>)
 -- Função: read_hashed_array (<nomeficheiro>, <A>, <separator_flag>)
     `read_hashed_array' trata o primeiro item sobre uma linha como uma
     chave hash, e associa o restante da linha (como uma lista) com a
     chava.  Por exemplo, a linha `567 12 17 32 55' é equivalente a
     `A[567]: [12, 17, 32, 55]$'.  Linhas não precisam ter o mesmo
     número de elementos.


 -- Função: read_nested_list (<nomeficheiro>)
 -- Função: read_nested_list (<nomeficheiro>, <separator_flag>)
     `read_nested_list' retorna uma lista que tem uma sublista para cada
     linha de entrada. Linhas não precisam ter o mesmo número de
     elementos.  Linhas vazias não são ignoradas: uma linha vazia
     retorna uma sublista vazia.


 -- Função: read_list (<nomeficheiro>)
 -- Função: read_list (<nomeficheiro>, <separator_flag>)
     `read_list' lê todas as entradas em uma lista monótona.
     `read_list' ignora o caractere de fim de linha.


 -- Função: write_data (<X>, <nomeficheiro>)
 -- Função: write_data (<object>, <nomeficheiro>, <separator_flag>)
     `write_data' escreve o objecto <X> no ficheiro <nomeficheiro>.

     `write_data' escreve matrizes da forma usual, com uma linha por
     fileira.

     `write_data' escreve arrays declarados do Lisp e do Maxima da
     forma usual, com um caractere de nova linha no final de todo
     pedaço.  Pedaços dimensionais muito grandes são separados por meio
     de novas linhas adicionais.

     `write_data' escreve arrays desordenados com uma chave seguida por
     a lista associada sobre cada linha.

     `write_data' escreve a lista seguinte com cada sublista em uma
     linha.

     `write_data' escreve uma lista monótona toda em uma linha.

     Se `write_data' anexa ao final ou abandona os excessos em seus
     ficheiros de saída é governado através da variável global
     `file_output_append'.



File: maxima.info,  Node: opsubst,  Next: orthopoly,  Prev: numericalio,  Up: Top

60 opsubst
**********

* Menu:

* Definições para  opsubst::


File: maxima.info,  Node: Definições para opsubst,  Prev: opsubst,  Up: opsubst

60.1 Definições para  opsubst
=============================

 -- Função: opsubst (<f>,<g>,<e>)
 -- Função: opsubst (<g>=<f>,<e>)
 -- Função: opsubst ([<g1>=<f1>,<g2>=<f2>,..., <gn>=<fn>],<e>)
     A função `opsubst'  similar à função `subst', excepto que
     `opsubst' somente faz substituições para as operações em uma
     expressões. Em geral, quando <f> for um operador em uma expressão
     <e>, substitui <g> por <f> na expressão <e>.

     Para determinar o operador, `opsubst' escolhe `inflag' para
     verdadeiro ( true ). Isso significa que `opsubst' substitui para a
     forma de operador interna, não para a mostrada, na expressão.

     Exemplos:
          (%i1) load (opsubst)$

          (%i2) opsubst(f,g,g(g(x)));
          (%o2)                     f(f(x))
          (%i3) opsubst(f,g,g(g));
          (%o3)                       f(g)
          (%i4) opsubst(f,g[x],g[x](z));
          (%o4)                       f(z)
          (%i5) opsubst(g[x],f, f(z));
          (%o5)                      g (z)
                                      x
          (%i6) opsubst(tan, sin, sin(sin));
          (%o6)                     tan(sin)
          (%i7) opsubst([f=g,g=h],f(x));
          (%o7)                       h(x)

     Internamente, Maxima não usa os operadores de negação unária,
     divisão, ou de subtração; dessa forma:
          (%i8) opsubst("+","-",a-b);
          (%o8)                     a - b
          (%i9) opsubst("f","-",-a);
          (%o9)                      - a
          (%i10) opsubst("^^","/",a/b);
                                       a
          (%o10)                       -
                                       b

     A representação interna de -a*b é *(-1,a,b); dessa forma
          (%i11) opsubst("[","*", -a*b);
          (%o11)                  [- 1, a, b]

     Quando o operador não for um símbolo Maxima, geralmente alguma
     outra função sinalizará um erro:
          (%i12) opsubst(a+b,f, f(x));

          Improper name or value in functional position:
          b + a
           -- an error.  Quitting.  To debug this try debugmode(true);

     Todavia, operadores subscritos são permitidos:
          (%i13) opsubst(g[5],f, f(x));
          (%o13)                     g (x)
                                      5

     Para usar essa função escreva primeiramente `load("opsubst")'.


File: maxima.info,  Node: orthopoly,  Next: plotdf,  Prev: opsubst,  Up: Top

61 orthopoly
************

* Menu:

* Introdução a polinómios ortogonais::
* Definições para polinómios ortogonais::


File: maxima.info,  Node: Introdução a polinómios ortogonais,  Next: Definições para polinómios ortogonais,  Prev: orthopoly,  Up: orthopoly

61.1 Introdução a polinómios ortogonais
=======================================

`orthopoly' é um pacote para avaliação simbólica e numérica de muitos
tipos de polinómios ortogonais, incluindo polinómios de Chebyshev,
Laguerre, Hermite, Jacobi, Legendre, e ultraesférico (Gegenbauer).
Adicionalmentey, `orthopoly' inclui suporte funções esféricas segundo o
critério de Bessel, esféricas segundo o critério de Hankel, e funções
harmônica esféricas.

Em sua maior parte, `orthopoly' segue as convenções de Abramowitz e
Stegun Handbook of Mathematical Functions, Chapter 22 (10th printing,
December 1972); adicionalmente, usamos Gradshteyn e Ryzhik, Table of
Integrals, Series, and Products (1980 corrected and enlarged edition),
e Eugen Merzbacher Quantum Mechanics (2nd edition, 1970).

Barton Willis da University de Nebraska e Kearney (UNK) escreveu o
pacote `orthopoly' e sua documetação. O pacote é liberado segundo a
licença pública geral GNU (GPL).

61.1.1 Iniciando com orthopoly
------------------------------

`load (orthopoly)' torna o pacote `orthopoly' disponível para uso.

Para encontrar o polinómio de Legendre de terceira ordem,

     (%i1) legendre_p (3, x);
                           3             2
                  5 (1 - x)    15 (1 - x)
     (%o1)      - ---------- + ----------- - 6 (1 - x) + 1
                      2             2

Para expressar esse polinómio como uma soma de potências de <x>,
aplique <ratsimp> ou <rat> para o resultado anterior.

     (%i2) [ratsimp (%), rat (%)];
                             3           3
                          5 x  - 3 x  5 x  - 3 x
     (%o2)/R/            [----------, ----------]
                              2           2

Alternativamente, faça o segundo argumento  para `legendre_p' (sua
variável "principal") uma expressão racional canónica (CRE)  usando
`rat(x)' em lugar de somente `x'.

     (%i1) legendre_p (3, rat (x));
                                   3
                                5 x  - 3 x
     (%o1)/R/                   ----------
                                    2

Para avaliação em ponto flutuante, `orthopoly' usa uma análise de erro
durante a execução para estimar uma associação superior para o erro.
Por exemplo,

     (%i1) jacobi_p (150, 2, 3, 0.2);
     (%o1) interval(- 0.062017037936715, 1.533267919277521E-11)

intervalos possuem a forma `interval (<c>, <r>)', onde <c> é o centro e
<r> é o raio do intervalo. Uma vez que Maxima não suporta aritmética
sobre intervalos, em algumas situações, tais como em gráficos, vai
querer suprimir o erro e sair somente com o centro do intervalo. Para
fazer isso, escolha a variável de opção `orthopoly_returns_intervals'
para `false'.

     (%i1) orthopoly_returns_intervals : false;
     (%o1)                         false
     (%i2) jacobi_p (150, 2, 3, 0.2);
     (%o2)                  - 0.062017037936715

Veja a secção *note Avaliação em Ponto Flutuante:: para maiores
informações.

Muitas funções em `orthopoly' possuem uma propriedade `gradef'; dessa
forma

     (%i1) diff (hermite (n, x), x);
     (%o1)                     2 n H     (x)
                                    n - 1
     (%i2) diff (gen_laguerre (n, a, x), x);
                   (a)               (a)
                n L   (x) - (n + a) L     (x) unit_step(n)
                   n                 n - 1
     (%o2)      ------------------------------------------
                                    x

A função de um único passo no segundo exemplo previne um erro que
poderia de outra forma surgir através da avaliação de <n> para 0.

     (%i3) ev (%, n = 0);
     (%o3)                           0

A propriedade `gradef' somente aplica para a variável "principal";
dderivadas com relação a outros argumentos usualmente resultam em uma
mensagem de erro; por exemplo

     (%i1) diff (hermite (n, x), x);
     (%o1)                     2 n H     (x)
                                    n - 1
     (%i2) diff (hermite (n, x), n);

     Maxima doesn't know the derivative of hermite with respect the first argument
      -- an error.  Quitting.  To debug this try debugmode(true);

Geralmente, funções em `orthopoly' mapeiam sobre listas e matrizes. Para
o mapeamento para avaliação total, as variáveis de opção `doallmxops' e
`listarith' devem ambas serem `true' (o valor padrão).  Para ilustrar o
mapeamento sobre matrizes, considere

     (%i1) hermite (2, x);
                                          2
     (%o1)                    - 2 (1 - 2 x )
     (%i2) m : matrix ([0, x], [y, 0]);
                                 [ 0  x ]
     (%o2)                       [      ]
                                 [ y  0 ]
     (%i3) hermite (2, m);
                    [                             2  ]
                    [      - 2        - 2 (1 - 2 x ) ]
     (%o3)          [                                ]
                    [             2                  ]
                    [ - 2 (1 - 2 y )       - 2       ]

No segundo exemplo, o elemento `i, j' do valor é `hermite (2, m[i,j])';
isso não é o mesmo que calcular `-2 + 4 m . m', como visto no próximo
exemplo.

     (%i4) -2 * matrix ([1, 0], [0, 1]) + 4 * m . m;
                         [ 4 x y - 2      0     ]
     (%o4)               [                      ]
                         [     0      4 x y - 2 ]

Se avaliar uma função em um ponto fora do seu domínio, geralmente
`orthopoly' retorna uma função não avaliada. Por exemplo,

     (%i1) legendre_p (2/3, x);
     (%o1)                        P   (x)
                                   2/3

`orthopoly' suporta tradução em TeX; `orthopoly' também faz saídas
bidimensionais em um terminal.

     (%i1) spherical_harmonic (l, m, theta, phi);
                               m
     (%o1)                    Y (theta, phi)
                               l
     (%i2) tex (%);
     $$Y_{l}^{m}\left(\vartheta,\varphi\right)$$
     (%o2)                         false
     (%i3) jacobi_p (n, a, a - b, x/2);
                               (a, a - b) x
     (%o3)                    P          (-)
                               n          2
     (%i4) tex (%);
     $$P_{n}^{\left(a,a-b\right)}\left({{x}\over{2}}\right)$$
     (%o4)                         false

61.1.2 Limitations
------------------

Quando uma expressão envolve muitos polinómios ortogonais com ordens
simbólicas, é possível que a expressão actualmente tenda para zero, e
ainda ocorre também que Maxima estar incapacitado de simplificar essa
expressão para zero. Se fizer uma divisão por tal quantidade que tende
a zero, poderá ficar em apuros. Por exemplo, a seguinte expressão tende
para zero para inteiros <n> maiores que 1, e ainda ocorre também que
Maxima está incapacitado de simplificar essa expressão para zero.

     (%i1) (2*n - 1) * legendre_p (n - 1, x) * x - n * legendre_p (n, x) + (1 - n) * legendre_p (n - 2, x);
     (%o1)  (2 n - 1) P     (x) x - n P (x) + (1 - n) P     (x)
                       n - 1           n               n - 2

Para um <n> específico, podemos reduzir a expressão a zero.

     (%i2) ev (% ,n = 10, ratsimp);
     (%o2)                           0

Geralmente, a forma polinomial de um polinómio ortogonal esteja
adequada de forma hostil para avaliaçao em ponto flutuante. Aqui está
um exemplo.

     (%i1) p : jacobi_p (100, 2, 3, x)$

     (%i2) subst (0.2, x, p);
     (%o2)                3.4442767023833592E+35
     (%i3) jacobi_p (100, 2, 3, 0.2);
     (%o3)  interval(0.18413609135169, 6.8990300925815987E-12)
     (%i4) float(jacobi_p (100, 2, 3, 2/10));
     (%o4)                   0.18413609135169

O verdadeiro valor está em torno de 0.184; ess calculo suporta erro de
cancelamento por extremo subtrativo.Expandindo o polinómio e então
avaliando, fornecendo um melhor resultado.
     (%i5) p : expand(p)$
     (%i6) subst (0.2, x, p);
     (%o6) 0.18413609766122982

Essa não é uma regra geral; expandindo o polinómio não resulta sempre
em expressões que são melhores adaptadas a avaliação numérica.  Com
grande folga, o melhor caminho para fazer avaliação numérica é fazer um
ou mais argumentos da função serem números em ponto flutuante. Em
função disso, algoritmos especializados em ponto flutuante são usados
para avaliação.

A função `float' do Maxima é até certo ponto indiscriminada; se aplicar
`float' a uma expressão envolvendo um polinómio ortogonal com um grau
simbólico ou um parâmetro de ordem, esses parâmetos (inteiros) podem ser
convertido em números em ponto flutuante; após o que, a expressão não
irá avaliar completamente. Considere

     (%i1) assoc_legendre_p (n, 1, x);
                                    1
     (%o1)                         P (x)
                                    n
     (%i2) float (%);
                                   1.0
     (%o2)                        P   (x)
                                   n
     (%i3) ev (%, n=2, x=0.9);
                                  1.0
     (%o3)                       P   (0.9)
                                  2

A expressão em (%o3) não irá avaliar para um número em ponto flutuante;
`orthopoly' não reconhece valores em ponto flutuante em lugares onde
deve haver valores inteiros. Similarmente, avaliação numérica da função
`pochhammer' para ordens que excedam `pochhammer_max_index' pode ser
perturbador; considere

     (%i1) x :  pochhammer (1, 10), pochhammer_max_index : 5;
     (%o1)                         (1)
                                      10

Aplicando `float' não avalia <x> para um número em ponto flutuante

     (%i2) float (x);
     (%o2)                       (1.0)
                                      10.0

Para avaliar <x> para um número em ponto flutuante, irá precisar
associar `pochhammer_max_index' a 11 ou mais e aplicar `float' a <x>.

     (%i3) float (x), pochhammer_max_index : 11;
     (%o3)                       3628800.0

O valor padrão de `pochhammer_max_index' é 100; modifique esse valor
após chama `orthopoly'.

Finalmente, tenha consciência que os livros citados nas referências
adotam diferentes definições de polinómios ortogonais; geralmente
adotamos as convenções citadas nas convenções de Abramowitz e Stegun.

Antes de suspeitar de um erro no pacote `orthopoly', verifique alguns
casos especiais para determinar se suas definições coincidem com
aquelas usadas por `orthopoly'.  Definitions muitas vezes diferem por
uma normalização; ocasionalmente, autores utilizam versões
"modificadas" das funções que fazem a família ortogonal sobre um
intervalo diferente do intervalo (-1, 1). Para definir, por exemplo, um
polinómio de Legendre que é ortogonal a (0, 1), defina

     (%i1) shifted_legendre_p (n, x) := legendre_p (n, 2*x - 1)$

     (%i2) shifted_legendre_p (2, rat (x));
                                 2
     (%o2)/R/                 6 x  - 6 x + 1
     (%i3) legendre_p (2, rat (x));
                                    2
                                 3 x  - 1
     (%o3)/R/                    --------
                                    2

61.1.3 Avaliação em Ponto Flutuante
-----------------------------------

Muitas funções em `orthopoly' utilizam análise de erro durante a
execução para estimar o erro em avaliações em ponto flutuante; as
exceções são funções de Bessel esféricas e os polinómios associados de
Legendre do segundo tipo. Para avaliações numéricas, as funções de
Bessel esféricas chamam funções da colecção de programas `SLATEC'.
Nenhum método especializado é usado para avaliação numérica dos
polinómios associados  de Legendre do segundo tipo.

A análise de erro durante a execução ignora erros que são de segunda
ordem ou maior na máquina (também conhecida como perda de algarismos).
A análise de erro durante a execução também ignora alguns poucos outros
tipos de erro. É possível (embora não provável) que o erro actual
exceda o estimado.

Intervalos possuem a forma `interval (<c>, <r>)', onde <c> é o centro
do intervalo e <r> é seu raio. O centro de um intervalo pode sr um
número complexo, e o raio é sempre um número real positivo.

Aqui está um exemplo.

     (%i1) fpprec : 50$

     (%i2) y0 : jacobi_p (100, 2, 3, 0.2);
     (%o2) interval(0.1841360913516871, 6.8990300925815987E-12)
     (%i3) y1 : bfloat (jacobi_p (100, 2, 3, 1/5));
     (%o3) 1.8413609135168563091370224958913493690868904463668b-1

Vamos testar o quanto o erro actual é é menor que o erro estimado

     (%i4) is (abs (part (y0, 1) - y1) < part (y0, 2));
     (%o4)                         true

Realmente, por esse exemplo o erro estimado é um maior que o erro
verdadeiro.

Maxima não suporta aritmética sobre intervalos.

     (%i1) legendre_p (7, 0.1) + legendre_p (8, 0.1);
     (%o1) interval(0.18032072148437508, 3.1477135311021797E-15)
             + interval(- 0.19949294375000004, 3.3769353084291579E-15)

Um utilizador pode definir operadores aritméticos que fazem matemática
de intervalos. Para definir adição de intervalos, podemos definir

     (%i1) infix ("@+")$

     (%i2) "@+"(x,y) := interval (part (x, 1) + part (y, 1), part (x, 2) + part (y, 2))$

     (%i3) legendre_p (7, 0.1) @+ legendre_p (8, 0.1);
     (%o3) interval(- 0.019172222265624955, 6.5246488395313372E-15)

As rotinas eseciais em ponto flutuante são chamadas quando os argumentos
forem complexos.  Por exemplo,

     (%i1) legendre_p (10, 2 + 3.0*%i);
     (%o1) interval(- 3.876378825E+7 %i - 6.0787748E+7,
                                                1.2089173052721777E-6)

Let's compare this to the true value.

     (%i1) float (expand (legendre_p (10, 2 + 3*%i)));
     (%o1)          - 3.876378825E+7 %i - 6.0787748E+7

Adicionalmente, quando os argumentos forem grandes números em ponto
flutuante, as rotinas especiais de ponto flutuante são chamadas;
todavia, tos grandes números em ponto flutuante são convertidos para
números em ponto flutuante de dupla precisão e o resultado final é
número em ponto flutuante de precisão dupla.

     (%i1) ultraspherical (150, 0.5b0, 0.9b0);
     (%o1) interval(- 0.043009481257265, 3.3750051301228864E-14)

61.1.4 Gráficos e `orthopoly'
-----------------------------

Para desenhar gráficos de expressões que envolvem polinómios
ortogonais, deverá fazer duas coisas:
  1. Escolher a variável de opção `orthopoly_returns_intervals' para
     `false',

  2. Colocar apóstrofo em qualquer chamada a funções do pacote
     `orthopoly'.
     Se chamadas a funções não receberem apóstrofo, Maxima irá
avaliá-las para polinómios antes de montar o gráfico; consequêntemente,
as rotinas especializadas em ponto flutuante não serão chamadas.  Aqui
está um exemplo de como montar o gráfico de uma expressão que envolve
um polinómio de Legendre.

     (%i1) plot2d ('(legendre_p (5, x)), [x, 0, 1]), orthopoly_returns_intervals : false;
     (%o1)

A expressão completa `legendre_p (5, x)' recebe apóstrofo; isso é
diferente de apenas colocar apóstrofo no nome da função usando
`'legendre_p (5, <x>)'.

61.1.5 Funções Diversas
-----------------------

O pacote `orthopoly' define o síbolo de Pochhammer e uma função de
passo de unidade. `orthopoly' utiliza a função delta de Kronecker e a
função de passo de unidade em declarações `gradef'.

Para converter os símbolos Pochhammer em quocientes da funções gama,
use `makegamma'.

     (%i1) makegamma (pochhammer (x, n));
                               gamma(x + n)
     (%o1)                     ------------
                                 gamma(x)
     (%i2) makegamma (pochhammer (1/2, 1/2));
                                     1
     (%o2)                       ---------
                                 sqrt(%pi)

Derivadas de símbolos de Pochhammer são fornecidas em termos de `psi'
function.

     (%i1) diff (pochhammer (x, n), x);
     (%o1)             (x)  (psi (x + n) - psi (x))
                          n     0             0
     (%i2) diff (pochhammer (x, n), n);
     (%o2)                   (x)  psi (x + n)
                                n    0

É preciso ser cuidadoso com expressões como (%o1); a diferença das
funções `psi' possuem polinómios quando `<x> = -1, -2, .., -<n>'. Esses
polinómios cacelam-se com factores em `pochhammer (<x>, <n>)' fazendo
da derivada um polinómio de grau `<n> - 1' quando <n> for um inteiro
positivo.

O símbolo de Pochhammer é definido de ordens negativas até sua
representação como um quociente de funções gama. Considere

     (%i1) q : makegamma (pochhammer (x, n));
                               gamma(x + n)
     (%o1)                     ------------
                                 gamma(x)
     (%i2) sublis ([x=11/3, n= -6], q);
                                    729
     (%o2)                        - ----
                                    2240

Alternativamente, podemos tomar ese resultado directamente.

     (%i1) pochhammer (11/3, -6);
                                    729
     (%o1)                        - ----
                                    2240

A função passo de unidade é contínua à esquerda; dessa forma

     (%i1) [unit_step (-1/10), unit_step (0), unit_step (1/10)];
     (%o1)                       [0, 0, 1]

Se precisar de uma função de degrau unitário que seja ou contínua à
esquerda ou contínua à direita do zero, defina a sua própria função
usando `signum'; por exemplo,

     (%i1) xunit_step (x) := (1 + signum (x))/2$

     (%i2) [xunit_step (-1/10), xunit_step (0), xunit_step (1/10)];
                                     1
     (%o2)                       [0, -, 1]
                                     2

Não redefina a própria `unit_step'; alguns código em `orthopoly'
requerem que a função de passo de unidade seja contínua à esquerda.

61.1.6 Algorítmos
-----------------

Geralmente, `orthopoly' faz avaliações simbólicas pelo uso de uma
representação hipergeométrica de polinómios ortogonais. As funções
hipegeométricas são avaliadas usando as funções (não documetadas)
`hypergeo11' e `hypergeo21'. As excessões são as funções de Bessel
metade inteiras e a função de Legendre associada de segundo tipo. As
funções de Bessel metade inteiras são avaliadas usando uma
representação explícita, e a função de Legendre associada de segundo
tipo é avaliada usando recursividade.

Para avaliação em ponto flutuante, nós novamente convertemos muitas
fuções em uma forma hipergeométrica; nós avaliamos as funções
hipergeométricas usando recursividade para frente. Novamente, as
excessões são as funções de Bessel metade inteiras e a função de
Legendre associada de segundo tipo. Numericamente, as funções de Bessel
meio inteiras são avaliadas usando o código SLATEC.



Local Variables:
coding: iso-8859-1
End:
