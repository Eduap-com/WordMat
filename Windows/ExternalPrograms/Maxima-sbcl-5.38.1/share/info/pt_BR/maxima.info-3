This is maxima.info, produced by makeinfo version 4.13 from maxima.texi.

Esse é um Manual do Maxima no formato Texinfo

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     Um sistema de álgebra computacional.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Introdução a Equações Diferenciais,  Next: Funções e Variáveis Definidas para Equações Diferenciais,  Prev: Equações Diferenciais,  Up: Equações Diferenciais

22.1 Introdução a Equações Diferenciais
=======================================

Essa seção descreve as funções disponíves no Maxima para obter
soluções analíticas para alguns tipos específicos de equações
diferencias de primeira ordem e de equações diferencias de segunda
ordem. Para obter uma solução numérica para um sistema de equações
diferenciais, veja o pacote adicional `dynamics'. Para representações
gráficas em espaço de fase, veja o pacote adicional `plotdf'.


File: maxima.info,  Node: Funções e Variáveis Definidas para Equações Diferenciais,  Prev: Introdução a Equações Diferenciais,  Up: Equações Diferenciais

22.2 Funções e Variáveis Definidas para Equações Diferenciais
=============================================================

 -- Função: bc2 (<solução>, <xval1>, <yval1>, <xval2>, <yval2>)
     Resolve o problema do valor limite para equações diferenciais de
     segunda ordem.  Aqui: <solução> é uma solução geral para a
     equação, como encontrado por `ode2', <xval1> especifica o valor da
     variável independente em um primeiro ponto, na forma `<x> = <x1>',
     e <yval1> fornece o valor da variável dependente naquele ponto, na
     forma `<y> = <y1>'. As expressões <xval2> e <yval2> fornecem os
     valores para essas variáveis em um segundo ponto, usando a mesma
     forma.

     Veja `ode2' para um exemplo de sua utilização.


 -- Função: desolve (<eqn>, <x>)
 -- Função: desolve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])
     A Função `dsolve' resolve sistema de equações diferenciais
     lineares ordinárias usando a transformada de Laplace.  Aqui as
     <eqn>'s são equações diferenciais nas variáveis dependentes <x_1>,
     ..., <x_n>.  A dependência funcional de <x_1>, ..., <x_n> com
     relação à variável independente, por exemplo <x>, deve ser
     explicitamente indicada nas variáveis e em suas derivadas. Por
     exemplo, isso pode não ser caminho correto para definir duas
     equações:

          eqn_1: 'diff(f,x,2) = sin(x) + 'diff(g,x);
          eqn_2: 'diff(f,x) + x^2 - f = 2*'diff(g,x,2);

     O caminho correto pode ser:

          eqn_1: 'diff(f(x),x,2) = sin(x) + 'diff(g(x),x);
          eqn_2: 'diff(f(x),x) + x^2 - f(x) = 2*'diff(g(x),x,2);

     A chamada à função `desolve' pode então ser
          desolve([eqn_1, eqn_2], [f(x),g(x)]);

     Se condições iniciais em `x=0' forem conhecidas, elas podem ser
     fornecidas antes chamando `desolve' através de `atvalue'.

          (%i1) 'diff(f(x),x)='diff(g(x),x)+sin(x);
                           d           d
          (%o1)            -- (f(x)) = -- (g(x)) + sin(x)
                           dx          dx
          (%i2) 'diff(g(x),x,2)='diff(f(x),x)-cos(x);
                            2
                           d            d
          (%o2)            --- (g(x)) = -- (f(x)) - cos(x)
                             2          dx
                           dx
          (%i3) atvalue('diff(g(x),x),x=0,a);
          (%o3)                           a
          (%i4) atvalue(f(x),x=0,1);
          (%o4)                           1
          (%i5) desolve([%o1,%o2],[f(x),g(x)]);
                            x
          (%o5) [f(x) = a %e  - a + 1, g(x) =

                                                          x
                                             cos(x) + a %e  - a + g(0) - 1]
          (%i6) [%o1,%o2],%o5,diff;
                       x       x      x                x
          (%o6)   [a %e  = a %e , a %e  - cos(x) = a %e  - cos(x)]

     Se `desolve' não pode obter uma solução, retorna `false'.


 -- Função: ic1 (<solução>, <xval>, <yval>)
     Resolve problemas de valor inicial para equações diferenciais de
     primeira ordem.  Aqui <solução> é uma solução geral para a
     equação, como encontrado por `ode2', <xval> fornece um valor
     inicial para a variável independente na forma `<x> = <x0>', e
     <yval> fornece o valor inicial para a variável dependente na forma
     `<y> = <y0>'.

     Veja `ode2' para um exemplo de sua utilização.


 -- Função: ic2 (<solução>, <xval>, <yval>, <dval>)
     Resolve problemas de valor inicial para equações diferenciais de
     segunda ordem.  Aqui <solução> é uma solução geral para a
     equação, como encontrada por `ode2', <xval> fornece o valor
     inicial para a variável independente na forma `<x> = <x0>', <yval>
     fornece o valor inicial da veriável dependente na forma `<y> =
     <y0>', e <dval> fornece o valor inicial para a primeira derivada
     da variável dependente com relação à variável independente, na
     forma `diff(<y>,<x>) = <dy0>' (`diff' não precisa receber
     apóstrofo para evitar avaliação).

     Veja `ode2' para um exemplo de seu uso.


 -- Função: ode2 (<eqn>, <dvar>, <ivar>)
     A função `ode2' resolve uma equação diferencial ordinária (EDO) de
     primeira ou de segunda ordem. `ode2' usa três argumentos: uma EDO
     fornecida por <eqn>, a variável dependente <dvar>, e a variável
     independente <ivar>. Quando `ode2' encontra uma solução, `ode2'
     retorna ou uma solução explícita ou uma sulução implícita para a
     variável dependente. `%c' é usado para representar a constante de
     integração no caso de equações de primeira ordem, e `%k1' e `%k2'
     as constantes para equações de segunda ordem. A dependência da
     variável dependente com relação à variável independente não tem
     que ser escrita explicitamente, como no caso de `desolve', mas a
     variável independente deve sempre ser fornecida como o terceiro
     argumento.

     Se `ode2' não conseguir obter uma solução por qualquer razaão,
     `ode2' retorna `false', após talvez imprimir uma mensagem de erro.
     Os métodos implementados para equações de primeira ordem na
     seqüência em que eles foram testados são: linear, separável, exato
     - talvez requerendo um fator de integração, homogêneo, equação de
     Bernoulli, e um método homogêneo generalizado. Os tipos de
     equaçõe de segunda ordem que podem ser resolvidos são:
     coeficientes constantes, exato, linear homogêneo com coeficientes
     não constantes que podem ser transformados em coeficientes
     constantes, o tipo de equação de Euler também chamado de
     equação equi-dimensional, equações resolvíveis pelo método de
     variação de parâmetros, e equações as quais são livres ou da
     variável independente ou da dependente de modo que elas possam ser
     reduzidas a duas equações lineares de primeira ordem para serem
     resolvidas seqüêncialmente.

     Na resolução de EDO's pelo Maxima, muitas variáveis são escolhidas
     puramente para propósitos informativos: `método' denota o método
     de solução usado (e.g., `linear'), `intfactor' denota qualquer
     fator de integração usado, `odeindex' denota o índice para o
     método de Bernoulli ou para o método homogêneo generalizado, e
     `yp' denota a solução particular para a técnica de variação de
     parâmetros.

     Com o objetivo de resolver poblemas de valor inicial (PVI) as
     funções `ic1' e `ic2' estão disponíveis para equações de primeira
     e de segunda ordem, e para resolver problemas do valor de segunda
     ordem associado (BVP em inglês) a função `bc2' pode ser usada.

     Exemplo:

          (%i1) x^2*'diff(y,x) + 3*y*x = sin(x)/x;
                                2 dy           sin(x)
          (%o1)                x  -- + 3 x y = ------
                                  dx             x
          (%i2) ode2(%,y,x);
                                       %c - cos(x)
          (%o2)                    y = -----------
                                            3
                                           x
          (%i3) ic1(%o2,x=%pi,y=0);
                                        cos(x) + 1
          (%o3)                   y = - ----------
                                             3
                                            x
          (%i4) 'diff(y,x,2) + y*'diff(y,x)^3 = 0;
                                   2
                                  d y      dy 3
          (%o4)                   --- + y (--)  = 0
                                    2      dx
                                  dx
          (%i5) ode2(%,y,x);
                                3
                               y  + 6 %k1 y
          (%o5)                ------------ = x + %k2
                                    6
          (%i6) ratsimp(ic2(%o5,x=0,y=0,'diff(y,x)=2));
                                       3
                                    2 y  - 3 y
          (%o6)                   - ---------- = x
                                        6
          (%i7) bc2(%o5,x=0,y=1,x=1,y=3);
                                   3
                                  y  - 10 y       3
          (%o7)                   --------- = x - -
                                      6           2



File: maxima.info,  Node: Numérico,  Next: Arrays,  Prev: Equações Diferenciais,  Up: Top

23 Numérico
***********

* Menu:

* Introdução a Numérico::
* Pacotes de Fourier::
* Funções e Variáveis Definidas para Numérico::
* Funções e Variáveis Definidas para Séries de Fourier::


File: maxima.info,  Node: Introdução a Numérico,  Next: Pacotes de Fourier,  Prev: Numérico,  Up: Numérico

23.1 Introdução a Numérico
==========================


File: maxima.info,  Node: Pacotes de Fourier,  Next: Funções e Variáveis Definidas para Numérico,  Prev: Introdução a Numérico,  Up: Numérico

23.2 Pacotes de Fourier
=======================

O pacote `fft' compreende funções para computação numérica (não
simbólica) das transformações rápidas de Fourier.  `load ("fft")' chama
esse pacote.  Veja `fft'.

   O pacote `fourie' compreende funções para computação simbólica de
séries de Fourier.  `load ("fourie")' chama esse pacote.  Existem
funções no pacote `fourie' para calcular coeficientes da integral de
Fourier e algumas funções para manipulação de expressões.  Veja
`Funções e Variáveis Definidas para Séries'.


File: maxima.info,  Node: Funções e Variáveis Definidas para Numérico,  Next: Funções e Variáveis Definidas para Séries de Fourier,  Prev: Pacotes de Fourier,  Up: Numérico

23.3 Funções e Variáveis Definidas para Numérico
================================================

 -- Função: polartorect (<magnitude_array>, <phase_array>)
     Traduz valores complexos da forma `r %e^(%i t)' para a forma `a +
     b %i'.  `load ("fft")' chama essa função dentro do Maxima. Veja
     também `fft'.

     O módulo e a fase, `r' e `t', São tomados de <magnitude_array> e
     <phase_array>, respectivamente. Os valores originais de arrays de
     entrada são substituídos pelas partes real e emaginária, `a' e
     `b', no retorno. As saídas são calculadas como

          a: r cos (t)
          b: r sin (t)

     Os arrays de entrada devem ter o mesmo tamanho  e ser
     unidimensionais.  O tamanho do array não deve ser uma potência de
     2.

     `polartorect' é a função inversa de `recttopolar'.


 -- Função: recttopolar (<real_array>, <imaginary_array>)
     Traduz valores complexos da forma `a + b %i' para a forma `r
     %e^(%i t)'.  `load ("fft")' chama essa função dentro do Maxima.
     Veja também `fft'.

     As partes real e imaginária, `a' e `b', são tomadas de
     <real_array> e <imaginary_array>, respectivamente. Os valores
     originais dos arrays de entrada são substituídos pelo módulo e
     pelo ângulo, `r' e `t', no retorno. As saídas são calculadas como

          r: sqrt (a^2 + b^2)
          t: atan2 (b, a)

     O ângulo calculado encontra-se no intervalo de `-%pi' a `%pi'.

     Os arrays de entrada devem ter o mesmo tamanho e ser
     unidimensionais.  O tamanho do array não deve ser uma potência de
     2.

     `recttopolar' é a função inversa de `polartorect'.


 -- Função: ift (<real_array>, <imaginary_array>)
     Transformação rápida inversa discreta de Fourier . `load ("fft")'
     chama essa função dentro do Maxima.

     `ift' realiza a transformação rápida complexa de Fourier sobre
     arrays em ponto flutuante unidimensionais. A transformação inversa
     é definida como

          x[j]: sum (y[j] exp (+2 %i %pi j k / n), k, 0, n-1)

     Veja `fft' para maiores detalhes.


 -- Função: fft (<real_array>, <imaginary_array>)
 -- Função: ift (<real_array>, <imaginary_array>)
 -- Função: recttopolar (<real_array>, <imaginary_array>)
 -- Função: polartorect (<magnitude_array>, <phase_array>)
     Transformação rápidada de Fourier e funções relacionadas. `load
     ("fft")' chama essas funções dentro do Maxima.

     `fft' e `ift' realiza transformação rápida complexa de Fourier e a
     transformação inversa, respectivamente, sobre arrays em ponto
     flutuante unidimensionais. O tamanho de <imaginary_array> deve ser
     igual ao tamanho de <real_array>.

     `fft' e `ift' operam in-loco. Isto é, sobre o retorno de `fft' ou
     de `ift', O conteúdo original dos arrays de entrada é substituído
     pela saída.  A função `fillarray' pode fazer uma cópia de um
     array, isso pode ser necessário.

     A transformação discreta de Fourier e sua transformação inversa
     são definidas como segue. Tome `x' sendo os dados originais, com

          x[i]: real_array[i] + %i imaginary_array[i]

     Tome `y' sendo os dados transformados. A transformação normal e
     sua transformação inversa são

          y[k]: (1/n) sum (x[j] exp (-2 %i %pi j k / n), j, 0, n-1)

          x[j]:       sum (y[j] exp (+2 %i %pi j k / n), k, 0, n-1)

     Arrays adequadas podem ser alocadas pela função `array'. Por
     exemplo:

          array (my_array, float, n-1)$

     declara um array unidimensional com n elementos, indexado de 0 a
     n-1 inclusive. O número de elementos n deve ser igual a 2^m para
     algum m.

     `fft' pode ser aplicada a dados reais (todos os arrays imaginários
     são iguais a zero) para obter coeficientes seno e cosseno.  Após
     chamar `fft', os coeficientes seno e cosseno, digamos `a' e `b',
     podem ser calculados como

          a[0]: real_array[0]
          b[0]: 0

     e

          a[j]: real_array[j] + real_array[n-j]
          b[j]: imaginary_array[j] - imaginary_array[n-j]

     para j variando de 1 a n/2-1, e

          a[n/2]: real_array[n/2]
          b[n/2]: 0

     `recttopolar' traduz valores complexos da forma `a + b %i' para a
     forma `r %e^(%i t)'. Veja `recttopolar'.

     `polartorect' traduz valores complexos da forma `r %e^(%i t)' para
     a forma `a + b %i'. Veja `polartorect'.

     `demo ("fft")' exibe uma demonstração do pacote `fft'.


 -- Variável de opção: fortindent
     Valor padrão: 0

     `fortindent' controla a margem esquerda de indentação de
     expressões mostradas pelo comando `fortran'.  0 fornece
     indentação normal (i.e., 6 espaços), e valores positivos farão com
     que expressões sejam mostrados mais além para a direita.


 -- Função: fortran (<expr>)
     Mostra <expr> como uma declaração Fortran.  A linha de saída é
     indentada com espaços.  Se a linha for muito longa, `fortran'
     imprime linhas de continuação.  `fortran' mostra o operador de
     exponenciação `^' como `**', e mostra um número complexo `a + b
     %i' na forma `(a,b)'.

     <expr> pode ser uma equação. Nesse caso, `fortran' mostra uma
     declaração de atribuição, atribuindo o primeiro membro (esquerda)
     da equação ao segundo membro (direita).  Em particular, se o
     primeiro membro <expr> é um nome de uma matriz, então `fortran'
     mostra uma declaração de atribuição para cada elemento da matriz.

     Se <expr> não for alguma coisa reconhecida por `fortran', a
     expressão é mostrada no formato `grind' sem reclamação.  `fortran'
     não conhece listas, arrays ou funções.

     `fortindent' controla o margem esquerda das linhas mostradas.  0 é
     a margem normal (i.e., indentada 6 espaços). Incrementando
     `fortindent' faz com que expressões sejam mostradas adiante para a
     direita.

     quando `fortspaces' for `true', `fortran' preenche cada linha
     mostrada com espaços em branco até completar 80 columas.

     `fortran' avalia seus argumentos; colocando um apóstrofo em um
     argumento evita avaliação.  `fortran' sempre retorna `done'.

     Exemplos:

          (%i1) expr: (a + b)^12$
          (%i2) fortran (expr);
                (b+a)**12
          (%o2)                         done
          (%i3) fortran ('x=expr);
                x = (b+a)**12
          (%o3)                         done
          (%i4) fortran ('x=expand (expr));
                x = b**12+12*a*b**11+66*a**2*b**10+220*a**3*b**9+495*a**4*b**8+792
               1   *a**5*b**7+924*a**6*b**6+792*a**7*b**5+495*a**8*b**4+220*a**9*b
               2   **3+66*a**10*b**2+12*a**11*b+a**12
          (%o4)                         done
          (%i5) fortran ('x=7+5*%i);
                x = (7,5)
          (%o5)                         done
          (%i6) fortran ('x=[1,2,3,4]);
                x = [1,2,3,4]
          (%o6)                         done
          (%i7) f(x) := x^2$
          (%i8) fortran (f);
                f
          (%o8)                         done


 -- Variável de opção: fortspaces
     Valor padrão: `false'

     Quando `fortspaces' for `true', `fortran' preenche cada linha
     mostrada com espaços em branco até completar 80 columas.


 -- Função: horner (<expr>, <x>)
 -- Função: horner (<expr>)
     Retorna uma representação rearranjada de <expr> como na regra de
     Horner, usando <x> como variável principal se isso for
     especificado.  `x' pode ser omitido e nesse caso a variável
     principal da forma de expressão racional canônica de <expr> é
     usada.

     `horner' algumas vezes melhora a estabilidade se `expr' for ser
     numericamente avaliada.  Isso também é útil se Maxima é usado para
     gerar programas para rodar em Fortran. Veja também `stringout'.

          (%i1) expr: 1e-155*x^2 - 5.5*x + 5.2e155;
                                     2
          (%o1)            1.0E-155 x  - 5.5 x + 5.2E+155
          (%i2) expr2: horner (%, x), keepfloat: true;
          (%o2)            (1.0E-155 x - 5.5) x + 5.2E+155
          (%i3) ev (expr, x=1e155);
          Maxima encountered a Lisp error:

           floating point overflow

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.
          (%i4) ev (expr2, x=1e155);
          (%o4)                       7.0E+154


 -- Função: find_root (<f>(<x>), <x>, <a>, <b>)
 -- Função: find_root (<f>, <a>, <b>)
     Encontra a raíz da função <f> com a variável <x> percorrendo o
     intervalo `[<a>, <b>]'.  A função deve ter um sinal diferente em
     cada ponto final.  Se essa condição não for alcançada, a action of
     the function is governed by `find_root_error'.  If
     `find_root_error' is `true' then an error occurs, otherwise the
     value of `find_root_error' is returned (thus for plotting
     `find_root_error' might be set to 0.0).  De outra forma (dado que
     Maxima pode avaliar o primeiro argumento no intervalo
     especificado, e que o intervalo é contínuo) `find_root' é
     garantido vir para cima com a raíz (ou um deles se existir mais
     que uma raíz).  A precisão de `find_root' é governada por
     `intpolabs' e `intpolrel' os quais devem ser números em ponto
     flutuante não negativos.  `find_root' encerrará quando o primeiro
     argumento avaliar para alguma coisa menor que ou igual a
     `intpolabs' ou se sucessivas aproximações da raíz diferirem por
     não mais que `intpolrel * <um dos aproximandos>'.  O valor padrão
     de `intpolabs' e `intpolrel' são 0.0 de forma que `find_root' pega
     como boa uma resposta como for possível com a precisão aritmética
     simples que tivermos.  O primeiro argumento pode ser uma
     equação.  A ordem dos dois últimos argumentos é irrelevante.
     Dessa forma

          find_root (sin(x) = x/2, x, %pi, 0.1);

     é equivalente a

          find_root (sin(x) = x/2, x, 0.1, %pi);

     O método usado é uma busca binária no intervalo especificado pelos
     últimos dois argumentos.  Quando o resultado da busca for
     encontrado a função é fechada o suficiente para ser linear, isso
     inicia usando interpolação linear.

     Examples:
          (%i1) f(x) := sin(x) - x/2;
                                                  x
          (%o1)                  f(x) := sin(x) - -
                                                  2
          (%i2) find_root (sin(x) - x/2, x, 0.1, %pi);
          (%o2)                   1.895494267033981
          (%i3) find_root (sin(x) = x/2, x, 0.1, %pi);
          (%o3)                   1.895494267033981
          (%i4) find_root (f(x), x, 0.1, %pi);
          (%o4)                   1.895494267033981
          (%i5) find_root (f, 0.1, %pi);
          (%o5)                   1.895494267033981


 -- Variável de opção: find_root_abs
     Valor padrão: 0.0

     `find_root_abs' é a precisão do comando `find_root'. A precisão é
     governada por `find_root_abs' e `find_root_rel' que devem ser
     números não negativos em ponto flutuante.  `find_root' terminará
     quando o primeiro argumento avaliar para alguma coisa menor que ou
     igual a `find_root_abs' ou se sucessivos aproximandos para a raíz
     diferirem por não mais que `find_root_rel * <um dos aproximandos>'.
     Os valores padrão de `find_root_abs' e `find_root_rel' são 0.0 de
     forma que `find_root' tome como boa uma resposta que for possível
     com a precisão aritmética simples que tivermos.


 -- Variável de opção: find_root_error
     Valor padrão: `true'

     `find_root_error' governa o comportamento de `find_root'.  Quando
     `find_root' for chamada, ela determina se a função a ser resolvida
     satisfaz ou não a condição que os valores da função nos pontos
     finais do intervalo de interpolação são opostos em sinal.  Se eles
     forem de sinais opostos, a interpolação prossegue.  Se eles forem
     de mesmo sinal, e `find_root_error' for `true', então um erro é
     sinalizado.  Se eles forem de mesmo sinal e `find_root_error' não
     for `true', o valor de `find_root_error' é retornado.  Dessa forma
     para montagem de gráfico, `find_root_error' pode ser escolhida
     para 0.0.


 -- Variável de opção: find_root_rel
     Valor padrão: 0.0

     `find_root_rel' é a precisão do comando `find_root' e é governada
     por `find_root_abs' e `find_root_rel' que devem ser números não
     negativos em ponto flutuante.  `find_root' terminará quando o
     primeiro argumento avaliar para alguma coisa menor que ou igual a
     `find_root_abs' ou se sucessivos aproximandos para a raíz
     diferirem de não mais que `find_root_rel * <um dos aproximandos>'.
     Os valores padrão de `find_root_labs' e `find_root_rel' é 0.0 de
     forma que `find_root' toma como boa uma resposta que for possível
     com a precisão aritmética simples que tivermos.


 -- Função: newton (<expr>, <x>, <x_0>, <eps>)
     Retorna uma solução aproximada de `<expr> = 0' através do método
     de Newton, considerando <expr> como sendo uma função de uma
     variável, <x>.  A busca pela solução começa com `<x> = <x_0>' e
     prossegue até `abs(<expr>) < <eps>' (com <expr> avaliada para o
     valor corrente de <x>).

     `newton' permite que variáveis indefinidas apareçam em <expr>,
     contanto que o teste de terminação `abs(<expr>) < <eps>' avalie
     para `true' ou `false'.  Dessa forma não é necessário que <expr>
     avalie para um número.

     `load(newton1)' chama essa função.

     Veja também `realroots', `allroots', `find_root', e `mnewton'.

     Exemplos:

          (%i1) load (newton1);
          (%o1) /usr/share/maxima/5.10.0cvs/share/numeric/newton1.mac
          (%i2) newton (cos (u), u, 1, 1/100);
          (%o2)                   1.570675277161251
          (%i3) ev (cos (u), u = %);
          (%o3)                 1.2104963335033528E-4
          (%i4) assume (a > 0);
          (%o4)                        [a > 0]
          (%i5) newton (x^2 - a^2, x, a/2, a^2/100);
          (%o5)                  1.00030487804878 a
          (%i6) ev (x^2 - a^2, x = %);
                                                     2
          (%o6)                6.098490481853958E-4 a



File: maxima.info,  Node: Funções e Variáveis Definidas para Séries de Fourier,  Prev: Funções e Variáveis Definidas para Numérico,  Up: Numérico

23.4 Funções e Variáveis Definidas para Séries de Fourier
=========================================================

 -- Função: equalp (<x>, <y>)
     Retorna `true' se `equal (<x>, <y>)' de outra forma `false' (não
     fornece uma mensagem de erro como `equal (x, y)' poderia fazer
     nesse caso).


 -- Função: remfun (<f>, <expr>)
 -- Função: remfun (<f>, <expr>, <x>)
     `remfun (<f>, <expr>)' substitue todas as ocorrências de `<f>
     (<arg>)' por <arg> em <expr>.

     `remfun (<f>, <expr>, <x>)' substitue todas as ocorrências de `<f>
     (<arg>)' por <arg> em <expr> somente se <arg> contiver a variável
     <x>.


 -- Função: funp (<f>, <expr>)
 -- Função: funp (<f>, <expr>, <x>)
     `funp (<f>, <expr>)' retorna `true' se <expr> contém a função <f>.

     `funp (<f>, <expr>, <x>)' retorna `true' se <expr> contém a
     função <f> e a variável <x> em algum lugar no argumento de uma das
     instâncias de <f>.


 -- Função: absint (<f>, <x>, <halfplane>)
 -- Função: absint (<f>, <x>)
 -- Função: absint (<f>, <x>, <a>, <b>)
     `absint (<f>, <x>, <halfplane>)' retorna a integral indefinida de
     <f> com relação a <x> no dado semi-plano (`pos', `neg', ou `both').
     <f> pode conter expressões da forma `abs (x)', `abs (sin (x))',
     `abs (a) * exp (-abs (b) * abs (x))'.

     `absint (<f>, <x>)' é equivalente a `absint (<f>, <x>, pos)'.

     `absint (<f>, <x>, <a>, <b>)' retorna a integral definida de <f>
     com relação a <x> de <a> até <b>.  <f> pode incluir valores
     absolutos.


 -- Função: fourier (<f>, <x>, <p>)
     Retorna uma lista de coeficientes de Fourier de `<f>(<x>)'
     definidos sobre o intervalo `[-p, p]'.


 -- Função: foursimp (<l>)
     Simplifica `sin (n %pi)' para 0 se `sinnpiflag' for `true' e `cos
     (n %pi)' para `(-1)^n' se `cosnpiflag' for `true'.


 -- Variável de opção: sinnpiflag
     Valor padrão: `true'

     Veja `foursimp'.


 -- Variável de opção: cosnpiflag
     Valor padrão: `true'

     Veja `foursimp'.


 -- Função: fourexpand (<l>, <x>, <p>, <limit>)
     Constrói e retorna a série de Fourier partindo da lista de
     coeficientes de Fourier <l> até (up through) <limit> termos
     (<limit> pode ser `inf'). <x> e <p> possuem o mesmo significado
     que em `fourier'.


 -- Função: fourcos (<f>, <x>, <p>)
     Retorna os coeficientes do cosseno de Fourier para `<f>(<x>)'
     definida sobre `[0, %pi]'.


 -- Função: foursin (<f>, <x>, <p>)
     Retorna os coeficientes do seno de Fourier para `<f>(<x>)'
     definida sobre `[0, <p>]'.


 -- Função: totalfourier (<f>, <x>, <p>)
     Retorna `fourexpand (foursimp (fourier (<f>, <x>, <p>)), <x>, <p>,
     'inf)'.


 -- Função: fourint (<f>, <x>)
     Constrói e retorna uma lista de coeficientes de integral de
     Fourier de `<f>(<x>)' definida sobre `[minf, inf]'.


 -- Função: fourintcos (<f>, <x>)
     Retorna os coeficientes da integral do cosseno de Fourier para
     `<f>(<x>)' on `[0, inf]'.


 -- Função: fourintsin (<f>, <x>)
     Retorna os coeficientes da integral do seno de Fourier para
     `<f>(<x>)' on `[0, inf]'.



File: maxima.info,  Node: Arrays,  Next: Matrizes e Álgebra Linear,  Prev: Numérico,  Up: Top

24 Arrays
*********

* Menu:

* Funções e Variáveis Definidas para Arrays::


File: maxima.info,  Node: Funções e Variáveis Definidas para Arrays,  Prev: Arrays,  Up: Arrays

24.1 Funções e Variáveis Definidas para Arrays
==============================================

 -- Função: array (<name>, <dim_1>, ..., <dim_n>)
 -- Função: array (<name>, <type>, <dim_1>, ..., <dim_n>)
 -- Função: array ([<nome_1>, ..., <nome_m>], <dim_1>, ..., <dim_n>)
     Cria um array n-dimensional.  n pode ser menor ou igual a 5.  Os
     subscritos para a i'ésima dimensão são inteiros no intervalo de 0
     a <dim_i>.

     `array (<name>, <dim_1>, ..., <dim_n>)' cria um array genérico.

     `array (<name>, <type>, <dim_1>, ..., <dim_n>)' cria um array, com
     elementos de um tipo especificado.  <type> pode ser `fixnum' para
     inteiros de tamanho limitado ou `flonum' para números em ponto
     flutuante.

     `array ([<nome_1>, ..., <nome_m>], <dim_1>, ..., <dim_n>)' cria m
     arrays, todos da mesma dimensão.

     Se o usuário atribui a uma variável subscrita antes de declarar o
     array correspondente, um array não declarado é criado.  Arrays não
     declarados, também conhecidos como array desordenado (porque o
     codigo desordenado termina nos subscritos), são mais gerais que
     arrays declarados.  O usuário não declara seu tamanho máximo, e
     ele cresce dinamicamente e desordenadamente à medida que são
     atribuídos valores a mais elementos.  Os subscritos de um array
     não declarado não precisam sempre ser números.  Todavia, exceto
     para um array um tanto quanto esparso, é provavelmente mais
     eficiente declarar isso quando possível que deixar não declarado.
     A função `array' pode ser usada para transformar um array não
     declarado em um array declarado.


 -- Função: arrayapply (<A>, [<i_1>, ..., <i_n>])
     Avalia `<A> [<i_1>, ..., <i_n>]', quando <A> for um array e <i_1>,
     ..., <i_n> são inteiros.

     Ela é remanescente de `apply', exceto o primeiro argumento que é
     um array ao invés de uma função.


 -- Função: arrayinfo (<A>)
     Retorna informações sobre o array <A>.  O argumento <A> pode ser
     um array declarado, uma array não declarado ( que sofreu um hash),
     uma função de array, ou uma função que possui subscrito.

     Para arrays declarados, `arrayinfo' retorna uma lista
     compreendendo o átomo `declared', o n;umero de dimensões, e o
     tamanho de cada dimensão.  Os elementos do array, ambos associados
     e não associados, são retornados por `listarray'.

     Para arrays não declarados (arrays que sofreram um hash),
     `arrayinfo' retorna uma lista compreendendo o átomo `hashed', o
     número de subscritos, e os subscritos de de todo elemento que
     tiver um valor.  Os valores são retornados por meio de `listarray'.

     Para funções de array, `arrayinfo' retretorna uma lista
     compreendendo o átomo `hashed', o número de subscritos, e
     quaisquer valores de subscritos para os quais exista valores
     funcionais armazenados.  Os valores funcionais armazenados são
     retornados através de `listarray'.

     Para funções que possuem subscritos, `arrayinfo' retorna uma lista
     compreendendo o átomo `hashed', o número de subscritos, e qualquer
     valores subscritos para os quais existe uma expressões lambda.  As
     expressões lambda são retornadas por `listarray'.

     Examples:

     `arrayinfo' e `listarray' aplicado a um array declarado.

          (%i1) array (aa, 2, 3);
          (%o1)                          aa
          (%i2) aa [2, 3] : %pi;
          (%o2)                          %pi
          (%i3) aa [1, 2] : %e;
          (%o3)                          %e
          (%i4) arrayinfo (aa);
          (%o4)                 [declared, 2, [2, 3]]
          (%i5) listarray (aa);
          (%o5) [#####, #####, #####, #####, #####, #####, %e, #####,
                                                  #####, #####, #####, %pi]

     `arrayinfo' e `listarray' aplicado a um array não declarado (no
     qual foi aplicado um hash).

          (%i1) bb [FOO] : (a + b)^2;
                                             2
          (%o1)                       (b + a)
          (%i2) bb [BAR] : (c - d)^3;
                                             3
          (%o2)                       (c - d)
          (%i3) arrayinfo (bb);
          (%o3)               [hashed, 1, [BAR], [FOO]]
          (%i4) listarray (bb);
                                        3         2
          (%o4)                 [(c - d) , (b + a) ]

     `arrayinfo' e `listarray' aplicado a uma função de array.

          (%i1) cc [x, y] := y / x;
                                               y
          (%o1)                      cc     := -
                                       x, y    x
          (%i2) cc [u, v];
                                          v
          (%o2)                           -
                                          u
          (%i3) cc [4, z];
                                          z
          (%o3)                           -
                                          4
          (%i4) arrayinfo (cc);
          (%o4)              [hashed, 2, [4, z], [u, v]]
          (%i5) listarray (cc);
                                        z  v
          (%o5)                        [-, -]
                                        4  u

     `arrayinfo' e `listarray' aplicadas a funções com subscritos.

          (%i1) dd [x] (y) := y ^ x;
                                               x
          (%o1)                     dd (y) := y
                                      x
          (%i2) dd [a + b];
                                              b + a
          (%o2)                  lambda([y], y     )
          (%i3) dd [v - u];
                                              v - u
          (%o3)                  lambda([y], y     )
          (%i4) arrayinfo (dd);
          (%o4)             [hashed, 1, [b + a], [v - u]]
          (%i5) listarray (dd);
                                   b + a                v - u
          (%o5)      [lambda([y], y     ), lambda([y], y     )]

 -- Função: arraymake (<A>, [<i_1>, ..., <i_n>])
     Retorna a expressão `<A>[<i_1>, ..., <i_n>]'.  O resultado é uma
     referência a um array não avaliado.

     `arraymake' é remanicência de `funmake', exceto o valor retornado
     é um array de referência não avaliado ao invés de uma chamada de
     função não avaliada.

     Exemplos:

          (%i1) arraymake (A, [1]);
          (%o1)                          A
                                          1
          (%i2) arraymake (A, [k]);
          (%o2)                          A
                                          k
          (%i3) arraymake (A, [i, j, 3]);
          (%o3)                       A
                                       i, j, 3
          (%i4) array (A, fixnum, 10);
          (%o4)                           A
          (%i5) fillarray (A, makelist (i^2, i, 1, 11));
          (%o5)                           A
          (%i6) arraymake (A, [5]);
          (%o6)                          A
                                          5
          (%i7) ''%;
          (%o7)                          36
          (%i8) L : [a, b, c, d, e];
          (%o8)                    [a, b, c, d, e]
          (%i9) arraymake ('L, [n]);
          (%o9)                          L
                                          n
          (%i10) ''%, n = 3;
          (%o10)                          c
          (%i11) A2 : make_array (fixnum, 10);
          (%o11)          {Array:  #(0 0 0 0 0 0 0 0 0 0)}
          (%i12) fillarray (A2, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o12)          {Array:  #(1 2 3 4 5 6 7 8 9 10)}
          (%i13) arraymake ('A2, [8]);
          (%o13)                         A2
                                           8
          (%i14) ''%;
          (%o14)                          9


 -- Variável de sistema: arrays
     Valor padrão: `[]'

     `arrays' é uma lista dos arrays que tiverem sido alocados.  Essa
     lista compreende arrays declarados através de `array', arrays
     desordenados (hashed) construídos através de definição implícita
     (atribuindo alguma coisa a um elemento de array), e funções de
     array definidas por meio de `:=' e `define'.  Arrays definidos por
     meio de `make_array' não estão incluídos.

     Veja também `array', `arrayapply', `arrayinfo', `arraymake',
     `fillarray', `listarray', e `rearray'.

     Exemplos:

          (%i1) array (aa, 5, 7);
          (%o1)                          aa
          (%i2) bb [FOO] : (a + b)^2;
                                             2
          (%o2)                       (b + a)
          (%i3) cc [x] := x/100;
                                             x
          (%o3)                      cc  := ---
                                       x    100
          (%i4) dd : make_array ('any, 7);
          (%o4)       {Array:  #(NIL NIL NIL NIL NIL NIL NIL)}
          (%i5) arrays;
          (%o5)                     [aa, bb, cc]


 -- Função: bashindices (<expr>)
     Transforma a expressão <expr> dando a cada somatório e a cada
     produto um único índice.  Isso dá a `changevar' grande precisão
     quando se está trabalhando com somatórios e produtos.  A forma do
     único índice é `j<number>'.  A quantidade <number> é determindad
     por referência a `gensumnum', que pode ser alterada pelo usuário.
     Por exemplo, `gensumnum:0$' reseta isso.


 -- Função: fillarray (<A>, <B>)
     Preenche o array <A> com <B>, que é uma lista ou um array.

     Se um tipo específico for declarado para <A> no momento de sua
     criação, <A> somente porde ser preenchido com elementos do tipo
     especificado; Constitui um erro alguma tentativa feita para copiar
     um um elemento de um tipo diferente.

     Se as dimensões dos arrays <A> e <B> forem diferents, <A> é
     preenchido no ordem de maior fileira.  Se não existirem elementos
     livres em <B> o último elemento é usado para preencher todo o
     resto de <A>.  Se existirem muitos , esses restantes seram
     ignorados.

     `fillarray' retorna esse primeiro argumento.

     Exemplos:

     Create an array of 9 elements and fill it from a list.

          (%i1) array (a1, fixnum, 8);
          (%o1)                          a1
          (%i2) listarray (a1);
          (%o2)              [0, 0, 0, 0, 0, 0, 0, 0, 0]
          (%i3) fillarray (a1, [1, 2, 3, 4, 5, 6, 7, 8, 9]);
          (%o3)                          a1
          (%i4) listarray (a1);
          (%o4)              [1, 2, 3, 4, 5, 6, 7, 8, 9]

     Quando existirem poucos elementos para preencher o array, o último
     elemento é repetido.  Quando houverem muitos elementos, os
     elementos extras são ignorados.

          (%i1) a2 : make_array (fixnum, 8);
          (%o1)             {Array:  #(0 0 0 0 0 0 0 0)}
          (%i2) fillarray (a2, [1, 2, 3, 4, 5]);
          (%o2)             {Array:  #(1 2 3 4 5 5 5 5)}
          (%i3) fillarray (a2, [4]);
          (%o3)             {Array:  #(4 4 4 4 4 4 4 4)}
          (%i4) fillarray (a2, makelist (i, i, 1, 100));
          (%o4)             {Array:  #(1 2 3 4 5 6 7 8)}

     Arrays multi-dimensionais são preenchidos em ordem de maior
     fileira.

          (%i1) a3 : make_array (fixnum, 2, 5);
          (%o1)        {Array:  #2A((0 0 0 0 0) (0 0 0 0 0))}
          (%i2) fillarray (a3, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o2)        {Array:  #2A((1 2 3 4 5) (6 7 8 9 10))}
          (%i3) a4 : make_array (fixnum, 5, 2);
          (%o3)     {Array:  #2A((0 0) (0 0) (0 0) (0 0) (0 0))}
          (%i4) fillarray (a4, a3);
          (%o4)     {Array:  #2A((1 2) (3 4) (5 6) (7 8) (9 10))}


 -- Função: listarray (<A>)
     Retorna uma lista dos elementos do array <A>.  O argumento <A>
     pode ser um array declarado, um array não declarado (desordenado -
     hashed), uma função de array, ou uma função com subscritos.

     Elementos são listados em ordem de linha maior.  Isto é, elementos
     são ordenados conforme o primeiro índice, en seguida conforme o
     segundo índice, e assim sucessivamente.  A sequüência de
     ordenação por meio dos valores dos índices é a mesma ordem
     estabelecida por meio de `orderless'.

     Para arrays não declarados , funções de arrays, e funções com
     subscritos, os elementos correspondem aos valores de índice
     retornados através de `arrayinfo'.

     Elemetos não associados de arrays genéricos declarados (isto é,
     não `fixnum' e não `flonum') são retornados como `#####'.
     Elementos não associados de arrays declarados `fixnum' ou `flonum'
     são retornados como 0 ou 0.0, respectivamente.  Elementos não
     associados de arrays não declarados, funções de array, e funções
     subscritas não são retornados.

     Exemplos:

     `listarray' e `arrayinfo' aplicados a um array declarado.

          (%i1) array (aa, 2, 3);
          (%o1)                          aa
          (%i2) aa [2, 3] : %pi;
          (%o2)                          %pi
          (%i3) aa [1, 2] : %e;
          (%o3)                          %e
          (%i4) listarray (aa);
          (%o4) [#####, #####, #####, #####, #####, #####, %e, #####,
                                                  #####, #####, #####, %pi]
          (%i5) arrayinfo (aa);
          (%o5)                 [declared, 2, [2, 3]]

     `listarray' e `arrayinfo' aplicadas a arrays não declarados
     (hashed - desordenados).

          (%i1) bb [FOO] : (a + b)^2;
                                             2
          (%o1)                       (b + a)
          (%i2) bb [BAR] : (c - d)^3;
                                             3
          (%o2)                       (c - d)
          (%i3) listarray (bb);
                                        3         2
          (%o3)                 [(c - d) , (b + a) ]
          (%i4) arrayinfo (bb);
          (%o4)               [hashed, 1, [BAR], [FOO]]

     `listarray' e `arrayinfo' aplicada a uma função de array.

          (%i1) cc [x, y] := y / x;
                                               y
          (%o1)                      cc     := -
                                       x, y    x
          (%i2) cc [u, v];
                                          v
          (%o2)                           -
                                          u
          (%i3) cc [4, z];
                                          z
          (%o3)                           -
                                          4
          (%i4) listarray (cc);
                                        z  v
          (%o4)                        [-, -]
                                        4  u
          (%i5) arrayinfo (cc);
          (%o5)              [hashed, 2, [4, z], [u, v]]

     `listarray' e `arrayinfo' aplicadas a funções com subscritos.

          (%i1) dd [x] (y) := y ^ x;
                                               x
          (%o1)                     dd (y) := y
                                      x
          (%i2) dd [a + b];
                                              b + a
          (%o2)                  lambda([y], y     )
          (%i3) dd [v - u];
                                              v - u
          (%o3)                  lambda([y], y     )
          (%i4) listarray (dd);
                                   b + a                v - u
          (%o4)      [lambda([y], y     ), lambda([y], y     )]
          (%i5) arrayinfo (dd);
          (%o5)             [hashed, 1, [b + a], [v - u]]


 -- Função: make_array (<type>, <dim_1>, ..., <dim_n>)
     Cria e retorna um array de Lisp.  <type> pode ser `any', `flonum',
     `fixnum', `hashed' ou `functional'.  Existem n indices, e o
     i'enésimo indice está no intervalo de 0 a <dim_i> - 1.

     A vantagem de `make_array' sobre `array' é que o valor de retorno
     não tem um nome, e uma vez que um ponteiro a ele vai, ele irá
     também.  Por exemplo, se `y: make_array (...)' então `y' aponta
     para um objeto que ocupa espaço, mas depois de `y: false', `y' não
     mais aponta para aquele objeto, então o objeto pode ser descartado.

     Exemplos:

          (%i1) A1 : make_array (fixnum, 10);
          (%o1)           {Array:  #(0 0 0 0 0 0 0 0 0 0)}
          (%i2) A1 [8] : 1729;
          (%o2)                         1729
          (%i3) A1;
          (%o3)          {Array:  #(0 0 0 0 0 0 0 0 1729 0)}
          (%i4) A2 : make_array (flonum, 10);
          (%o4) {Array:  #(0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0)}
          (%i5) A2 [2] : 2.718281828;
          (%o5)                      2.718281828
          (%i6) A2;
          (%o6)
               {Array:  #(0.0 0.0 2.718281828 0.0 0.0 0.0 0.0 0.0 0.0 0.0)}
          (%i7) A3 : make_array (any, 10);
          (%o7) {Array:  #(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)}
          (%i8) A3 [4] : x - y - z;
          (%o8)                      - z - y + x
          (%i9) A3;
          (%o9) {Array:  #(NIL NIL NIL NIL ((MPLUS SIMP) $X ((MTIMES SIMP)\
           -1 $Y) ((MTIMES SIMP) -1 $Z))
            NIL NIL NIL NIL NIL)}
          (%i10) A4 : make_array (fixnum, 2, 3, 5);
          (%o10) {Array:  #3A(((0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0)) ((0 0 \
          0 0 0) (0 0 0 0 0) (0 0 0 0 0)))}
          (%i11) fillarray (A4, makelist (i, i, 1, 2*3*5));
          (%o11) {Array:  #3A(((1 2 3 4 5) (6 7 8 9 10) (11 12 13 14 15))
              ((16 17 18 19 20) (21 22 23 24 25) (26 27 28 29 30)))}
          (%i12) A4 [0, 2, 1];
          (%o12)                         12


 -- Função: rearray (<A>, <dim_1>, ..., <dim_n>)
     Altera as dimenções de um array.  O novo array será preenchido com
     os elementos do antigo em ordem da maior linha.  Se o array antigo
     era muito pequeno, os elementos restantes serão preenchidos com
     `false', `0.0' ou `0', dependendo do tipo do array.  O tipo do
     array não pode ser alterado.


 -- Função: remarray (<A_1>, ..., <A_n>)
 -- Função: remarray (all)
     Remove arrays e funções associadas a arrays e libera o espaço
     ocupado.  Os argumentos podem ser arrays declarados, arrays não
     declarados (dsordenados - hashed), funções de array functions, e
     funções com subscritos.

     `remarray (all)' remove todos os ítens na lista global `arrays'.

     Isso pode ser necessário para usar essa função se isso é desejado
     para redefinir os valores em um array desordenado.

     `remarray' retorna a lista dos arrays removidos.


 -- Função: subvar (<x>, <i>)
     Avalia a expressão subscrita `<x>[<i>]'.

     `subvar' avalia seus argumentos.

     `arraymake (<x>, [<i>]' constrói a expressão `<x>[<i>]', mas não a
     avalia.

     Exemplos:

          (%i1) x : foo $
          (%i2) i : 3 $
          (%i3) subvar (x, i);
          (%o3)                         foo
                                           3
          (%i4) foo : [aa, bb, cc, dd, ee]$
          (%i5) subvar (x, i);
          (%o5)                          cc
          (%i6) arraymake (x, [i]);
          (%o6)                         foo
                                           3
          (%i7) ''%;
          (%o7)                          cc


 -- Variável de pção: use_fast_arrays
     - Se `true' somente dois tipos de arrays são reconhecidos.

     1) O array art-q (t no Lisp Comum) que pode ter muitas dimensões
     indexadas por inteiros, e pode aceitar qualquer objeto do Lisp ou
     do Maxima como uma entrada.  Para construir assim um array, insira
     `a:make_array(any,3,4);' então `a' terá como valor, um array com
     doze posições, e o índice é baseado em zero.

     2) O array Hash_table que é o tipo padrão de array criado se um
     faz `b[x+1]:y^2' (e `b' não é ainda um array, uma lista, ou uma
     matriz - se isso ou um desses ocorrer um erro pode ser causado
     desde `x+1' não poderá ser um subscrito válido para um array
     art-q, uma lista ou uma matriz).  Esses índices (também conhecidos
     como chaves) podem ser quaisquer objetos.  Isso somente pega uma
     chave por vez a cada vez (`b[x+1,u]:y' ignorará o `u').  A
     referência termina em `b[x+1] ==> y^2'.  Certamente a chave poe
     ser uma lista , e.g.  `b[[x+1,u]]:y' poderá ser válido.  Isso é
     incompatível com os arrays antigos do Maxima, mas poupa recursos.

     Uma vantagem de armazenar os arrays como valores de símbolos é que
     as convenções usuais sobre variáveis locais de uma função
     aplicam-se a arrays também.  O tipo Hash_table também usa menos
     recursos e é mais eficiente que o velho tipo hashar do Maxima.
     Para obter comportamento consistente em códigos traduzidos e
     compilados posicione `translate_fast_arrays' para ser `true'.



File: maxima.info,  Node: Matrizes e Álgebra Linear,  Next: Funções Afins,  Prev: Arrays,  Up: Top

25 Matrizes e Álgebra Linear
****************************

/Matrices.texi/1.29/Sat Jun  2 00:12:57 2007/-ko/

* Menu:

* Introdução a Matrizes e Álgebra Linear::
* Funções e Variáveis Definidas para Matrizes e Álgebra Linear::


File: maxima.info,  Node: Introdução a Matrizes e Álgebra Linear,  Next: Funções e Variáveis Definidas para Matrizes e Álgebra Linear,  Prev: Matrizes e Álgebra Linear,  Up: Matrizes e Álgebra Linear

25.1 Introdução a Matrizes e Álgebra Linear
===========================================

* Menu:

* Ponto::
* Vetores::
* auto::


File: maxima.info,  Node: Ponto,  Next: Vetores,  Prev: Introdução a Matrizes e Álgebra Linear,  Up: Introdução a Matrizes e Álgebra Linear

25.1.1 Ponto
------------

O operador `.' representa multiplicação não comutativa e produto
escalar.  Quando os operandos são matrizes 1-coluna ou 1-linha `a' e
`b', a expresão `a.b' é equivalente a `sum (a[i]*b[i], i, 1,
length(a))'.  Se `a' e `b' não são complexos, isso é o produto escalar,
também chamado produto interno ou produto do ponto, de `a' e `b'.  O
produto escalar é definido como `conjugate(a).b' quando `a' e `b' são
complexos; `innerproduct' no pacote `eigen' fornece o produto escalar
complexo.

   Quando os operandos são matrizes mais gerais, o produto é a matriz
produto `a' e `b'.  O número de linhas de `b' deve ser igual ao número
de colunas de `a', e o resultado tem número de linhas igual ao número
de linhas de `a' e número de colunas igual ao número de colunas de `b'.

   Para distingüir `.' como um operador aritmético do ponto decimal em
um número em ponto flutuante, pode ser necessário deixar espaços em
cada lado.  Por exemplo, `5.e3' é `5000.0' mas `5 . e3' é `5' vezes
`e3'.

   Existem muitos sinalizadores que governam a simplificação de
expresões envolvendo `.', a saber `dot', `dot0nscsimp', `dot0simp',
`dot1simp', `dotassoc', `dotconstrules', `dotdistrib', `dotexptsimp',
`dotident', e `dotscrules'.


File: maxima.info,  Node: Vetores,  Next: auto,  Prev: Ponto,  Up: Introdução a Matrizes e Álgebra Linear

25.1.2 Vetores
--------------

`vect' é um pacote de funções para análise vetorial.  `load ("vect")'
chama esse pacote, e `demo ("vect")' permite visualizar uma
demonstração.

   O pacote de análise vetorial pode combinar e simplificar expresões
simbólicas incluindo produtos dos pontos e productos dos x, juntamente
com o gradiente, divergencia, torção, e operadores Laplacianos.  A
distribuição desses operadores sobre adições ou produtos é governada
por muitos sinalizadores, como são várias outras expansões, incluindo
expansão dentro de componentes em qualquer sistema de coordenadas
ortogonais.  Existem também funções para derivar o escalar ou vetor
potencial de um campo.

   O pacote `vect' contém essas funções: `vectorsimp', `scalefactors',
`express', `potential', e `vectorpotential'.

   Atenção: o pacote `vect' declara o operador ponto `.' como sendo um
operador comutativo.


File: maxima.info,  Node: auto,  Prev: Vetores,  Up: Introdução a Matrizes e Álgebra Linear

25.1.3 auto
-----------

O pacote `eigen' contém muitas funções devotadas para a computação
simbólica de autovalores e autovetores.  Maxima chama o pacote
automaticamente se uma das funções `eigenvalues' ou `eigenvectors' é
invocada.  O pacote pode ser chamado explicitamente com `load
("eigen")'.

   `demo ("eigen")' mostra uma demonstração das compatibilidades desse
pacote.  `batch ("eigen")' executa a mesma demonstração, mas sem
lembretes de usuário entre sucessivas computações.

   As funções no pacote `eigen' são `innerproduct', `unitvector',
`columnvector', `gramschmidt', `eigenvalues', `eigenvectors',
`uniteigenvectors', e `similaritytransform'.


File: maxima.info,  Node: Funções e Variáveis Definidas para Matrizes e Álgebra Linear,  Prev: Introdução a Matrizes e Álgebra Linear,  Up: Matrizes e Álgebra Linear

25.2 Funções e Variáveis Definidas para Matrizes e Álgebra Linear
=================================================================

 -- Função: addcol (<M>, <list_1>, ..., <list_n>)
     Anexa a(s) coluna(s) dadas por uma ou mais listas (ou matrizes)
     sobre a matriz <M>.


 -- Função: addrow (<M>, <list_1>, ..., <list_n>)
     Anexa a(s) linha(s) dadas por uma ou mais listas (ou matrizes)
     sobre a matriz <M>.


 -- Função: adjoint (<M>)
     Retorna a matriz adjunta da matriz <M>.  A matriz adjunta é a
     transposta da matriz dos cofatores de <M>.


 -- Função: augcoefmatrix ([<eqn_1>, ..., <eqn_m>], [<x_1>, ..., <x_n>])
     Retorna a matriz dos coeficientes aumentada para as variáveis
     <x_1>, ..., <x_n> do sistema de equações lineares <eqn_1>, ...,
     <eqn_m>.  Essa é a matriz dos coeficientes com uma coluna anexada
     para os termos independentes em cada equação (i.e., esses termos
     não dependem de <x_1>, ..., <x_n>).

          (%i1) m: [2*x - (a - 1)*y = 5*b, c + b*y + a*x = 0]$
          (%i2) augcoefmatrix (m, [x, y]);
                                 [ 2  1 - a  - 5 b ]
          (%o2)                  [                 ]
                                 [ a    b      c   ]


 -- Função: charpoly (<M>, <x>)
     Retorna um polinômio característico para a matriz <M> em
     relação à variável <x>.  Que é, `determinant (<M> - diagmatrix
     (length (<M>), <x>))'.

          (%i1) a: matrix ([3, 1], [2, 4]);
                                      [ 3  1 ]
          (%o1)                       [      ]
                                      [ 2  4 ]
          (%i2) expand (charpoly (a, lambda));
                                     2
          (%o2)                lambda  - 7 lambda + 10
          (%i3) (programmode: true, solve (%));
          (%o3)               [lambda = 5, lambda = 2]
          (%i4) matrix ([x1], [x2]);
                                       [ x1 ]
          (%o4)                        [    ]
                                       [ x2 ]
          (%i5) ev (a . % - lambda*%, %th(2)[1]);
                                    [ x2 - 2 x1 ]
          (%o5)                     [           ]
                                    [ 2 x1 - x2 ]
          (%i6) %[1, 1] = 0;
          (%o6)                     x2 - 2 x1 = 0
          (%i7) x2^2 + x1^2 = 1;
                                      2     2
          (%o7)                     x2  + x1  = 1
          (%i8) solve ([%th(2), %], [x1, x2]);
                            1               2
          (%o8) [[x1 = - -------, x2 = - -------],
                         sqrt(5)         sqrt(5)

                                                       1             2
                                              [x1 = -------, x2 = -------]]
                                                    sqrt(5)       sqrt(5)


 -- Função: coefmatrix ([<eqn_1>, ..., <eqn_m>], [<x_1>, ..., <x_n>])
     Retorna a matriz dos coeficientes para as variáveis <x_1>, ...,
     <x_n> do sistema de equações lineares <eqn_1>, ..., <eqn_m>.

          (%i1) coefmatrix([2*x-(a-1)*y+5*b = 0, b*y+a*x = 3], [x,y]);
                                           [ 2  1 - a ]
          (%o1)                            [          ]
                                           [ a    b   ]


 -- Função: col (<M>, <i>)
     Reorna a <i>'ésima coluna da matriz <M>.  O valor de retorno é uma
     matriz.


 -- Função: columnvector (<L>)
 -- Função: covect (<L>)
     Retorna uma matriz de uma coluna e `length (<L>)' linhas, contendo
     os elementos da lista <L>.

     `covect' é um sinônimo para `columnvector'.

     `load ("eigen")' chama essa função.

     Isso é útil se você quer usar partes das saídas das funções nesse
     pacote em cálculos matriciais.

     Exemplo:

          (%i1) load ("eigen")$
          Warning - you are redefining the Macsyma function autovalores
          Warning - you are redefining the Macsyma function autovetores
          (%i2) columnvector ([aa, bb, cc, dd]);
                                       [ aa ]
                                       [    ]
                                       [ bb ]
          (%o2)                        [    ]
                                       [ cc ]
                                       [    ]
                                       [ dd ]


 -- Função: conjugate (<x>)
     Retorna o conjugado complexo de <x>.

          (%i1) declare ([aa, bb], real, cc, complex, ii, imaginary);

          (%o1)                         done
          (%i2) conjugate (aa + bb*%i);

          (%o2)                      aa - %i bb
          (%i3) conjugate (cc);

          (%o3)                     conjugate(cc)
          (%i4) conjugate (ii);

          (%o4)                         - ii
          (%i5) conjugate (xx + yy);

          (%o5)             conjugate(yy) + conjugate(xx)


 -- Função: copymatrix (<M>)
     Retorna uma cópia da matriz <M>.  Esse é o único para fazer uma
     copia separada copiando <M> elemento a elemento.

     Note que uma atribuição de uma matriz para outra, como em `m2: m1',
     não copia `m1'.  Uma atribuição `m2 [i,j]: x' ou `setelmx (x, i,
     j, m2' também modifica `m1 [i,j]'.  criando uma cópia com
     `copymatrix' e então usando atribução cria uma separada e
     modificada cópia.


 -- Função: determinant (<M>)
     Calcula o determinante de <M> por um método similar à
     eliminação de Gauss.

     A forma do resultado depende da escolha do comutador `ratmx'.

     Existe uma rotina especial para calcular determinantes esparsos
     que é chamada quando os comutadores `ratmx' e `sparse' são ambos
     `true'.


 -- Variável: detout
     Valor padrão: `false'

     Quando `detout' é `true', o determinante de uma matriz cuja
     inversa é calculada é fatorado fora da inversa.

     Para esse comutador ter efeito `doallmxops' e `doscmxops' deveram
     ambos serem `false' (veja suas transcrições).  Alternativamente
     esses comutadores podem ser dados para `ev' o que faz com que os
     outros dois sejam escolhidos corretamente.

     Exemplo:

          (%i1) m: matrix ([a, b], [c, d]);
                                      [ a  b ]
          (%o1)                       [      ]
                                      [ c  d ]
          (%i2) detout: true$
          (%i3) doallmxops: false$
          (%i4) doscmxops: false$
          (%i5) invert (m);
                                    [  d   - b ]
                                    [          ]
                                    [ - c   a  ]
          (%o5)                     ------------
                                     a d - b c


 -- Função: diagmatrix (<n>, <x>)
     Retorna uma matriz diagonal de tamanho <n> por <n> com os
     elementos da diagonal todos iguais a <x>.  `diagmatrix (<n>, 1)'
     retorna uma matriz identidade (o mesmo que `ident (<n>)').

     <n> deve avaliar para um inteiro, de outra forma `diagmatrix'
     reclama com uma mensagem de erro.

     <x> pode ser qualquer tipo de expresão, incluindo outra matriz.
     Se <x> é uma matriz, isso não é copiado; todos os elementos da
     diagonal referem-se à mesma instância, <x>.


 -- Variável: doallmxops
     Valor padrão: `true'

     Quando `doallmxops' é `true', todas as operações relacionadas a
     matrizes são realizadas.  Quando isso é `false' então a escolha de
     comutadores individuais `dot' governam quais operações são
     executadas.


 -- Variável: domxexpt
     Valor padrão: `true'

     Quando `domxexpt' é `true', uma matriz exponencial, `exp (<M>)'
     onde <M> é a matriz, é interpretada como uma matriz com elementos
     `[i,j' iguais a `exp (m[i,j])'.  de outra forma `exp (<M>)' avalia
     para `exp (<ev(M)>'.

     `domxexpt' afeta todas as expresões da forma `<base>^<expoente>'
     onde <base> é uma expresão assumida escalar ou constante, e
     <expoente> é uma lista ou matriz.

     Exemplo:

          (%i1) m: matrix ([1, %i], [a+b, %pi]);
                                   [   1    %i  ]
          (%o1)                    [            ]
                                   [ b + a  %pi ]
          (%i2) domxexpt: false$
          (%i3) (1 - c)^m;
                                       [   1    %i  ]
                                       [            ]
                                       [ b + a  %pi ]
          (%o3)                 (1 - c)
          (%i4) domxexpt: true$
          (%i5) (1 - c)^m;
                            [                      %i  ]
                            [    1 - c      (1 - c)    ]
          (%o5)             [                          ]
                            [        b + a         %pi ]
                            [ (1 - c)       (1 - c)    ]


 -- Variável de opção: domxmxops
     Valor padrão: `true'

     Quando `domxmxops' é `true', todas as operações matriz-matriz ou
     matriz-lista são realizadas (mas não operações escalar-matriz); se
     esse comutador é `false' tais operações não são.


 -- Variável de opção: domxnctimes
     Valor padrão: `false'

     Quando `domxnctimes' é `true', produtos não comutativos de
     matrizes são realizados.


 -- Variável de opção: dontfactor
     Valor padrão: `[]'

     `dontfactor' pode ser escolhido para uma lista de variáveis em
     relação a qual fatoração não é para ocorrer.  (A lista é
     inicialmente vazia.)  Fatoração também não pegará lugares com
     relação a quaisquer variáveis que são menos importantes, conforme
     a hierarquía de variável assumida para a forma expresão racional
     canônica (CRE), que essas na lista `dontfactor'.


 -- Variável de opção: doscmxops
     Valor padrão: `false'

     Quando `doscmxops' é `true', operações escalar-matriz são
     realizadas.


 -- Variável de opção: doscmxplus
     Valor padrão: `false'

     Quando `doscmxplus' é `true', operações escalar-matriz retornam
     uma matriz resultado.  Esse comutador não é subsomado sob
     `doallmxops'.


 -- Variável de opção: dot0nscsimp
     Valor padrão: `true'

     Quando `dot0nscsimp' é `true', um produto não comutativo de zero e
     um termo não escalar é simplificado para um produto comutativo.


 -- Variável de opção: dot0simp
     Valor padrão: `true'

     Quando `dot0simp' é `true', um produto não comutativo de zero e um
     termo escalar é simplificado para um produto não comutativo.


 -- Variável de opção: dot1simp
     Valor padrão: `true'

     Quando `dot1simp' é `true', um produto não comutativo de um e
     outro termo é simplificado para um produto comutativo.


 -- Variável de opção: dotassoc
     Valor padrão: `true'

     Quando `dotassoc' é `true', uma expresão `(A.B).C' simplifica para
     `A.(B.C)'.


 -- Variável de opção: dotconstrules
     Valor padrão: `true'

     Quando `dotconstrules' é `true', um produto não comutativo de uma
     constante e outro termo é simplificado para um produto comutativo.
     Ativando esse sinalizador efetivamente ativamos `dot0simp',
     `dot0nscsimp', e `dot1simp' também.


 -- Variável de opção: dotdistrib
     Valor padrão: `false'

     Quando `dotdistrib' é `true', uma expresão `A.(B + C)' simplifica
     para `A.B + A.C'.


 -- Variável de opção: dotexptsimp
     Valor padrão: `true'

     Quando `dotexptsimp' é `true', uma expresão `A.A' simplifica para
     `A^^2'.


 -- Variável de opção: dotident
     Valor padrão: 1

     `dotident' é o valor retornado por `X^^0'.


 -- Variável de opção: dotscrules
     Valor padrão: `false'

     Quando `dotscrules' é `true', uma expresão `A.SC' ou `SC.A'
     simplifica para `SC*A' e `A.(SC*B)' simplifica para `SC*(A.B)'.


 -- Função: echelon (<M>)
     Retorna a forma escalonada da matriz <M>, como produzido através
     da eliminação de Gauss.  A forma escalonada é calculada de <M> por
     operações elementares de linha tais que o primeiro elemento não
     zero em cada linha na matriz resultante seja o número um e os
     elementos da coluna abaixo do primeiro número um em cada linha
     sejam todos zero.

     `triangularize' também realiza eliminação de Gaussian, mas não
     normaliza o elemento líder não nulo em cada linha.

     `lu_factor' e `cholesky' são outras funções que retornam matrizes
     triangularizadas.

          (%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                                 [  3   7  aa  bb ]
                                 [                ]
          (%o1)                  [ - 1  8  5   2  ]
                                 [                ]
                                 [  9   2  11  4  ]
          (%i2) echelon (M);
                            [ 1  - 8  - 5      - 2     ]
                            [                          ]
                            [         28       11      ]
                            [ 0   1   --       --      ]
          (%o2)             [         37       37      ]
                            [                          ]
                            [              37 bb - 119 ]
                            [ 0   0    1   ----------- ]
                            [              37 aa - 313 ]


 -- Função: eigenvalues (<M>)
 -- Função: eivals (<M>)
     Retorna uma lista de duas listas contendo os autovalores da matriz
     <M>.  A primeira sublista do valor de retorno é a lista de
     autovalores da matriz, e a segunda sublista é a lista de
     multiplicidade dos autovalores na ordem correspondente.

     `eivals' é um sinônimo de `eigenvalues'.

     `eigenvalues' chama a função `solve' para achar as raízes do
     polinômio característico da matriz.  Algumas vezes `solve' pode
     não estar habilitado a achar as raízes do polinômio; nesse caso
     algumas outras funções nesse pacote (except `innerproduct',
     `unitvector', `columnvector' e `gramschmidt') não irão trabalhar.

     Em alguns casos os autovalores achados por `solve' podem ser
     expresões complicadas.  (Isso pode acontecer quando `solve'
     retorna uma expresão real não trivial para um autovalor que é
     sabidamente real.)  Isso pode ser possível para simplificar os
     autovalores usando algumas outras funções.

     O pacote `eigen.mac' é chamado automaticamente quando
     `eigenvalues' ou `eigenvectors' é referenciado.  Se `eigen.mac'
     não tiver sido ainda chamado, `load ("eigen")' chama-o.  Após ser
     chamado, todas as funções e variáveis no pacote estarão
     disponíveis.


 -- Função: eigenvectors (<M>)
 -- Função: eivects (<M>)
     pegam uma matriz <M> como seu argumento e retorna uma lista de
     listas cuja primeira sublista é a saída de `eigenvalues' e as
     outras sublistas são os autovetores da matriz correspondente para
     esses autovalores respectivamente.

     `eivects' é um sinônimo para `eigenvectors'.

     O pacote `eigen.mac' é chamado automaticamente quando
     `eigenvalues' ou `eigenvectors' é referenciado.  Se `eigen.mac'
     não tiver sido ainda chamado, `load ("eigen")' chama-o.  Após ser
     chamado, todas as funções e variáveis no pacote estarão
     disponíveis.

     Os sinalizadores que afetam essa função são:

     `nondiagonalizable' é escolhido para `true' ou `false' dependendo
     de se a matriz é não diagonalizável ou diagonalizável após o
     retorno de `eigenvectors'.

     `hermitianmatrix' quando `true', faz com que os autovetores
     degenerados da matriz Hermitiana sejam ortogonalizados usando o
     algorítmo de Gram-Schmidt.

     `knowneigvals' quando `true' faz com que o pacote `eigen' assumir
     que os autovalores da matriz são conhecidos para o usuário e
     armazenados sob o nome global `listeigvals'.  `listeigvals' poderá
     ser escolhido para uma lista similar à saída de `eigenvalues'.

     A função `algsys' é usada aqui para resolver em relação aos
     autovetores.  Algumas vezes se os autovalores estão ausêntes,
     `algsys' pode não estar habilitado a achar uma solução.  Em alguns
     casos, isso pode ser possível para simplificar os autovalores por
     primeiro achando e então usando o comando `eigenvalues' e então
     usando outras funções para reduzir os autovalores a alguma coisa
     mais simples.  Continuando a simplificação, `eigenvectors' pode
     ser chamada novamente com o sinalizador `knowneigvals' escolhido
     para `true'.


 -- Função: ematrix (<m>, <n>, <x>, <i>, <j>)
     Retorna uma matriz <m> por <n>, todos os elementos da qual são
     zero exceto para o elemento `[<i>, <j>]' que é <x>.


 -- Função: entermatrix (<m>, <n>)
     Retorna uma matriz <m> por <n>, lendo os elementos interativamente.

     Se <n> é igual a <m>, Maxima pergunta pelo tipo de matriz
     (diagonal, simétrica, antisimétrica, ou genérica) e por cada
     elemento.  Cada resposta é terminada por um ponto e vírgula `;' ou
     sinal de dólar `$'.

     Se <n> não é igual a <m>, Maxima pergunta por cada elemento.

     Os elementos podem ser quaisquer expressões, que são avaliadas.
     `entermatrix' avalia seus argumentos.

          (%i1) n: 3$
          (%i2) m: entermatrix (n, n)$

          Is the matriz  1.  Diagonal  2.  Symmetric  3.  Antisymmetric  4.  General
          Answer 1, 2, 3 or 4 :
          1$
          Row 1 Column 1:
          (a+b)^n$
          Row 2 Column 2:
          (a+b)^(n+1)$
          Row 3 Column 3:
          (a+b)^(n+2)$

          Matriz entered.
          (%i3) m;
                          [        3                     ]
                          [ (b + a)      0         0     ]
                          [                              ]
          (%o3)           [                  4           ]
                          [    0      (b + a)      0     ]
                          [                              ]
                          [                            5 ]
                          [    0         0      (b + a)  ]


 -- Função: genmatrix (<a>, <i_2>, <j_2>, <i_1>, <j_1>)
 -- Função: genmatrix (<a>, <i_2>, <j_2>, <i_1>)
 -- Função: genmatrix (<a>, <i_2>, <j_2>)
     Retorna uma matriz gerada de <a>, pegando o elemento
     `<a>[<i_1>,<j_1>]' como o elemento do canto superior esquerdo e
     `<a>[<i_2>,<j_2>]' como o elemento do canto inferior direto da
     matriz.  Aqui <a> é um array declarado (criado através de `array'
     mas não por meio de `make_array') ou um array não declarado, ou
     uma função array, ou uma expressão lambda de dois argumentos.
     (Uma funçãO array é criado como outras funções com `:=' ou
     `define', mas os argumentos são colocados entre colchêtes em lugar
     de parêntesis.)

     Se <j_1> é omitido, isso é assumido ser igual a <i_1>.  Se ambos
     <j_1> e <i_1> são omitidos, ambos são assumidos iguais a 1.

     Se um elemento selecionado `i,j' de um array for indefinido, a
     matriz conterá um elemento simbólico `<a>[i,j]'.

     Exemplos:

          (%i1) h [i, j] := 1 / (i + j - 1);
                                              1
          (%o1)                  h     := ---------
                                  i, j    i + j - 1
          (%i2) genmatrix (h, 3, 3);
                                     [    1  1 ]
                                     [ 1  -  - ]
                                     [    2  3 ]
                                     [         ]
                                     [ 1  1  1 ]
          (%o2)                      [ -  -  - ]
                                     [ 2  3  4 ]
                                     [         ]
                                     [ 1  1  1 ]
                                     [ -  -  - ]
                                     [ 3  4  5 ]
          (%i3) array (a, fixnum, 2, 2);
          (%o3)                           a
          (%i4) a [1, 1] : %e;
          (%o4)                          %e
          (%i5) a [2, 2] : %pi;
          (%o5)                          %pi
          (%i6) genmatrix (a, 2, 2);
                                     [ %e   0  ]
          (%o6)                      [         ]
                                     [ 0   %pi ]
          (%i7) genmatrix (lambda ([i, j], j - i), 3, 3);
                                   [  0    1   2 ]
                                   [             ]
          (%o7)                    [ - 1   0   1 ]
                                   [             ]
                                   [ - 2  - 1  0 ]
          (%i8) genmatrix (B, 2, 2);
                                  [ B      B     ]
                                  [  1, 1   1, 2 ]
          (%o8)                   [              ]
                                  [ B      B     ]
                                  [  2, 1   2, 2 ]


 -- Função: gramschmidt (<x>)
 -- Função: gschmit (<x>)
     Realiza o algorítmo de ortonalização de Gram-Schmidt sobre <x>,
     seja ela uma matriz ou uma lista de listas.  <x> não é modificado
     por `gramschmidt'.

     Se <x> é uma matriz, o algorítmo é aplicado para as linhas de <x>.
     Se <x> é uma lista de listas, o algorítmo é aplicado às sublistas,
     que devem ter igual números de elementos.  Nos dois casos, o valor
     de retorno é uma lista de listas, as sublistas das listas são
     ortogonais e gera o mesmo spaço que <x>.  Se a dimensão do
     conjunto gerador de <x> é menor que o número de linhas ou
     sublistas, algumas sublistas do valor de retorno são zero.

     `factor' é chamada a cada estágio do algorítmo para simplificar
     resultados intermediários.  Como uma conseqüência, o valor de
     retorno pode conter inteiros fatorados.

     `gschmit' (nota ortográfica) é um sinônimo para `gramschmidt'.

     `load ("eigen")' chama essa função.

     Exemplo:

          (%i1) load ("eigen")$
          Warning - you are redefining the Macsyma function autovalores
          Warning - you are redefining the Macsyma function autovetores
          (%i2) x: matrix ([1, 2, 3], [9, 18, 30], [12, 48, 60]);
                                   [ 1   2   3  ]
                                   [            ]
          (%o2)                    [ 9   18  30 ]
                                   [            ]
                                   [ 12  48  60 ]
          (%i3) y: gramschmidt (x);
                                 2      2            4     3
                                3      3   3 5      2  3  2  3
          (%o3)  [[1, 2, 3], [- ---, - --, ---], [- ----, ----, 0]]
                                2 7    7   2 7       5     5
          (%i4) i: innerproduct$
          (%i5) [i (y[1], y[2]), i (y[2], y[3]), i (y[3], y[1])];
          (%o5)                       [0, 0, 0]


 -- Função: ident (<n>)
     Retorna uma matriz identidade <n> por <n>.


 -- Função: innerproduct (<x>, <y>)
 -- Função: inprod (<x>, <y>)
     Retorna o produto interno (também chamado produto escalar ou
     produto do ponto) de <x> e <y>, que são listas de igual
     comprimento, ou ambas matrizes 1-coluna ou 1-linha de igual
     comprimento.  O valor de retorno é `conjugate (x) . y', onde `.' é
     o operador de multiplicação não comutativa.

     `load ("eigen")' chama essa função.

     `inprod' é um sinônimo para `innerproduct'.


 -- Função: invert (<M>)
     Retorna a inversa da matriz <M>.  A inversa é calculada pelo
     método adjunto.

     Isso permite a um usuário calcular a inversa de uma matriz com
     entradas bfloat ou polinômios com coeficientes em ponto flutuante
     sem converter para a forma CRE.

     Cofatores são calculados pela função  `determinant', então se
     `ratmx' é `false' a inversa é calculada sem mudar a
     representação dos elementos.

     A implementação corrente é ineficiente para matrizes de alta ordem.

     Quando `detout' é `true', o determinante é fatorado fora da
     inversa.

     Os elementos da inversa não são automaticamente expandidos.  Se
     <M> tem elementos polinomiais, melhor aparência de saída pode ser
     gerada por `expand (invert (m)), detout'.  Se isso é desejável
     para ela divisão até pelo determinante pode ser excelente por
     `xthru (%)' ou alternativamente na unha por

          expe (adjoint (m)) / expand (determinant (m))
          invert (m) := adjoint (m) / determinant (m)

     Veja `^^' (expoente não comutativo) para outro método de inverter
     uma matriz.


 -- Variável de opção: lmxchar
     Valor padrão: `['

     `lmxchar' é o caractere mostrado como o delimitador esquerdo de
     uma matriz.  Veja também `rmxchar'.

     Exemplo:

          (%i1) lmxchar: "|"$
          (%i2) matrix ([a, b, c], [d, e, f], [g, h, i]);
                                     | a  b  c ]
                                     |         ]
          (%o2)                      | d  e  f ]
                                     |         ]
                                     | g  h  i ]


 -- Função: matrix (<row_1>, ..., <row_n>)
     Retorna uma matriz retangular que tem as linhas <row_1>, ...,
     <row_n>.  Cada linha é uma lista de expressões.  Todas as linhas
     devem ter o mesmo comprimento.

     As operações `+' (adição), `-' (subtração), `*' (multiplicação), e
     `/' (divisão), são realizadas elemento por elemento quando os
     operandos são duas matrizes, um escalar e uma matriz, ou uma
     matriz e um escalar.  A operação `^' (exponenciação,
     equivalentemente `**') é realizada elemento por elemento se os
     operandos são um escalar e uma matriz ou uma matriz e um escalar,
     mas não se os operandos forem duas matrizes.  Todos as operações
     são normalmente realizadas de forma completa, incluindo `.'
     (multiplicação não comutativa).

     Multiplicação de matrizes é representada pelo operador de
     multiplicação não comutativa `.'.  O correspondente operador de
     exponenciação não comutativa é `^^'.  Para uma matriz `<A>',
     `<A>.<A> = <A>^^2' e `<A>^^-1' é a inversa de <A>, se existir.

     Existem comutadores para controlar a simplificação de expresões
     envolvendo operações escalar e matriz-lista.  São eles
     `doallmxops', `domxexpt' `domxmxops', `doscmxops', e `doscmxplus'.

     Existem opções adicionais que são relacionadas a matrizes.  São
     elas: `lmxchar', `rmxchar', `ratmx', `listarith', `detout',
     `scalarmatrix', e `sparse'.

     Existe um número de funções que pegam matrizes como argumentos ou
     devolvem matrizes como valor de retorno.  Veja `eigenvalues',
     `eigenvectors', `determinant', `charpoly', `genmatrix', `addcol',
     `addrow', `copymatrix', `transpose', `echelon', e `rank'.

     Exemplos:

        * Construção de matrizes de listas.

          (%i1) x: matrix ([17, 3], [-8, 11]);
                                     [ 17   3  ]
          (%o1)                      [         ]
                                     [ - 8  11 ]
          (%i2) y: matrix ([%pi, %e], [a, b]);
                                     [ %pi  %e ]
          (%o2)                      [         ]
                                     [  a   b  ]

        * Adição, elemento por elemento.

          (%i3) x + y;
                                [ %pi + 17  %e + 3 ]
          (%o3)                 [                  ]
                                [  a - 8    b + 11 ]

        * Subtração, elemento por elemento.

          (%i4) x - y;
                                [ 17 - %pi  3 - %e ]
          (%o4)                 [                  ]
                                [ - a - 8   11 - b ]

        * Multiplicação, elemento por elemento.

          (%i5) x * y;
                                  [ 17 %pi  3 %e ]
          (%o5)                   [              ]
                                  [ - 8 a   11 b ]

        * Divisão, elemento por elemento.

          (%i6) x / y;
                                  [ 17       - 1 ]
                                  [ ---  3 %e    ]
                                  [ %pi          ]
          (%o6)                   [              ]
                                  [   8    11    ]
                                  [ - -    --    ]
                                  [   a    b     ]

        * Matriz para um expoente escalar, elemento por elemento.

          (%i7) x ^ 3;
                                   [ 4913    27  ]
          (%o7)                    [             ]
                                   [ - 512  1331 ]

        * Base escalar para um expoente matriz, elemento por elemento.

          (%i8) exp(y);
                                   [   %pi    %e ]
                                   [ %e     %e   ]
          (%o8)                    [             ]
                                   [    a     b  ]
                                   [  %e    %e   ]

        * Base matriz para um expoente matriz.  Essa não é realizada
          elemento por elemento.

          (%i9) x ^ y;
                                          [ %pi  %e ]
                                          [         ]
                                          [  a   b  ]
                               [ 17   3  ]
          (%o9)                [         ]
                               [ - 8  11 ]

        * Multiplicação não comutativa de matrizes.

          (%i10) x . y;
                            [ 3 a + 17 %pi  3 b + 17 %e ]
          (%o10)            [                           ]
                            [ 11 a - 8 %pi  11 b - 8 %e ]
          (%i11) y . x;
                          [ 17 %pi - 8 %e  3 %pi + 11 %e ]
          (%o11)          [                              ]
                          [  17 a - 8 b     11 b + 3 a   ]

        * Exponenciação não comutativa de matrizes.  Uma base escalar
          <b> para uma potência matriz <M> é realizada elemento por
          elemento e então `b^^m' é o mesmo que `b^m'.

          (%i12) x ^^ 3;
                                  [  3833   1719 ]
          (%o12)                  [              ]
                                  [ - 4584  395  ]
          (%i13) %e ^^ y;
                                   [   %pi    %e ]
                                   [ %e     %e   ]
          (%o13)                   [             ]
                                   [    a     b  ]
                                   [  %e    %e   ]

        * A matriz elevada a um expoente -1 com exponenciação não
          comutativa é a matriz inversa, se existir.

          (%i14) x ^^ -1;
                                   [ 11      3  ]
                                   [ ---  - --- ]
                                   [ 211    211 ]
          (%o14)                   [            ]
                                   [  8    17   ]
                                   [ ---   ---  ]
                                   [ 211   211  ]
          (%i15) x . (x ^^ -1);
                                      [ 1  0 ]
          (%o15)                      [      ]
                                      [ 0  1 ]


 -- Função: matrixmap (<f>, <M>)
     Retorna uma matriz com elemento `i,j' igual a `<f>(<M>[i,j])'.

     Veja também `map', `fullmap', `fullmapl', e `apply'.


 -- Função: matrixp (<expr>)
     Retorna `true' se <expr> é uma matriz, de outra forma retorna
     `false'.


 -- Variável de opção: matrix_element_add
     Valor padrão: `+'

     `matrix_element_add' é a operação invocada em lugar da adição em
     uma multiplicação de matrizes.  A `matrix_element_add' pode ser
     atribuído qualquer operador n-ário (que é, uma função que manuseia
     qualquer número de argumentos).  Os valores atribuídos podem ser o
     nome de um operador entre aspas duplas, o nome da função, ou uma
     expressão lambda.

     Veja também `matrix_element_mult' e `matrix_element_transpose'.

     Exemplo:

          (%i1) matrix_element_add: "*"$
          (%i2) matrix_element_mult: "^"$
          (%i3) aa: matrix ([a, b, c], [d, e, f]);
                                     [ a  b  c ]
          (%o3)                      [         ]
                                     [ d  e  f ]
          (%i4) bb: matrix ([u, v, w], [x, y, z]);
                                     [ u  v  w ]
          (%o4)                      [         ]
                                     [ x  y  z ]
          (%i5) aa . transpose (bb);
                               [  u  v  w   x  y  z ]
                               [ a  b  c   a  b  c  ]
          (%o5)                [                    ]
                               [  u  v  w   x  y  z ]
                               [ d  e  f   d  e  f  ]


 -- Variável de opção: matrix_element_mult
     Valor padrão: `*'

     `matrix_element_mult' é a operação invocada em lugar da
     multiplicação em uma multiplicação de matrizes.  A
     `matrix_element_mult' pode ser atribuído qualquer operador binário.
     O valor atribuído pode ser o nome de um operador entre aspas
     duplas, o nome de uma função, ou uma expressão lambda.

     O operador do ponto `.' é uma escolha útil em alguns contextos.

     Veja também `matrix_element_add' e `matrix_element_transpose'.

     Exemplo:

          (%i1) matrix_element_add: lambda ([[x]], sqrt (apply ("+", x)))$
          (%i2) matrix_element_mult: lambda ([x, y], (x - y)^2)$
          (%i3) [a, b, c] . [x, y, z];
                                    2          2          2
          (%o3)         sqrt((c - z)  + (b - y)  + (a - x) )
          (%i4) aa: matrix ([a, b, c], [d, e, f]);
                                     [ a  b  c ]
          (%o4)                      [         ]
                                     [ d  e  f ]
          (%i5) bb: matrix ([u, v, w], [x, y, z]);
                                     [ u  v  w ]
          (%o5)                      [         ]
                                     [ x  y  z ]
          (%i6) aa . transpose (bb);
                         [             2          2          2  ]
                         [ sqrt((c - w)  + (b - v)  + (a - u) ) ]
          (%o6)  Col 1 = [                                      ]
                         [             2          2          2  ]
                         [ sqrt((f - w)  + (e - v)  + (d - u) ) ]

                                   [             2          2          2  ]
                                   [ sqrt((c - z)  + (b - y)  + (a - x) ) ]
                           Col 2 = [                                      ]
                                   [             2          2          2  ]
                                   [ sqrt((f - z)  + (e - y)  + (d - x) ) ]


 -- Variável de opção: matrix_element_transpose
     Valor padrão: `false'

     `matrix_element_transpose' é a operação aplicada a cada elemento
     de uma matriz quando for uma transposta.  A `matrix_element_mult'
     pode ser atribuído qualquer operador unário.  O valor atribuído
     pode ser  nome de um operador entre aspas duplas, o nome de uma
     função, ou uma expressão lambda.

     Quando `matrix_element_transpose' for igual a `transpose', a
     função  `transpose' é aplicada a todo elemento.  Quando
     `matrix_element_transpose' for igual a `nonscalars', a função
     `transpose' é aplicada a todo elemento não escalar.  Se algum
     elemento é um átomo, a opção `nonscalars' aplica `transpose'
     somente se o átomo for declarado não escalar, enquanto a opção
     `transpose' sempre aplica `transpose'.

     O valor padrão, `false', significa nenhuma operação é aplicada.

     Veja também `matrix_element_add' e `matrix_element_mult'.

     Exemplos:

          (%i1) declare (a, nonscalar)$
          (%i2) transpose ([a, b]);
                                  [ transpose(a) ]
          (%o2)                   [              ]
                                  [      b       ]
          (%i3) matrix_element_transpose: nonscalars$
          (%i4) transpose ([a, b]);
                                  [ transpose(a) ]
          (%o4)                   [              ]
                                  [      b       ]
          (%i5) matrix_element_transpose: transpose$
          (%i6) transpose ([a, b]);
                                  [ transpose(a) ]
          (%o6)                   [              ]
                                  [ transpose(b) ]
          (%i7) matrix_element_transpose: lambda ([x], realpart(x) - %i*imagpart(x))$
          (%i8) m: matrix ([1 + 5*%i, 3 - 2*%i], [7*%i, 11]);
                               [ 5 %i + 1  3 - 2 %i ]
          (%o8)                [                    ]
                               [   7 %i       11    ]
          (%i9) transpose (m);
                                [ 1 - 5 %i  - 7 %i ]
          (%o9)                 [                  ]
                                [ 2 %i + 3    11   ]


 -- Função: mattrace (<M>)
     Retorna o traço (que é, a soma dos elementos sobre a diagonal
     principal) da matriz quadrada <M>.

     `mattrace' é chamada por `ncharpoly', uma alternativa para
     `charpoly' do Maxima.

     `load ("nchrpl")' chama essa função.


 -- Função: minor (<M>, <i>, <j>)
     Retorna o <i>, <j> menor do elemento localizado na linha <i>
     coluna <j> da matriz <M>.  Que é <M> com linha <i> e coluna <j>
     ambas removidas.


 -- Função: ncexpt (<a>, <b>)
     Se uma expressão exponencial não comutativa é muito alta para ser
     mostrada como `<a>^^<b>' aparecerá como `ncexpt (<a>,<b>)'.

     `ncexpt' não é o nome de uma função ou operador; o nome somente
     aparece em saídas, e não é reconhecido em entradas.


 -- Função: ncharpoly (<M>, <x>)
     Retorna o polinômio característico da matriz <M> com relação a
     <x>.  Essa é uma alternativa para `charpoly' do Maxima.

     `ncharpoly' trabalha pelo cálculo dos traços das potências na dada
     matriz, que são sabidos serem iguais a somas de potências das
     raízes do polinômio característico.  Para essas quantidade a
     função simétrica das raízes pode ser calculada, que nada mais são
     que os coeficientes do polinômio característico.  `charpoly'
     trabalha formatando o determinante de `<x> * ident [n] - a'.
     Dessa forma `ncharpoly' é vencedor, por exemplo, no caso de largas
     e densas matrizes preencidas com inteiros, desde que isso evite
     inteiramente a aritmética polinomial.

     `load ("nchrpl")' loads this file.


 -- Função: newdet (<M>, <n>)
     Calcula o determinante de uma matriz ou array <M> pelo algorítmo
     da árvore menor de Johnson-Gentleman.  O argumento <n> é a ordem;
     isso é opcional se <M> for uma matriz.


 -- Declaração: nonscalar
     Faz átomos ser comportarem da mesma forma que uma lista ou matriz
     em relação ao operador do ponto.


 -- Função: nonscalarp (<expr>)
     Retorna `true' se <expr> é um não escalar, i.e., isso contém
     átomos declarados como não escalares, listas, ou matrizes.


 -- Função: permanent (<M>, <n>)
     Calcula o permanente da matriz <M>.  Um permanente é como um
     determinante mas sem mudança de sinal.


 -- Função: rank (<M>)
     Calcula o posto da matriz <M>.  Que é, a ordem do mais largo
     determinante não singular de <M>.

     <rank> pode retornar uma resposta ruim se não puder determinar que
     um elemento da matriz que é equivalente a zero é realmente isso.


 -- Variável de opção: ratmx
     Valor padrão: `false'

     Quando `ratmx' é `false', adição, subtração, e multiplicação para
     determinantes e matrizes são executados na representação dos
     elementos da matriz e fazem com que o resultado da inversão de
     matrizes seja esquerdo na representação geral.

     Quando `ratmx' é `true', as 4 operações mencionadas acima são
     executadas na forma CRE e o resultado da matriz inversa é dado na
     forma CRE.  Note isso pode fazer com que os elementos sejam
     expandidos (dependendo da escolha de `ratfac') o que pode não ser
     desejado sempre.


 -- Função: row (<M>, <i>)
     retorna a <i>'ésima linha da matriz <M>.  O valor de retorno é uma
     matriz.


 -- Variável de opção: scalarmatrixp
     Valor padrão: `true'

     Quando `scalarmatrixp' é `true', então sempre que uma matriz 1 x 1
     é produzida como um resultado de cálculos o produto do ponto de
     matrizes é simplificado para um escalar, a saber o elemento
     solitário da matriz.

     Quando `scalarmatrixp' é `all', então todas as matrizes 1 x 1
     serão simplificadas para escalares.

     Quando `scalarmatrixp' é `false', matrizes 1 x 1 não são
     simplificadas para escalares.


 -- Função: scalefactors (<coordinatetransform>)
     Aqui coordinatetransform avalia para a forma [[expresão1,
     expresão2, ...], indeterminação1, indeterminação2, ...], onde
     indeterminação1, indeterminação2, etc.  são as variáveis de
     coordenadas curvilíneas e onde a escolha de componentes
     cartesianas retangulares é dada em termos das coordenadas
     curvilíneas por [expresão1, expresão2, ...].  `coordinates' é
     escolhida para o vetor [indeterminação1, indeterminação2,...], e
     `dimension' é escolhida para o comprimento desse vetor.  SF[1],
     SF[2], ..., SF[DIMENSION] são escohidos para fatores de escala de
     coordenada, e `sfprod' é escohido para o produto desse fatores de
     escala.  Inicialmente, `coordinates' é [X, Y, Z], `dimension' é 3,
     e SF[1]=SF[2]=SF[3]=SFPROD=1, correspondendo a coordenadas
     Cartesianas retangulares 3-dimensional.  Para expandir uma
     expresão dentro de componentes físicos no sistema de coordenadas
     corrente , existe uma função com uso da forma


 -- Função: setelmx (<x>, <i>, <j>, <M>)
     Atribue <x> para o (<i>, <j>)'ésimo elemento da matriz <M>, e
     retorna a matriz alterada.

     `<M> [<i>, <j>]: <x>' tem o mesmo efeito, mas retorna <x> em lugar
     de <M>.


 -- Função: similaritytransform (<M>)
 -- Função: simtran (<M>)
     `similaritytransform' calcula uma transformação homotética da
     matriz `M'.  Isso retorna uma lista que é a saída do comando
     `uniteigenvectors'.  Em adição se o sinalizador `nondiagonalizable'
     é `false' duas matrizes globais `leftmatrix' e `rightmatrix' são
     calculadas.  Essas matrizes possuem a propriedade de `leftmatrix .
     <M> . rightmatrix' é uma matriz diagonal com os autovalores de <M>
     sobre a diagonal.  Se `nondiagonalizable' é `true' as matrizes
     esquerda e direita não são computadas.

     Se o sinalizador `hermitianmatrix' é `true' então `leftmatrix' é o
     conjugado complexo da transposta de `rightmatrix'.  De outra forma
     `leftmatrix' é a inversa de `rightmatrix'.

     `rightmatrix' é a matriz cujas colunas são os autovetores
     unitários de <M>.  Os outros sinalizadores (veja `eigenvalues' e
     `eigenvectors') possuem o mesmo efeito desde que
     `similaritytransform' chama as outras funções no pacote com o
     objetivo de estar habilitado para a forma `rightmatrix'.

     `load ("eigen")' chama essa função.

     `simtran' é um sinônimo para `similaritytransform'.


 -- Variável de opção: sparse
     Valor padrão: `false'

     Quando `sparse' é `true', e se `ratmx' é `true', então
     `determinant' usará rotinas especiais para calcular determinantes
     esparsos.


 -- Função: submatrix (<i_1>, ..., <i_m>, <M>, <j_1>, ..., <j_n>)
 -- Função: submatrix (<i_1>, ..., <i_m>, <M>)
 -- Função: submatrix (<M>, <j_1>, ..., <j_n>)
     Retorna uma nova matriz formada pela matrix <M> com linhas <i_1>,
     ..., <i_m> excluídas, e colunas <j_1>, ..., <j_n> excluídas.


 -- Função: transpose (<M>)
     Retorna a transposta de <M>.

     Se <M> é uma matriz, o valor de retorno é outra matriz <N> tal que
     `N[i,j] = M[j,i]'.

     Se <M> for uma lista, o valor de retorno é uma matrix <N> de
     `length (m)' linhas e 1 coluna, tal que `N[i,1] = M[i]'.

     De outra forma <M> é um símbolo, e o valor de retorno é uma
     expressão substantiva `'transpose (<M>)'.


 -- Função: triangularize (<M>)
     Retorna a maior forma triangular da matriz `M', como produzido
     através da eliminação de Gauss.  O valor de retorno é o mesmo que
     `echelon', exceto que o o coeficiente lider não nulo em cada linha
     não é normalizado para 1.

     `lu_factor' e `cholesky' são outras funções que retornam matrizes
     triangularizadas.

          (%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                                 [  3   7  aa  bb ]
                                 [                ]
          (%o1)                  [ - 1  8  5   2  ]
                                 [                ]
                                 [  9   2  11  4  ]
          (%i2) triangularize (M);
                       [ - 1   8         5            2      ]
                       [                                     ]
          (%o2)        [  0   - 74     - 56         - 22     ]
                       [                                     ]
                       [  0    0    626 - 74 aa  238 - 74 bb ]


 -- Função: uniteigenvectors (<M>)
 -- Função: ueivects (<M>)
     Calcula autovetores unitários da matriz <M>.  O valor de retorno é
     uma lista de listas, a primeiro sublista é a saída do comando
     `eigenvalues', e as outras sublistas são os autovetores unitários
     da matriz correspondente a esses autovalores respectivamente.

     Os sinalizadores mencionados na descrição do comando
     `eigenvectors' possuem o mesmo efeito aqui também.

     Quando `knowneigvects' é `true', o pacote `eigen' assume que os
     autovetores da matriz são conhecidos para o usuário são
     armazenados sob o nome global `listeigvects'.  `listeigvects' pode
     ser ecolhido para uma lista similar à saída do comando
     `eigenvectors'.

     Se `knowneigvects' é escolhido para `true' e a lista de
     autovetores é dada a escolha do sinalizador `nondiagonalizable'
     pode não estar correta.  Se esse é o caso por favor ecolha isso
     para o valor correto.  O autor assume que o usuário sabe o que
     está fazendo e que não tentará diagonalizar uma matriz cujos
     autovetores não geram o mesmo espaço vetorial de dimensão
     apropriada.

     `load ("eigen")' chama essa função.

     `ueivects' é um sinônimo para `uniteigenvectors'.


 -- Função: unitvector (<x>)
 -- Função: uvect (<x>)
     Retorna <x>/norm(<x>); isso é um vetor unitário na mesma
     direção que <x>.

     `load ("eigen")' chama essa função.

     `uvect' é um sinônimo para `unitvector'.


 -- Função: vectorsimp (<expr>)
     Aplica simplificações e expansões conforme os seguintes
     sinalizadores globais:

     `expandall', `expanddot', `expanddotplus', `expandcross',
     `expandcrossplus', `expandcrosscross', `expandgrad',
     `expandgradplus', `expandgradprod', `expanddiv', `expanddivplus',
     `expanddivprod', `expandcurl', `expandcurlplus', `expandcurlcurl',
     `expandlaplacian', `expandlaplacianplus', e `expandlaplacianprod'.

     Todos esses sinalizadores possuem valor padrão `false'.  O sufixo
     `plus' refere-se a utilização aditivamente ou distribuitivamente.
     O sufixo `prod' refere-se a expansão para um operando que é
     qualquer tipo de produto.

    `expandcrosscross'
          Simplifica p ~ (q ~ r) para (p . r)*q - (p . q)*r.

    `expandcurlcurl'
          Simplifica curl curl p para grad div p + div grad p.

    `expandlaplaciantodivgrad'
          Simplifica laplacian p para div grad p.

    `expandcross'
          Habilita `expandcrossplus' e `expandcrosscross'.

    `expandplus'
          Habilita `expanddotplus', `expandcrossplus', `expandgradplus',
          `expanddivplus', `expandcurlplus', e `expandlaplacianplus'.

    `expandprod'
          Habilita `expandgradprod', `expanddivprod', e
          `expandlaplacianprod'.

     Esses sinalizadores foram todos declarados `evflag'.


 -- Variável de opção: vect_cross
     Valor padrão: `false'

     Quando `vect_cross' é `true', isso permite DIFF(X~Y,T) trabalhar
     onde ~ é definido em SHARE;VECT (onde VECT_CROSS é escolhido para
     `true', de qualqeur modo.)


 -- Função: zeromatrix (<m>, <n>)
     Retorna um matriz <m> por <n>, com todos os elementos sendo zero.


 -- Símbolo especial: [
 -- Símbolo especial: ]
     `[' e `]' marcam o omeço e o fim, respectivamente, de uma lista.

     `[' e `]' também envolvem os subscritos de uma lista, array, array
     desordenado, ou função array.

     Exemplos:

          (%i1) x: [a, b, c];
          (%o1)                       [a, b, c]
          (%i2) x[3];
          (%o2)                           c
          (%i3) array (y, fixnum, 3);
          (%o3)                           y
          (%i4) y[2]: %pi;
          (%o4)                          %pi
          (%i5) y[2];
          (%o5)                          %pi
          (%i6) z['foo]: 'bar;
          (%o6)                          bar
          (%i7) z['foo];
          (%o7)                          bar
          (%i8) g[k] := 1/(k^2+1);
                                            1
          (%o8)                     g  := ------
                                     k     2
                                          k  + 1
          (%i9) g[10];
                                          1
          (%o9)                          ---
                                         101



File: maxima.info,  Node: Funções Afins,  Next: itensor,  Prev: Matrizes e Álgebra Linear,  Up: Top

26 Funções Afins
****************

* Menu:

* Funções e Variáveis Definidas para Funções Afins::


File: maxima.info,  Node: Funções e Variáveis Definidas para Funções Afins,  Prev: Funções Afins,  Up: Funções Afins

26.1 Funções e Variáveis Definidas para Funções Afins
=====================================================

 -- Função: fast_linsolve ([<expr_1>, ..., <expr_m>], [<x_1>, ...,
          <x_n>])
     Resolve equações lineares simultâneas <expr_1>, ..., <expr_m> para
     as variáveis <x_1>, ..., <x_n>.  Cada <expr_i> pode ser uma
     equação ou uma expressão geral; se dada como uma expressão geral,
     ela  tratada como uma equação na forma `<expr_i> = 0'.

     O valor de retorno é uma lista de equações da forma `[<x_1> =
     <a_1>, ..., <x_n> = <a_n>]' onde <a_1>, ..., <a_n> são todas
     livres de <x_1>, ..., <x_n>.

     `fast_linsolve' é mais rápido que `linsolve' para sistemas de
     equações que são esparsas.

     Para usar essa função escreva primeiramente `load(affine)'.

 -- Função: grobner_basis ([<expr_1>, ..., <expr_m>])
     Retorna uma base de Groebner para as equações <expr_1>, ...,
     <expr_m>.  A funçã `polysimp' pode então ser usada para
     simplificar outras funções relativas às equações.

          grobner_basis ([3*x^2+1, y*x])$

          polysimp (y^2*x + x^3*9 + 2) ==> -3*x + 2

     `polysimp(f)' produz 0 se e somente se <f> está no ideal gerado por
     <expr_1>, ..., <expr_m>, isto é, se e somente se <f> for uma
     combinação polinomial dos elementos de <expr_1>, ..., <expr_m>.

     Para usar essa função escreva primeiramente `load(affine)'.

 -- Função: set_up_dot_simplifications (<eqns>, <check_through_degree>)
 -- Função: set_up_dot_simplifications (<eqns>)
     As <eqns> são equações polinomiais em variáveis não comutativas.
     O valor de `current_variables'  é uma lista de variáveis usadas
     para calcular graus.  As equações devem ser homogêneas, com o
     objetivo de que o procedimento termine.

     Se você checou simplificações de envoltório em
     `dot_simplifications' acima do grau de <f>, então o seguinte é
     verdadeiro: `dotsimp (<f>)' retorna 0 se e somente se <f> está no
     ideal gerado pelas equações, i.e., se e somente se <f> for uma
     combinação polinomial dos elementos das equações.

     O grau é aquele retornado por `nc_degree'.   Isso por sua vez é
     nfluenciado pelos pesos das variáveis individuais.

     Para usar essa função escreva primeiramente `load(affine)'.

 -- Função: declare_weights (<x_1>, <w_1>, ..., <x_n>, <w_n>)
     Atribui pesos <w_1>, ..., <w_n> to <x_1>, ..., <x_n>,
     respectivamente.  Esses são pesos usados em cálculos `nc_degree'.

     Para usar essa função escreva primeiramente `load(affine)'.

 -- Função: nc_degree (<p>)
     Retorna o grau de um polinômio não comutativo <p>.  Veja
     `declare_weights'.

     Para usar essa função escreva primeiramente `load(affine)'.

 -- Função: dotsimp (<f>)
     Retorna 0 se e somente se <f> for um ideal gerado pelas equações,
     i.e., se e somente se <f> for uma combinação polinomial dos
     elementos das equações.

     Para usar essa função escreva primeiramente `load(affine)'.

 -- Função: fast_central_elements ([<x_1>, ..., <x_n>], <n>)
     Se `set_up_dot_simplifications' tiver sido feito previamente, ache
     o polinômio central nas variáveis <x_1>, ..., <x_n> no grau dado,
     <n>.

     Por exemplo:
          set_up_dot_simplifications ([y.x + x.y], 3);
          fast_central_elements ([x, y], 2);
          [y.y, x.x];

     Para usar essa função escreva primeiramente `load(affine)'.

 -- Função: check_overlaps (<n>, <add_to_simps>)
     Verifica as sobreposies através do grau <n>, tendo certeza que
     você tem regras de simplificaçõ suficiente em cada grau, para
     `dotsimp' trabalhar corretamente.  Esse processo pode ter sua
     velocidade aumentada se você souber antes de começar souber de
     qual dimensão do espaço de monômios é.  Se ele for de dimensão
     global finita, então `hilbert' pode ser usada.  Se você não
     conhece as dimensões monomiais, não especifique um `rank_function'.
     Um opcional terceiro argumento `reset', `false' diz para não se
     incomodar em perguntar sobre resetar coisas.

     Para usar essa função escreva primeiramente `load(affine)'.

 -- Função: mono ([<x_1>, ..., <x_n>], <n>)
     Retorna a lista de monômios independentes relativamente à
     simplificação atual do grau <n> nas variáveis <x_1>, ..., <x_n>.

     Para usar essa função escreva primeiramente `load(affine)'.

 -- Função: monomial_dimensions (<n>)
     Calcula a série de Hilbert através do grau <n> para a algebra
     corrente.

     Para usar essa função escreva primeiramente `load(affine)'.

 -- Função: extract_linear_equations ([<p_1>, ..., <p_n>], [<m_1>, ...,
          <m_n>])
     Faz uma lista dos coeficientes dos polinômios não comutativos
     <p_1>, ..., <p_n> dos monomios não comutatvos <m_1>, ..., <m_n>.
     Os coeficientes podem ser escalares.   Use `list_nc_monomials'
     para construir a lista dos monômios.

     Para usar essa função escreva primeiramente `load(affine)'.

 -- Função: list_nc_monomials ([<p_1>, ..., <p_n>])
 -- Função: list_nc_monomials (<p>)
     Retorna uma lista de monômios não comutativos que ocorrem em um
     polinômio <p> ou em uma lista de polinômios <p_1>, ..., <p_n>.

     Para usar essa função escreva primeiramente `load(affine)'.

 -- Variável de opção: all_dotsimp_denoms
     Valor padrão: `false'

     Quando `all_dotsimp_denoms' é uma lista, os denominadores
     encontrados por `dotsimp' são adicionados ao final da lista.
     `all_dotsimp_denoms' pode ser iniciado como uma lista vazia `[]'
     antes chamando `dotsimp'.

     Por padrão, denominadores não são coletados por `dotsimp'.



File: maxima.info,  Node: itensor,  Next: ctensor,  Prev: Funções Afins,  Up: Top

27 itensor
**********

* Menu:

* Introdução a itensor::
* Funções e Variáveis Definidas para itensor::


File: maxima.info,  Node: Introdução a itensor,  Next: Funções e Variáveis Definidas para itensor,  Prev: itensor,  Up: itensor

27.1 Introdução a itensor
=========================

Maxima implementa a manipulação de tensores simbólicos d dois tipos
distintos: manipulação de componentes de tensores (pacote `ctensor') e
manipulação de tensores indiciais (pacote `itensor').

   Note bem: Por favor veja a nota sobre 'nova notação de tensor'
abaixo.

   Manipulação de componentes de tensores significa que objetos do tipo
tensor geométrico são representados como arrays ou matrizes.
Operações com tensores tais com contração ou diferenciação covariante
são realizadas sobre índices (que ocorrem exatamente duas vezes)
repetidos com declarações `do'.  Isto é, se executa explicitamente
operações sobre as componentes apropriadas do tensor armazenadas em um
array ou uma matriz.

   Manipulação tensorial de índice é implementada através da
representação de tensores como funções e suas covariantes,
contravariantes e índices de derivação. Operações com tensores como
contração ou diferenciação covariante são executadas através de
manipulação dos índices em si mesmos em lugar das componentes para as
quais eles correspondem.

   Esses dois métodos aproximam-se do tratamento de processos
diferenciais, algébricos e analíticos no contexto da geometria de
Riemannian possuem várias vantagens e desvantagens as quais se revelam
por si mesmas somente apesar da natureza particular e dificuldade dos
problemas de usuário.  Todavia, se pode ter em mente as seguintes
características das duas implementações:

   As representações de tensores e de operações com tensores
explicitamente em termos de seus componntes tornam o pacote `ctensor'
fácil de usar. Especificação da métrica e o cálculo de tensores
induzidos e invariantes é direto. Embora todas a capacidade de
simplificação poderosa do Maxima está em manusear, uma métrica complexa
com intrincada dependência funcional e de coordenadas pode facilmente
conduzir a expressões cujo tamanho é excessivo e cuja estrutura está
escondida. Adicionalmente, muitos cálculos envolvem expressões
intermediárias cujo crescimento fazem com que os programas terminem
antes de serem completados. Através da experiência, um usuário pode
evitar muitas dessas dificuldade.

   O motivo de caminhos especiais através dos quais tensores e
operações de tensores são representados em termos de operações
simbólicas sobre seus índices, expressões cujas representação de
componentes podem ser não gerenciaveis da forma comum podem algumas
vezes serem grandemente simplificadas através do uso das rotinas
especiais para objetos simétricos em `itensor'. Nesse caminho a
estrutura de uma expressão grande pode ser mais transparente. Por outro
lado, o motivo da representação indicial especial em `itensor', faz com
que em alguns casos o usuário possa encontrar dificuldade com a
especificação da métrica, definição de função, e a avaliação de objetos
"indexados" diferenciados.

27.1.1 Nova notação d tensores
------------------------------

Até agora, o pacote `itensor' no Maxima tinha usado uma notação que
algumas vezes conduzia a ordenação incorreta de índices. Considere o
seguinte, por exemplo:

     (%i2) imetric(g);
     (%o2)                                done
     (%i3) ishow(g([],[j,k])*g([],[i,l])*a([i,j],[]))$
                                      i l  j k
     (%t3)                           g    g    a
                                                i j
     (%i4) ishow(contract(%))$
                                           k l
     (%t4)                                a

   O resultado está incorreto a menos que ocorra ser `a' um tensor
simétrico.  A razão para isso é que embora `itensor' mantenha
corretamente a ordem dentro do conjunto de índices covariantes e
contravariantes, assim que um índice é incrementado ou decrementado,
sua posição relativa para o outro conjunto de índices é perdida.

   Para evitar esse problema, uma nova notação tem sido desenvolvida
que mantém total compatibilidade com a notação existente e pode ser
usada intercambiavelmente. Nessa notação, índices contravariantes são
inseridos na posição apropriada na lista de índices covariantes, mas
com um sinal de menos colocado antes.  Funções como `contract' e
`ishow' estão agora consciente dessa nova notação de índice e podem
processar tensores apropriadamente.

   Nessa nova notação, o exemplo anterior retorna um resultado correto:

     (%i5) ishow(g([-j,-k],[])*g([-i,-l],[])*a([i,j],[]))$
                                      i l       j k
     (%t5)                           g    a    g
                                           i j
     (%i6) ishow(contract(%))$
                                           l k
     (%t6)                                a

   Presentemente, o único código que faz uso dessa notação é a
função `lc2kdt'. Através dessa notação, a função `lc2kdt' encontra com
êxito resultados consistentes como a aplicação do tensor métrico para
resolver os símbolos de Levi-Civita sem reordenar para índices
numéricos.

   Uma vez que esse código é um tipo novo, provavelmente contém erros.
Enquanto esse tipo novo não tiver sido testado para garantir que ele
não interrompe nada usando a "antiga" notação de tensor, existe uma
considerável chance que "novos" tensores irão falhar em interoperar com
certas funções ou recursos. Essas falhas serão corrigidas à medida que
forem encontradas... até então, seja cuidadoso!

27.1.2 Manipulação de tensores indiciais
----------------------------------------

o pacote de manipulação de tensores indiciais pode ser chamado através
de `load(itensor)'. Demonstações estão também disponíveis: tente
`demo(tensor)'.  Em `itensor' um tensor é representado como um "objeto
indexado" .  Um "objeto indexado" é uma função de 3 grupos de índices
os quais representam o covariante, o contravariante e o índice de
derivação.  Os índices covariantes são especificados através de uma
lista com o primeiro argumento para o objeto indexado, e os índices
contravariantes através de uma lista como segundo argumento. Se o
objeto indexado carece de algum desses grupos de índices então a lista
vazia `[]' é fornecida como o argumento correspondente.  Dessa forma,
`g([a,b],[c])' representa um objeto indexado chamado `g' o qual tem
dois índices covariantes `(a,b)', um índice contravariante (`c') e não
possui índices de derivação.

   Os índices de derivação, se estiverem presente, são anexados ao
final como argumentos adicionais para a função numérica representando o
tensor.  Eles podem ser explicitamente especificado pelo usuário ou
serem criados no processo de diferenciação com relação a alguma
variável coordenada.  Uma vez que diferenciação ordinária é comutativa,
os índices de derivação são ordenados alfanumericamente, a menos que
`iframe_flag' seja escolhida para `true', indicando que uma moldura
métrica está sendo usada. Essa ordenação canônica torna possível para
Maxima reconhecer que, por exemplo, `t([a],[b],i,j)' é o mesmo que
`t([a],[b],j,i)'.  Diferenciação de um objeto indexado com relação a
alguma coordenada cujos índices não aparecem como um argumento para o
objeto indexado podem normalmente retornar zero. Isso é porque Maxima
pode não saber que o tensor representado através do objeto indexado
possívelmente depende implicitamente da respectiva coordenada.  Pela
modificação da função existente no Maxima, `diff',  em `itensor',
Maxima sabe assumir que todos os objetos indexados dependem de qualquer
variável de diferenciação a menos que seja declarado de outra forma.
Isso torna possível para a convençào de somatório ser extendida para
índices derivativos. Pode ser verificado que `itensor' não possui a
compatibilidade de incrementar índices derivativos, e então eles são
sempre tratados como covariantes.

   As seguintes funções estão disponíveis no pacote tensor para
manipulação de objetos.  Atualmente, com relação às rotinas de
simplificação, é assumido que objetos indexados não possuem por padrão
propriedades simétricas. Isso pode ser modificado através da escolha da
variável `allsym[false]' para `true', o que irá resultar no tratamento
de todos os objetos indexados completamente simétricos em suas listas
de índices covariantes e simétricos em suas listas de índices
contravariantes.

   O pacote `itensor' geralmente trata tensores como objetos opacos.
Equações tensoriais são manipuladas baseadas em regras algébricas,
especificamente simetria e regras de contração. Adicionalmente, o
pacote `itensor' não entende diferenciação covariante, curvatura, e
torsão. Cálculos podem ser executados relativamente a um métrica de
molduras de movimento, dependendo da escolha para a variável
`iframe_flag'.

   Uma sessão demonstrativa abaixo mostra como chamar o pacote
`itensor', especificando o nome da métrica, e executando alguns
cálculos simples.

     (%i1) load(itensor);
     (%o1)      /share/tensor/itensor.lisp
     (%i2) imetric(g);
     (%o2)                                done
     (%i3) components(g([i,j],[]),p([i,j],[])*e([],[]))$
     (%i4) ishow(g([k,l],[]))$
     (%t4)                               e p
                                            k l
     (%i5) ishow(diff(v([i],[]),t))$
     (%t5)                                  0
     (%i6) depends(v,t);
     (%o6)                               [v(t)]
     (%i7) ishow(diff(v([i],[]),t))$
                                         d
     (%t7)                               -- (v )
                                         dt   i
     (%i8) ishow(idiff(v([i],[]),j))$
     (%t8)                                v
                                           i,j
     (%i9) ishow(extdiff(v([i],[]),j))$
     (%t9)                             v    - v
                                        j,i    i,j
                                       -----------
                                            2
     (%i10) ishow(liediff(v,w([i],[])))$
                                    %3          %3
     (%t10)                        v   w     + v   w
                                        i,%3    ,i  %3
     (%i11) ishow(covdiff(v([i],[]),j))$
                                                   %4
     (%t11)                        v    - v   ichr2
                                    i,j    %4      i j
     (%i12) ishow(ev(%,ichr2))$
                    %4 %5
     (%t12) v    - g      v   (e p       + e   p     - e p       - e    p
             i,j           %4     j %5,i    ,i  j %5      i j,%5    ,%5  i j

                                                     + e p       + e   p    )/2
                                                          i %5,j    ,j  i %5
     (%i13) iframe_flag:true;
     (%o13)                               true
     (%i14) ishow(covdiff(v([i],[]),j))$
                                                  %6
     (%t14)                        v    - v   icc2
                                    i,j    %6     i j
     (%i15) ishow(ev(%,icc2))$
                                                  %6
     (%t15)                        v    - v   ifc2
                                    i,j    %6     i j
     (%i16) ishow(radcan(ev(%,ifc2,ifc1)))$
                  %6 %8                    %6 %8
     (%t16) - (ifg      v   ifb       + ifg      v   ifb       - 2 v
                         %6    j %8 i             %6    i j %8      i,j

                                                         %6 %8
                                                    - ifg      v   ifb      )/2
                                                                %6    %8 i j
     (%i17) ishow(canform(s([i,j],[])-s([j,i])))$
     (%t17)                            s    - s
                                        i j    j i
     (%i18) decsym(s,2,0,[sym(all)],[]);
     (%o18)                               done
     (%i19) ishow(canform(s([i,j],[])-s([j,i])))$
     (%t19)                                 0
     (%i20) ishow(canform(a([i,j],[])+a([j,i])))$
     (%t20)                            a    + a
                                        j i    i j
     (%i21) decsym(a,2,0,[anti(all)],[]);
     (%o21)                               done
     (%i22) ishow(canform(a([i,j],[])+a([j,i])))$
     (%t22)                                 0


File: maxima.info,  Node: Funções e Variáveis Definidas para itensor,  Prev: Introdução a itensor,  Up: itensor

27.2 Funções e Variáveis Definidas para itensor
===============================================

27.2.1 Gerenciando objetos indexados
------------------------------------

 -- Função: entertensor (<nome>)
     É uma função que, através da linha de comando, permite criar um
     objeto indexado chamado <nome> com qualquer número de índices de
     tensores e derivativos. Ou um índice simples ou uma lista de
     índices (às quais podem ser nulas) são entradas aceitáveis (veja o
     exemplo sob `covdiff').


 -- Função: changename (<antigo>, <novo>, <expr>)
     Irá mudar o nome de todos os objetos indexados chamados <antigo>
     para <novo> em <expr>. <antigo> pode ser ou um símbolo ou uma
     lista da forma `[<nome>, <m>, <n>]' nesse caso somente esses
     objetos indexados chamados <nome> com índice covariante <m> e
     índice contravariante <n> serão renomeados para <novo>.


 -- Função: listoftens
     Lista todos os tensores em uma expressão tensorial, incluindo seus
     índices. E.g.,


          (%i6) ishow(a([i,j],[k])*b([u],[],v)+c([x,y],[])*d([],[])*e)$
                                                   k
          (%t6)                        d e c    + a    b
                                            x y    i j  u,v
          (%i7) ishow(listoftens(%))$
                                         k
          (%t7)                        [a   , b   , c   , d]
                                         i j   u,v   x y


 -- Função: ishow (<expr>)
     Mostra <expr> com os objetos indexados tendo seus índices
     covariantes como subscritos e índices contravariantes como
     sobrescritos.  Os índices derivativos são mostrados como
     subscritos, separados dos índices covariantes por uma vírgula
     (veja os exemplos através desse documento).


 -- Função: indices (<expr>)
     Retorna uma lista de dois elementos.  O primeiro é uma lista de
     índices livres em <expr> (aqueles que ocorrem somente uma vez). O
     segundo é uma lista de indices que ocorrem exatamente duas vezes
     em <expr> (dummy) como demonstra o seguinte exemplo.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(a([i,j],[k,l],m,n)*b([k,o],[j,m,p],q,r))$
                                          k l      j m p
          (%t2)                          a        b
                                          i j,m n  k o,q r
          (%i3) indices(%);
          (%o3)                 [[l, p, i, n, o, q, r], [k, j, m]]

     Um produto de tensores contendo o mesmo índice mais que duas vezes
     é sintaticamente ilegal. `indices' tenta lidar com essas
     expressões de uma forma razoável; todavia, quando `indices' é
     chamada para operar sobre tal uma expressão ilegal, seu
     comportamento pode ser considerado indefinido.


 -- Função: rename (<expr>)
 -- Função: rename (<expr>, <contador>)
     Retorna uma expressão equivalente para <expr> mas com índices que
     ocorrem exatamente duas vezes em cada termo alterado do conjunto
     `[%1, %2,...]', se o segundo argumento opcional for omitido. De
     outra forma, os índices que ocorrem exatamente duas vezes são
     indexados começando no valor de <contador>.  Cada índice que
     ocorre exatamente duas vezes em um produto será diferente. Para
     uma adição, `rename' irá operar sobre cada termo na a adição
     zerando o contador com cada termo. Nesse caminho `rename' pode
     servir como um simplificador tensorial. Adicionalmente, os índices
     serão ordenados alfanumericamente (se `allsym' for `true') com
     relação a índices covariantes ou contravariantes dependendo do
     valor de `flipflag'.  Se `flipflag' for `false' então os índices
     serão renomeados conforme a ordem dos índices contravariantes. Se
     `flipflag' for `true' a renomeação ocorrerá conforme a ordem dos
     índices covariantes. Isso muitas vezes ajuda que o efeito
     combinado dos dois restantes sejam reduzidos a uma expressão de
     valor um ou mais que um por si mesma.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) allsym:true;
          (%o2)                                true
          (%i3) g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%4],[%3])*
          ichr2([%2,%3],[u])*ichr2([%5,%6],[%1])*ichr2([%7,r],[%2])-
          g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%2],[u])*
          ichr2([%3,%5],[%1])*ichr2([%4,%6],[%3])*ichr2([%7,r],[%2]),noeval$
          (%i4) expr:ishow(%)$

                 %4 %5  %6 %7      %3         u          %1         %2
          (%t4) g      g      ichr2      ichr2      ichr2      ichr2
                                   %1 %4      %2 %3      %5 %6      %7 r

                        %4 %5  %6 %7      u          %1         %3         %2
                     - g      g      ichr2      ichr2      ichr2      ichr2
                                          %1 %2      %3 %5      %4 %6      %7 r
          (%i5) flipflag:true;
          (%o5)                                true
          (%i6) ishow(rename(expr))$
                 %2 %5  %6 %7      %4         u          %1         %3
          (%t6) g      g      ichr2      ichr2      ichr2      ichr2
                                   %1 %2      %3 %4      %5 %6      %7 r

                        %4 %5  %6 %7      u          %1         %3         %2
                     - g      g      ichr2      ichr2      ichr2      ichr2
                                          %1 %2      %3 %4      %5 %6      %7 r
          (%i7) flipflag:false;
          (%o7)                                false
          (%i8) rename(%th(2));
          (%o8)                                  0
          (%i9) ishow(rename(expr))$
                 %1 %2  %3 %4      %5         %6         %7        u
          (%t9) g      g      ichr2      ichr2      ichr2     ichr2
                                   %1 %6      %2 %3      %4 r      %5 %7

                        %1 %2  %3 %4      %6         %5         %7        u
                     - g      g      ichr2      ichr2      ichr2     ichr2
                                          %1 %3      %2 %6      %4 r      %5 %7


 -- Variável de Opção: flipflag
     Valor padrão: `false'. Se `false' então os índices irão ser
     renomeados conforme a ordem dos índices contravariantes, de outra
     forma serão ordenados conforme a ordem dos índices covariantes.

     Se `flipflag' for `false' então `rename' forma uma lista de
     índices contravariantes na ordem em que forem encontrados da
     esquerda para a direita (se `true' então de índices
     contravariantes). O primeiro índice que ocorre exatamente duas
     vezes na lista é renomeado para `%1', o seguinte para `%2', etc.
     Então a ordenação ocorre após a ocorrência do `rename' (veja o
     exemplo sob `rename').


 -- Função: defcon (<tensor_1>)
 -- Função: defcon (<tensor_1>, <tensor_2>, <tensor_3>)
     Dado <tensor_1> a propriedade que a contração de um produto do
     <tensor_1> e do <tensor_2> resulta em <tensor_3> com os índices
     apropriados.  Se somente um argumento, <tensor_1>, for dado, então
     a contração do produto de <tensor_1> com qualquer objeto indexado
     tendo os índices apropriados (digamos `my_tensor') irá retornar
     como resultado um objeto indexado com aquele nome, i.e.
     `my_tensor', e com uma nova escolha de índices refletindo as
     contrações executadas.  Por exemplo, se `imetric:g', então
     `defcon(g)' irá implementar o incremento e decremento de índices
     através da contração com o tensor métrico.  Mais de uma `defcon'
     pode ser dada para o mesmo objeto indexado; o último  fornecido
     que for aplicado a uma contração particular será usado.
     `contractions' é uma lista de objetos indexados que tenham
     fornecido propriedades de contrações com `defcon'.


 -- Função: remcon (<tensor_1>, ..., <tensor_n>)
 -- Função: remcon (all)
     Remove todas as propriedades de contração de <tensor_1>, ...,
     <tensor_n>). `remcon(all)' remove todas as propriedades de
     contração de todos os objetos indexados.


 -- Função: contract (<expr>)
     Realiza contrações tensoriais em <expr> a qual pode ser qualquer
     combinação de adições e produtos. Essa função usa a informação
     dada para a função `defcon'. Para melhores resultados, `expr' pode
     ser completamente expandida. `ratexpand' é o meio mais rápido para
     expandir produtos e expoentes de adições se não existirem
     variáveis nos denominadores dos termos. O comutador `gcd' pode ser
     `false' se cancelamentos de máximo divisor comum forem
     desnecessários.


 -- Função: indexed_tensor (<tensor>)
     Deve ser executada antes de atribuir componentes para um <tensor>
     para o qual um valor interno já existe como com `ichr1', `ichr2',
     `icurvature'. Veja o exemplo sob `icurvature'.


 -- Função: components (<tensor>, <expr>)
     Permite que se atribua um valor indicial a uma expressão <expr>
     dando os valores das componentes do <tensor>. Esses são
     automaticamente substituídos para o tensor mesmo que isso ocorra
     com todos os seus índices. O tensor deve ser da forma
     `t([...],[...])' onde qualquer lista pode ser vazia. <expr> pode
     ser qualquer expressão indexada envolvendo outros objetos com os
     mesmos índices livres que <tensor>. Quando usada para atribuir
     valores a um tensor métrico no qual as componentes possuem índices
     que ocorrem exatamente duas vezes se deve ser cuidadoso para
     definir esses índices de forma a evitar a geração de índices que
     ocorrem exatamente duas vezes e que são multiplos. a remoção dessas
     atribuições é dada para a função `remcomps'.

     É importante ter em mente que `components' cuida somente da
     valência de um tensor, e que ignora completamente qualquer
     ordenação particular de índices. Dessa forma atribuindo
     componentes a, digamos, `x([i,-j],[])', `x([-j,i],[])', ou
     `x([i],[j])' todas essas atribuições produzem o mesmo resultado, a
     saber componentes sendo atribuidas a um tensor chamado `x' com
     valência `(1,1)'.

     Componentes podem ser atribuidas a uma expressão indexada por
     quatro caminhos, dois dos quais envolvem o uso do comando
     `components':

     1) Como uma expressão indexada. Por exemplo:


          (%i2) components(g([],[i,j]),e([],[i])*p([],[j]))$
          (%i3) ishow(g([],[i,j]))$
                                                i  j
          (%t3)                                e  p

     2) Como uma matriz:


          (%i6) components(g([i,j],[]),lg);
          (%o6)                                done
          (%i7) ishow(g([i,j],[]))$
          (%t7)                                g
                                                i j
          (%i8) g([3,3],[]);
          (%o8)                                  1
          (%i9) g([4,4],[]);
          (%o9)                                 - 1

     3) Como uma função. Você pode usar uma função Maxima para
     especificar as componentes de um tensor baseado nesses índices.
     Por exemplo, os seguintes códigos atribuem `kdelta' a `h' se `h'
     tiver o mesmo número de índices covariantes e índices
     contravariantes e nenhum índice derivativo, e atribui `kdelta' a
     `g' caso as condições anteriores não sejam atendidas:


          (%i4) h(l1,l2,[l3]):=if length(l1)=length(l2) and length(l3)=0
            then kdelta(l1,l2) else apply(g,append([l1,l2], l3))$
          (%i5) ishow(h([i],[j]))$
                                                    j
          (%t5)                               kdelta
                                                    i
          (%i6) ishow(h([i,j],[k],l))$
                                               k
          (%t6)                               g
                                               i j,l

     4) Usando a compatibilidade dos modelos de coincidência do Maxima,
     especificamente os comandos `defrule' e `applyb1':


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) matchdeclare(l1,listp);
          (%o2)                                done
          (%i3) defrule(r1,m(l1,[]),(i1:idummy(),
                g([l1[1],l1[2]],[])*q([i1],[])*e([],[i1])))$

          (%i4) defrule(r2,m([],l1),(i1:idummy(),
                w([],[l1[1],l1[2]])*e([i1],[])*q([],[i1])))$

          (%i5) ishow(m([i,n],[])*m([],[i,m]))$
                                              i m
          (%t5)                              m    m
                                                   i n
          (%i6) ishow(rename(applyb1(%,r1,r2)))$
                                     %1  %2  %3 m
          (%t6)                     e   q   w     q   e   g
                                                   %1  %2  %3 n


 -- Função: remcomps (<tensor>)
     Desassocia todos os valores de <tensor> que foram atribuídos com a
     função `components'.


 -- Função: showcomps (<tensor>)
     Mostra atribuições de componentes de um tensor, feitas usando o
     comando `components'. Essa função pode ser particularmente útil
     quando uma matriz é atribuída a um tensor indicial usando
     `components', como demonstrado através do seguinte exemplo:


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) load(itensor);
          (%o2)      /share/tensor/itensor.lisp
          (%i3) lg:matrix([sqrt(r/(r-2*m)),0,0,0],[0,r,0,0],
                          [0,0,sin(theta)*r,0],[0,0,0,sqrt((r-2*m)/r)]);
                         [         r                                     ]
                         [ sqrt(-------)  0       0              0       ]
                         [      r - 2 m                                  ]
                         [                                               ]
                         [       0        r       0              0       ]
          (%o3)          [                                               ]
                         [       0        0  r sin(theta)        0       ]
                         [                                               ]
                         [                                      r - 2 m  ]
                         [       0        0       0        sqrt(-------) ]
                         [                                         r     ]
          (%i4) components(g([i,j],[]),lg);
          (%o4)                                done
          (%i5) showcomps(g([i,j],[]));
                            [         r                                     ]
                            [ sqrt(-------)  0       0              0       ]
                            [      r - 2 m                                  ]
                            [                                               ]
                            [       0        r       0              0       ]
          (%t5)      g    = [                                               ]
                      i j   [       0        0  r sin(theta)        0       ]
                            [                                               ]
                            [                                      r - 2 m  ]
                            [       0        0       0        sqrt(-------) ]
                            [                                         r     ]
          (%o5)                                false

     O comando `showcomps' pode também mostrar componentes de um tensor
     de categoria maior que 2.


 -- Função: idummy ()
     Incrementos `icounter' e retorno como seu valor um índice da forma
     `%n' onde n é um inteiro positivo.  Isso garante que índices que
     ocorrem exatamente duas vezes e que são necessários na formação de
     expressões não irão conflitar com índices que já estiverem sendo
     usados (veja o exemplo sob `indices').


 -- Variável de opção: idummyx
     Valor padrão: `%'

     É o prefixo para índices que ocorrem exatamente duas vezes (veja o
     exemplo sob índices `indices').


 -- Variável de Opção: icounter
     Valor padrão: `1'

     Determina o sufixo numérico a ser usado na geração do próximo
     índice que ocorre exatamente duas vezes no pacote tensor.  O
     prefixo é determinado através da opção `idummy' (padrão: `%').

 -- Função: kdelta (<L1>, <L2>)
     é a função delta generalizada de Kronecker definida no pacote
     `itensor' com <L1> a lista de índices covariantes e <L2> a lista
     de índices contravariantes.  `kdelta([i],[j])' retorna o delta de
     Kronecker comum.  O comando `ev(<expr>,kdelta)' faz com que a
     avaliação de uma expressão contendo `kdelta([],[])' se dê para a
     dimensão de multiplicação.

     No que conduzir a um abuso dessa notação, `itensor' também permite
     `kdelta' ter 2 covariantes e nenhum contravariante, ou 2
     contravariantes e nenhum índice covariante, com efeito fornecendo
     uma compatibilidade para "matriz unitária" covariante ou
     contravariante. Isso é estritamente considerado um recurso de
     programação e não significa implicar que `kdelta([i,j],[])' seja
     um objeto tensorial válido.


 -- Função: kdels (<L1>, <L2>)
     Delta de Kronecker simetrizado, usado em alguns cálculos. Por
     exemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) kdelta([1,2],[2,1]);
          (%o2)                                 - 1
          (%i3) kdels([1,2],[2,1]);
          (%o3)                                  1
          (%i4) ishow(kdelta([a,b],[c,d]))$
                                       c       d         d       c
          (%t4)                  kdelta  kdelta  - kdelta  kdelta
                                       a       b         a       b
          (%i4) ishow(kdels([a,b],[c,d]))$
                                       c       d         d       c
          (%t4)                  kdelta  kdelta  + kdelta  kdelta
                                       a       b         a       b


 -- Função: levi_civita (<L>)
     é o tensor de permutação (ou de Levi-Civita) que retorna 1 se a
     lista <L> consistir de uma permutação par de inteiros, -1 se isso
     consistir de uma permutação ímpar, e 0 se alguns índices em <L>
     forem repetidos.


 -- Função: lc2kdt (<expr>)
     Simplifica expressões contendo os símbolos de Levi-Civita,
     convertendo esses para expressões delta de Kronecker quando
     possível. A principal diferença entre essa função e simplesmente
     avaliar os simbolos de Levi-Civita é que a avaliação direta muitas
     vezes resulta em expressões Kronecker contendo índices numéricos.
     Isso é muitas vezes indesejável como na prevenção de
     simplificação adicional.  A função `lc2kdt' evita esse problema,
     retornando expressões que são mais facilmente simplificadas com
     `rename' ou `contract'.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) expr:ishow('levi_civita([],[i,j])*'levi_civita([k,l],[])*a([j],[k]))$
                                            i j  k
          (%t2)                  levi_civita    a  levi_civita
                                                 j            k l
          (%i3) ishow(ev(expr,levi_civita))$
                                            i j  k       1 2
          (%t3)                       kdelta    a  kdelta
                                            1 2  j       k l
          (%i4) ishow(ev(%,kdelta))$
                       i       j         j       i   k
          (%t4) (kdelta  kdelta  - kdelta  kdelta ) a
                       1       2         1       2   j

                                         1       2         2       1
                                  (kdelta  kdelta  - kdelta  kdelta )
                                         k       l         k       l
          (%i5) ishow(lc2kdt(expr))$
                               k       i       j    k       j       i
          (%t5)               a  kdelta  kdelta  - a  kdelta  kdelta
                               j       k       l    j       k       l
          (%i6) ishow(contract(expand(%)))$
                                           i           i
          (%t6)                           a  - a kdelta
                                           l           l

     A função `lc2kdt' algumas vezes faz uso de tensores métricos.  Se
     o tensor métrico não tiver sido definido previamente com `imetric',
     isso resulta em um erro.


          (%i7) expr:ishow('levi_civita([],[i,j])*'levi_civita([],[k,l])*a([j,k],[]))$
                                           i j            k l
          (%t7)                 levi_civita    levi_civita    a
                                                               j k
          (%i8) ishow(lc2kdt(expr))$
          Maxima encountered a Lisp error:

           Error in $IMETRIC [or a callee]:
           $IMETRIC [or a callee] requires less than two arguments.

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.
          (%i9) imetric(g);
          (%o9)                                done
          (%i10) ishow(lc2kdt(expr))$
                   %3 i       k   %4 j       l     %3 i       l   %4 j       k
          (%t10) (g     kdelta   g     kdelta   - g     kdelta   g     kdelta  ) a
                              %3             %4               %3             %4   j k
          (%i11) ishow(contract(expand(%)))$
                                            l i      l i
          (%t11)                           a    - a g


 -- Função: lc_l
     Regra de simplificação usada para expressões contendo símbolos não
     avaliados de Levi-Civita (`levi_civita'). Juntamente com `lc_u',
     pode ser usada para simplificar muitas expressões mais
     eficientemente que a avaliação de `levi_civita'.  Por exemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2)  el1:ishow('levi_civita([i,j,k],[])*a([],[i])*a([],[j]))$
                                       i  j
          (%t2)                       a  a  levi_civita
                                                       i j k
          (%i3) el2:ishow('levi_civita([],[i,j,k])*a([i])*a([j]))$
                                                 i j k
          (%t3)                       levi_civita      a  a
                                                        i  j
          (%i4) ishow(canform(contract(expand(applyb1(el1,lc_l,lc_u)))))$
          (%t4)                                  0
          (%i5) ishow(canform(contract(expand(applyb1(el2,lc_l,lc_u)))))$
          (%t5)                                  0


 -- Função: lc_u
     Regra de simplificação usada para expressões contendo símbolos não
     avaliados de Levi-Civita (`levi_civita'). Juntamente com `lc_u',
     pode ser usada para simplificar muitas expressões mais
     eficientemente que a avaliação de `levi_civita'.  Para detalhes,
     veja `lc_l'.


 -- Função: canten (<expr>)
     Simplifica <expr> por renomeação (veja `rename') e permutando
     índices que ocorrem exatamente duas vezes. `rename' é restrito a
     adições de produto de tensores nos quais nenhum índice derivativo
     estiver presente. Como tal isso é limitado e pode somente ser
     usado se `canform' não for capaz de realizar a simplificação
     requerida.

     A função `canten' retorna um resultado matematicamente correto
     somente se seu argumento for uma expressão que é completamente
     simétrica em seus índices.  Por essa razão, `canten' retorna um
     erro se `allsym' não for posicionada em `true'.


 -- Função: concan (<expr>)
     Similar a `canten' mas também executa contração de índices.


27.2.2 Simetrias de tensores
----------------------------

 -- Variável de Opção: allsym
     Valor padrão: `false'. Se `true' então todos os objetos indexados
     são assumidos simétricos em todos os seus índices covariantes e
     contravariantes. Se `false' então nenhum simétrico de qualquer
     tipo é assumidos nesses índices. Índices derivativos são sempre
     tomados para serem simétricos a menos que `iframe_flag' seja
     escolhida para `true'.


 -- Função: decsym (<tensor>, <m>, <n>, [<cov_1>, <cov_2>, ...],
          [<contr_1>, <contr_2>, ...])
     Declara propriedades de simetria para <tensor> de covariante <m> e
     <n> índices contravariantes. As <cov_i> e <contr_i> são
     pseudofunções expressando relações de simetrias em meio a índices
     covariante e índices contravariantes respectivamente.  Esses são
     da forma `symoper(<index_1>, <index_2>,...)' onde `symoper' é um
     entre `sym', `anti' ou `cyc' e os <index_i> são inteiros indicando
     a posição do índice no <tensor>.  Isso irá declarar <tensor> para
     ser simétrico, antisimétrico ou cíclico respectivamente nos
     <index_i>. `symoper(all)' é também forma permitida que indica
     todos os índices obedecem à condição de simetria. Por exemplo,
     dado um objeto `b' com 5 índices covariantes,
     `decsym(b,5,3,[sym(1,2),anti(3,4)],[cyc(all)])' declara `b'
     simétrico no seu primeiro e no seu segundo índices e antisimétrico
     no seu terceiro e quarto índices covariantes, e cíclico em todos
     de seus índices contravariantes.  Qualquer lista de declarações de
     simetria pode ser nula.  A função que executa as simplificações é
     `canform' como o exemplo abaixo ilustra.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) expr:contract(expand(a([i1,j1,k1],[])*kdels([i,j,k],[i1,j1,k1])))$
          (%i3) ishow(expr)$
          (%t3)         a      + a      + a      + a      + a      + a
                         k j i    k i j    j k i    j i k    i k j    i j k
          (%i4) decsym(a,3,0,[sym(all)],[]);
          (%o4)                                done
          (%i5) ishow(canform(expr))$
          (%t5)                              6 a
                                                i j k
          (%i6) remsym(a,3,0);
          (%o6)                                done
          (%i7) decsym(a,3,0,[anti(all)],[]);
          (%o7)                                done
          (%i8) ishow(canform(expr))$
          (%t8)                                  0
          (%i9) remsym(a,3,0);
          (%o9)                                done
          (%i10) decsym(a,3,0,[cyc(all)],[]);
          (%o10)                               done
          (%i11) ishow(canform(expr))$
          (%t11)                        3 a      + 3 a
                                           i k j      i j k
          (%i12) dispsym(a,3,0);
          (%o12)                     [[cyc, [[1, 2, 3]], []]]


 -- Função: remsym (<tensor>, <m>, <n>)
     Remove todas as propriedades de simetria de <tensor> que tem <m>
     índices covariantes e <n> índices contravariantes.

 -- Função: canform (<expr>)
     Simplifica <expr> através de mudança de nome de índices que
     ocorrem exatamente duas vezes e reordenação de todos os índices
     como ditados pelas condições de simetria impostas sobre eles. Se
     `allsym' for `true' então todos os índices são assumidos
     simétricos, de outra forma a informação de simetria fornecida
     pelas declarações `decsym' irão ser usadas. Os índices que ocorrem
     exatamente duas vezes são renomeados da mesma maneira que na
     função `rename'. Quando `canform' é aplicada a uma expressão larga
     o cálculo pode tomar um considerável montante de tempo.  Esse
     tempo pode ser diminuído através do uso de `rename' sobre a
     expressão em primeiro lugar.  Também veja o exemplo sob `decsym'.
     Nota: `canform' pode não estar apta a reduzir um expressão
     completamente para sua forma mais simples embora retorne sempre um
     resultado matemáticamente correto.

27.2.3 Cálculo de tensores indiciais
------------------------------------

 -- Função: diff (<expr>, <v_1>, [<n_1>, [<v_2>, <n_2>] ...])
     É a função usual de diferenciação do Maxima que tem sido expandida
     nessas habilidades para `itensor'. `diff' toma a derivada de <expr>
     <n_1> vezes com relação a <v_1>, <n_2> vezes com relação a <v_2> ,
     etc. Para o pacote `tensor', a função tem sido modificada de forma
     que os <v_i> possam ser inteiros de 1 até o valor da variável
     `dim'.  Isso causará a conclusão da diferenciação com relação ao
     <v_i>ésimo membro da lista `vect_coords'.  Se `vect_coords' for
     associado a uma variável atômica, então aquela variável subscrita
     através de <v_i> será usada para a variável de diferenciação.
     Isso permite que um array de nomes de coordenadas ou nomes
     subscritos como `x[1]', `x[2]', ...  sejam usados.

 -- Função: idiff (<expr>, <v_1>, [<n_1>, [<v_2>, <n_2>] ...])
     Diferenciação indicial. A menos que `diff', que diferencia com
     relação a uma variável independente, `idiff' possa ser usada para
     diferenciar com relação a uma coordenada. Para um objeto indexado,
     isso equivale a anexar ao final os <v_i> como índices derivativos.
     Subseqüêntemente, índices derivativos irão ser ordenados, a menos
     que `iframe_flag' seja escolhida para `true'.

     `idiff' pode também ser o determinante de um tensor métrico. Dessa
     forma, se `imetric' tiver sido associada a `G' então
     `idiff(determinant(g),k)' irá retornar
     `2*determinant(g)*ichr2([%i,k],[%i])' onde o índice que ocorre
     exatamente duas vezes `%i' é escolhido apropriadamente.


 -- Função: liediff (<v>, <ten>)
     Calcula a derivada de Lie da expressão tensorial <ten> com
     relação ao campo vetorial <v>. <ten> pode ser qualquer expressão
     tensorial indexada; <v> pode ser o nome (sem índices) de um campo
     vetorial. Por exemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(liediff(v,a([i,j],[])*b([],[k],l)))$
                 k    %2            %2          %2
          (%t2) b   (v   a       + v   a     + v   a    )
                 ,l       i j,%2    ,j  i %2    ,i  %2 j

                                          %1  k        %1  k      %1  k
                                      + (v   b      - b   v    + v   b   ) a
                                              ,%1 l    ,l  ,%1    ,l  ,%1   i j


 -- Função: rediff (<ten>)
     Avalia todas as ocorrências do comando `idiff' na expressão
     tensorial <ten>.


 -- Função: undiff (<expr>)
     Retorna uma expressão equivalente a <expr> mas com todas as
     derivadas de objetos indexados substituídas pela forma substantiva
     da função `idiff'. Seu argumento pode retornar aquele objeto
     indexado se a diferenciação for concluída.  Isso é útil quando for
     desejado substituir um objeto indexado que sofreu diferenciação
     com alguma definição de função resultando em <expr> e então
     concluir a diferenciação através de digamos `ev(<expr>, idiff)'.


 -- Função: evundiff (<expr>)
     Equivalente à execução de `undiff', seguida por `ev' e `rediff'.

     O ponto dessa operação é facilmente avaliar expressões que não
     possam ser diretamente avaliadas na forma derivada. Por exemplo, o
     seguinte causa um erro:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) icurvature([i,j,k],[l],m);
          Maxima encountered a Lisp error:

           Error in $ICURVATURE [or a callee]:
           $ICURVATURE [or a callee] requires less than three arguments.

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.

     Todavia, se `icurvature' é informado em sua forma substantiva,
     pode ser avaliado usando `evundiff':

          (%i3) ishow('icurvature([i,j,k],[l],m))$
                                                   l
          (%t3)                          icurvature
                                                   i j k,m
          (%i4) ishow(evundiff(%))$
                       l              l         %1           l           %1
          (%t4) - ichr2        - ichr2     ichr2      - ichr2       ichr2
                       i k,j m        %1 j      i k,m        %1 j,m      i k

                          l              l         %1           l           %1
                   + ichr2        + ichr2     ichr2      + ichr2       ichr2
                          i j,k m        %1 k      i j,m        %1 k,m      i j

     Nota: Em versões anteriores do Maxima, formas derivadas dos
     símbolos de Christoffel também não podiam ser avaliadas. Isso foi
     corrigido atualmente, de forma que `evundiff' não mais é
     necessária para expressões como essa:

          (%i5) imetric(g);
          (%o5)                                done
          (%i6) ishow(ichr2([i,j],[k],l))$
                 k %3
                g     (g         - g         + g        )
                        j %3,i l    i j,%3 l    i %3,j l
          (%t6) -----------------------------------------
                                    2

                                   k %3
                                  g     (g       - g       + g      )
                                   ,l     j %3,i    i j,%3    i %3,j
                                + -----------------------------------
                                                   2


 -- Função: flush (<expr>, <tensor_1>, <tensor_2>, ...)
     Escolhe para zero, em <expr>, todas as ocorrências de <tensor_i>
     que não tiverem índices derivativos.


 -- Função: flushd (<expr>, <tensor_1>, <tensor_2>, ...)
     Escolhe para zero, em <expr>, todas as ocorrências de <tensor_i>
     que tiverem índices derivativos.


 -- Função: flushnd (<expr>, <tensor>, <n>)
     Escolhe para zero, em <expr>, todas as ocorrências do objeto
     diferenciado <tensor> que tem <n> ou mais índices derivativos como
     demonstra o seguinte exemplo.

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(a([i],[J,r],k,r)+a([i],[j,r,s],k,r,s))$
                                          J r      j r s
          (%t2)                          a      + a
                                          i,k r    i,k r s
          (%i3) ishow(flushnd(%,a,3))$
                                               J r
          (%t3)                               a
                                               i,k r

 -- Função: coord (<tensor_1>, <tensor_2>, ...)
     Dados os <tensor_i> a propriedade de diferenciação da coordenada
     que a derivada do vetor contravariante cujo nome é um dos
     <tensor_i> retorna um delta de Kronecker. Por exemplo, se
     `coord(x)' tiver sido concluída então `idiff(x([],[i]),j)' fornece
     `kdelta([i],[j])'.  `coord' que é uma lista de todos os objetos
     indexados tendo essa propriedade.


 -- Função: remcoord (<tensor_1>, <tensor_2>, ...)
 -- Função: remcoord (all)
     Remove a propriedade de coordenada de diferenciação dos `tensor_i'
     que foram estabelecidos através da função `coord'.  `remcoord(all)'
     remove essa propriedade de todos os objetos indexados.


 -- Função: makebox (<expr>)
     Mostra <expr> da mesma maneira que `show'; todavia, qualquer
     tensor d'Alembertiano ocorrendo em <expr> será indicado usando o
     símbolo `[]'.  Por exemplo, `[]p([m],[n])' representa
     `g([],[i,j])*p([m],[n],i,j)'.


 -- Função: conmetderiv (<expr>, <tensor>)
     Simplifica expressões contendo derivadas comuns de ambas as formas
     covariantes e contravariantes do tensor métrico (a restrição
     corrente).  Por exemplo, `conmetderiv' pode relatar a derivada do
     tensor contravariante métrico com símbolos de Christoffel como
     visto adiante:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(g([],[a,b],c))$
                                                a b
          (%t2)                                g
                                                ,c
          (%i3) ishow(conmetderiv(%,g))$
                                   %1 b      a       %1 a      b
          (%t3)                 - g     ichr2     - g     ichr2
                                             %1 c              %1 c

 -- Função: simpmetderiv (<expr>)
 -- Função: simpmetderiv (<expr>[, <stop>])
     Simplifica expressões contendo produtos de derivadas de tensores
     métricos. Especificamente, `simpmetderiv' reconhece duas
     identidades:


             ab        ab           ab                 a
            g   g   + g   g     = (g   g  )   = (kdelta )   = 0
             ,d  bc        bc,d         bc ,d          c ,d

     conseqüêntemente


             ab          ab
            g   g   = - g   g
             ,d  bc          bc,d

     e


            ab          ab
           g   g     = g   g
            ,j  ab,i    ,i  ab,j

     que seguem de simetrias de símbolos de Christoffel.

     A função `simpmetderiv' toma um parâmetro opcional que, quando
     presente, faz com que a função pare após a primeira
     substituição feita com sucesso em uma expressão produto. A
     função `simpmetderiv' também faz uso da variável global <flipflag>
     que determina como aplicar uma ordenação "canonica" para os
     índices de produto.

     Colocados juntos, essas compatibilidades podem ser usadas
     poderosamente para encontrar simplificações que são difíceis ou
     impossíveis de realizar de outra forma.  Isso é demonstrado
     através do seguinte exemplo que explicitamente usa o recurso de
     simplificação parcial de `simpmetderiv' para obter uma expressão
     contractível:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) imetric(g);
          (%o2)                                done
          (%i3) ishow(g([],[a,b])*g([],[b,c])*g([a,b],[],d)*g([b,c],[],e))$
                                       a b  b c
          (%t3)                       g    g    g      g
                                                 a b,d  b c,e
          (%i4) ishow(canform(%))$

          errexp1 has improper indices
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) ishow(simpmetderiv(%))$
                                       a b  b c
          (%t5)                       g    g    g      g
                                                 a b,d  b c,e
          (%i6) flipflag:not flipflag;
          (%o6)                                true
          (%i7) ishow(simpmetderiv(%th(2)))$
                                         a b  b c
          (%t7)                         g    g    g    g
                                         ,d   ,e   a b  b c
          (%i8) flipflag:not flipflag;
          (%o8)                                false
          (%i9) ishow(simpmetderiv(%th(2),stop))$
                                         a b  b c
          (%t9)                       - g    g    g      g
                                              ,e   a b,d  b c
          (%i10) ishow(contract(%))$
                                              b c
          (%t10)                           - g    g
                                              ,e   c b,d

     Veja também `weyl.dem' para um exemplo que usa `simpmetderiv' e
     `conmetderiv' juntos para simplificar contrações do tensor de Weyl.


 -- Função: flush1deriv (<expr>, <tensor>)
     Escolhe para zero, em `expr', todas as ocorrências de `tensor' que
     possuem exatamente um índice derivativo.


27.2.4 Tensores em espaços curvos
---------------------------------

 -- Função: imetric (<g>)
 -- Variável de sistema: imetric
     Especifica a métrica através de atribuição à variável `imetric:<g>'
     adicionalmente, as propriedades de contração da métrica <g> são
     escolhidas através da execução dos comandos
     `defcon(<g>),defcon(<g>,<g>,kdelta)'.  A variável `imetric'
     (desassociada por padrão), é associada à métrica, atribuida pelo
     comando `imetric(<g>)'.


 -- Função: idim (<n>)
     Escolhe as dimensões da métrica. Também inicializa as propriedades
     de antisimetria dos símbolos de Levi-Civita para as dimensões
     dadas.


 -- Função: ichr1 ([<i>, <j>, <k>])
     Retorna o símbolo de Christoffel de primeiro tipo via definição
                 (g      + g      - g     )/2 .
                   ik,j     jk,i     ij,k
     Para avaliar os símbolos de Christoffel para uma métrica
     particular, à variável `imetric' deve ser atribuída um nome como
     no exemplo sob `chr2'.


 -- Função: ichr2 ([<i>, <j>], [<k>])
     Retorna o símbolo de Christoffel de segundo tipo definido pela
     relação
                                 ks
             ichr2([i,j],[k]) = g    (g      + g      - g     )/2
                                       is,j     js,i     ij,s

 -- Função: icurvature ([<i>, <j>, <k>], [<h>])
     Retorna o tensor da curvatura de Riemann em termos de símbolos de
     Christoffel de segundo tipo (`ichr2').  A seguinte notação é usada:
                         h             h            h         %1         h
               icurvature     = - ichr2      - ichr2     ichr2    + ichr2
                         i j k         i k,j        %1 j      i k        i j,k
                                         h          %1
                                  + ichr2      ichr2
                                         %1 k       i j

 -- Função: covdiff (<expr>, <v_1>, <v_2>, ...)
     Retorna a derivada da covariante de <expr> com relação às
     variáveis <v_i> em termos de símbolos de Christoffel de segundo
     tipo (`ichr2').  Com o objetivo de avaliar esses, se pode usar
     `ev(<expr>,ichr2)'.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) entertensor()$
          Enter tensor name: a;
          Enter a list of the índices covariantes: [i,j];
          Enter a list of the índices contravariantes: [k];
          Enter a list of the derivative indices: [];
                                                k
          (%t2)                                a
                                                i j
          (%i3) ishow(covdiff(%,s))$
                       k         %1     k         %1     k            k     %1
          (%t3)     - a     ichr2    - a     ichr2    + a      + ichr2     a
                       i %1      j s    %1 j      i s    i j,s        %1 s  i j
          (%i4) imetric:g;
          (%o4)            g
          (%i5) ishow(ev(%th(2),ichr2))$
            %1 %4  k
           g      a     (g       - g       + g  )
            i %1   s %4,j  j s,%4    j %4,s
          (%t5) - ------------------------------------------
                 2
              %1 %3  k
             g   a     (g       - g    + g     )
              %1 j   s %3,i    i s,%3    i %3,s
           - ------------------------------------------
                   2
              k %2  %1
             g     a    (g        - g    + g      )
             i j   s %2,%1    %1 s,%2    %1 %2,s   k
           + ------------------------------------------- + a
             2     i j,s
          (%i6)


 -- Função: lorentz_gauge (<expr>)
     Impõe a condição de Lorentz através da substituição de 0 para
     todos os objetos indexados em <expr> que possui um índice de
     derivada idêntico ao índice contravariante.


 -- Função: igeodesic_coords (<expr>, <nome>)
     Faz com que símbolos de Christoffel não diferenciados e a primeira
     derivada do tensor métrico tendam para zero em <expr>. O <nome> na
     função `igeodesic_coords' refere-se à métrica <nome> (se isso
     aparecer em <expr>) enquando os coeficientes de conecção devem ser
     chamados com os nomes `ichr1' e/ou `ichr2'. O seguinte exemplo
     demonstra a verificação da identidade cíclica satisfeita através
     do tensor da curvatura de Riemann usando a função
     `igeodesic_coords'.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(icurvature([r,s,t],[u]))$
                       u            u         %1         u            u         %1
          (%t2) - ichr2      - ichr2     ichr2    + ichr2      + ichr2     ichr2
                       r t,s        %1 s      r t        r s,t        %1 t      r s
          (%i3) ishow(igeodesic_coords(%,ichr2))$
                                           u            u
          (%t3)                       ichr2      - ichr2
                                           r s,t        r t,s
          (%i4) ishow(igeodesic_coords(icurvature([r,s,t],[u]),ichr2)+
                      igeodesic_coords(icurvature([s,t,r],[u]),ichr2)+
                      igeodesic_coords(icurvature([t,r,s],[u]),ichr2))$
                       u            u            u            u            u
          (%t4) - ichr2      + ichr2      + ichr2      - ichr2      - ichr2
                       t s,r        t r,s        s t,r        s r,t        r t,s

                                                                            u
                                                                     + ichr2
                                                                            r s,t
          (%i5) canform(%);
          (%o5)                                  0


27.2.5 Molduras móveis
----------------------

Maxima atualmente tem a habilidade de executar cálculos usando molduras
móveis.  Essas podem ser molduras ortonormais (tetrads, vielbeins) ou
uma moldura arbitrária.

   Para usar molduras, você primeiro escolhe `iframe_flag' para `true'.
Isso faz com que os símbolos de Christoffel, `ichr1' e `ichr2', sejam
substituídos pelas molduras mais gerais de coeficientes de conecção
`icc1' e `icc2' em cálculos. Especialmente, o comportamento de
`covdiff' e `icurvature' são alterados.

   A moldura é definida através de dois tensores: o campo de moldura
inversa (`ifri'), a base tetrad dual), e a métrica da moldura `ifg'. A
métrica da moldura é a matriz identidade para molduras ortonormais, ou
a métrica de Lorentz para molduras ortonormais no espaço-tempo de
Minkowski. O campo de moldura inversa define a base da moldura (vetores
unitários).  Propriedades de contração são definidas para o campo de
moldura e para a métrica da moldura.

   Quando `iframe_flag' for `true', muitas expressões `itensor' usam a
métrica da moldura `ifg' em lugar da métrica definida através de
`imetric' para o decremento e para o incremento de índices.

   IMPORTANTE: Escolhendo a variável `iframe_flag' para `true' NÃO
remove a definição das propriedades de contração de uma métrica
definida através de uma chamada a `defcon' ou `imetric'. Se um campo de
moldura for usado, ele é melhor para definir a métrica através de
atribuição desse nome para a variável `imetric' e NÃO invoque a
função `imetric'.

   Maxima usa esses dois tensores para definir os coeficientes de
moldura (`ifc1' e `ifc2') cuja forma parte dos coeficientes de
conecção (`icc1' e `icc2'), como demonstra o seguinte exemplo:


     (%i1) load(itensor);
     (%o1)      /share/tensor/itensor.lisp
     (%i2) iframe_flag:true;
     (%o2)                                true
     (%i3) ishow(covdiff(v([],[i]),j))$
                                    i        i     %1
     (%t3)                         v   + icc2     v
                                    ,j       %1 j
     (%i4) ishow(ev(%,icc2))$
                             %1      i           i        i
     (%t4)                  v   (ifc2     + ichr2    ) + v
                                     %1 j        %1 j     ,j
     (%i5) ishow(ev(%,ifc2))$
                 %1    i %2
                v   ifg     (ifb        - ifb        + ifb       )
                                j %2 %1      %2 %1 j      %1 j %2     i
     (%t5)      -------------------------------------------------- + v
                                        2                             ,j
     (%i6) ishow(ifb([a,b,c]))$
                            %5    %4
     (%t6)               ifr   ifr   (ifri        - ifri       )
                            a     b       c %4,%5       c %5,%4

   Um método alternativo é usado para calcular o suporte da moldura
(`ifb') se o sinalizador `iframe_bracket_form' é escolhido para `false':


     (%i8) block([iframe_bracket_form:false],ishow(ifb([a,b,c])))$
                            %7    %6        %6      %7
     (%t8)              (ifr   ifr     - ifr     ifr  ) ifri
                            a     b,%7      a,%7    b       c %6

 -- Função: iframes ()
     Uma vez que nessa versão do Maxima, identidades de contração para
     `ifr' e `ifri' são sempre definidas, como é o suporte da moldura
     (`ifb'), essa função não faz nada.


 -- Variável: ifb
     O suporte da moldura. A contribuição da métrica da moldura para os
     coeficientes de conecção é expressa usando o suporte da moldura:


                    - ifb      + ifb      + ifb
                         c a b      b c a      a b c
          ifc1    = --------------------------------
              abc                  2

     O suporte da moldura por si mesmo é definido em termos de campo de
     moldura e métrica da moldura. Dois métodos alternativos de cálculo
     são usados dependendo do valor de `frame_bracket_form'. Se `true'
     (o padrão) ou se o sinalizador `itorsion_flag' for `true':


                    d      e                                      f
          ifb =  ifr    ifr   (ifri      - ifri      - ifri    itr   )
             abc    b      c       a d,e       a e,d       a f    d e

     Otherwise:


                       e      d        d      e
          ifb    = (ifr    ifr    - ifr    ifr   ) ifri
             abc       b      c,e      b,e    c        a d


 -- Variável: icc1
     Coeficientes de conecção de primeiro tipo. Em `itensor', definido
     como


          icc1    = ichr1    - ikt1    - inmc1
              abc        abc       abc        abc

     Nessa expressão, se `iframe_flag' for `true', o símbolo de
     Christoffel `ichr1' é substituído com o coeficiente de conecção da
     moldura `ifc1'.  Se `itorsion_flag' for `false', `ikt1' será
     omitido. `ikt1' é também omitido se uma base de moldura for usada,
     como a torsão está já calculada como parte do suporte da moldura.
     Ultimamente, como `inonmet_flag' é `false', `inmc1' não estará
     presente.


 -- Variável: icc2
     Coeficientes de conecção de segundo tipo. Em `itensor', definido
     como


              c         c        c         c
          icc2   = ichr2   - ikt2   - inmc2
              ab        ab       ab        ab

     Nessa expressão, se `iframe_flag' for `true', o símbolo de
     Christoffel `ichr2' é substituído com o coeficiente de conecção
     `ifc2'.  Se `itorsion_flag' for `false', `ikt2' será omitido.
     `ikt2' também será omitido se uma base de moldura for usada, uma
     vez que a torsão já está calculada como parte do suporte da
     moldura.  Ultimamente, como `inonmet_flag' é `false', `inmc2' não
     estará presente.


 -- Variável: ifc1
     Coeficiente de moldura de primeiro tipo (também conhecido como
     coeficientes de rotação de Ricci).  Esse tensor representa a
     contribuição da métrica da moldura para o coeficiente de
     conecção de primeiro tipo. Definido como:


                    - ifb      + ifb      + ifb
                         c a b      b c a      a b c
          ifc1    = --------------------------------
              abc                   2


 -- Variável: ifc2
     Coeficiente de moldura de primeiro tipo. Esse tensor representa a
     contribuição da métrica da moldura para o coeficiente de
     conecção de primeiro tipo. Definido como uma permutação de suporte
     de moldura (`ifb') com os índices apropriados incrementados e
     decrementados como necessário:


              c       cd
          ifc2   = ifg   ifc1
              ab             abd


 -- Variável: ifr
     O campo da moldura. Contrai (`ifri') para e com a forma do campo
     inverso da moldura para formar a métrica da moldura (`ifg').


 -- Variável: ifri
     O campo inverso da moldura. Especifica a base da moldura (vetores
     base duais). Juntamente com a métrica da moldura, forma a base de
     todos os cálculos baseados em molduras.


 -- Variável: ifg
     A métrica da moldura. O valor padrão é `kdelta', mas pode ser
     mudada usando `components'.


 -- Variável: ifgi
     O inverso da métrica da moldura. Contrai com a métrica da moldura
     (`ifg') para `kdelta'.


 -- Variável de Opção: iframe_bracket_form
     Valor padrão: `true'

     Especifica como o suporte da moldura (`ifb') é calculado.


27.2.6 Torsão e não metricidade
-------------------------------

Maxima pode trabalhar com torsão e não metricidade. Quando o sinalizador
`itorsion_flag' for escolhido para `true', a contribuição de torsão é
adicionada aos coeficientes de conecção. Similarmente, quando o
sinalizador `inonmet_flag' for `true', componentes de não metricidades
são incluídos.

 -- Variável: inm
     O vetor de não metricidade. Conforme a não metricidade está
     definida através da derivada covariante do tensor métrico.
     Normalmente zero, o tensor da métrica derivada covariante irá
     avaliar para o seguinte quando `inonmet_flag' for escolhido para
     `true':


          g     =- g  inm
           ij;k     ij  k


 -- Variável: inmc1
     Permutação covariante de componentes do vetor de não metricidade.
     Definida como


                     g   inm  - inm  g   - g   inm
                      ab    c      a  bc    ac    b
          inmc1    = ------------------------------
               abc                 2

     (Substitue `ifg' em lugar de `g' se uma moldura métrica for usada.)


 -- Variável: inmc2
     Permutação covariante de componentes do vetor de não metricidade.
     Usada nos coeficicientes de conecção se `inonmet_flag' for `true'.
     Definida como:


                                c         c         cd
                    -inm  kdelta  - kdelta  inm  + g   inm  g
               c        a       b         a    b          d  ab
          inmc2   = -------------------------------------------
               ab                        2

     (Substitue `ifg' em lugar de `g' se uma moldura métrica for usada.)


 -- Variável: ikt1
     Permutação covariante do tensor de torsão (também conhecido como
     contorsão).  Definido como:


                            d           d       d
                    -g   itr  - g    itr   - itr   g
                      ad    cb    bd    ca      ab  cd
          ikt1    = ----------------------------------
              abc                   2

     (Substitue `ifg' em lugar de `g' se uma moldura métrica for usada.)


 -- Variável: ikt2
     Permutação contravariante do tensor de torsão (também conhecida
     como contorsão).  Definida como:


              c     cd
          ikt2   = g   ikt1
              ab           abd

     (Substitue `ifg' em lugar de `g' se uma moldura métrica for usada.)


 -- Variável: itr
     O tensor de torsão. Para uma métrica com torsão, diferenciação
     covariante repetida sobre uma funçào escalar não irá comutar,como
     demonstrado através do seguinte exemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) imetric:g;
          (%o2)                                  g
          (%i3) covdiff(covdiff(f([],[]),i),j)-covdiff(covdiff(f([],[]),j),i)$
          (%i4) ishow(%)$
                                             %4              %2
          (%t4)                    f    ichr2    - f    ichr2
                                    ,%4      j i    ,%2      i j
          (%i5) canform(%);
          (%o5)                                  0
          (%i6) itorsion_flag:true;
          (%o6)                                true
          (%i7) covdiff(covdiff(f([],[]),i),j)-covdiff(covdiff(f([],[]),j),i)$
          (%i8) ishow(%)$
                                     %8             %6
          (%t8)             f    icc2    - f    icc2    - f     + f
                             ,%8     j i    ,%6     i j    ,j i    ,i j
          (%i9) ishow(canform(%))$
                                             %1             %1
          (%t9)                     f    icc2    - f    icc2
                                     ,%1     j i    ,%1     i j
          (%i10) ishow(canform(ev(%,icc2)))$
                                             %1             %1
          (%t10)                    f    ikt2    - f    ikt2
                                     ,%1     i j    ,%1     j i
          (%i11) ishow(canform(ev(%,ikt2)))$
                                %2 %1                    %2 %1
          (%t11)          f    g      ikt1       - f    g      ikt1
                           ,%2            i j %1    ,%2            j i %1
          (%i12) ishow(factor(canform(rename(expand(ev(%,ikt1))))))$
                                     %3 %2            %1       %1
                               f    g      g      (itr    - itr   )
                                ,%3         %2 %1     j i      i j
          (%t12)               ------------------------------------
                                                2
          (%i13) decsym(itr,2,1,[anti(all)],[]);
          (%o13)                               done
          (%i14) defcon(g,g,kdelta);
          (%o14)                               done
          (%i15) subst(g,nounify(g),%th(3))$
          (%i16) ishow(canform(contract(%)))$
                                                     %1
          (%t16)                           - f    itr
                                              ,%1    i j


27.2.7 Álgebra externa (como em produto externo)
------------------------------------------------

O pacote `itensor' pode executar operações sobre campos tensores
covariantes totalmente antisimétricos. Um campo tensor totalmente
antisimétrico de classe (0,L) corresponde a uma forma diferencial L.
Sobre esses objetos, uma operação de multiplicação funciona como um
produto externo, ou produto cunha, é definido.

   Desafortunadamente, nem todos os autores concordam sobre a
definição de produto cunha. Alguns autores preferem uma definição que
corresponde à noção de antisimetrização: nessas palavras, o produto
cunha de dois campos vetoriais, por exemplo, pode ser definido como

                 a a  - a a
                  i j    j i
      a  /\ a  = -----------
       i     j        2

   Mais geralmente, o produto de uma forma p e uma forma q pode ser
definido como

                            1     k1..kp l1..lq
     A       /\ B       = ------ D              A       B
      i1..ip     j1..jq   (p+q)!  i1..ip j1..jq  k1..kp  l1..lq

   onde `D' simboliza o delta de Kronecker.

   Outros autores, todavia, preferem uma definição "geométrica" que
corresponde à notação de elemento volume:

     a  /\ a  = a a  - a a
      i     j    i j    j i

   e, no caso geral

                            1    k1..kp l1..lq
     A       /\ B       = ----- D              A       B
      i1..ip     j1..jq   p! q!  i1..ip j1..jq  k1..kp  l1..lq

   Uma vez que `itensor' é um pacote de algebra de tensores, a primeira
dessas duas definições aparenta ser a mais natural por si mesma. Muitas
aplicações, todavia, usam a segunda definição. Para resolver esse
dilema, um sinalizador tem sido implementado que controla o
comportamento do produto cunha: se `igeowedge_flag' for `false' (o
padrão), a primeira, definição "tensorial" é usada, de outra forma a
segunda, definição "geométrica" irá ser aplicada.

 -- Operador: ~
     O operador do produto cunha é definido como sendo o acento til
     `~'. O til é um operador binário. Seus argumentos podem ser
     expressões envolvendo escalares, tensores covariantes de categoria
     1, ou tensores covariantes de categoria `l' que tiverem sido
     declarados antisimétricos em todos os índices covariantes.

     O comportamento do operador do produto cunha é controlado através
     do sinalizador `igeowedge_flag', como no seguinte exemplo:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(a([i])~b([j]))$
                                           a  b  - b  a
                                            i  j    i  j
          (%t2)                            -------------
                                                 2
          (%i3) decsym(a,2,0,[anti(all)],[]);
          (%o3)                                done
          (%i4) ishow(a([i,j])~b([k]))$
                                    a    b  + b  a    - a    b
                                     i j  k    i  j k    i k  j
          (%t4)                     ---------------------------
                                                 3
          (%i5) igeowedge_flag:true;
          (%o5)                                true
          (%i6) ishow(a([i])~b([j]))$
          (%t6)                            a  b  - b  a
                                            i  j    i  j
          (%i7) ishow(a([i,j])~b([k]))$
          (%t7)                     a    b  + b  a    - a    b
                                     i j  k    i  j k    i k  j


 -- Operador: |
     A barra vertical `|' denota a operação binária "contração com um
     vetor". Quando um tensor covariante totalmente antisimétrico é
     contraído com um vetor contravariante, o resultado é o mesmo
     independente de qual índice foi usado para a contração. Dessa
     forma, é possível definir a operação de contração de uma forma
     livre de índices.

     No pacote `itensor', contração com um vetor é sempre realizada com
     relação ao primeiro índice na ordem literal de ordenação. Isso
     garante uma melhor simplificação de expressões envolvendo o
     operador `|'. Por exemplo:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) decsym(a,2,0,[anti(all)],[]);
          (%o2)                                done
          (%i3) ishow(a([i,j],[])|v)$
                                              %1
          (%t3)                              v   a
                                                  %1 j
          (%i4) ishow(a([j,i],[])|v)$
                                               %1
          (%t4)                             - v   a
                                                   %1 j

     Note que isso é essencial que os tensores usado como o operador
     `|' seja declarado totalmente antisimétrico em seus índices
     covariantes. De outra forma, os resultados serão incorretos.


 -- Função: extdiff (<expr>, <i>)
     Calcula a derivada externa de <expr> com relação ao índice <i>. A
     derivada externa é formalmente definida como o produto cunha do
     operador de derivada parcial e uma forma diferencial. Como tal,
     essa operação é também controlada através da escolha de
     `igeowedge_flag'.  Por exemplo:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(extdiff(v([i]),j))$
                                            v    - v
                                             j,i    i,j
          (%t2)                             -----------
                                                 2
          (%i3) decsym(a,2,0,[anti(all)],[]);
          (%o3)                                done
          (%i4) ishow(extdiff(a([i,j]),k))$
                                     a      - a      + a
                                      j k,i    i k,j    i j,k
          (%t4)                      ------------------------
                                                3
          (%i5) igeowedge_flag:true;
          (%o5)                                true
          (%i6) ishow(extdiff(v([i]),j))$
          (%t6)                             v    - v
                                             j,i    i,j
          (%i7) ishow(extdiff(a([i,j]),k))$
          (%t7)                      a      - a      + a
                                      j k,i    i k,j    i j,k


 -- Função: hodge (<expr>)
     Calcula o Hodge dual de <expr>. Por exemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) imetric(g);
          (%o2)                            done
          (%i3) idim(4);
          (%o3)                            done
          (%i4) icounter:100;
          (%o4)                             100
          (%i5) decsym(A,3,0,[anti(all)],[])$

          (%i6) ishow(A([i,j,k],[]))$
          (%t6)                           A
                                           i j k
          (%i7) ishow(canform(hodge(%)))$
                                    %1 %2 %3 %4
                         levi_civita            g        A
                                                 %1 %102  %2 %3 %4
          (%t7)          -----------------------------------------
                                             6
          (%i8) ishow(canform(hodge(%)))$
                           %1 %2 %3 %8            %4 %5 %6 %7
          (%t8) levi_civita            levi_civita            g        g
                                                               %1 %106  %2 %107
                                                      g        g      A        /6
                                                       %3 %108  %4 %8  %5 %6 %7
          (%i9) lc2kdt(%)$

          (%i10) %,kdelta$

          (%i11) ishow(canform(contract(expand(%))))$
          (%t11)                     - A
                                        %106 %107 %108


 -- Variável de Opção: igeowedge_flag
     Valor padrão: `false'

     Controla o comportamento de produto cunha e derivada externa.
     Quando for esconhida para `false' (o padrão), a noção de formas
     diferenciais irá corresponder àquela de um campo tensor covariante
     totalmente antisimétrico.  Quando escolhida para `true', formas
     diferenciais irão concordar com a noção do elemento volume.


27.2.8 Exportando expressões TeX
--------------------------------

O pacote `itensor' fornece suporte limitado à exportação de expressões
de tensores para o TeX.  Uma vez que expressões `itensor' aparecem como
chamada a funções, o comando regular `tex' do Maxima não produzirá a
saída esperada. Você pode tentar em seu lugar o comando `tentex', o
qual tenta traduzir expressões de tensores dentro de objetos TeX
indexados apropriadamente.

 -- Função: tentex (<expr>)
     Para usar a função `tentex', você deve primeiro chamar `tentex',
     como no seguinte exemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) load(tentex);
          (%o2)       /share/tensor/tentex.lisp
          (%i3) idummyx:m;
          (%o3)                                  m
          (%i4) ishow(icurvature([j,k,l],[i]))$
                      m1       i           m1       i           i            i
          (%t4)  ichr2    ichr2     - ichr2    ichr2     - ichr2      + ichr2
                      j k      m1 l        j l      m1 k        j l,k        j k,l
          (%i5) tentex(%)$
          $$\Gamma_{j\,k}^{m_1}\,\Gamma_{l\,m_1}^{i}-\Gamma_{j\,l}^{m_1}\,
           \Gamma_{k\,m_1}^{i}-\Gamma_{j\,l,k}^{i}+\Gamma_{j\,k,l}^{i}$$

     Note o uso da declaração `idummyx', para evitar o aparecimento do
     sinal de porcentagem na expressão TeX, o qual pode induzir a erros
     de compilação.

     Note Bem: Essa vesão da função `tentex' é um tanto quanto
     experimental.


27.2.9 Interagindo com o pacote `ctensor'
-----------------------------------------

O pacote `itensor' possui a habilidade de gerar código Maxima que pode
então ser executado no contexto do pacote `ctensor'. A função que
executa essa tarefa é `ic_convert'.

 -- Função: ic_convert (<eqn>)
     Converte a equação <eqn> na sintaxe `itensor' para uma
     declaração de atribuição `ctensor'.  Adições implícitas sobre
     índices que ocorrem exatamente duas vezes são tornadas explícitas
     enquanto objetos indexados são transformados em arrays (os arrays
     subscritos estão na ordem de covariância seguidos de índices
     contravariantes dos objetos indexados). A derivada de um objeto
     indexado será substituída pela forma substantiva de `diff' tomada
     com relação a `ct_coords' subscrita pelo índice de derivação. Os
     símbolos de Christoffel `ichr1' e `ichr2' irão ser traduzidos para
     `lcs' e `mcs', respectivamente e se `metricconvert' for `true'
     então todas as ocorrências da métrica com dois índices covariantes
     (ou contravariantes) irão ser renomeadas para `lg' (ou `ug').
     Adicionalmente, ciclos `do' irão ser introduzidos adicionando sobre
     todos os índices livres de forma que a declaração de atribuição
     transformada pode ser avaliada através de apenas fazendo `ev'. Os
     seguintes exemplos demonstam os recursos dessa função.

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) eqn:ishow(t([i,j],[k])=f([],[])*g([l,m],[])*a([],[m],j)*b([i],[l,k]))$
                                       k        m   l k
          (%t2)                       t    = f a   b    g
                                       i j      ,j  i    l m
          (%i3) ic_convert(eqn);
          (%o3) for i thru dim do (for j thru dim

          do (for k thru dim do t        : f sum(sum(diff(a , ct_coords ) b
                                 i, j, k                   m           j   i, l, k

           g    , l, 1, dim), m, 1, dim)))
            l, m
          (%i4) imetric(g);
          (%o4)                                done
          (%i5) metricconvert:true;
          (%o5)                                true
          (%i6) ic_convert(eqn);
          (%o6) for i thru dim do (for j thru dim

          do (for k thru dim do t        : f sum(sum(diff(a , ct_coords ) b
                                 i, j, k                   m           j   i, l, k

           lg    , l, 1, dim), m, 1, dim)))
             l, m


27.2.10 Palavras reservadas
---------------------------

As palavras seguintes do Maxima são usadas internamente pelo pacote
`itensor' e não podem ser redefinidas:

       Keyword    Comments
       ------------------------------------------
       indices2() versão interna de `indices()'
       conti      Lista de índices contravariantes
       covi       Lista de índices covariantes de um objeto indexado
       deri       Lista de índices de derivada de um objeto indexado
       name       Retorna o nome de um objeto indexado
       concan
       irpmon
       lc0
       _lc2kdt0
       _lcprod
       _extlc


File: maxima.info,  Node: ctensor,  Next: Pacote atensor,  Prev: itensor,  Up: Top

28 ctensor
**********

* Menu:

* Introdução a ctensor::
* Funções e Variáveis Definidas para ctensor::


File: maxima.info,  Node: Introdução a ctensor,  Next: Funções e Variáveis Definidas para ctensor,  Prev: ctensor,  Up: ctensor

28.1 Introdução a ctensor
=========================

`ctensor' é um pacote de manipulação de componentes.  Para usar o pacote
`ctensor', digite `load(ctensor)'.  Para começar uma sessão iterativa
com `ctensor', digite `csetup()'.  Você é primeiramente solicitado a
especificar a dimensão a ser manipulada. Se a dimensão for 2, 3 ou 4
então a lista de coordenadas padrão é `[x,y]', `[x,y,z]' ou `[x,y,z,t]'
respectivamente.  Esses nomes podem ser mudados através da
atribuição de uma nova lista de coordenadas para a variável `ct_coords'
(descrita abaixo) e o usuário é perguntado sobre isso.Cuidado deve ser
tomado para evitar o conflito de nomes de coordenadas com outras
definições de objetos.

   No próximo passo, o usuário informa a métrica ou diretamente ou de
um arquivo especificando sua posição ordinal. Como um exemplo de um
arquivo de métrica comum, veja `share/tensor/metrics.mac'. A métrica
está armazenada na matriz LG. Finalmente, o inverso da métrica é
calculado e armazenado na matriz UG. Se tem a opção de realizar todos
os cálculos em séries de potência.

   Um protocolo amostra é iniciado abaixo para a métrica estática,
esfericamente simétrica (coordenadas padrão) que será aplicadas ao
problema de derivação das equações de vácuo de Einstein (que levam à
solução de Schwarzschild) como um exemplo. Muitas das funções em
`ctensor' irão ser mostradas para a métrica padrão como exemplos.

     (%i1) load(ctensor);
     (%o1)      /usr/local/lib/maxima/share/tensor/ctensor.mac
     (%i2) csetup();
     Enter the dimension of the coordinate system:
     4;
     Do you wish to change the coordinate names?
     n;
     Do you want to
     1. Enter a new metric?

     2. Enter a metric from a file?

     3. Approximate a metric with a Taylor series?
     1;

     Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric  4. General
     Answer 1, 2, 3 or 4
     1;
     Row 1 Column 1:
     a;
     Row 2 Column 2:
     x^2;
     Row 3 Column 3:
     x^2*sin(y)^2;
     Row 4 Column 4:
     -d;

     Matrix entered.
     Enter functional dependencies with the DEPENDS function or 'N' if none
     depends([a,d],x);
     Do you wish to see the metric?
     y;
                               [ a  0       0        0  ]
                               [                        ]
                               [     2                  ]
                               [ 0  x       0        0  ]
                               [                        ]
                               [         2    2         ]
                               [ 0  0   x  sin (y)   0  ]
                               [                        ]
                               [ 0  0       0       - d ]
     (%o2)                                done
     (%i3) christof(mcs);
                                                 a
                                                  x
     (%t3)                          mcs        = ---
                                       1, 1, 1   2 a

                                                  1
     (%t4)                           mcs        = -
                                        1, 2, 2   x

                                                  1
     (%t5)                           mcs        = -
                                        1, 3, 3   x

                                                 d
                                                  x
     (%t6)                          mcs        = ---
                                       1, 4, 4   2 d

                                                   x
     (%t7)                          mcs        = - -
                                       2, 2, 1     a

                                                cos(y)
     (%t8)                         mcs        = ------
                                      2, 3, 3   sin(y)

                                                    2
                                               x sin (y)
     (%t9)                      mcs        = - ---------
                                   3, 3, 1         a

     (%t10)                   mcs        = - cos(y) sin(y)
                                 3, 3, 2

                                                 d
                                                  x
     (%t11)                         mcs        = ---
                                       4, 4, 1   2 a
     (%o11)                               done


File: maxima.info,  Node: Funções e Variáveis Definidas para ctensor,  Prev: Introdução a ctensor,  Up: ctensor

28.2 Funções e Variáveis Definidas para ctensor
===============================================

28.2.1 Inicialização e configuração
-----------------------------------

 -- Função: csetup ()
     É uma função no pacote `ctensor' (component tensor) que inicializa
     o pacote e permite ao usuário inserir uma métrica interativamente.
     Veja `ctensor' para mais detalhes.

 -- Função: cmetric (<dis>)
 -- Função: cmetric ()
     É uma função no pacote `ctensor' que calcula o inverso da métrica
     e prepara o pacote para cálculos adiante.

     Se `cframe_flag' for `false', a função calcula a métrica inversa
     `ug' a partir da matriz `lg' (definida pelo usuário). O
     determinante da métrica é também calculado e armazenado na
     variável `gdet'. Mais adiante, o pacote determina se a métrica é
     diagonal e escolhe o valor de `diagmetric' conforme a
     determinação. Se o argumento opcional <dis> estiver presente e não
     for `false', a saída é mostrada ao usuário pela linha de comando
     para que ele possa ver o inverso da métrica.

     Se `cframe_flag' for `true', a função espera que o valor de `fri'
     (a matriz moldura inversa) e `lfg' (a métrica da moldura) sejam
     definidas. A partir dessas, a matriz da moldura `fr' e a métrica
     da moldura inversa `ufg' são calculadas.


 -- Função: ct_coordsys (<sistema_de_coordenadas>, <extra_arg>)
 -- Função: ct_coordsys (<sistema_de_coordenadas>)
     Escolhe um sistema de coordenadas predefinido e uma métrica. O
     argumento <sistema_de_coordenadas> pode ser um dos seguintes
     símbolos:


            SYMBOL               Dim Coordenadas       Descrição/comentários
            --------------------------------------------------------------------------
            cartesian2d           2  [x,y]             Sist. de coord. cartesianas 2D
            polar                 2  [r,phi]           Sist. de coord. Polare
            elliptic              2  [u,v]
            confocalelliptic      2  [u,v]
            bipolar               2  [u,v]
            parabolic             2  [u,v]
            cartesian3d           3  [x,y,z]           Sist. de coord. cartesianas 3D
            polarcylindrical      3  [r,theta,z]
            ellipticcylindrical   3  [u,v,z]           Elíptica 2D com Z cilíndrico
            confocalellipsoidal   3  [u,v,w]
            bipolarcylindrical    3  [u,v,z]           Bipolar 2D com Z cilíndrico
            paraboliccylindrical  3  [u,v,z]           Parabólico 2D com Z cilíndrico
            paraboloidal          3  [u,v,phi]
            conical               3  [u,v,w]
            toroidal              3  [u,v,phi]
            spherical             3  [r,theta,phi]     Sist. de coord. Esféricas
            oblatespheroidal      3  [u,v,phi]
            oblatespheroidalsqrt  3  [u,v,phi]
            prolatespheroidal     3  [u,v,phi]
            prolatespheroidalsqrt 3  [u,v,phi]
            ellipsoidal           3  [r,theta,phi]
            cartesian4d           4  [x,y,z,t]         Sist. de coord. 4D
            spherical4d           4  [r,theta,eta,phi]
            exteriorschwarzschild 4  [t,r,theta,phi]   Métrica de Schwarzschild
            interiorschwarzschild 4  [t,z,u,v]        Métrica de Schwarzschild Interior
            kerr_newman           4  [t,r,theta,phi]   Métrica simétrica axialmente alterada

     `sistema_de_coordenadas' pode também ser uma lista de funções de
     transformação, seguida por uma lista contendo as varáveis
     coordenadas. Por exemplo, você pode especificar uma métrica
     esférica como segue:


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
                r*sin(theta),[r,theta,phi]]);
          (%o2)                                done
          (%i3) lg:trigsimp(lg);
                                     [ 1  0         0        ]
                                     [                       ]
                                     [     2                 ]
          (%o3)                      [ 0  r         0        ]
                                     [                       ]
                                     [         2    2        ]
                                     [ 0  0   r  cos (theta) ]
          (%i4) ct_coords;
          (%o4)                           [r, theta, phi]
          (%i5) dim;
          (%o5)                                  3

     Funções de transformação podem também serem usadas quando
     `cframe_flag' for `true':


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) cframe_flag:true;
          (%o2)                                true
          (%i3) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
                r*sin(theta),[r,theta,phi]]);
          (%o3)                                done
          (%i4) fri;
                [ cos(phi) cos(theta)  - cos(phi) r sin(theta)  - sin(phi) r cos(theta) ]
                [                                                                       ]
          (%o4) [ sin(phi) cos(theta)  - sin(phi) r sin(theta)   cos(phi) r cos(theta)  ]
                [                                                                       ]
                [     sin(theta)            r cos(theta)                   0            ]
          (%i5) cmetric();
          (%o5)                                false
          (%i6) lg:trigsimp(lg);
                                     [ 1  0         0        ]
                                     [                       ]
                                     [     2                 ]
          (%o6)                      [ 0  r         0        ]
                                     [                       ]
                                     [         2    2        ]
                                     [ 0  0   r  cos (theta) ]

     O argumento opcional <extra_arg> pode ser qualquer um dos
     seguintes:

     `cylindrical' diz a `ct_coordsys' para anexar uma coordenada
     adicional cilíndrica.

     `minkowski' diz a `ct_coordsys' para anexar uma coordenada com
     assinatura métrica negativa.

     `all' diz a `ct_coordsys' para chamar `cmetric' e
     `christof(false)' após escolher a métrica.

     Se a variável global `verbose' for escolhida para `true',
     `ct_coordsys' mostra os valores de `dim', `ct_coords', e ou `lg'
     ou `lfg' e `fri', dependendo do valor de `cframe_flag'.


 -- Função: init_ctensor ()
     Inicializa o pacote `ctensor'.

     A função `init_ctensor' reinicializa o pacote `ctensor'. Essa
     função remove todos os arrays e matrizes usados por `ctensor',
     coloca todos os sinalizadores de volta a seus valores padrão,
     retorna `dim' para 4, e retorna a métrica da moldura para a
     métrica da moldura de Lorentz.


28.2.2 Os tensores do espaço curvo
----------------------------------

O principal propósito do pacote `ctensor' é calcular os tensores do
espaç(tempo) curvo, mais notavelmente os tensores usados na relatividade
geral.

   Quando uma base métrica é usada, `ctensor' pode calcular os
seguintes tensores:


      lg  -- ug
        \      \
         lcs -- mcs -- ric -- uric
                   \      \       \
                    \      tracer - ein -- lein
                     \
                      riem -- lriem -- weyl
                          \
                           uriem

   `ctensor' pode também usar molduras móveis. Quando `cframe_flag' for
escolhida para `true', os seguintes tensores podem ser calculados:


      lfg -- ufg
          \
      fri -- fr -- lcs -- mcs -- lriem -- ric -- uric
           \                       |  \      \       \
            lg -- ug               |   weyl   tracer - ein -- lein
                                   |\
                                   | riem
                                   |
                                   \uriem

 -- Função: christof (<dis>)
     Uma função no pacote `ctensor'.  Essa função calcula os símbolos
     de Christoffel de ambos os tipos.  O argumento <dis> determina
     quais resultados são para serem imediatamente mostrados.  Os
     símbolos de Christoffel de primeiro e de segundo tipo são
     armazenados nos arrays `lcs[i,j,k]' e `mcs[i,j,k]' respectivamente
     e definidos para serem simétricos nos primeiros dois índices. Se o
     argumento para `christof' for `lcs' ou for `mcs' então o único
     valor não nulo de `lcs[i,j,k]' ou de `mcs[i,j,k]',
     respectivamente, será mostrado. Se o argumento for `all' então o
     único valor não nulo de `lcs[i,j,k]' e o único valor não nulo de
     `mcs[i,j,k]' serão mostrados.  Se o argumento for `false' então a
     exibição dos elementos não acontecerá. Os elementos do array
     `mcs[i,j,k]' são definidos de uma tal maneira que o índice final é
     contravariante.

 -- Função: ricci (<dis>)
     Uma função no pacote `ctensor'.  `ricci' calcula as componentes
     contravariantes (simétricas) `ric[i,j]' do tensor de Ricci.  Se o
     argumento <dis> for `true', então as componentes não nulas são
     mostradas.

 -- Função: uricci (<dis>)
     Essa função primeiro calcula as componentes contravariantes
     `ric[i,j]' do tensor de Ricci.  Então o tensor misto de Ricci é
     calculado usando o tensor métrico contravariante.  Se o valor do
     argumento <dis> for `true', então essas componentes mistas,
     `uric[i,j]' (o índice "i" é covariante e o índice "j" é
     contravariante), serão mostradas diretamente.  De outra forma,
     `ricci(false)' irá simplesmente calcular as entradas do array
     `uric[i,j]' sem mostrar os resultados.


 -- Função: scurvature ()
     Retorna a curvatura escalar (obtida através da contração do tensor
     de Ricci) do Riemaniano multiplicado com a métrica dada.


 -- Função: einstein (<dis>)
     Uma função no pacote `ctensor'.  `einstein' calcula o tensor misto
     de Einstein após os símbolos de Christoffel e o tensor de Ricci
     terem sido obtidos (com as funções `christof' e `ricci').  Se o
     argumento <dis> for `true', então os valores não nulos do tensor
     misto de Einstein `ein[i,j]' serão mostrados quando `j' for o
     índice contravariante.  A variável `rateinstein' fará com que a
     simplificação racional ocorra sobre esses componentes. Se `ratfac'
     for `true' então as componentes irão também ser fatoradas.


 -- Função: leinstein (<dis>)
     Tensor covariante de Einstein. `leinstein' armazena o valor do
     tensor covariante de Einstein no array `lein'. O tensor covariante
     de Einstein é calculado a partir tensor misto de Einstein `ein'
     através da multiplicação desse pelo tensor métrico. Se o argumento
     <dis> for `true', então os valores não nulos do tensor covariante
     de Einstein são mostrados.


 -- Função: riemann (<dis>)
     Uma função no pacote `ctensor'.  `riemann' calcula o tensor de
     curvatura de Riemann a partir da métrica dada e correspondendo aos
     símbolos de Christoffel. As seguintes convenções de índice são
     usadas:

                          l      _l       _l       _l   _m    _l   _m
           R[i,j,k,l] =  R    = |      - |      + |    |   - |    |
                          ijk     ij,k     ik,j     mk   ij    mj   ik

     Essa notação é consistente com a notação usada por no pacote
     `itensor' e sua função `icurvature'.  Se o argumento opcional
     <dis> for `true', as componentes não nulas `riem[i,j,k,l]' serão
     mostradas.  Como com o tensor de Einstein, vários comutadores
     escolhidos pelo usuário controlam a simplificação de componentes
     do tensor de Riemann.  Se `ratriemann' for `true', então
     simplificação racional será feita. Se `ratfac' for `true' então
     cada uma das componentes irá também ser fatorada.

     Se a variável `cframe_flag' for `false', o tensor de Riemann é
     calculado diretamente dos símbolos de Christoffel. Se
     `cframe_flag' for `true', o tensor covariante de Riemann é
     calculado primeiro dos coeficientes de campo da moldura.


 -- Função: lriemann (<dis>)
     Tensor covariante de Riemann (`lriem[]').

     Calcula o tensor covariante de Riemann como o array `lriem'. Se o
     argumento <dis> for `true', únicos valores não nulos são mostrados.

     Se a variável `cframe_flag' for `true', o tensor covariante de
     Riemann é calculado diretamente dos coeficientes de campo da
     moldura. De outra forma, o tensor (3,1) de Riemann é calculado
     primeiro.

     Para informação sobre a ordenação de índice, veja `riemann'.


 -- Função: uriemann (<dis>)
     Calcula as componentes contravariantes do tensor de curvatura  de
     Riemann como elementos do array `uriem[i,j,k,l]'.  Esses são
     mostrados se <dis> for `true'.


 -- Função: rinvariant ()
     Compõe o invariante de Kretchmann (`kinvariant') obtido através da
     contração dos tensores

          lriem[i,j,k,l]*uriem[i,j,k,l].

     Esse objeto não é automaticamente simplificado devido ao fato de
     poder ser muito largo.


 -- Função: weyl (<dis>)
     Calcula o tensor conformal de Weyl.  Se o argumento <dis> for
     `true', as componentes não nulas `weyl[i,j,k,l]' irão ser
     mostradas para o usuário.  De outra forma, essas componentes irão
     simplesmente serem calculadas e armazenadas.  Se o comutador
     `ratweyl' é escolhido para `true', então as componentes irão ser
     racionalmente simplificadas; se `ratfac' for `true' então os
     resultados irão ser fatorados também.


28.2.3 Expansão das séries de Taylor
------------------------------------

O pacote `ctensor' possui a habilidade para truncar resultados assumindo
que eles são aproximações das séries de Taylor. Esse comportamenteo é
controlado através da variável `ctayswitch'; quando escolhida para
`true', `ctensor' faz uso internamente da função `ctaylor' quando
simplifica resultados.

   A função `ctaylor' é invocada pelas seguintes funções de `ctensor':


         Function     Comments
         ---------------------------------
         christof()   só para mcs
         ricci()
         uricci()
         einstein()
         riemann()
         weyl()
         checkdiv()

 -- Função: ctaylor ()
     A função `ctaylor' trunca seus argumentos através da conversão
     destes para uma série de Taylor usando `taylor', e então chamando
     `ratdisrep'. Isso tem efeito combinado de abandonar termos de
     ordem mais alta na variável de expansão `ctayvar'. A ordem dos
     termos que podem ser abandonados é definida através de `ctaypov'; o
     ponto em torno do qual a expansão da série é realizada está
     especificado em `ctaypt'.

     Como um exemplo, considere uma métrica simples que é uma
     perturbação da métrica de Minkowski. Sem restrições adicionais,
     mesmo uma métrica diagonal produz expressões para o tensor de
     Einstein que são de longe muito complexas:


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) ratfac:true;
          (%o2)                                true
          (%i3) derivabbrev:true;
          (%o3)                                true
          (%i4) ct_coords:[t,r,theta,phi];
          (%o4)                         [t, r, theta, phi]
          (%i5) lg:matrix([-1,0,0,0],[0,1,0,0],[0,0,r^2,0],[0,0,0,r^2*sin(theta)^2]);
                                  [ - 1  0  0         0        ]
                                  [                            ]
                                  [  0   1  0         0        ]
                                  [                            ]
          (%o5)                   [          2                 ]
                                  [  0   0  r         0        ]
                                  [                            ]
                                  [              2    2        ]
                                  [  0   0  0   r  sin (theta) ]
          (%i6) h:matrix([h11,0,0,0],[0,h22,0,0],[0,0,h33,0],[0,0,0,h44]);
                                      [ h11   0    0    0  ]
                                      [                    ]
                                      [  0   h22   0    0  ]
          (%o6)                       [                    ]
                                      [  0    0   h33   0  ]
                                      [                    ]
                                      [  0    0    0   h44 ]
          (%i7) depends(l,r);
          (%o7)                               [l(r)]
          (%i8) lg:lg+l*h;
                   [ h11 l - 1      0          0                 0            ]
                   [                                                          ]
                   [     0      h22 l + 1      0                 0            ]
                   [                                                          ]
          (%o8)    [                        2                                 ]
                   [     0          0      r  + h33 l            0            ]
                   [                                                          ]
                   [                                    2    2                ]
                   [     0          0          0       r  sin (theta) + h44 l ]
          (%i9) cmetric(false);
          (%o9)                                done
          (%i10) einstein(false);
          (%o10)                               done
          (%i11) ntermst(ein);
          [[1, 1], 62]
          [[1, 2], 0]
          [[1, 3], 0]
          [[1, 4], 0]
          [[2, 1], 0]
          [[2, 2], 24]
          [[2, 3], 0]
          [[2, 4], 0]
          [[3, 1], 0]
          [[3, 2], 0]
          [[3, 3], 46]
          [[3, 4], 0]
          [[4, 1], 0]
          [[4, 2], 0]
          [[4, 3], 0]
          [[4, 4], 46]
          (%o12)                               done

     Todavia, se nós recalcularmos esse exemplo como uma aproximação
     que é linear na variável `l', pegamos expressões muito simples:


          (%i14) ctayswitch:true;
          (%o14)                               true
          (%i15) ctayvar:l;
          (%o15)                                 l
          (%i16) ctaypov:1;
          (%o16)                                 1
          (%i17) ctaypt:0;
          (%o17)                                 0
          (%i18) christof(false);
          (%o18)                               done
          (%i19) ricci(false);
          (%o19)                               done
          (%i20) einstein(false);
          (%o20)                               done
          (%i21) ntermst(ein);
          [[1, 1], 6]
          [[1, 2], 0]
          [[1, 3], 0]
          [[1, 4], 0]
          [[2, 1], 0]
          [[2, 2], 13]
          [[2, 3], 2]
          [[2, 4], 0]
          [[3, 1], 0]
          [[3, 2], 2]
          [[3, 3], 9]
          [[3, 4], 0]
          [[4, 1], 0]
          [[4, 2], 0]
          [[4, 3], 0]
          [[4, 4], 9]
          (%o21)                               done
          (%i22) ratsimp(ein[1,1]);
                                   2      2  4               2     2
          (%o22) - (((h11 h22 - h11 ) (l )  r  - 2 h33 l    r ) sin (theta)
                                        r               r r

                                          2               2      4    2
                            - 2 h44 l    r  - h33 h44 (l ) )/(4 r  sin (theta))
                                     r r                r

     Essa compatibilidade pode ser útil, por exemplo, quando
     trabalhamos no limite do campo fraco longe de uma fonte
     gravitacional.


28.2.4 Campos de moldura
------------------------

Quando a variável `cframe_flag' for escolhida para `true', o pacote
`ctensor' executa seus cálculos usando uma moldura móvel.

 -- Função: frame_bracket (<fr>, <fri>, <diagframe>)
     O delimitador da moldura (`fb[]').

     Calcula o delimitador da moldura conforme a seguinte definição:

             c          c         c        d     e
          ifb   = ( ifri    - ifri    ) ifr   ifr
             ab         d,e       e,d      a     b


28.2.5 Classificação Algébrica
------------------------------

Um novo recurso (a partir de November de 2004) de `ctensor' é sua
habilidade para calcular a classificação de Petrov de uma métrica
espaço tempo tetradimensional.  Para uma demonstração dessa
compatibilidade, veja o arquivo `share/tensor/petrov.dem'.

 -- Função: nptetrad ()
     Calcula um tetrad nulo de Newman-Penrose (`np') e seus índices
     ascendentes em contrapartida (`npi'). Veja `petrov' para um
     exemplo.

     O tetrad nulo é construído assumindo que uma moldura métrica
     ortonormal tetradimensional com assinatura métrica (-,+,+,+) está
     sendo usada.  As componentes do tetrad nulo são relacionadas para
     a matriz moldura inversa como segue:


          np  = (fri  + fri ) / sqrt(2)
            1       1      2

          np  = (fri  - fri ) / sqrt(2)
            2       1      2

          np  = (fri  + %i fri ) / sqrt(2)
            3       3         4

          np  = (fri  - %i fri ) / sqrt(2)
            4       3         4


 -- Função: psi (<dis>)
     Calcula os cinco coeficientes de Newman-Penrose
     `psi[0]'...`psi[4]'.  Se `psi' for escolhida para `true', os
     coeficientes são mostrados.  Veja `petrov' para um exemplo.

     Esses coeficientes são calculados a partir do tensor de Weyl em
     uma base de coordenada.  Se uma base de moldura for usada,o tensor
     de Weyl é primeiro convertido para a base de coordenada, que pode
     ser um procedimento computacional expansível. Por essa razão, em
     alguns casos pode ser mais vantajoso usar uma base de coordenada em
     primeiro lugar antes que o tensor de Weyl seja calculado. Note
     todavia, que para a construção de um tetrad nulo de Newman-Penrose
     é necessário uma base de moldura. Portanto, uma seqüência de
     cálculo expressiva pode começar com uma base de moldura, que é
     então usada para calcular `lg' (calculada automaticamente através
     de `cmetric') e em seguida calcula `ug'. Nesse ponto, você pode
     comutar de volta para uma base de coordenada escolhendo
     `cframe_flag' para `false' antes de começar a calcular os símbolos
     de Christoffel. Mudando para uma base de moldura em um estágio
     posterior pode retornar resultados inconsistentes, já que você
     pode terminar com um grande mistura de tensores, alguns calculados
     em uma base de moldura, alguns em uma base de coordenada, sem
     nenhum modo para distingüir entre os dois tipos.


 -- Função: petrov ()
     Calcula a classificação de petrov da métrica caracterizada através
     de `psi[0]'...`psi[4]'.

     Por exemplo, o seguinte demonstra como obter a classificação de
     Petrov da métrica de Kerr:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) (cframe_flag:true,gcd:spmod,ctrgsimp:true,ratfac:true);
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) ug:invert(lg)$
          (%i5) weyl(false);
          (%o5)                                done
          (%i6) nptetrad(true);
          (%t6) np =

                 [  sqrt(r - 2 m)           sqrt(r)                                     ]
                 [ ---------------   ---------------------      0             0         ]
                 [ sqrt(2) sqrt(r)   sqrt(2) sqrt(r - 2 m)                              ]
                 [                                                                      ]
                 [  sqrt(r - 2 m)            sqrt(r)                                    ]
                 [ ---------------  - ---------------------     0             0         ]
                 [ sqrt(2) sqrt(r)    sqrt(2) sqrt(r - 2 m)                             ]
                 [                                                                      ]
                 [                                              r      %i r sin(theta)  ]
                 [        0                    0             -------   ---------------  ]
                 [                                           sqrt(2)       sqrt(2)      ]
                 [                                                                      ]
                 [                                              r       %i r sin(theta) ]
                 [        0                    0             -------  - --------------- ]
                 [                                           sqrt(2)        sqrt(2)     ]

                                       sqrt(r)          sqrt(r - 2 m)
          (%t7) npi = matrix([- ---------------------, ---------------, 0, 0],
                                sqrt(2) sqrt(r - 2 m)  sqrt(2) sqrt(r)

                    sqrt(r)            sqrt(r - 2 m)
          [- ---------------------, - ---------------, 0, 0],
             sqrt(2) sqrt(r - 2 m)    sqrt(2) sqrt(r)

                     1               %i
          [0, 0, ---------, --------------------],
                 sqrt(2) r  sqrt(2) r sin(theta)

                     1                 %i
          [0, 0, ---------, - --------------------])
                 sqrt(2) r    sqrt(2) r sin(theta)

          (%o7)                                done
          (%i7) psi(true);
          (%t8)                              psi  = 0
                                                0

          (%t9)                              psi  = 0
                                                1

                                                    m
          (%t10)                             psi  = --
                                                2    3
                                                    r

          (%t11)                             psi  = 0
                                                3

          (%t12)                             psi  = 0
                                                4
          (%o12)                               done
          (%i12) petrov();
          (%o12)                                 D

     A função de classificação Petrov é baseada no algorítmo publicado
     em "Classifying geometries in general relativity: III
     Classification in practice" por Pollney, Skea, e d'Inverno, Class.
     Quant. Grav. 17 2885-2902 (2000).  Exceto para alguns casos de
     teste simples, a implementação não está testada até 19 de Dezembro
     de 2004, e é provável que contenha erros.


28.2.6 Torsão e não metricidade
-------------------------------

`ctensor' possui a habilidade de calcular e incluir coeficientes de
torsão e não metricidade nos coeficientes de conecção.

   Os coeficientes de torsão são calculados a partir de um tensor
fornecido pelo usuário `tr', que pode ser um tensor de categoria (2,1).
A partir disso, os coeficientes de torsão `kt' são calculados de acordo
com a seguinte fórmula:


                   m          m      m
            - g  tr   - g   tr   - tr   g
               im  kj    jm   ki     ij  km
     kt   = -------------------------------
       ijk                 2


       k     km
     kt   = g   kt
       ij         ijm

   Note que somente o tensor de índice misto é calculao e armazenado no
array `kt'.

   Os coeficientes de não metricidade são calculados a partir  do vetor
de não metricidade fornecido pelo usuário `nm'. A partir disso, os
coeficientes de não metricidade `nmc' são calculados como segue:


                  k    k        km
            -nm  D  - D  nm  + g   nm  g
        k      i  j    i   j         m  ij
     nmc  = ------------------------------
        ij                2

   onde D simboliza o delta de Kronecker.

   Quando `ctorsion_flag' for escolhida para `true', os valores de `kt'
são subtraídos dos coeficientes de conecção indexados mistos calculados
através de `christof' e armazenados em `mcs'. Similarmente, se
`cnonmet_flag' for escolhida para `true', os valores de `nmc' são
subtraídos dos coeficientes de conecção indexados mistos.

   Se necessário, `christof' chama as funções `contortion' e
`nonmetricity' com o objetivo de calcular `kt' e `nm'.

 -- Função: contortion (<tr>)
     Calcula os coeficientes de contorsão de categoria (2,1) a partir
     do tensor de torsão <tr>.


 -- Função: nonmetricity (<nm>)
     Calcula o coeficiente de não metricidade de categoria (2,1) a
     partir do vetor de não metricidade <nm>.


28.2.7 Recursos diversos
------------------------

 -- Função: ctransform (<M>)
     Uma função no pacote `ctensor' que irá executar uma
     transformação de coordenadas sobre uma matriz simétrica quadrada
     arbitrária <M>. O usuário deve informar as funçãoes que definem a
     transformação.  (Formalmente chamada `transform'.)


 -- Função: findde (<A>, <n>)
     Retorna uma lista de equações diferenciais únicas (expressões)
     correspondendo aos elementos do array quadrado <n> dimensional
     <A>. Atualmente, <n> pode ser 2 ou 3. `deindex' é uma lista global
     contendo os índices de <A> correspondendo a essas únicas
     equações diferenciais. Para o tensor de Einstein (`ein'), que é um
     array dimensional, se calculado para a métrica no exemplo abaixo,
     `findde' fornece as seguintes equações diferenciais independentes:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) derivabbrev:true;
          (%o2)                                true
          (%i3) dim:4;
          (%o3)                                  4
          (%i4) lg:matrix([a,0,0,0],[0,x^2,0,0],[0,0,x^2*sin(y)^2,0],[0,0,0,-d]);
                                    [ a  0       0        0  ]
                                    [                        ]
                                    [     2                  ]
                                    [ 0  x       0        0  ]
          (%o4)                     [                        ]
                                    [         2    2         ]
                                    [ 0  0   x  sin (y)   0  ]
                                    [                        ]
                                    [ 0  0       0       - d ]
          (%i5) depends([a,d],x);
          (%o5)                            [a(x), d(x)]
          (%i6) ct_coords:[x,y,z,t];
          (%o6)                            [x, y, z, t]
          (%i7) cmetric();
          (%o7)                                done
          (%i8) einstein(false);
          (%o8)                                done
          (%i9) findde(ein,2);
                                                      2
          (%o9) [d  x - a d + d, 2 a d d    x - a (d )  x - a  d d  x + 2 a d d
                  x                     x x         x        x    x            x

                                                                  2          2
                                                          - 2 a  d , a  x + a  - a]
                                                               x      x
          (%i10) deindex;
          (%o10)                     [[1, 1], [2, 2], [4, 4]]


 -- Função: cograd ()
     Calcula o gradiente covariante de uma função escalar permitindo ao
     usuário escolher o nome do vetor correspondente como o exemplo sob
     `contragrad' ilustra.

 -- Função: contragrad ()
     Calcula o gradiente contravariante de uma função escalar permitindo
     ao usuário escolher o nome do vetor correspondente como o exemplo
     abaixo como ilustra a métrica de Schwarzschild:


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) derivabbrev:true;
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) depends(f,r);
          (%o4)                               [f(r)]
          (%i5) cograd(f,g1);
          (%o5)                                done
          (%i6) listarray(g1);
          (%o6)                            [0, f , 0, 0]
                                                r
          (%i7) contragrad(f,g2);
          (%o7)                                done
          (%i8) listarray(g2);
                                         f  r - 2 f  m
                                          r        r
          (%o8)                      [0, -------------, 0, 0]
                                               r


 -- Função: dscalar ()
     Calcula o tensor d'Alembertiano da função escalar assim que as
     dependências tiverem sido declaradas sobre a função. Po exemplo:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) derivabbrev:true;
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) depends(p,r);
          (%o4)                               [p(r)]
          (%i5) factor(dscalar(p));
                                    2
                              p    r  - 2 m p    r + 2 p  r - 2 m p
                               r r           r r        r          r
          (%o5)               --------------------------------------
                                                 2
                                                r


 -- Função: checkdiv ()
     Calcula a divergência covariante do tensor de segunda categoria
     misto (cujo primeiro índice deve ser covariante) imprimindo as
     correspondentes n componentes do campo do vetor (a divergência)
     onde n = `dim'. Se o argumento para a função for `g' então a
     divergência do tensor de Einstein será formada e pode ser zero.
     Adicionalmente, a divergência (vetor) é dada no array chamado
     `div'.

 -- Função: cgeodesic (<dis>)
     Uma função no pacote `ctensor'.  `cgeodesic' calcula as equações
     geodésicas de movimento para uma dada métrica.  Elas são
     armazenadas no array `geod[i]'.  Se o argumento <dis> for `true'
     então essas equações são mostradas.


 -- Função: bdvac (<f>)
     Gera as componentes covariantes das equações de campo de vácuo da
     teoria de gravitação de Brans-Dicke. O campo escalar é especificado
     através do argumento <f>, que pode ser um nome de função (com
     apóstrofo) com dependências funcionais, e.g., `'p(x)'.

     As componentes de segunda categoria do tensor campo covariante são
     as componentes de segunda categoria representadas pelo array `bd'.


 -- Função: invariant1 ()
     Gera o tensor misto de Euler-Lagrange (equações de campo) para a
     densidade invariante de R^2. As equações de campo são componentes
     de um array chamado `inv1'.


 -- Função: invariant2 ()
     *** NOT YET IMPLEMENTED ***

     Gera o tensor misto de Euler-Lagrange (equações de campo) para a
     densidade invariante de `ric[i,j]*uriem[i,j]'. As equações de
     campo são as componentes de um array chamado `inv2'.


 -- Função: bimetric ()
     *** NOT YET IMPLEMENTED ***

     Gera as euauações de campo da teoria bimétrica de Rosen. As
     equações de campo são as componentes de um array chamado `rosen'.


28.2.8 Funções utilitárias
--------------------------

 -- Função: diagmatrixp (<M>)
     Retorna `true' se <M> for uma matriz diagonal ou um array (2D).


 -- Função: symmetricp (<M>)
     Retorna `true' se <M> for uma matriz simétrica ou um array (2D).


 -- Função: ntermst (<f>)
     Fornece ao usuário um rápido quadro do "tamanho" do tensor
     duplamente subscrito (array) <f>.  Imprime uma lista de dois
     elementos onde o segundo elemento corresponde a N-TERMOS de
     componentes especificadas através dos primeiros elementos.  Nesse
     caminho, é possível rapidamente encontrar as expressões não nulas
     e tentar simplificação.


 -- Função: cdisplay (<ten>)
     Mostra todos os elementos do tensor <ten>, como representados por
     um array multidimensional. Tensores de categoria 0 e 1, assim como
     outros tipos de variáveis, são mostrados com `ldisplay'. Tensores
     de categoria 2 são mostrados como matrizes bidimensionais,
     enquanto tensores de alta categoria são mostrados como uma lista
     de matrizes bidimensionais. Por exemplo, o tensor de Riemann da
     métrica de Schwarzschild pode ser visto como:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) ratfac:true;
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) riemann(false);
          (%o4)                                done
          (%i5) cdisplay(riem);
                         [ 0               0                    0            0      ]
                         [                                                          ]
                         [                              2                           ]
                         [      3 m (r - 2 m)   m    2 m                            ]
                         [ 0  - ------------- + -- - ----       0            0      ]
                         [            4          3     4                            ]
                         [           r          r     r                             ]
                         [                                                          ]
              riem     = [                                 m (r - 2 m)              ]
                  1, 1   [ 0               0               -----------       0      ]
                         [                                      4                   ]
                         [                                     r                    ]
                         [                                                          ]
                         [                                              m (r - 2 m) ]
                         [ 0               0                    0       ----------- ]
                         [                                                   4      ]
                         [                                                  r       ]

                                          [    2 m (r - 2 m)       ]
                                          [ 0  -------------  0  0 ]
                                          [          4             ]
                                          [         r              ]
                               riem     = [                        ]
                                   1, 2   [ 0        0        0  0 ]
                                          [                        ]
                                          [ 0        0        0  0 ]
                                          [                        ]
                                          [ 0        0        0  0 ]

                                          [         m (r - 2 m)    ]
                                          [ 0  0  - -----------  0 ]
                                          [              4         ]
                                          [             r          ]
                               riem     = [                        ]
                                   1, 3   [ 0  0        0        0 ]
                                          [                        ]
                                          [ 0  0        0        0 ]
                                          [                        ]
                                          [ 0  0        0        0 ]

                                          [            m (r - 2 m) ]
                                          [ 0  0  0  - ----------- ]
                                          [                 4      ]
                                          [                r       ]
                               riem     = [                        ]
                                   1, 4   [ 0  0  0        0       ]
                                          [                        ]
                                          [ 0  0  0        0       ]
                                          [                        ]
                                          [ 0  0  0        0       ]

                                         [       0         0  0  0 ]
                                         [                         ]
                                         [       2 m               ]
                                         [ - ------------  0  0  0 ]
                              riem     = [    2                    ]
                                  2, 1   [   r  (r - 2 m)          ]
                                         [                         ]
                                         [       0         0  0  0 ]
                                         [                         ]
                                         [       0         0  0  0 ]

                             [     2 m                                         ]
                             [ ------------  0        0               0        ]
                             [  2                                              ]
                             [ r  (r - 2 m)                                    ]
                             [                                                 ]
                             [      0        0        0               0        ]
                             [                                                 ]
                  riem     = [                         m                       ]
                      2, 2   [      0        0  - ------------        0        ]
                             [                     2                           ]
                             [                    r  (r - 2 m)                 ]
                             [                                                 ]
                             [                                         m       ]
                             [      0        0        0         - ------------ ]
                             [                                     2           ]
                             [                                    r  (r - 2 m) ]

                                          [ 0  0       0        0 ]
                                          [                       ]
                                          [            m          ]
                                          [ 0  0  ------------  0 ]
                               riem     = [        2              ]
                                   2, 3   [       r  (r - 2 m)    ]
                                          [                       ]
                                          [ 0  0       0        0 ]
                                          [                       ]
                                          [ 0  0       0        0 ]

                                          [ 0  0  0       0       ]
                                          [                       ]
                                          [               m       ]
                                          [ 0  0  0  ------------ ]
                               riem     = [           2           ]
                                   2, 4   [          r  (r - 2 m) ]
                                          [                       ]
                                          [ 0  0  0       0       ]
                                          [                       ]
                                          [ 0  0  0       0       ]

                                                [ 0  0  0  0 ]
                                                [            ]
                                                [ 0  0  0  0 ]
                                                [            ]
                                     riem     = [ m          ]
                                         3, 1   [ -  0  0  0 ]
                                                [ r          ]
                                                [            ]
                                                [ 0  0  0  0 ]

                                                [ 0  0  0  0 ]
                                                [            ]
                                                [ 0  0  0  0 ]
                                                [            ]
                                     riem     = [    m       ]
                                         3, 2   [ 0  -  0  0 ]
                                                [    r       ]
                                                [            ]
                                                [ 0  0  0  0 ]

                                         [   m                      ]
                                         [ - -   0   0       0      ]
                                         [   r                      ]
                                         [                          ]
                                         [        m                 ]
                                         [  0   - -  0       0      ]
                              riem     = [        r                 ]
                                  3, 3   [                          ]
                                         [  0    0   0       0      ]
                                         [                          ]
                                         [              2 m - r     ]
                                         [  0    0   0  ------- + 1 ]
                                         [                 r        ]

                                              [ 0  0  0    0   ]
                                              [                ]
                                              [ 0  0  0    0   ]
                                              [                ]
                                   riem     = [            2 m ]
                                       3, 4   [ 0  0  0  - --- ]
                                              [             r  ]
                                              [                ]
                                              [ 0  0  0    0   ]

                                          [       0        0  0  0 ]
                                          [                        ]
                                          [       0        0  0  0 ]
                                          [                        ]
                               riem     = [       0        0  0  0 ]
                                   4, 1   [                        ]
                                          [      2                 ]
                                          [ m sin (theta)          ]
                                          [ -------------  0  0  0 ]
                                          [       r                ]

                                          [ 0        0        0  0 ]
                                          [                        ]
                                          [ 0        0        0  0 ]
                                          [                        ]
                               riem     = [ 0        0        0  0 ]
                                   4, 2   [                        ]
                                          [         2              ]
                                          [    m sin (theta)       ]
                                          [ 0  -------------  0  0 ]
                                          [          r             ]

                                        [ 0  0          0          0 ]
                                        [                            ]
                                        [ 0  0          0          0 ]
                                        [                            ]
                             riem     = [ 0  0          0          0 ]
                                 4, 3   [                            ]
                                        [                2           ]
                                        [         2 m sin (theta)    ]
                                        [ 0  0  - ---------------  0 ]
                                        [                r           ]

                           [        2                                             ]
                           [   m sin (theta)                                      ]
                           [ - -------------         0                0         0 ]
                           [         r                                            ]
                           [                                                      ]
                           [                         2                            ]
                           [                    m sin (theta)                     ]
                riem     = [        0         - -------------         0         0 ]
                    4, 4   [                          r                           ]
                           [                                                      ]
                           [                                          2           ]
                           [                                   2 m sin (theta)    ]
                           [        0                0         ---------------  0 ]
                           [                                          r           ]
                           [                                                      ]
                           [        0                0                0         0 ]

          (%o5)                                done

 -- Função: deleten (<L>, <n>)
     Retorna uma nova lista consistindo de <L> com o <n>'ésimo elemento
     apagado.

28.2.9 Variáveis usadas por `ctensor'
-------------------------------------

 -- Variável de opção: dim
     Valor padrão: 4

     Uma opção no pacote `ctensor'.  `dim' é a dimensão de
     multiplicação com o padrão 4. O comando `dim: n' irá escolher a
     dimensão para qualquer outro valor `n'.


 -- Variável de opção: diagmetric
     Valor padrão: `false'

     Uma opção no pacote `ctensor'.  Se `diagmetric' for `true' rotinas
     especiais calculam todos os objetos geométricos (que possuem o
     tensor métrico explicitamente) levando em consideração a
     diagonalidade da métrica. Tempo de execuçào reduzido irá, com
     certeza, resultar dessa escolha. Nota: essa opção é escolhida
     automaticamente por `csetup' se uma métrica diagonal for
     especificada.


 -- Variável de opção: ctrgsimp
     Faz com que simplificações trigonométricas sejam usadas quando
     tensores forem calculados. Atualmente, `ctrgsimp' afeta somente
     cálculos envolvendo uma moldura móvel.


 -- Variável de opção: cframe_flag
     Faz com que cálculos sejam executados relativamente a uma moldura
     móvel em oposição a uma métrica holonômica. A moldura é definida
     através do array da moldura inversa `fri' e da métrica da moldura
     `lfg'. Para cálculos usando uma moldura Cartesiana, `lfg' pode ser
     a matriz unitária de dimensão apropriada; para cálculos em uma
     moldura de Lorentz, `lfg' pode ter a assinatura apropriada.


 -- Variável de opção: ctorsion_flag
     Faz com que o tensor de contorsão seja incluído no cálculo dos
     coeficientes de conecção. O tensor de contorsão por si mesmo é
     calculado através de `contortion' a partir do tensor `tr'
     fornecido pelo usuário.


 -- Variável de opção: cnonmet_flag
     Faz com que os coeficientes de não metricidade sejam incluídos no
     cálculo dos coeficientes de conecção. Os coeficientes de não
     metricidade são calculados a partir do vetor de não metricidade
     `nm' fornecido pelo usuário através da função `nonmetricity'.


 -- Variável de opção: ctayswitch
     Se escolhida para `true', faz com que alguns cálculos de `ctensor'
     sejam realizados usando expansões das séries de Taylor.
     atualmente, `christof', `ricci', `uricci', `einstein', e `weyl'
     levam em conta essa escolha.


 -- Variável de opção: ctayvar
     Variável usada pela expansão de séries de Taylor se `ctayswitch' é
     escolhida para `true'.


 -- Variável de opção: ctaypov
     Maximo expoente usado em expansões de séries de Taylor quando
     `ctayswitch' for escolhida para `true'.


 -- Variável de opção: ctaypt
     Ponto em torno do qual expansões de séries de Taylor sao
     realizadas quando `ctayswitch' for escolhida para `true'.


 -- Variável de sistema: gdet
     O determinante do tensor métrico `lg'. Calculado através de
     `cmetric' quando `cframe_flag' for escolhido para `false'.


 -- Variável de opção: ratchristof
     Faz com que simplificações racionais sejam aplicadas através de
     `christof'.


 -- Variável de opção: rateinstein
     Valor padrão: `true'

     Se `true' simplificação racional será executada sobre as
     componentes não nulas de tensores de Einstein; se `ratfac' for
     `true' então as componentes irão também ser fatoradas.


 -- Variável de opção: ratriemann
     Valor padrão: `true'

     Um dos comutadores que controlam simplificações dos tensores de
     Riemann; se `true', então simplificações racionais irão ser
     concluídas; se `ratfac' for `true' então cada uma das componentes
     irá também ser fatorada.


 -- Variável de opção: ratweyl
     Valor padrão: `true'

     Se `true', esse comutador faz com que a função de `weyl' aplique
     simplificações racionais aos valores do tensor de Weyl. Se
     `ratfac' for `true', então as componentes irão também ser
     fatoradas.

 -- Variável: lfg
     A moldura métrica covariante. Por padrão, é inicializada para a
     moldura tetradimensional de Lorentz com assinatura (+,+,+,-).
     Usada quando `cframe_flag' for `true'.

 -- Variável: ufg
     A métrica da moldura inversa. Calculada de `lfg' quando `cmetric'
     for chamada enquanto `cframe_flag' for escolhida para `true'.

 -- Variável: riem
     O tensor de categoria (3,1) de Riemann. Calculado quando a
     função `riemann' é invocada. Para informação sobre ordenação de
     índices, veja a descrição de `riemann'.

     Se `cframe_flag' for `true', `riem' é calculado a partir do tensor
     covariante de Riemann `lriem'.


 -- Variável: lriem
     O tensor covariante de Riemann. Calculado através de `lriemann'.


 -- Variável: uriem
     O tensor contravariante de Riemann. Calculado através de
     `uriemann'.


 -- Variável: ric
     O tensor misto de Ricci. Calculado através de `ricci'.


 -- Variável: uric
     O tensor contravariante de Ricci. Calculado através de `uricci'.


 -- Variável: lg
     O tensor métrico. Esse tensor deve ser especificado (como uma
     `dim' através da matriz `dim') antes que outro cálculo possa ser
     executado.


 -- Variável: ug
     O inverso do tensor métrico. Calculado através de `cmetric'.


 -- Variável: weyl
     O tensor de Weyl. Calculado através de `weyl'.


 -- Variável: fb
     Coeficientes delimitadores da moldura, como calculado através de
     `frame_bracket'.


 -- Variável: kinvariant
     O invariante de Kretchmann. Calculado através de `rinvariant'.


 -- Variável: np
     Um tetrad nulo de Newman-Penrose. Calculado através de `nptetrad'.


 -- Variável: npi
     O índice ascendente do tetrad nulo de Newman-Penrose. Calculado
     através de `nptetrad'.  Definido como `ug.np'. O produto
     `np.transpose(npi)' é constante:

          (%i39) trigsimp(np.transpose(npi));
                                        [  0   - 1  0  0 ]
                                        [                ]
                                        [ - 1   0   0  0 ]
          (%o39)                        [                ]
                                        [  0    0   0  1 ]
                                        [                ]
                                        [  0    0   1  0 ]


 -- Variável: tr
     Tensor de categoria 3 fornecido pelo usuário representando torsão.
     Usado por `contortion'.

 -- Variável: kt
     O tensor de contorsão, calculado a partir de `tr' através de
     `contortion'.

 -- Variável: nm
     Vetor de não metrcidade fornecido pelo usuário. Usado por
     `nonmetricity'.

 -- Variável: nmc
     Os coeficientes de não metricidade, calculados a partir de `nm'
     por `nonmetricity'.


 -- Variável de sistema: tensorkill
     Variável indicando se o pacote tensor foi inicializado. Escolhida
     e usada por `csetup', retornada ao seu valor original através de
     `init_ctensor'.


 -- Variável de opção: ct_coords
     Valor padrão: `[]'

     Uma opção no pacote `ctensor'.  `ct_coords' contém uma lista de
     coordenadas.  Enquanto normalmente definida quando a função
     `csetup' for chamada, se pode redefinir as coordenadas com a
     atribuição `ct_coords: [j1, j2, ..., jn]' onde os j's são os novos
     nomes de coordenadas.  Veja também `csetup'.


28.2.10 Nomes reservados
------------------------

Os seguintes nomes são usados internamente pelo pacote `ctensor' e não
devem ser redefinidos:

       Name         Description
       ---------------------------------------
       _lg()        Avalia para `lfg' se a moldura métrica for usada,
                         para `lg' de outra forma
       _ug()        Avalia para `ufg' se a moldura métrica for usada,
                         para `ug' de outra forma
       cleanup()    Remove ítens da lista `deindex'
       contract4()  Usado por psi()
       filemet()    Usado por csetup() quando lendo a métrica de um arquivo
       findde1()    Usado por findde()
       findde2()    Usado por findde()
       findde3()    Usado por findde()
       kdelt()      Delta de Kronecker (não generalizado)
       newmet()     Usado por csetup() para escolher uma métrica
                         interativamente
       setflags()   Usado por init_ctensor()
       readvalue()
       resimp()
       sermet()     Usado por csetup() para informar uma métricacom série
                         de Taylor
       txyzsum()
       tmetric()    Moldura métrica, usado por cmetric() quando
                         cframe_flag:true
       triemann()   Tensor de Riemann em base de moldura, usado quando
                         cframe_flag:true
       tricci()     Tensor de Ricci em base de moldura, usada quando
                         cframe_flag:true
       trrc()       Coeficientes de rotação de Ricci, usado por
                         christof()
       yesp()

28.2.11 Modificações
--------------------

Em Novembro de 2004, o pacote `ctensor' foi extensivamente reescrito.
Muitas funções e variáveis foram renomeadas com o objetivo de tornar o
pacote com a versão comercial do Macsyma.

       Novo Nome    Nome Antigo     Descrição
       --------------------------------------------------------------------
       ctaylor()    DLGTAYLOR()     Expansão da série de Taylor de uma
       -----------------------------expressão
       lgeod[]      EM              Equações geodésicas
       ein[]        G[]             Tensor misto de Einstein
       ric[]        LR[]            Tensor misto de Ricci
       ricci()      LRICCICOM()     Calcula o tensor misto de Ricci
       ctaypov      MINP            Maximo expoente em expansões de séries de
       -----------------------------Taylor
       cgeodesic()  MOTION          Calcula as equações geodésicas
       ct_coords    OMEGA           Coordenadas métricas
       ctayvar      PARAM           Variável de expansão de séries de
       -----------------------------Taylor
       lriem[]      R[]             Tensor covariante de Riemann
       uriemann()   RAISERIEMANN()  Calcula o tensor contravariante de
       -----------------------------Riemann
       ratriemann   RATRIEMAN       Simplificação racional do tensor de
       -----------------------------Riemann
       uric[]       RICCI[]         Tensor de Ricci contravariante
       uricci()     RICCICOM()      Calcula o tensor de Ricci contravariante
       cmetric()    SETMETRIC()     Escolhe a métrica
       ctaypt       TAYPT           Ponto para expansões de séries de Taylor
       ctayswitch   TAYSWITCH       Escolhe o comutador de séries de Taylor
       csetup()     TSETUP()        Inicia sessão interativa de configuração
       ctransform() TTRANSFORM()    Transformação de coordenadas interativa
       uriem[]      UR[]            Tensor contravariante de Riemann
       weyl[]       W[]             Tensor (3,1) de Weyl


File: maxima.info,  Node: Pacote atensor,  Next: Séries,  Prev: ctensor,  Up: Top

29 Pacote atensor
*****************

* Menu:

* Introdução ao Pacote atensor::
* Funções e Variáveis Definidas para o Pacote atensor::


File: maxima.info,  Node: Introdução ao Pacote atensor,  Next: Funções e Variáveis Definidas para o Pacote atensor,  Prev: Pacote atensor,  Up: Pacote atensor

29.1 Introdução ao Pacote atensor
=================================

`atensor' é um pacote de manipulção de tensores algébricos.  Para usar
`atensor', digite `load(atensor)', seguido por uma chamada à função
`init_atensor'.

   A essência de `atensor' é um conjunto de regras de simplificação
para o operador de produto (ponto) não comutativo ("`.'").  `atensor'
reconhece muitos tipos de álgebra; as regras de simplificação
correspondentes são ativadas quando a função `init_atensor' é chamada.

   A compatibilidade de `atensor' pode ser demonstrada pela
definição da álgebra de quatérnios como uma álgera-Clifford Cl(0,2) com
dois vetores fundamentais.  As três unidades quaterniônicas imaginárias
fundamentais são então os dois vetores base  e seu produto, i.e.:

         i = v     j = v     k = v  .  v
              1         2         1    2

   Embora o pacote `atensor' tenha uma definição interna para a álgebra
dos quatérnios, isso não foi usado nesse exemplo, no qual nós nos
esforçamos para construir a tabela de multiplicação dos quatérnios como
uma matriz:


     (%i1) load(atensor);
     (%o1)       /share/tensor/atensor.mac
     (%i2) init_atensor(clifford,0,0,2);
     (%o2)                                done
     (%i3) atensimp(v[1].v[1]);
     (%o3)                                 - 1
     (%i4) atensimp((v[1].v[2]).(v[1].v[2]));
     (%o4)                                 - 1
     (%i5) q:zeromatrix(4,4);
                                     [ 0  0  0  0 ]
                                     [            ]
                                     [ 0  0  0  0 ]
     (%o5)                           [            ]
                                     [ 0  0  0  0 ]
                                     [            ]
                                     [ 0  0  0  0 ]
     (%i6) q[1,1]:1;
     (%o6)                                  1
     (%i7) for i thru adim do q[1,i+1]:q[i+1,1]:v[i];
     (%o7)                                done
     (%i8) q[1,4]:q[4,1]:v[1].v[2];
     (%o8)                               v  .  v
                                          1    2
     (%i9) for i from 2 thru 4 do for j from 2 thru 4 do
           q[i,j]:atensimp(q[i,1].q[1,j]);
     (%o9)                                done
     (%i10) q;
                        [    1        v         v      v  .  v  ]
                        [              1         2      1    2 ]
                        [                                      ]
                        [   v         - 1     v  .  v    - v    ]
                        [    1                 1    2      2   ]
     (%o10)             [                                      ]
                        [   v      - v  .  v     - 1      v     ]
                        [    2        1    2              1    ]
                        [                                      ]
                        [ v  .  v      v        - v       - 1   ]
                        [  1    2      2          1            ]

   `atensor' reconhece como bases vetoriais símbolos indexados, onde o
símbolo é aquele armazenado em `asymbol' e o iíndice está entre 1 e
`adim'.  Para símbolos indexado, e somente para símbolos indexados, as
formas bilineares `sf', `af', e `av' são avaliadas.  A avaliação
substitui os valores  de `aform[i,j]' em lugar de `fun(v[i],v[j])' onde
`v' representa o valor de `asymbol' e `fun' é ainda `af' ou `sf'; ou,
isso substitui `v[aform[i,j]]' em lugar de `av(v[i],v[j])'.

   Desnecessário dizer, as funções `sf', `af' e `av' podem ser
redefinidas.

   Quando o pacote `atensor' é chamado, os seguintes sinalizadores são
configurados:

     dotscrules:true;
     dotdistrib:true;
     dotexptsimp:false;

   Se você deseja experimentar com uma álgebra não associativa, você
pode também considerar a configuração de `dotassoc' para `false'.
Nesse caso, todavia, `atensimp' não stará sempre habilitado a obter as
simplificações desejadas.


File: maxima.info,  Node: Funções e Variáveis Definidas para o Pacote atensor,  Prev: Introdução ao Pacote atensor,  Up: Pacote atensor

29.2 Funções e Variáveis Definidas para o Pacote atensor
========================================================

 -- Função: init_atensor (<alg_type>, <opt_dims>)
 -- Função: init_atensor (<alg_type>)
     Inicializa o pacote `atensor' com o tipo especificado de álgebra.
     <alg_type> pode ser um dos seguintes:

     `universal': A álgebra universal tendo regras não comutativas.

     `grassmann': A álgebra de Grassman é definida pela relação de
     comutação `u.v+v.u=0'.

     `clifford': A álgebra de Clifford é definida pela relação de
     comutação `u.v+v.u=-2*sf(u,v)' onde `sf' é a função valor-escalar
     simétrico.  Para essa álgebra, <opt_dims> pode ser acima de três
     inteiros não negativos, representando o número de dimensões
     positivas, dimensões degeneradas, e dimensões negativas da
     álgebra, respectivamente.  Se quaisquer valores <opt_dims> são
     fornecidos, `atensor' irá configurar os valores de `adim' e
     `aform' apropriadamente.  Caso contrário, `adim' irá por padrão
     para 0 e `aform' não será definida.

     `symmetric': A álgebra simétrica é definida pela relação de
     comutação `u.v-v.u=0'.

     `symplectic': A álgebra simplética é definida pela relação de
     comutação `u.v-v.u=2*af(u,v)' onde `af' é uma função valor-escalar
     antisimétrica.  Para a álgebra simplética, <opt_dims> pode mais de
     dois inteiros não negativos, representando a dimensão não
     degenerada e e a dimensão degenerada, respectivamente.  Se
     quaisquer valores <opt_dims> são fornecidos, `atensor' irá
     configurar os valores de `adim' e `aform' apropriadamente.  Caso
     contrário, `adim' irá por padrão para 0 e `aform' não será
     definida.

     `lie_envelop': O invólucro da álgebra de Lie é definido pela
     relação de comutação `u.v-v.u=2*av(u,v)' onde `av' é uma função
     antisimétrica.

     A função `init_atensor' também reconhece muitos tipos
     pré-definidos de álgebra:

     `complex' implementa a álgebra de números complexos como a álgebra
     de Clifford Cl(0,1).  A chamada `init_atensor(complex)' é
     equivalente a `init_atensor(clifford,0,0,1)'.

     `quaternion' implementa a álgebra de quatérnios.  A chamada
     `init_atensor(quaternion)' é equivalente a
     `init_atensor(clifford,0,0,2)'.

     `pauli' implementa a álgebra de Pauli-spinors como a
     Clifford-álgebra Cl(3,0).  Uma chamada a `init_atensor(pauli)' é
     equivalente a `init_atensor(clifford,3)'.

     `dirac' implementa a álgebra de Dirac-spinors como a
     Clifford-álgebra Cl(3,1).  Uma chamada a `init_atensor(dirac)' é
     equivalente a `init_atensor(clifford,3,0,1)'.


 -- Função: atensimp (<expr>)
     Simplifica a expressão algébrica de tensores <expr> conforme as
     regras configuradas por uma chamada a `init_atensor'.
     Simplificações incluem aplicação recursiva de relações comutativas
     e resoluções de chamadas a `sf', `af', e `av' onde for aplicável.
     Uma salvaguarda é usada para garantir que a função sempre termine,
     mesmo para expressões complexas.


 -- Função: alg_type
     O tipo de álgebra.  Valores válidos sáo `universal', `grassmann',
     `clifford', `symmetric', `symplectic' e `lie_envelop'.


 -- Variável: adim
     Valor padrão: 0

     A dimensionalidade da álgebra.  `atensor' usa o valor de `adim'
     para determinar se um objeto indexado é uma base vetorial válida.
     Veja `abasep'.


 -- Variável: aform
     Valor padrão para as formas bilineares `sf', `af', e `av'.  O
     padrão é a matriz identidade `ident(3)'.


 -- Variável: asymbol
     Valor padrão: `v'

     O símbolo para bases vetoriais.


 -- Função: sf (<u>, <v>)
     É uma função escalar simétrica que é usada em relações comutativas.
     A implementação padrão verifica se ambos os argumentos são bases
     vetoriais usando `abasep' e se esse for o caso, substitui o valor
     correspondente da matriz `aform'.


 -- Função: af (<u>, <v>)
     É uma função escalar antisimétrica que é usada em relações
     comutativas.  A implementação padrão verifica se ambos os
     argumentos são bases vetoriais usando `abasep' e se esse for o
     caso, substitui o valor correspondente da matriz `aform'.


 -- Função: av (<u>, <v>)
     É uma função antisimétrica que é usada em relações comutativas.  A
     implementação padrão verifica se ambos os argumentos são bases
     vetoriais usando `abasep' e se esse for o caso, substitui o valor
     correspondente da matriz `aform'.

     Por exemplo:

          (%i1) load(atensor);
          (%o1)       /share/tensor/atensor.mac
          (%i2) adim:3;
          (%o2)                                  3
          (%i3) aform:matrix([0,3,-2],[-3,0,1],[2,-1,0]);
                                         [  0    3   - 2 ]
                                         [               ]
          (%o3)                          [ - 3   0    1  ]
                                         [               ]
                                         [  2   - 1   0  ]
          (%i4) asymbol:x;
          (%o4)                                  x
          (%i5) av(x[1],x[2]);
          (%o5)                                 x
                                                 3


 -- Função: abasep (<v>)
     Verifica se esse argumento é uma base vetorial `atensor' .  E
     será, se ele for um símbolo indexado, com o símbolo sendo o mesmo
     que o valor de `asymbol', e o índice tiver o mesmo valor numérico
     entre 1 e `adim'.



File: maxima.info,  Node: Séries,  Next: Teoria dos Números,  Prev: Pacote atensor,  Up: Top

30 Séries
*********

* Menu:

* Introdução a Séries::
* Funções e Variáveis Definidas para Séries::


File: maxima.info,  Node: Introdução a Séries,  Next: Funções e Variáveis Definidas para Séries,  Prev: Séries,  Up: Séries

30.1 Introdução a Séries
========================

Maxima contém funções `taylor' e `powerseries' (séries de potência)
para encontrar as séries de funções diferenciáveis.   Maxima também tem
ferramentas  tais como `nusum' capazes de encontrar a forma fechada de
algumas séries.   Operações tais como adição e multiplicação travalham
da forma usual sobre séries.  Essa seção apresenta as variáveis globais
que controlam a expansão.


File: maxima.info,  Node: Funções e Variáveis Definidas para Séries,  Prev: Introdução a Séries,  Up: Séries

30.2 Funções e Variáveis Definidas para Séries
==============================================

 -- Variável de opção: cauchysum
     Valor padrão: `false'

     Quando multiplicando adições jutas com `inf' como seus limites
     superiores, se `sumexpand' for `true' e `cauchysum' for `true'
     então o produto de Cauchy será usado em lugar do produto usual.
     No produto de Cauchy o índice do somatório interno é uma função do
     índice do externo em lugar de variar independentemente.

     Exemplo:

          (%i1) sumexpand: false$
          (%i2) cauchysum: false$
          (%i3) s: sum (f(i), i, 0, inf) * sum (g(j), j, 0, inf);
                                inf         inf
                                ====        ====
                                \           \
          (%o3)                ( >    f(i))  >    g(j)
                                /           /
                                ====        ====
                                i = 0       j = 0
          (%i4) sumexpand: true$
          (%i5) cauchysum: true$
          (%i6) ''s;
                           inf     i1
                           ====   ====
                           \      \
          (%o6)             >      >     g(i1 - i2) f(i2)
                           /      /
                           ====   ====
                           i1 = 0 i2 = 0


 -- Função: deftaylor (<f_1>(<x_1>), <expr_1>, ..., <f_n>(<x_n>),
          <expr_n>)
     Para cada função <f_i> de uma variável <x_i>, `deftaylor' define
     <expr_i> como a séries de Taylor sobre zero.  <expr_i> é
     tipicamente um polinômio em <x_i> ou um somatório; expressões mais
     gerais são aceitas por `deftaylor' sem reclamações.

     `powerseries (<f_i>(<x_i>), <x_i>, 0)' retorna as séries definidas
     por `deftaylor'.

     `deftaylor' retorna uma lista das funções <f_1>, ..., <f_n>.
     `deftaylor' avalia seus argumentos.

     Exemplo:

          (%i1) deftaylor (f(x), x^2 + sum(x^i/(2^i*i!^2), i, 4, inf));
          (%o1)                          [f]
          (%i2) powerseries (f(x), x, 0);
                                inf
                                ====      i1
                                \        x         2
          (%o2)                  >     -------- + x
                                /       i1    2
                                ====   2   i1!
                                i1 = 4
          (%i3) taylor (exp (sqrt (f(x))), x, 0, 4);
                                2         3          4
                               x    3073 x    12817 x
          (%o3)/T/     1 + x + -- + ------- + -------- + . . .
                               2     18432     307200


 -- Variável de opção: maxtayorder
     Valor padrão: `true'

     Quando `maxtayorder' for `true', durante a manipulação algébrica
     de séries (truncadas) de Taylor, `taylor' tenta reter tantos
     termos quantos forem conhecidos serem corretos.


 -- Função: niceindices (<expr>)
     Renomeia os índices de adições e produtos em <expr>.
     `niceindices' tenta renomear cada índice para o valor de
     `niceindicespref[1]', a menos que o nome apareça nas parcelas do
     somatório ou produtório, nesses casos `niceindices' tenta os
     elementos seguintes de `niceindicespref' por sua vez, até que uma
     varável não usada unused variable seja encontrada.  Se a lista
     inteira for exaurida, índices adicionais são constrídos através da
     anexaao de inteiros ao valor de `niceindicespref[1]', e.g., `i0',
     `i1', `i2', ....

     `niceindices' retorna uma expressão.  `niceindices' avalia seu
     argumento.

     Exemplo:

          (%i1) niceindicespref;
          (%o1)                  [i, j, k, l, m, n]
          (%i2) product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
                           inf    inf
                          /===\   ====
                           ! !    \
          (%o2)            ! !     >      f(bar i j + foo)
                           ! !    /
                          bar = 1 ====
                                  foo = 1
          (%i3) niceindices (%);
                               inf  inf
                              /===\ ====
                               ! !  \
          (%o3)                ! !   >    f(i j l + k)
                               ! !  /
                              l = 1 ====
                                    k = 1


 -- Variável de opção: niceindicespref
     Valor padrão: `[i, j, k, l, m, n]'

     `niceindicespref' é a lista da qual `niceindices' pega os nomes
     dos índices de adições e produtos products.

     Os elementos de `niceindicespref' são tipicamente nomes de
     variáveis, embora que não seja imposto por `niceindices'.

     Exemplo:

          (%i1) niceindicespref: [p, q, r, s, t, u]$
          (%i2) product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
                           inf    inf
                          /===\   ====
                           ! !    \
          (%o2)            ! !     >      f(bar i j + foo)
                           ! !    /
                          bar = 1 ====
                                  foo = 1
          (%i3) niceindices (%);
                               inf  inf
                              /===\ ====
                               ! !  \
          (%o3)                ! !   >    f(i j q + p)
                               ! !  /
                              q = 1 ====
                                    p = 1


 -- Função: nusum (<expr>, <x>, <i_0>, <i_1>)
     Realiza o somatório hipergeométrico indefinido de <expr> com
     relação a <x> usando um procedimento de decisão devido a R.W.
     Gosper.  <expr> e o resultado deve ser expressável como produtos
     de expoentes inteiros, fatoriais, binomios, e funções recionais.

     Os termos "definido" and "e somatório indefinido" são usados
     analogamente a "definida" and "integração indefinida".  Adicionar
     indefinidamente significa dar um resultado simólico para a
     adição sobre intervalos de comprimentos de variáveis, não apenas
     e.g. 0 a infinito.  Dessa forma, uma vez que não existe fórmula
     para a adição parcial geral de séries binomiais, `nusum' não pode
     fazer isso.

     `nusum' e `unsum' conhecem um porco sobre adições e subtrações de
     produtos finitos.  Veja também `unsum'.

     Exemplos:

          (%i1) nusum (n*n!, n, 0, n);

          Dependent equations eliminated:  (1)
          (%o1)                     (n + 1)! - 1
          (%i2) nusum (n^4*4^n/binomial(2*n,n), n, 0, n);
                               4        3       2              n
                2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
          (%o2) ------------------------------------------------ - ------
                              693 binomial(2 n, n)                 3 11 7
          (%i3) unsum (%, n);
                                        4  n
                                       n  4
          (%o3)                   ----------------
                                  binomial(2 n, n)
          (%i4) unsum (prod (i^2, i, 1, n), n);
                              n - 1
                              /===\
                               ! !   2
          (%o4)              ( ! !  i ) (n - 1) (n + 1)
                               ! !
                              i = 1
          (%i5) nusum (%, n, 1, n);

          Dependent equations eliminated:  (2 3)
                                      n
                                    /===\
                                     ! !   2
          (%o5)                      ! !  i  - 1
                                     ! !
                                    i = 1


 -- Função: pade (<taylor_series>, <numer_deg_bound>, <denom_deg_bound>)
     Retorna uma lista de todas as funções racionais que possuem a dada
     expansão da séries de Taylor onde a adição dos graus do numerador
     e do denominador é menor que ou igual ao nível de truncação das
     séries de potência, i.e.  são "melhores" aproximações, e que
     adicionalmente satisfazem o grau especificado associado.

     <taylor_series> é uma séries de Taylor de uma variável.
     <numer_deg_bound> e <denom_deg_bound> são inteiros positivos
     especificando o grau associado sobre o numerador e o denominador.

     <taylor_series> podem também ser séries de Laurent, e o grau
     associado pode ser `inf' que acarreta todas funções racionais cujo
     grau total for menor que ou igual ao comprimento das séries de
     potências a serem retornadas.  O grau total é definido como
     `<numer_deg_bound> + <denom_deg_bound>'.  O comprimento de séries
     de potência é definido como `"nível de trncação" + 1 - min(0,
     "ordem das séries")'.

          (%i1) taylor (1 + x + x^2 + x^3, x, 0, 3);
                                        2    3
          (%o1)/T/             1 + x + x  + x  + . . .
          (%i2) pade (%, 1, 1);
                                           1
          (%o2)                       [- -----]
                                         x - 1
          (%i3) t: taylor(-(83787*x^10 - 45552*x^9 - 187296*x^8
                             + 387072*x^7 + 86016*x^6 - 1507328*x^5
                             + 1966080*x^4 + 4194304*x^3 - 25165824*x^2
                             + 67108864*x - 134217728)
                 /134217728, x, 0, 10);
                              2    3       4       5       6        7
                       x   3 x    x    15 x    23 x    21 x    189 x
          (%o3)/T/ 1 - - + ---- - -- - ----- + ----- - ----- - ------
                       2    16    32   1024    2048    32768   65536

                                            8         9          10
                                      5853 x    2847 x    83787 x
                                    + ------- + ------- - --------- + . . .
                                      4194304   8388608   134217728
          (%i4) pade (t, 4, 4);
          (%o4)                          []

     Não existe função racional de grau 4 numerador/denominador, com
     essa expansão de série de potência.  Você obrigatoriamente em
     geral tem grau do numerador e grau do denominador adicionando para
     cima ao menor grau das séries de potência, com o objetivo de ter
     disponível coeficientes desconhecidos para resolver.

          (%i5) pade (t, 5, 5);
                               5                4                 3
          (%o5) [- (520256329 x  - 96719020632 x  - 489651410240 x

                            2
           - 1619100813312 x  - 2176885157888 x - 2386516803584)

                         5                 4                  3
          /(47041365435 x  + 381702613848 x  + 1360678489152 x

                            2
           + 2856700692480 x  + 3370143559680 x + 2386516803584)]


 -- Variável de opção: powerdisp
     Valor padrão: `false'

     Quando `powerdisp' for `true', uma adição é mostrada com seus
     termos em ordem do crescimento do expoente.  Dessa forma um
     polinômio é mostrado como séries de potências truncadas, com o
     termo constante primeiro e o maior expoente por último.

     Por padão, termos de uma adição são mostrados em ordem do expoente
     decrescente.


 -- Função: powerseries (<expr>, <x>, <a>)
     Retorna a forma geral expansão de séries de potência para <expr>
     na variável <x> sobre o ponto <a> (o qual pode ser `inf' para
     infinito).

     Se `powerseries' incapaz de expandir <expr>, `taylor' pode dar os
     primeiros muitos termos de séries.

     Quando `verbose' for `true', `powerseries' mostra mensagens de
     progresso.

          (%i1) verbose: true$
          (%i2) powerseries (log(sin(x)/x), x, 0);
          can't expand
                                           log(sin(x))
          so we'll try again after applying the rule:
                                                  d
                                                / -- (sin(x))
                                                [ dx
                                  log(sin(x)) = i ----------- dx
                                                ]   sin(x)
                                                /
          in the first simplification we have returned:
                                       /
                                       [
                                       i cot(x) dx - log(x)
                                       ]
                                       /
                              inf
                              ====        i1  2 i1             2 i1
                              \      (- 1)   2     bern(2 i1) x
                               >     ------------------------------
                              /                i1 (2 i1)!
                              ====
                              i1 = 1
          (%o2)                -------------------------------------
                                                2


 -- Variável de opção: psexpand
     Valor padrão: `false'

     Quando `psexpand' for `true', uma expressão função racional
     extendida é mostrada completamente expandida.  O comutador
     `ratexpand' tem o mesmo efeito.

     Quando `psexpand' for `false', uma expressão de várias variáveis é
     mostrada apenas como no pacote de função racional.

     Quando `psexpand' for  `multi', então termos com o mesmo grau
     total nas variáveis são agrupados juntos.


 -- Função: revert (<expr>, <x>)
 -- Função: revert2 (<expr>, <x>, <n>)
     Essas funções retornam a reversão de <expr>, uma série de Taylor
     sobre zero na variável <x>.  `revert' retorna um polinômio de grau
     igual ao maior expoente em <expr>.  `revert2' retorna um polinômio
     de grau <n>, o qual pode ser maior que, igual a, ou menor que o
     grau de <expr>.

     `load ("revert")' chama essas funções.

     Exemplos:

          (%i1) load ("revert")$
          (%i2) t: taylor (exp(x) - 1, x, 0, 6);
                             2    3    4    5     6
                            x    x    x    x     x
          (%o2)/T/      x + -- + -- + -- + --- + --- + . . .
                            2    6    24   120   720
          (%i3) revert (t, x);
                         6       5       4       3       2
                     10 x  - 12 x  + 15 x  - 20 x  + 30 x  - 60 x
          (%o3)/R/ - --------------------------------------------
                                          60
          (%i4) ratexpand (%);
                               6    5    4    3    2
                              x    x    x    x    x
          (%o4)             - -- + -- - -- + -- - -- + x
                              6    5    4    3    2
          (%i5) taylor (log(x+1), x, 0, 6);
                              2    3    4    5    6
                             x    x    x    x    x
          (%o5)/T/       x - -- + -- - -- + -- - -- + . . .
                             2    3    4    5    6
          (%i6) ratsimp (revert (t, x) - taylor (log(x+1), x, 0, 6));
          (%o6)                           0
          (%i7) revert2 (t, x, 4);
                                    4    3    2
                                   x    x    x
          (%o7)                  - -- + -- - -- + x
                                   4    3    2


 -- Função: taylor (<expr>, <x>, <a>, <n>)
 -- Função: taylor (<expr>, [<x_1>, <x_2>, ...], <a>, <n>)
 -- Função: taylor (<expr>, [<x>, <a>, <n>, 'asymp])
 -- Função: taylor (<expr>, [<x_1>, <x_2>, ...], [<a_1>, <a_2>, ...],
          [<n_1>, <n_2>, ...])
 -- Função: taylor (<expr>, [<x_1>, <a_1>, <n_1>], [<x_2>, <a_2>,
          <n_2>], ...)
     `taylor (<expr>, <x>, <a>, <n>)' expande a expressão <expr> em uma
     série truncada de Taylor ou de Laurent na variável <x> em torno do
     ponto <a>, contendo termos até `(<x> - <a>)^<n>'.

     Se <expr> é da forma `<f>(<x>)/<g>(<x>)' e `<g>(<x>)' não possui
     de grau acima do grau <n> então `taylor' tenta expandir `<g>(<x>)'
     acima do gau `2 <n>'.  Se existe ainda termos não zero, `taylor'
     dobra o grau de expansão de `<g>(<x>)' contanto que o grau da
     expansão o grau da expansão seja menor que ou igual a `<n>
     2^taylordepth'.

     `taylor (<expr>, [<x_1>, <x_2>, ...], <a>, <n>)' retorna uma série
     de potência truncada de grau <n> em todas as variáveis <x_1>,
     <x_2>, ...  sobre o ponto `(<a>, <a>, ...)'.

     `taylor (<expr>, [<x_1>, <a_1>, <n_1>], [<x_2>, <a_2>, <n_2>],
     ...)'  retorna uma série de potência truncada nas variáveis <x_1>,
     <x_2>, ...  sobre o ponto `(<a_1>, <a_2>, ...)', truncada em
     <n_1>, <n_2>, ....

     `taylor (<expr>, [<x_1>, <x_2>, ...], [<a_1>, <a_2>, ...], [<n_1>,
     <n_2>, ...])' retorna uma série de potência truncada nas variáveis
     <x_1>, <x_2>, ...  sobre o ponto `(<a_1>, <a_2>, ...)', truncada
     em <n_1>, <n_2>, ....

     `taylor (<expr>, [<x>, <a>, <n>, 'asymp])' retorna uma expansão de
     <expr> em expoentes negativos de `<x> - <a>'.  O termo de maior
     ordem é `(<x> - <a>)^<-n>'.

     Quando `maxtayorder' for `true', então durante maniplulação
     algébrica da séries de Taylor (truncada), `taylor' tenta reter
     tantos termos quantos forem conhecidos serem corretos.

     Quando `psexpand' for `true', uma expressão de função racional
     extendida é mostrada completamente expandida.  O comutador
     `ratexpand' tem o mesmo efeito.  Quando `psexpand' for `false',
     uma expressão de várias variáveis é mostrada apenas como no pacote
     de função racional.  Quando `psexpand' for  `multi', então os
     termos com o mesmo grau total nas variáveis são agrupados juntos.

     Veja também o comutador `taylor_logexpand' para controlar a
     expansão.

     Exemplos:

          (%i1) taylor (sqrt (sin(x) + a*x + 1), x, 0, 3);
                                     2             2
                       (a + 1) x   (a  + 2 a + 1) x
          (%o1)/T/ 1 + --------- - -----------------
                           2               8

                                             3      2             3
                                         (3 a  + 9 a  + 9 a - 1) x
                                       + -------------------------- + . . .
                                                     48
          (%i2) %^2;
                                              3
                                             x
          (%o2)/T/           1 + (a + 1) x - -- + . . .
                                             6
          (%i3) taylor (sqrt (x + 1), x, 0, 5);
                                 2    3      4      5
                            x   x    x    5 x    7 x
          (%o3)/T/      1 + - - -- + -- - ---- + ---- + . . .
                            2   8    16   128    256
          (%i4) %^2;
          (%o4)/T/                  1 + x + . . .
          (%i5) product ((1 + x^i)^2.5, i, 1, inf)/(1 + x^2);
                                   inf
                                  /===\
                                   ! !    i     2.5
                                   ! !  (x  + 1)
                                   ! !
                                  i = 1
          (%o5)                   -----------------
                                        2
                                       x  + 1
          (%i6) ev (taylor(%, x,  0, 3), keepfloat);
                                         2           3
          (%o6)/T/    1 + 2.5 x + 3.375 x  + 6.5625 x  + . . .
          (%i7) taylor (1/log (x + 1), x, 0, 3);
                                         2       3
                           1   1   x    x    19 x
          (%o7)/T/         - + - - -- + -- - ----- + . . .
                           x   2   12   24    720
          (%i8) taylor (cos(x) - sec(x), x, 0, 5);
                                          4
                                     2   x
          (%o8)/T/                - x  - -- + . . .
                                         6
          (%i9) taylor ((cos(x) - sec(x))^3, x, 0, 5);
          (%o9)/T/                    0 + . . .
          (%i10) taylor (1/(cos(x) - sec(x))^3, x, 0, 5);
                                                         2          4
                      1     1       11      347    6767 x    15377 x
          (%o10)/T/ - -- + ---- + ------ - ----- - ------- - --------
                       6      4        2   15120   604800    7983360
                      x    2 x    120 x

                                                                    + . . .
          (%i11) taylor (sqrt (1 - k^2*sin(x)^2), x, 0, 6);
                         2  2       4      2   4
                        k  x    (3 k  - 4 k ) x
          (%o11)/T/ 1 - ----- - ----------------
                          2            24

                                              6       4       2   6
                                         (45 k  - 60 k  + 16 k ) x
                                       - -------------------------- + . . .
                                                    720
          (%i12) taylor ((x + 1)^n, x, 0, 4);
                                2       2     3      2         3
                              (n  - n) x    (n  - 3 n  + 2 n) x
          (%o12)/T/ 1 + n x + ----------- + --------------------
                                   2                 6

                                         4      3       2         4
                                       (n  - 6 n  + 11 n  - 6 n) x
                                     + ---------------------------- + . . .
                                                    24
          (%i13) taylor (sin (y + x), x, 0, 3, y, 0, 3);
                         3                 2
                        y                 y
          (%o13)/T/ y - -- + . . . + (1 - -- + . . .) x
                        6                 2

                              3                       2
                         y   y            2      1   y            3
                    + (- - + -- + . . .) x  + (- - + -- + . . .) x  + . . .
                         2   12                  6   12
          (%i14) taylor (sin (y + x), [x, y], 0, 3);
                               3        2      2      3
                              x  + 3 y x  + 3 y  x + y
          (%o14)/T/   y + x - ------------------------- + . . .
                                          6
          (%i15) taylor (1/sin (y + x), x, 0, 3, y, 0, 3);
                    1   y              1    1               1            2
          (%o15)/T/ - + - + . . . + (- -- + - + . . .) x + (-- + . . .) x
                    y   6               2   6                3
                                       y                    y

                                                     1            3
                                                + (- -- + . . .) x  + . . .
                                                      4
                                                     y
          (%i16) taylor (1/sin (y + x), [x, y], 0, 3);
                                       3         2       2        3
                      1     x + y   7 x  + 21 y x  + 21 y  x + 7 y
          (%o16)/T/ ----- + ----- + ------------------------------- + . . .
                    x + y     6                   360


 -- Variável de opção: taylordepth
     Valor padrão: 3

     Se existem ainda termos não zero, `taylor' dobra o grau da
     expansão de `<g>(<x>)' contanto que o grau da expansão seja menor
     que ou igual a `<n> 2^taylordepth'.


 -- Função: taylorinfo (<expr>)
     Retorna information about the séries de Taylor <expr>.  O valor de
     retorno é uma lista de listas.  Cada lista compreende o nome de
     uma variável, o ponto de expansão, e o grau da expansão.

     `taylorinfo' retorna `false' se <expr> não for uma séries de
     Taylor.

     Exemplo:

          (%i1) taylor ((1 - y^2)/(1 - x), x, 0, 3, [y, a, inf]);
                            2                       2
          (%o1)/T/ - (y - a)  - 2 a (y - a) + (1 - a )

                   2                        2
           + (1 - a  - 2 a (y - a) - (y - a) ) x

                   2                        2   2
           + (1 - a  - 2 a (y - a) - (y - a) ) x

                   2                        2   3
           + (1 - a  - 2 a (y - a) - (y - a) ) x  + . . .
          (%i2) taylorinfo(%);
          (%o2)               [[y, a, inf], [x, 0, 3]]


 -- Função: taylorp (<expr>)
     Retorna `true' se <expr> for uma séries de Taylor, e `false' de
     outra forma.


 -- Variável de opção: taylor_logexpand
     Valor padrão: `true'

     `taylor_logexpand' controla expansão de logarítmos em séries de
     `taylor'.

     Quando `taylor_logexpand' for `true', todos  logarítmos são
     expandidos completamente dessa forma problemas de reconhecimento
     de zero envolvendo envolvendo identidades logarítmicas não
     atrapalham o processo de expansão.  Todavia, esse esquema não é
     sempre maematicamente correto uma vez que isso ignora
     informações de ramo.

     Quando `taylor_logexpand' for escolhida para `false', então a
     expansão logarítmica que ocorre é somente aquela que for
     necessária para obter uma séries de potência formal.


 -- Variável de opção: taylor_order_coefficients
     Valor padrão: `true'

     `taylor_order_coefficients' controla a ordenação dos coeficientes
     em uma série de Taylor.

     Quando `taylor_order_coefficients' for `true', coeficientes da
     séries de Taylor são ordenados canonicamente.


 -- Função: taylor_simplifier (<expr>)
     Simplifica coeficientes da séries  de potência <expr>.  `taylor'
     chama essa função.


 -- Variável de opção: taylor_truncate_polynomials
     Valor padrão: `true'

     Quando `taylor_truncate_polynomials' for `true', polinômios são
     truncados baseados sobre a entrada de níveis de truncação.

     De outra forma, entrada de polinômios para `taylor' são
     consideradas terem precisão infinita.


 -- Função: taytorat (<expr>)
     Converte <expr> da forma `taylor' para a forma de expressão
     racional canônica (CRE).  O efeito é o mesmo que `rat (ratdisrep
     (<expr>))', mas mais rápido.


 -- Função: trunc (<expr>)
     Coloca notas na representação interna da expressão geral <expr> de
     modo que isso é mostrado como se suas adições forem séries de
     Taylor truncadas.  <expr> is not otherwise modified.

     Exemplo:

          (%i1) expr: x^2 + x + 1;
                                      2
          (%o1)                      x  + x + 1
          (%i2) trunc (expr);
                                          2
          (%o2)                  1 + x + x  + . . .
          (%i3) is (expr = trunc (expr));
          (%o3)                         true


 -- Função: unsum (<f>, <n>)
     Retorna a primeira diferençã de trás para frente `<f>(<n>) -
     <f>(<n> - 1)'.  Dessa forma `unsum' logicamente é a inversa de
     `sum'.

     Veja também `nusum'.

     Exemplos:

          (%i1) g(p) := p*4^n/binomial(2*n,n);
                                               n
                                            p 4
          (%o1)               g(p) := ----------------
                                      binomial(2 n, n)
          (%i2) g(n^4);
                                        4  n
                                       n  4
          (%o2)                   ----------------
                                  binomial(2 n, n)
          (%i3) nusum (%, n, 0, n);
                               4        3       2              n
                2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
          (%o3) ------------------------------------------------ - ------
                              693 binomial(2 n, n)                 3 11 7
          (%i4) unsum (%, n);
                                        4  n
                                       n  4
          (%o4)                   ----------------
                                  binomial(2 n, n)


 -- Variável de opção: verbose
     Valor padrão: `false'

     Quando `verbose' for `true', `powerseries' mostra mensagens de
     progresso.



File: maxima.info,  Node: Teoria dos Números,  Next: Simetrias,  Prev: Séries,  Up: Top

31 Teoria dos Números
*********************

* Menu:

* Funções e Variáveis Definidas para Teoria dos Números::



Local Variables:
coding: iso-8859-1
End:
