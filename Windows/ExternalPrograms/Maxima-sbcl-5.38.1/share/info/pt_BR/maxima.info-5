This is maxima.info, produced by makeinfo version 4.13 from maxima.texi.

Esse é um Manual do Maxima no formato Texinfo

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     Um sistema de álgebra computacional.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Funções e Variáveis Definidas para Fluxo de Programa,  Prev: Introdução a Fluxo de Programa,  Up: Fluxo de Programa

40.2 Funções e Variáveis Definidas para Fluxo de Programa
=========================================================

 -- Função: backtrace ()
 -- Função: backtrace (<n>)
     Imprime a pilha de chamadas, que é, a lista de funções que foram
     chamadas pela função correntemente ativa.

     `backtrace()' imprime toda a pilha de chamadas.

     `backtrace (<n>)' imprime as <n> mais recentes chamadas a
     funções, incluindo a função correntemente ativa.

     `backtrace' pode ser chamada por um script, uma função, ou a
     partir da linha de comando interativa (não somente em um contexto
     de depuração).

     Exemplos:

        * `backtrace()' imprime toda a pilha de chamadas.

               (%i1) h(x) := g(x/7)$
               (%i2) g(x) := f(x-11)$
               (%i3) f(x) := e(x^2)$
               (%i4) e(x) := (backtrace(), 2*x + 13)$
               (%i5) h(10);
               #0: e(x=4489/49)
               #1: f(x=-67/7)
               #2: g(x=10/7)
               #3: h(x=10)
                                             9615
               (%o5)                         ----
                                              49

        * `backtrace (<n>)' imprime as <n> mais recentes chamadas a
          funções, incluindo a função correntemente ativa.

               (%i1) h(x) := (backtrace(1), g(x/7))$
               (%i2) g(x) := (backtrace(1), f(x-11))$
               (%i3) f(x) := (backtrace(1), e(x^2))$
               (%i4) e(x) := (backtrace(1), 2*x + 13)$
               (%i5) h(10);
               #0: h(x=10)
               #0: g(x=10/7)
               #0: f(x=-67/7)
               #0: e(x=4489/49)
                                             9615
               (%o5)                         ----
                                              49


 -- Operador especial: do
     A declaração `do' é usada para executar iteração.  Devido à sua
     grande generalidade a declaração `do' será  descrita em duas
     partes.  Primeiro a forma usual será dada que é análoga à forma
     que é usada em muitas outras linguagens de programação (Fortran,
     Algol, PL/I, etc.); em segundo lugar os outros recursos serão
     mencionados.

     Existem três variantes do operador especial `do' que diferem
     somente por suas condições de encerramento.  São elas:

        * `for <Variável>: <valor_inicial> step <incremento>       thru
          <limite> do <corpo>'

        * `for <Variável>: <valor_inicial> step <incremento>
          while <condição> do <corpo>'

        * `for <Variável>: <valor_inicial> step <incremento>
          unless <condição> do <corpo>'

     (Alternativamente, o `step' pode ser dado após a <condição> de
     encerramento ou limite.)

     <valor_inicial>, <incremento>, <limite>, e <corpo> podem ser
     quaisquer expressões.  Se o incremento for 1 então "`step 1'" pode
     ser omitido.

     A execução da declaração `do' processa-se primeiro atribuindo o
     `valor_inicial' para a variável (daqui em diante chamada a
     variável de controle).  Então: (1) Se a variável de controle excede
     o limite de uma especificação `thru', ou se a condição de `unless'
     for `true', ou se a condição de `while' for `false' então o `do'
     será encerrado.  (2) O <corpo> é avaliado.  (3) O incremento é
     adicionado à variável de controle.  O processo de (1) a (3) é
     executado repetidamente até que a condição de encerramento seja
     satisfeita.  Pode-se também dar muitas condições de encerramento e
     nesse caso o `do' termina quando qualquer delas for satisfeita.

     Em geral o teste `thru' é satisfeito quando a variável de controle
     for maior que o <limite> se o incremento for não negativo, ou
     quando a variável de controle for menor que o <limite> se o
     <incremento> for negativo.  O <incremento> e o <limite> podem ser
     expressões não numéricas enquanto essa desigualdade puder ser
     determinada.  Todavia, a menos que o <incremento> seja
     sintaticamente negativo (e.g. for um número negativo) na hora em
     que a declaração `do' for iniciada, Maxima assume que o incremento
     e o limite serão positivos quando o `do' for executado.  Se o
     limite e o incremento não forem positivos, então o `do' pode não
     terminar propriamente.

     Note que o <limite>, <incremento>, e <condição> de encerramento são
     avaliados cada vez que ocorre um ciclo.  Dessa forma se qualquer
     desses for responsável por muitos cálculos, e retornar um
     resultado que não muda durante todas as execuções do <corpo>,
     então é mais eficiente escolher uma variável para seu valor prévio
     para o `do' e usar essa variável na forma `do'.

     O valor normalmente retornado por uma declaração `do' é o átomo
     `done'.  Todavia, a função `return' pode ser usada dentro do
     <corpo> para sair da delcaração `do' prematuramente e dar a isso
     qualquer valor desejado.  Note todavia que um `return' dentro de
     um `do' que ocorre em um `block' encerrará somente o `do' e não o
     `block'.  Note também que a função `go' não pode ser usada para
     sair de dentro de um `do' dentro de um `block' que o envolve.

     A variável de controle é sempre local para o `do' e dessa forma
     qualquer variável pode ser usada sem afetar o valor de uma
     variável com o mesmo nome fora da declaração `do'.  A variável de
     controle é liberada após o encerramento da declaração `do'.

          (%i1) for a:-3 thru 26 step 7 do display(a)$
                                       a = - 3

                                        a = 4

                                       a = 11

                                       a = 18

                                       a = 25

          (%i1) s: 0$
          (%i2) for i: 1 while i <= 10 do s: s+i;
          (%o2)                         done
          (%i3) s;
          (%o3)                          55

     Note que a condição `while i <= 10' é equivalente a `unless i >
     10' e também `thru 10'.

          (%i1) series: 1$
          (%i2) term: exp (sin (x))$
          (%i3) for p: 1 unless p > 7 do
                    (term: diff (term, x)/p,
                     series: series + subst (x=0, term)*x^p)$
          (%i4) series;
                            7    6     5    4    2
                           x    x     x    x    x
          (%o4)            -- - --- - -- - -- + -- + x + 1
                           90   240   15   8    2

     que fornece 8 termos da série de Taylor para `e^sin(x)'.

          (%i1) poly: 0$
          (%i2) for i: 1 thru 5 do
                    for j: i step -1 thru 1 do
                        poly: poly + i*x^j$
          (%i3) poly;
                            5      4       3       2
          (%o3)          5 x  + 9 x  + 12 x  + 14 x  + 15 x
          (%i4) guess: -3.0$
          (%i5) for i: 1 thru 10 do
                    (guess: subst (guess, x, 0.5*(x + 10/x)),
                     if abs (guess^2 - 10) < 0.00005 then return (guess));
          (%o5)                  - 3.162280701754386

     Esse exemplo calcula a raíz quadrada negativa de 10 usando a
     iteração de Newton- Raphson um maximum de 10 vezes.  Caso o
     critério de convergêcia não tenha sido encontrado o valor
     retornado pode ser `done'.  Em lugar de sempre adicionar uma
     quantidade à variável de controle pode-se algumas vezes desejar
     alterar isso de alguma outra forma para cada iteração.  Nesse caso
     pode-se usar `next <expressão>' em lugar de `step <incremento>'.
     Isso fará com que a variável de controle seja escolhida para o
     resultado de avaliação da <expressão> cada vez que o ciclo de
     repetição for executado.

          (%i6) for count: 2 next 3*count thru 20 do display (count)$
                                      count = 2

                                      count = 6

                                     count = 18

     Como uma alternativa para `for <Variável>: <valor> ...do...' a
     sintaxe `for <Variável> from <valor> ...do...'  pode ser usada.
     Isso permite o `from <valor>' ser colocado após o `step' ou após o
     <next> valor ou após a <condição> de encerramento.  Se `from
     <valor>' for omitido então 1 é usado como o valor inicial.

     Algumas vezes se pode estar interessado em executar uma
     iteração onde a variável de controle nunca seja usada.  Isso é
     permissível para dar somente as condições de encerramento omitindo
     a inicialização e a informação de atualização como no exemplo
     seguinte para para calcular a raíz quadrada de 5 usando uma fraca
     suposição inicial.

          (%i1) x: 1000$
          (%i2) thru 20 do x: 0.5*(x + 5.0/x)$
          (%i3) x;
          (%o3)                   2.23606797749979
          (%i4) sqrt(5), numer;
          (%o4)                   2.23606797749979

     Se isso for desejado pode-se sempre omitir as condições de
     encerramento inteiramente e apenas dar o `do <corpo>' que o
     <corpo> continuará a ser avaliado indefinidamente.  Nesse caso a
     função `return' será usada para encerrar a execução da
     declaração `do'.

          (%i1) newton (f, x):= ([y, df, dfx], df: diff (f ('x), 'x),
                    do (y: ev(df), x: x - f(x)/y,
                        if abs (f (x)) < 5e-6 then return (x)))$
          (%i2) sqr (x) := x^2 - 5.0$
          (%i3) newton (sqr, 1000);
          (%o3)                   2.236068027062195

     (Note que `return', quando executado, faz com que o valor corrente
     de `x' seja retornado como o valor da declaração `do'.  O `block'
     é encerrado e esse valor da declaração `do' é retornado como o
     valor do `block' porque o `do' é a última declaração do `block'.)

     Uma outra forma de `do' é disponível no Maxima.  A sintaxe é:

          for <Variável> in <list> <end_tests> do <corpo>

     Os elementos de <list> são quaisquer expressões que irão
     sucessivamente ser atribuídas para a <variável> a cada iteração do
     <corpo>.  O teste opcional <end_tests> pode ser usado para
     encerrar a execução da declaração `do'; de outra forma o `do'
     terminará quando a <lista> for exaurida ou quando um `return' for
     executado no <corpo>.  (De fato, a <lista> pode ser qualquer
     expressão não atômica, e partes sucessivas são usadas.)

          (%i1)  for f in [log, rho, atan] do ldisp(f(1))$
          (%t1)                                  0
          (%t2)                                rho(1)
                                               %pi
          (%t3)                                 ---
                                                4
          (%i4) ev(%t3,numer);
          (%o4)                             0.78539816


 -- Função: errcatch (<expr_1>, ..., <expr_n>)
     Avalia <expr_1>, ..., <expr_n> uma por uma e retorna `[<expr_n>]'
     (uma lista) se nenhum erro ocorrer.  Se um erro ocorrer na
     avaliação de qualquer argumento, `errcatch' evita que o erro se
     propague e retorna a lista vazia `[]' sem avaliar quaisquer mais
     argumentos.

     `errcatch' é útil em arquivos `batch' onde se suspeita que um erro
     possa estar ocorrendo o `errcatch' terminará o `batch' se o erro
     não for detectado.


 -- Função: error (<expr_1>, ..., <expr_n>)
 -- Variável de sistema: error
     Avalia e imprime <expr_1>, ..., <expr_n>, e então causa um retorno
     de erro para o nível mais alto do Maxima ou para o mais próximo
     contendo `errcatch'.

     A variável `error' é escolhida para uma lista descrevendo o erro.
     O primeiro elemento de `error' é uma seqüência de caracteres de
     formato, que junta todas as seqüências de caracteres entre os
     argumentos <expr_1>, ..., <expr_n>, e os elementos restantes são
     os valores de quaisquer argumentos que não são seqüências de
     caracteres.

     `errormsg()' formata e imprime `error'.  Isso efetivamente
     reimprime a mais recente mensagem de erro.


 -- Função: errormsg ()
     Reimprime a mais recente mensagem de erro.  A variável `error'
     recebe a mensagem, e `errormsg' formata e imprime essa mensagem.


 -- Operador especial: for
     Usado em iterações.  Veja `do' para uma descrição das facilidades
     de iteração do Maxima.


 -- Função: go (<tag>)
     é usada dentro de um `block' para transferir o controle para a
     declaração do bloco que for identificada com o argumento para
     `go'.  Para identificar uma declaração, coloque antes dessa
     declaração um argumento atômico como outra declaração no `block'.
     Por exemplo:

          block ([x], x:1, loop, x+1, ..., go(loop), ...)

     O argumento para `go' deve ser o nome de um identificardor
     aparecendo no mesmo `block'.  Não se pode usar `go' para
     transferir para um identificador em um outro `block' que não seja
     o próprio contendo o `go'.


 -- Operador especial: if
     Representa avaliação condicional. Várias formas de expressões `if'
     são reconhecidas.  `if <cond_1> then <expr_1> else <expr_0>'
     avalia para <expr_1> se <cond_1> avaliar para `true', de outra
     forma a expressão avalia para `expr_0'.

     `if <cond_1> then <expr_1> elseif <cond_2> then <expr_2> elseif
     ... else <expr_0>' avalia para <expr_k> se <cond_k> for `true' e
     todas as condições precedentes forem `false'.  Se nenhuma das
     condições forem `true', a expressão avalia para `expr_0'.

     O comportamento `else false' é assumido se `else' for omitido.
     Isso é, `if <cond_1> then <expr_1>' é equivalente a `if <cond_1>
     then <expr_1> else false', e `if <cond_1> then <expr_1> elseif ...
     elseif <cond_n> then <expr_n>' é equivalente a `if <cond_1> then
     <expr_1> elseif ... elseif <cond_n> then <expr_n> else false'.

     As alternativas <expr_0>, ..., <expr_n> podem ser quaisquer
     expressões do Maxima, incluíndo expressões `if' aninhadas ( if
     dentro de if).  As alternativas não são nem simplificadas nem
     avaliadas a menos que a correspondente condição seja `true'.

     As condições <cond_1>, ..., <cond_n> são expressões as quais
     potencialmente ou atualmente avaliem para `true' ou para `false'.
     Quando uma condição não avalia atualmente para para `true' ou para
     `false', o comportamento de `if' é governado pelo sinalizador
     global `prederror'.  Quando `prederror' for `true', isso é um erro
     se qualquer condição avaliada não avaliar para `true' ou `false'.
     De outra forma, condições que não avaliem para `true' ou `false'
     são aceitas, e o resultado é uma expressão condicional.

     Entre outros elementos, condições podem compreender operadores
     lógicos e relacionais como segue.

          Operação             Símbolo      Tipo

          menor que            <           infixo relacional
          menor que            <=
            ou igual a                     infixo relacional
          igualdade            =
            (sintática)                    infixo relacional
          negação de =         #           infixo relacional
          igualdade (valor)    equal       função relacional
          negação de           notequal
            igualdade                      função relacional
          maior que            >=
            ou igual a                     infixo relacional
          maior que            >           infixo relacional
          e                    and         infixo lógico
          ou                   or          infixo lógico
          não                  not         prefixo lógico


 -- Função: map (<f>, <expr_1>, ..., <expr_n>)
     Retorna uma expressão cujo operador principal é o mesmo que o das
     expressões <expr_1>, ..., <expr_n> mas cujas subpartes são os
     resultados da aplicação de <f> nas correspondentes subpartes das
     expressões.  <f> é ainda o nome de uma função de n argumentos ou é
     uma forma `lambda' de n argumentos.

     `maperror' - se `false' fará com que todas as funções mapeadas (1)
     parem quando elas terminarem retornando a menor <exp_i> se não
     forem todas as <exp_i> do mesmo comprimento e (2) aplique fn a
     [exp1, exp2,...]  se <exp_i> não forem todas do mesmo tipo de
     objeto.  Se `maperror' for `true' então uma mensagem de erro será
     dada nas duas instâncias acima.

     Um dos usos dessa função é para mapear (`map') uma função (e.g.
     `partfrac') sobre cada termo de uma expressão muito larga onde
     isso comumente não poderia ser possível usar a função sobre a
     expressão inteira devido a uma exaustão de espaço da lista de
     armazenamento no decorrer da computação.

          (%i1) map(f,x+a*y+b*z);
          (%o1)                        f(b z) + f(a y) + f(x)
          (%i2) map(lambda([u],partfrac(u,x)),x+1/(x^3+4*x^2+5*x+2));
                                     1       1        1
          (%o2)                     ----- - ----- + -------- + x
                                   x + 2   x + 1          2
                                                   (x + 1)
          (%i3) map(ratsimp, x/(x^2+x)+(y^2+y)/y);
                                                1
          (%o3)                            y + ----- + 1
                                              x + 1
          (%i4) map("=",[a,b],[-0.5,3]);
          (%o4)                          [a = - 0.5, b = 3]

 -- Função: mapatom (<expr>)
     Retorna `true' se e somente se <expr> for tratada pelas rotinas de
     mapeamento como um átomo.  "Mapatoms" são átomos, números
     (incluíndo números racioanais), e variáveis subscritas.


 -- Variável de opção: maperror
     Valor padrão: `true'

     Quando `maperror' é `false', faz com que todas as funções
     mapeadas, por exemplo

          map (f, <expr_1>, <expr_2>, ...)

     para (1) parar quando elas terminarem retornando a menor <exp_i>
     se não forem todas as <exp_i> do mesmo comprimento e (2) aplique
     `f' a `[<expr_1>, <expr_2>, ...]' se `expr_i' não forem todas do
     mesmo tipo de objeto.

     Se `maperror' for `true' então uma ,mensagem de erro é mostrada
     nas duas instâncias acima.


 -- Função: maplist (<f>, <expr_1>, ..., <expr_n>)
     Retorna uma lista de aplicações de <f> em todas as partes das
     expressões <expr_1>, ..., <expr_n>.  <f> é o nome de uma função,
     ou uma expressão lambda.

     `maplist' difere de `map (<f>, <expr_1>, ..., <expr_n>)' que
     retorna uma expressão com o mesmo operador principal que <expr_i>
     tem (exceto para simplificações  e o caso onde `map' faz um
     `apply').


 -- Variável de opção: prederror
     Valor padrão: `true'

     Quando `prederror' for `true', uma mensagem de erro é mostrada
     sempre que o predicado de uma declaração `if' ou uma função `is'
     falha em avaliar ou para `true' ou para  `false'.

     Se `false', `unknown' é retornado no lugar nesse caso.  O modo
     `prederror: false' não é suportado no código traduzido; todavia,
     `maybe' é suportado no código traduzido.

     Veja também `is' e `maybe'.


 -- Função: return (<valor>)
     Pode ser usada para sair explicitamente de um bloco, levando seu
     argumento.  Veja `block' para mais informação.


 -- Função: scanmap (<f>, <expr>)
 -- Função: scanmap (<f>, <expr>, bottomup)
     Recursivamente aplica <f> a <expr>, de cima para baixo.  Isso é
     muito útil quando uma fatoração completa é desejada, por exemplo:

          (%i1) exp:(a^2+2*a+1)*y + x^2$
          (%i2) scanmap(factor,exp);
                                              2      2
          (%o2)                         (a + 1)  y + x

     Note o caminho através do qual `scanmap' aplica a dada função
     `factor' para as subexpressões constituintes de <expr>; se outra
     forma de <expr> é apresentada para `scanmap' então o resultado
     pode ser diferente.  Dessa forma, `%o2' não é recuperada quando
     `scanmap' é aplicada para a forma expandida de <exp>:

          (%i3) scanmap(factor,expand(exp));
                                     2                  2
          (%o3)                      a  y + 2 a y + y + x

     Aqui está um outro exemplo do caminho no qual `scanmap' aplica
     recursivamente uma função dada para todas as subexpressões,
     incluindo expoentes:

          (%i4) expr : u*v^(a*x+b) + c$
          (%i5) scanmap('f, expr);
                              f(f(f(a) f(x)) + f(b))
          (%o5) f(f(f(u) f(f(v)                      )) + f(c))

     `scanmap (<f>, <expr>, bottomup)' aplica <f> a <expr> de baixo
     para cima.  E.g., para `f' indefinida,

          scanmap(f,a*x+b) ->
             f(a*x+b) -> f(f(a*x)+f(b)) -> f(f(f(a)*f(x))+f(b))
          scanmap(f,a*x+b,bottomup) -> f(a)*f(x)+f(b)
              -> f(f(a)*f(x))+f(b) ->
               f(f(f(a)*f(x))+f(b))

     Nesse caso, você pega a mesma resposta em ambos os caminhos.


 -- Função: throw (<expr>)
     Avalia <expr> e descarta o valor retornado para o mais recente
     `catch'.  `throw' é usada com `catch' como um mecanismo de retorno
     não local.


 -- Operador especial: while
     Veja `do'.


 -- Função: outermap (<f>, <a_1>, ..., <a_n>)
     Aplica a função <f> para cada um dos elementos do produto externo
     <a_1> vezes <a_2> ... vezes <a_n>.

     <f> é o nome de uma função de n argumentos ou uma expressão lambda
     de n argumentos.  Cada argumento <a_k> pode ser uma lista simples
     ou lista aninhada ( lista contendo listas como elementos ), ou uma
     matrz, ou qualquer outro tip de expressão.

     O valor de retorno de `outermap' é uma estrutura aninhada.
     Tomemos <x> como sendo o valor de retorno.  Então <x> tem a mesma
     estrutura da primeira lista, lista aninhada, ou argumento matriz,
     `<x>[i_1]...[i_m]' tem a mesma estrutura que a segunda lista,
     lista aninhada, ou argumento matriz,
     `<x>[i_1]...[i_m][j_1]...[j_n]' tem a mesma estrutura que a
     terceira lista, lista aninhada, ou argumento matriz, e assim por
     diante, onde <m>, <n>, ... são os números dos índices requeridos
     para acessar os elementos de cada argumento (um para uma lista,
     dois para uma matriz, um ou mais para uma lista aninhada).
     Argumentos que não forem listas ou matrizes não afetam a estrutura
     do valor de retorno.

     Note que o efeito de `outermap' é diferente daquele de aplicar <f>
     a cada um dos elementos do produto externo retornado por
     `cartesian_product'.  `outermap' preserva a estrutura dos
     argumentos no valor de retorno, enquanto `cartesian_product' não
     reserva essa mesma estrutura.

     `outermap' avalia seus argumentos.

     Veja também `map', `maplist', e `apply'.

     Exemplos: Exemplos elementares de `outermap'.  Para mostrar a a
     combinação de argumentos mais claramente, `F' está indefinida à
     esquerda.

          (%i1) outermap (F, [a, b, c], [1, 2, 3]);
          (%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)],
                                               [F(c, 1), F(c, 2), F(c, 3)]]
          (%i2) outermap (F, matrix ([a, b], [c, d]), matrix ([1, 2], [3, 4]));
                   [ [ F(a, 1)  F(a, 2) ]  [ F(b, 1)  F(b, 2) ] ]
                   [ [                  ]  [                  ] ]
                   [ [ F(a, 3)  F(a, 4) ]  [ F(b, 3)  F(b, 4) ] ]
          (%o2)    [                                            ]
                   [ [ F(c, 1)  F(c, 2) ]  [ F(d, 1)  F(d, 2) ] ]
                   [ [                  ]  [                  ] ]
                   [ [ F(c, 3)  F(c, 4) ]  [ F(d, 3)  F(d, 4) ] ]
          (%i3) outermap (F, [a, b], x, matrix ([1, 2], [3, 4]));
                 [ F(a, x, 1)  F(a, x, 2) ]  [ F(b, x, 1)  F(b, x, 2) ]
          (%o3) [[                        ], [                        ]]
                 [ F(a, x, 3)  F(a, x, 4) ]  [ F(b, x, 3)  F(b, x, 4) ]
          (%i4) outermap (F, [a, b], matrix ([1, 2]), matrix ([x], [y]));
                 [ [ F(a, 1, x) ]  [ F(a, 2, x) ] ]
          (%o4) [[ [            ]  [            ] ],
                 [ [ F(a, 1, y) ]  [ F(a, 2, y) ] ]
                                        [ [ F(b, 1, x) ]  [ F(b, 2, x) ] ]
                                        [ [            ]  [            ] ]]
                                        [ [ F(b, 1, y) ]  [ F(b, 2, y) ] ]
          (%i5) outermap ("+", [a, b, c], [1, 2, 3]);
          (%o5) [[a + 1, a + 2, a + 3], [b + 1, b + 2, b + 3],
                                                     [c + 1, c + 2, c + 3]]

     Uma explanação final do valor de retorno de `outermap'.  Os
     argumentos primeiro, segundo, e terceiro são matriz, lista, e
     matriz, respectivamente.  O valor de retorno é uma matriz.  Cada
     elementos daquela matriz é uma lista, e cada elemento de cada
     lista é uma matriz.

          (%i1) arg_1 :  matrix ([a, b], [c, d]);
                                      [ a  b ]
          (%o1)                       [      ]
                                      [ c  d ]
          (%i2) arg_2 : [11, 22];
          (%o2)                       [11, 22]
          (%i3) arg_3 : matrix ([xx, yy]);
          (%o3)                      [ xx  yy ]
          (%i4) xx_0 : outermap (lambda ([x, y, z], x / y + z), arg_1, arg_2, arg_3);
                         [  [      a        a  ]  [      a        a  ]  ]
                         [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                         [  [      11       11 ]  [      22       22 ]  ]
          (%o4)  Col 1 = [                                              ]
                         [  [      c        c  ]  [      c        c  ]  ]
                         [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                         [  [      11       11 ]  [      22       22 ]  ]
                           [  [      b        b  ]  [      b        b  ]  ]
                           [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                           [  [      11       11 ]  [      22       22 ]  ]
                   Col 2 = [                                              ]
                           [  [      d        d  ]  [      d        d  ]  ]
                           [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                           [  [      11       11 ]  [      22       22 ]  ]
          (%i5) xx_1 : xx_0 [1][1];
                     [      a        a  ]  [      a        a  ]
          (%o5)     [[ xx + --  yy + -- ], [ xx + --  yy + -- ]]
                     [      11       11 ]  [      22       22 ]
          (%i6) xx_2 : xx_0 [1][1] [1];
                                [      a        a  ]
          (%o6)                 [ xx + --  yy + -- ]
                                [      11       11 ]
          (%i7) xx_3 : xx_0 [1][1] [1] [1][1];
                                            a
          (%o7)                        xx + --
                                            11
          (%i8) [op (arg_1), op (arg_2), op (arg_3)];
          (%o8)                  [matrix, [, matrix]
          (%i9) [op (xx_0), op (xx_1), op (xx_2)];
          (%o9)                  [matrix, [, matrix]

     `outermap' preserves the structure of the arguments in the return
     value, while `cartesian_product' does not.

          (%i1) outermap (F, [a, b, c], [1, 2, 3]);
          (%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)],
                                               [F(c, 1), F(c, 2), F(c, 3)]]
          (%i2) setify (flatten (%));
          (%o2) {F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3),
                                                 F(c, 1), F(c, 2), F(c, 3)}
          (%i3) map (lambda ([L], apply (F, L)), cartesian_product ({a, b, c}, {1, 2, 3}));
          (%o3) {F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3),
                                                 F(c, 1), F(c, 2), F(c, 3)}
          (%i4) is (equal (%, %th (2)));
          (%o4)                         true



File: maxima.info,  Node: Depurando,  Next: augmented_lagrangian,  Prev: Fluxo de Programa,  Up: Top

41 Depurando
************

* Menu:

* Depurando o Código Fonte::
* Comandos Palavra Chave::
* Funções e Variáveis Definidas para Depuração::


File: maxima.info,  Node: Depurando o Código Fonte,  Next: Comandos Palavra Chave,  Up: Depurando

41.1 Depurando o Código Fonte
=============================

Maxima tem um depurador interno de código fonte.  O usuário pode
escolher um ponto de parada em uma função, e então caminhar linha por
linha a partir daí.  A pilha de chamadas po ser examinada, juntamente
com as variáveis associadas àquele nível.

   O comando `:help' ou `:h' mostra a lista de comando de depuração.
(Em geral, comandos podem ser abreviados se a abreviação for única.  Se
não for única, as alternativas podem ser listadas.)  Dentro do
depurador, o usuário pode também usar qualquer funções comuns do Maxima
para examinar, definir, e manipular variáveis e expressões.

   Um ponto de parada é escolhido através do comando `:br' na linha de
comando do Maxima.  Dentro do depurador, o usuário pode avançar uma
linha de cada vez usando o comando `:n' ("next").  o comando `:bt'
("backtrace") mostra uma lista da pilha de frames.  O comando `:r'
("resume") sai do depurador e continua com a execução.  Esses comandos
são demostrados no exemplo abaixo.

     (%i1) load ("/tmp/foobar.mac");

     (%o1)                           /tmp/foobar.mac

     (%i2) :br foo
     Turning on debugging debugmode(true)
     Bkpt 0 for foo (in /tmp/foobar.mac line 1)

     (%i2) bar (2,3);
     Bkpt 0:(foobar.mac 1)
     /tmp/foobar.mac:1::

     (dbm:1) :bt                        <-- :bt digitado aqui lista os frames
     #0: foo(y=5)(foobar.mac line 1)
     #1: bar(x=2,y=3)(foobar.mac line 9)

     (dbm:1) :n                         <-- Aqui digite :n para avançar linha
     (foobar.mac 2)
     /tmp/foobar.mac:2::

     (dbm:1) :n                         <-- Aqui digite :n para avançar linha
     (foobar.mac 3)
     /tmp/foobar.mac:3::

     (dbm:1) u;                         <-- Investiga o valor de u
     28

     (dbm:1) u: 33;                     <-- Altera u para ser 33
     33

     (dbm:1) :r                         <-- Digite :r para retomar a computação

     (%o2)                                1094

   O arquivo `/tmp/foobar.mac' é o seguinte:

     foo(y) := block ([u:y^2],
       u: u+3,
       u: u^2,
       u);

     bar(x,y) := (
       x: x+2,
       y: y+2,
       x: foo(y),
       x+y);

   USO DO DEPURADOR ATRAVÉS DO EMACS

   Se o usuário estiver rodando o código sob o GNU emacs em uma janela
shell (shell dbl), ou está rodando a versão de interface gráfica,
Xmaxima, então se ele para em um ponto de parada, ele verá sua
posição corrente no arquivo fonte a qua será mostrada na outra metade
da janela, ou em vermelho brilhante, ou com um pequeno seta apontando
na direita da linha.  Ele pode avançar uma linha por vez digitando M-n
(Alt-n).

   Sob Emacs você pode executar em um shell `dbl', o qual requer o
arquivo `dbl.el' no diretório elisp.  Tenha certeza que instalou os
arquivos elisp ou adicionou o diretório elisp do Macima ao seu caminho:
e.g., adicione o seguinte ao seu arquivo `.emacs' ou ao seu arquivo
`site-init.el'

     (setq load-path (cons "/usr/share/maxima/5.9.1/emacs" load-path))
     (autoload 'dbl "dbl")

   então no emacs

     M-x dbl

   pode iniciar uma janela shell na qual você pode executar programas,
por exemplo Maxima, gcl, gdb etc.   Essa janela de shell também
reconhece informações sobre depuração de código fonte, e mostra o
código fonte em outra janela.

   O usuário pode escolher um ponto de parada em certa linha do arquivo
digitando `C-x space'.  Isso encontra qual a função que o cursor está
posicionado, e então mostra qual a linha daquela função que o cursor
está habilitado.   Se o cursor estiver habilitado, digamos, na linha 2
de `foo', então isso irá inserir na outra janela o comando, "`:br foo
2'", para parar `foo' nessa segunda linha.   Para ter isso habilitado,
o usuário deve ter maxima-mode.el habilitado na janela na qual o
arquivo `foobar.mac' estiver interagindo.  Existe comandos adicional
disponíveis naquela janela de arquivo, tais como avaliando a função
dentro do Maxima, através da digitação de `Alt-Control-x'.


File: maxima.info,  Node: Comandos Palavra Chave,  Next: Funções e Variáveis Definidas para Depuração,  Prev: Depurando o Código Fonte,  Up: Depurando

41.2 Comandos Palavra Chave
===========================

Comandos palavra chave são palavras chaves especiais que não são
interpretadas como expressões do Maxima.  Um comando palavra chave pode
ser inserido na linha de comando do Maxima ou na linha de comando do
depurador, embora não possa ser inserido na linha de comando de parada.
Comandos palavra chave iniciam com um dois pontos, `:'.  Por exemplo,
para avaliar uma forma Lisp você pode digitar `:lisp' seguido pela
forma a ser avaliada.

     (%i1) :lisp (+ 2 3)
     5

   O número de argumentos tomados depende do comando em particular.
Também, você não precisa digitar o comando completo, apenas o
suficiente para ser único no meio das palavras chave de parada.   Dessa
forma `:br' será suficiente para `:break'.

   Os comandos de palavra chave são listados abaixo.

`:break F n'
     Escolhe um ponto de parada em uma função `F' na linha `n' a partir
     do início da função.  Se `F' for dado como uma seqüência de
     caracteres, então essa seqüência de caracteres é assumida
     referir-se a um arquivo, e `n' é o deslocamente a partir do início
     do arquivo.  O deslocamento é opcional. Se for omitido, é assumido
     ser zero (primeira linha da função ou do arquivo).

`:bt'
     Imprime na tela uma lista da pilha de frames

`:continue'
     Continua a computação

`:delete'
     Remove o ponto de parada selecionado, ou todos se nenum for
     especificado

`:disable'
     Desabilita os pontos de parada selecionados, ou todos se nenhum
     for especificado

`:enable'
     Habilita os pontos de de parada especificados, ou todos se nenhum
     for especificado

`:frame n'
     Imprime na tela a pilha de frame `n', ou o corrente frame se
     nenhum for especificado

`:help'
     Imprime na tela a ajuda sobre um comando do depurador, ou todos os
     comandos se nenhum for especificado

`:info'
     Imprime na tela informações sobre um item

`:lisp alguma-forma'
     Avalia `alguma-forma' como uma forma Lisp

`:lisp-quiet alguma-forma'
     Avalia a forma Lisp `alguma-forma' sem qualquer saída

`:next'
     Como `:step', exceto `:next' passos sobre chamadas de fução

`:quit'
     Sai do nível corrente do depurador sem concluir a computação

`:resume'
     Continua a computação

`:step'
     Continua a computação até encontraruma nova linha de códico

`:top'
     Retorne para a linha de comando do Maxima (saindo de qualquer
     nível do depurador) sem completar a computação


File: maxima.info,  Node: Funções e Variáveis Definidas para Depuração,  Prev: Comandos Palavra Chave,  Up: Depurando

41.3 Funções e Variáveis Definidas para Depuração
=================================================

 -- Variável de opção: refcheck
     Valor padrão: `false'

     Quando `refcheck' for `true', Maxima imprime uma mensagem cada vez
     que uma variável associada for usada pela primeira vez em uma
     computação.


 -- Variável de opção: setcheck
     Valor padrão: `false'

     Se `setcheck' for escolhido para uma lista de variáveis (as quais
     podem ser subscritas), Maxima mostra uma mensagem quando as
     variáveis, ou ocorrências subscritas delas, forem associadas com o
     operador comum de atribuição `:', o operador `::' de atribuição,
     ou associando argumentos de função, mas não com o operador de
     atribuição de função `:=' nem o operador de atribuição `::=' de
     macro.  A mensagem compreende o nome das variáveis e o valor
     associado a ela.

     `setcheck' pode ser escolhida para `all' ou `true' incluindo desse
     modo todas as variáveis.

     Cada nova atribuição de `setcheck' estabelece uma nova lista de
     variáveis para verificar, e quaisquer variáveis previamente
     atribuídas a `setcheck' são esquecidas.

     Os nomes atribuídos a `setcheck' devem ter um apóstrofo no início
     se eles forem de outra forma avaliam para alguma outra coisa que
     não eles mesmo.  Por exemplo, se `x', `y', e `z' estiverem
     atualmente associados, então digite

          setcheck: ['x, 'y, 'z]$

     para colocá-los na lista de variáveis monitoradas.

     Nenhuma saída é gerada quando uma variável na lista `setcheck' for
     atribuída a sí mesma, e.g., `X: 'X'.


 -- Variável de opção: setcheckbreak
     Valor padrão: `false'

     Quando `setcheckbreak' for `true', Maxima mostrará um ponto de
     parada quando uma variável sob a lista `setcheck' for atribuída a
     um novo valor.  A parada ocorre antes que a atribuíção seja
     concluída.  Nesse ponto, `setval' retém o valor para o qual a
     variável está para ser atribuída.  Conseqüentemente, se pode
     atribuir um valor diferente através da atribuição a `setval'.

     Veja também `setcheck' e `setval'.


 -- Variável de sistema: setval
     Mantém o valor para o qual a variável está para ser escolhida
     quando um `setcheckbreak' ocorrer.  Conseqüentemente, se pode
     atribuir um valor diferente através da atribuição a `setval'.

     Veja também `setcheck' e `setcheckbreak'.


 -- Função: timer (<f_1>, ..., <f_n>)
 -- Função: timer (all)
 -- Função: timer ()
     Dadas as funções <f_1>, ..., <f_n>, `timer' coloca cada uma na
     lista de funções para as quais cronometragens estatísticas são
     coletadas.  `timer(f)$ timer(g)$' coloca `f' e então `g' sobre a
     lista; a lista acumula de uma chamada para a chamada seguinte.

     `timer(all)' coloca todas as funções definidas pelo usuário (a
     saber pela variável global `functions') na lista de funções
     monitoradas pela função `time'.

     Sem argumentos, `timer' retorna a lista das funções tempo
     estatisticamente monitoradas.

     Maxima armazena quanto tempo é empregado executando cada função na
     lista de funções tempo estatisticamente monitoradas.  `timer_info'
     retorna a coronometragem estatística, incluindo o tempo médio
     decorrido por chamada de função, o número de chamadas, e o tempo
     total decorrido.  `untimer' remove funções da lista de funções
     tempo estatisticamente monitoradas.

     `timer' não avalia seus argumentos.  `f(x) := x^2$ g:f$ timer(g)$'
     não coloca `f' na lista de funções estatisticamente monitoradas.

     Se `trace(f)' está vigorando, então `timer(f)' não tem efeito;
     `trace' e `timer' não podem ambas atuarem ao mesmo tempo.

     Veja também `timer_devalue'.


 -- Função: untimer (<f_1>, ..., <f_n>)
 -- Função: untimer ()
     Dadas as funções <f_1>, ..., <f_n>, `untimer' remove cada uma das
     funções listadas da lista de funções estatisticamente monitoradas.

     Sem argumentos, `untimer' remove todas as funções atualmente na
     lista de funções estatisticamente monitoradas.

     Após `untimer (f)' ser executada, `timer_info (f)' ainda retorna
     estatisticas de tempo previamente coletadas, embora `timer_info()'
     (sem argumentos) não retorna informações sobre qualquer função que
     não estiver atualmente na lista de funções tempo estatisticamente
     monitoradas.  `timer (f)' reposiciona todas as estatisticas de
     tempo para zero e coloca `f' na lista de funções estatisticamente
     monitoradas novamente.


 -- Variável de opção: timer_devalue
     Valor Padrão: `false'

     Quando `timer_devalue' for `true', Maxima subtrai de cada
     função estatisticamente monitorada o tempo empregado em ou
     funções estatisticamente monitoradas. De outra forma, o tempo
     reportado para cada função inclui o tempo empregado em outras
     funções.  Note que tempo empregado em funções não estatisticamente
     monitoradas não é subtraído do tempo total.

     Veja também `timer' e `timer_info'.


 -- Função: timer_info (<f_1>, ..., <f_n>)
 -- Função: timer_info ()
     Dadas as funções <f_1>, ..., <f_n>, `timer_info' retorna uma
     matriz contendo informações de cronometragem para cada função.
     Sem argumentos, `timer_info' retorna informações de cronometragem
     para todas as funções atualmente na lista de funções
     estatisticamente monitoradas.

     A matriz retornada através de `timer_info' contém o nome da
     função, tempo por chamda de função, número de chamadas a
     funções,tempo total, e `gctime', cujja forma "tempo de descarte"
     no Macsyma original mas agora é sempre zero.

     Os dados sobre os quais `timer_info' constrói seu valor de retorno
     podem também serem obtidos através da função `get':

          get(f, 'calls);  get(f, 'runtime);  get(f, 'gctime);

     Veja também `timer'.


 -- Função: trace (<f_1>, ..., <f_n>)
 -- Função: trace (all)
 -- Função: trace ()
     Dadas as funções <f_1>, ..., <f_n>, `trace' instrui Maxima para
     mostrar informações de depuração quando essas funções forem
     chamadas.  `trace(f)$ trace(g)$' coloca `f' e então `g' na lista
     de funções para serem colocadas sob a ação de `trace'; a lista
     acumula de uma chamada para a seguinte.

     `trace(all)' coloca todas as funções definidas pelo usuário (a
     saber pela variável global `functions') na lista de funções a
     serem monitoradas pela função `trace'.

     Sem argumentos, `trace' retorna uma lista de todas as funções
     atualmente sob a ação de `trace'.

     A função `untrace' desabilita a ação de `trace'.  Veja também
     `trace_options'.

     `trace' não avalia seus argumentos. Dessa forma, `f(x) := x^2$
     g:f$ trace(g)$' não coloca `f' sobre a lista de funções
     monitoradas pela função `trace'.

     Quando uma função for redefinida, ela é removida da lista de
     `timer'.  Dessa forma após `timer(f)$ f(x) := x^2$', a função `f'
     não mais está na lista de `timer'.

     Se `timer (f)' estiver em efeito, então `trace (f)' não está
     agindo; `trace' e `timer' não podem ambas estar agindo para a
     mesma função.


 -- Função: trace_options (<f>, <option_1>, ..., <option_n>)
 -- Função: trace_options (<f>)
     Escolhe as opções de `trace' para a função <f>.  Quaisquer
     opções anteriores são substituídas.  `trace_options (<f>, ...)'
     não tem efeito a menos que `trace (<f>)' tenha sido também chamada
     (ou antes ou após `trace_options').

     `trace_options (<f>)' reposiciona todas as opções para seus
     valores padrão.

     As opções de palavra chave são:

        * `noprint' Não mostre uma mensagem na entrada da função e saia.

        * `break' Coloque um ponto de parada antes da função ser
          inserida, e após a funçãos er retirada. Veja `break'.

        * `lisp_print' Mostre argumentos e valores de retorno com
          objetos Lisp.

        * `info' Mostre `-> true' na entrada da funçào e saia.

        * `errorcatch' Capture os erros, fornecendo a opção para
          sinalizar um erro, tentar novamente a chamada de função, ou
          especificar um valor de retorno.

     Opções para `trace' são especificadas em duas formas. A
     presença da palavra chave de opção sozinha coloca a opção para ter
     efeito incondicionalmente.  (Note que opção <foo> não coloca para
     ter efeito especificando `<foo>: true' ou uma forma similar; note
     também que palavras chave não precisam estar com apóstrofo.)
     Especificando a opção palavra chave com uma função predicado torna
     a opção condicional sobre o predicado.

     A lista de argumentos para a função predicado é sempre `[level,
     direction, function, item]' onde `level' é o nível rerecursão para
     a função,  `direction' é ou `enter' ou `exit', `function' é o nome
     da função, e `item' é a lista de argumentos (sobre entrada) ou o
     valor de retorno (sobre a saída).

     Aqui está um exemplo de opções incondicionais de `trace':

          (%i1) ff(n) := if equal(n, 0) then 1 else n * ff(n - 1)$

          (%i2) trace (ff)$

          (%i3) trace_options (ff, lisp_print, break)$

          (%i4) ff(3);

     Aqui está a mesma função, com a opção `break' condicional sobre um
     predicado:

          (%i5) trace_options (ff, break(pp))$

          (%i6) pp (level, direction, function, item) := block (print (item),
              return (function = 'ff and level = 3 and direction = exit))$

          (%i7) ff(6);


 -- Função: untrace (<f_1>, ..., <f_n>)
 -- Função: untrace ()
     Dadas as funções <f_1>, ..., <f_n>, `untrace' desabilita a a
     monitoração habilitada pela função `trace'.  Sem argumentos,
     `untrace' desabilita a atuação da função `trade' para todas as
     funções.

     `untrace' retorne uma lista das funções para as quais `untrace'
     desabilita a atuação de `trace'.



File: maxima.info,  Node: augmented_lagrangian,  Next: bode,  Prev: Depurando,  Up: Top

42 augmented_lagrangian
***********************

* Menu:

* Funções e Variáveis Definidas para augmented_lagrangian::


File: maxima.info,  Node: Funções e Variáveis Definidas para augmented_lagrangian,  Prev: augmented_lagrangian,  Up: augmented_lagrangian

42.1 Funções e Variáveis Definidas para augmented_lagrangian
============================================================

 -- Função: augmented_lagrangian_method (<FOM>, <xx>, <C>, <yy>)
 -- Função: augmented_lagrangian_method (<FOM>, <xx>, <C>, <yy>,
          args_opcionais)
     Retorna um mínimo aproximado da expressão <FOM> com relação às
     variáveis <xx>, mantendo restrito o valor de <C> a zero.  <yy> é
     uma lista de suposições iniciais para <xx>.  O método utilizado é
     o método do Lagrangiano aumentado (veja referências [1] e [2]).

     `args_opcionais' representam argumentos adicionais, especificados
     como `<símbolo> = <valor>'.  Os argumentos opcionais que podem ser
     colocados no lugar de <símbolo>:

    `niter'
          Número de iterações do algorítmo do Langrangiano aumentado

    `lbfgs_tolerance'
          Tolerância forneceida a LBFGS (Limited-memory, Broyden,
          Fletcher, Goldfarb, Shanno)

    `iprint'
          Parâmetro IPRINT (uma lista de dois inteiros que controlam o
          nível de informação) fornecido a LBFGS

    `%lambda'
          Valor inicial de `%lambda' a ser usado durante o cálculo do
          Lagrangiano aumentado

     Essa implementação minimiza o Lagrangiano aumentado pela pela
     aplicação do algorítmo de memória limitada BFGS (LBFGS), que é um
     algorítmo quasi-Newton.

     `load(augmented_lagrangian)' chama essa função.

     Veja também `lbfgs'.

     References:

     [1]
     http://www-fp.mcs.anl.gov/otc/Guide/OptWeb/continuous/constrained/nonlinearcon/auglag.html

     [2] http://www.cs.ubc.ca/spider/ascher/542/chap10.pdf

     Exemplo:

          (%i2) load (augmented_lagrangian);
          (%o2) /home/robert/tmp/maxima-release-branch/maxima/share/contri\
          b/augmented_lagrangian.mac
          (%i3) FOM: x^2 + 2*y^2;
                                         2    2
          (%o3)                       2 y  + x
          (%i4) xx: [x, y];
          (%o4)                        [x, y]
          (%i5) C: [x + y - 1];
          (%o5)                      [y + x - 1]
          (%o6)                        [1, 1]
          (%i7) augmented_lagrangian_method (FOM, xx, C, yy, iprint = [-1, 0]);
          (%o7) [[x = 0.6478349888525, y = 0.32391749442625],
                                           %lambda = [- 1.267422460983745]]



File: maxima.info,  Node: bode,  Next: contrib_ode,  Prev: augmented_lagrangian,  Up: Top

43 bode
*******

* Menu:

* Funções e Variáveis Definidas para bode::


File: maxima.info,  Node: Funções e Variáveis Definidas para bode,  Prev: bode,  Up: bode

43.1 Funções e Variáveis Definidas para bode
============================================

 -- Função: bode_gain (<H>, <range>, ...<plot_opts>...)
     Função para desenhar gráficos de ganho para Bode.

     Exemplos (1 a 7 provenientes de
          http://www.swarthmore.edu/NatSci/echeeve1/Ref/Bode/BodeHow.html,
     8 proveniente de Ron Crummett):
          (%i1) load("bode")$

          (%i2) H1 (s) := 100 * (1 + s) / ((s + 10) * (s + 100))$

          (%i3) bode_gain (H1 (s), [w, 1/1000, 1000])$

          (%i4) H2 (s) := 1 / (1 + s/omega0)$

          (%i5) bode_gain (H2 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i6) H3 (s) := 1 / (1 + s/omega0)^2$

          (%i7) bode_gain (H3 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i8) H4 (s) := 1 + s/omega0$

          (%i9) bode_gain (H4 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i10) H5 (s) := 1/s$

          (%i11) bode_gain (H5 (s), [w, 1/1000, 1000])$

          (%i12) H6 (s) := 1/((s/omega0)^2 + 2 * zeta * (s/omega0) + 1)$

          (%i13) bode_gain (H6 (s), [w, 1/1000, 1000]),
                            omega0 = 10, zeta = 1/10$

          (%i14) H7 (s) := (s/omega0)^2 + 2 * zeta * (s/omega0) + 1$

          (%i15) bode_gain (H7 (s), [w, 1/1000, 1000]),
                            omega0 = 10, zeta = 1/10$

          (%i16) H8 (s) := 0.5 / (0.0001 * s^3 + 0.002 * s^2 + 0.01 * s)$

          (%i17) bode_gain (H8 (s), [w, 1/1000, 1000])$

     Para usar essa função escreva primeiramente `load("bode")'. Veja
     também `bode_phase'

 -- Função: bode_phase (<H>, <range>, ...<plot_opts>...)
     Função para desenhar gráficos de fase para Bode

     Exemplos (1 a 7 provenientes de
          http://www.swarthmore.edu/NatSci/echeeve1/Ref/Bode/BodeHow.html,
     8 proveniente de Ron Crummett):
          (%i1) load("bode")$

          (%i2) H1 (s) := 100 * (1 + s) / ((s + 10) * (s + 100))$

          (%i3) bode_phase (H1 (s), [w, 1/1000, 1000])$

          (%i4) H2 (s) := 1 / (1 + s/omega0)$

          (%i5) bode_phase (H2 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i6) H3 (s) := 1 / (1 + s/omega0)^2$

          (%i7) bode_phase (H3 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i8) H4 (s) := 1 + s/omega0$

          (%i9) bode_phase (H4 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i10) H5 (s) := 1/s$

          (%i11) bode_phase (H5 (s), [w, 1/1000, 1000])$

          (%i12) H6 (s) := 1/((s/omega0)^2 + 2 * zeta * (s/omega0) + 1)$

          (%i13) bode_phase (H6 (s), [w, 1/1000, 1000]),
                             omega0 = 10, zeta = 1/10$

          (%i14) H7 (s) := (s/omega0)^2 + 2 * zeta * (s/omega0) + 1$

          (%i15) bode_phase (H7 (s), [w, 1/1000, 1000]),
                             omega0 = 10, zeta = 1/10$

          (%i16) H8 (s) := 0.5 / (0.0001 * s^3 + 0.002 * s^2 + 0.01 * s)$

          (%i17) bode_phase (H8 (s), [w, 1/1000, 1000])$

          (%i18) block ([bode_phase_unwrap : false],
                        bode_phase (H8 (s), [w, 1/1000, 1000]));

          (%i19) block ([bode_phase_unwrap : true],
                        bode_phase (H8 (s), [w, 1/1000, 1000]));

     Para usar essa função escreva primeiramente `load("bode")'. Veja
     também `bode_gain'


File: maxima.info,  Node: contrib_ode,  Next: descriptive,  Prev: bode,  Up: Top

44 contrib_ode
**************

* Menu:

* Introdução a contrib_ode::
* Funções e Variáveis Definidas para contrib_ode::
* Possibilidades de melhorias em contrib_ode::
* Casos de teste para contrib_ode::
* Referências bibliográficas para contrib_ode::


File: maxima.info,  Node: Introdução a contrib_ode,  Next: Funções e Variáveis Definidas para contrib_ode,  Prev: contrib_ode,  Up: contrib_ode

44.1 Introdução a contrib_ode
=============================

O resolvedor de equações diferenciais ordinárias (EDO) do MAXIMA, o
`ode2', resolve EDO's elementares de primeira e segunda ordem.  A
função `contrib_ode' extende `ode2' com métodos adicionais para EDO's
lineares e EDO's não lineares de primeira ordem e EDO's lineares
homogêneas de segunda ordem.  O código está ainda em desenvolvimemto e
a seqüência de chamada da função pode mudar em futuras versões.  Uma
vez que o código estiver estabilizado essa função pode ser movida do
diretório contrib e integrada dentro do MAXIMA.

   Esse pacote deve torna-se disponível para uso com o comando
`load('contrib_ode)' em primeiro lugar.

   A convenção de chamada para `contrib_ode' é idêntica a `ode2'.  Toma
três argumentos: uma EDO (somente o lado esquerdo precisa ser fornecido
se o lado direito for 0), a variável dependente, e a variável
independente.  Quando `contrib_ode' obtiver sucesso, retorna uma lista
de soluções.

   A forma de retorno da lista de solução difere de `ode2'.  Como
equações não lineares podem ter múltiplas soluções, `contrib_ode'
retorna uma lista de soluções.  Cada solução pode ter várias formas:
   * uma solução explícita para a variável dependente,

   * uma solução implícita para a variável dependente,

   * uma solução paramétrica em termos de variável %t, ou

   * uma transfrmação em outra EDO na variável %u.


   `%c' é usado para representar a constante de integração para
equações de primeira ordem.  `%k1' e `%k2' são constantes para
equações de segunda ordem.  Se `contrib_ode' não puder obter uma
solução por qualquer razão, `false' é retornado, após talvez mostrar
uma mensagem de erro.

   Isso é necessário para retornar uma lista de soluções, como mesmo
EDO's de primeira ordem não lineares podem ter soluções multiplas.  Por
exemplo:

     (%i1) load('contrib_ode)$

     (%i2) eqn:x*'diff(y,x)^2-(1+x*y)*'diff(y,x)+y=0;

                         dy 2             dy
     (%o2)            x (--)  - (x y + 1) -- + y = 0
                         dx               dx
     (%i3) contrib_ode(eqn,y,x);

                                                  x
     (%o3)             [y = log(x) + %c, y = %c %e ]
     (%i4) method;

     (%o4)                        factor

   EDO's não lineares podem ter soluções singulares sem constantes de
integração, como na segunda solução do seguinte exemplo:

     (%i1) load('contrib_ode)$

     (%i2) eqn:'diff(y,x)^2+x*'diff(y,x)-y=0;

                            dy 2     dy
     (%o2)                 (--)  + x -- - y = 0
                            dx       dx
     (%i3) contrib_ode(eqn,y,x);

                                                2
                                      2        x
     (%o3)              [y = %c x + %c , y = - --]
                                               4
     (%i4) method;

     (%o4)                       clairault

   A seguinte EDO possui duas soluções paramétricas em termos da
variável fictícia %t.  Nesse caso as soluções paramétricaspodem ser
manipuladas para fornecer soluções explícitas.

     (%i1) load('contrib_ode)$

     (%i2) eqn:'diff(y,x)=(x+y)^2;

                               dy          2
     (%o2)                     -- = (y + x)
                               dx
     (%i3) contrib_ode(eqn,y,x);

     (%o3) [[x = %c - atan(sqrt(%t)), y = - x - sqrt(%t)],
                          [x = atan(sqrt(%t)) + %c, y = sqrt(%t) - x]]
     (%i4) method;

     (%o4)                       lagrange

   O seguinte exemplo (Kamke 1.112) demonstra uma solução implícita.

     (%i1) load('contrib_ode)$

     (%i2) assume(x>0,y>0);

     (%o2)                    [x > 0, y > 0]
     (%i3) eqn:x*'diff(y,x)-x*sqrt(y^2+x^2)-y;

                          dy           2    2
     (%o3)              x -- - x sqrt(y  + x ) - y
                          dx
     (%i4) contrib_ode(eqn,y,x);

                                       y
     (%o4)                  [x - asinh(-) = %c]
                                       x
     (%i5) method;

     (%o5)                          lie

   A seguinte equação de Riccati é transformada em uma EDO linear de
segunda ordem na variável %u.  MAXIMA não está apto a resolver a nova
EDO, de forma que essa nova EDO é retornada sem avaliação.
     (%i1) load('contrib_ode)$

     (%i2) eqn:x^2*'diff(y,x)=a+b*x^n+c*x^2*y^2;

                         2 dy      2  2      n
     (%o2)              x  -- = c x  y  + b x  + a
                           dx
     (%i3) contrib_ode(eqn,y,x);

                    d%u
                    ---                            2
                    dx        2     n - 2   a     d %u
     (%o3)  [[y = - ----, %u c  (b x      + --) + ---- c = 0]]
                    %u c                     2      2
                                            x     dx
     (%i4) method;

     (%o4)                        riccati

   Para EDO's de primeira ordem `contrib_ode' chama `ode2'.  `ode2'
tenta então os seguintes métodos: fatoração, Clairault, Lagrange,
Riccati, Abel e os métodos de simetria de Lie.  O método de Lie não é
tentado sobre equações de Abel se o método de Abel falhar, mas é tendado
se o método de Riccati uma EDO de segunda ordem não resolvida.

   Para EDO's de segunda ordem `contrib_ode' chama `ode2' e em seguida
`odelin'.

   Rastros extensivos de depuração mensagens são mostradas se o comando
`put('contrib_ode,true,'verbose)' for executado.


File: maxima.info,  Node: Funções e Variáveis Definidas para contrib_ode,  Next: Possibilidades de melhorias em contrib_ode,  Prev: Introdução a contrib_ode,  Up: contrib_ode

44.2 Funções e Variáveis Definidas para contrib_ode
===================================================

 -- Função: contrib_ode (<eqn>, <y>, <x>)
     Retorna uma lista de soluções da EDO <eqn> com variável
     independente <x> e variável dependente <y>.


 -- Função: odelin (<eqn>, <y>, <x>)
     `odelin' resolve EDO's lineares homogêneas de primeira e segunda
     ordem com variável independente <x> e variável dependente <y>.
     `odelin' retorna um conjunto solução fundamental da EDO.

     para EDO's de segunda ordem, `odelin' usa um método, devido a
     Bronstein e Lafaille, que busca por soluções em termos de
     funções especiais dadas.

          (%i1) load('contrib_ode);

          (%i2) odelin(x*(x+1)*'diff(y,x,2)+(x+5)*'diff(y,x,1)+(-4)*y,y,x);
          ...trying factor method
          ...solving 7 equations in 4 variables
          ...trying the Bessel solver
          ...solving 1 equations in 2 variables
          ...trying the F01 solver
          ...solving 1 equations in 3 variables
          ...trying the spherodial wave solver
          ...solving 1 equations in 4 variables
          ...trying the square root Bessel solver
          ...solving 1 equations in 2 variables
          ...trying the 2F1 solver
          ...solving 9 equations in 5 variables
                 gauss_a(- 6, - 2, - 3, - x)  gauss_b(- 6, - 2, - 3, - x)
          (%o2) {---------------------------, ---------------------------}
                              4                            4
                             x                            x


 -- Função: ode_check (<eqn>, <sol>)
     Retorna o valor da EDO <eqn> após substituir uma possível
     solução <sol>.  O valor é igual a zero se <sol> for uma solução of
     <eqn>.

          (%i1) load('contrib_ode)$

          (%i2) eqn:'diff(y,x,2)+(a*x+b)*y;

                                   2
                                  d y
          (%o2)                   --- + (a x + b) y
                                    2
                                  dx
          (%i3) ans:[y = bessel_y(1/3,2*(a*x+b)^(3/2)/(3*a))*%k2*sqrt(a*x+b)
                   +bessel_j(1/3,2*(a*x+b)^(3/2)/(3*a))*%k1*sqrt(a*x+b)];

                                            3/2
                              1  2 (a x + b)
          (%o3) [y = bessel_y(-, --------------) %k2 sqrt(a x + b)
                              3       3 a
                                                    3/2
                                      1  2 (a x + b)
                           + bessel_j(-, --------------) %k1 sqrt(a x + b)]
                                      3       3 a
          (%i4) ode_check(eqn,ans[1]);

          (%o4)                           0


 -- Variável global: `method'
     A variável `method' é escolhida para o método que resolver com
     sucesso uma dada EDO.


 -- Variável: `%c'
     `%c' é a constante de integração para EDO's de primeira ordem.


 -- Variável: `%k1'
     `%k1' é a primeira constante de integração para EDO's de segunda
     ordem.


 -- Variável: `%k2'
     `%k2' é a segunda constante de integração para EDO's de segunda
     ordem.


 -- Função: gauss_a (<a>, <b>, <c>, <x>)
     `gauss_a(a,b,c,x)' e `gauss_b(a,b,c,x)' são funções
     hipergeométricas 2F1.  Elas represetnam quaisquer duas soluções
     independentes da equação diferencial hipergeométrica `x(1-x)
     diff(y,x,2) + [c-(a+b+1)x diff(y,x) - aby = 0' (A&S 15.5.1).

     O único uso dessas funções é em soluções de EDO's retornadas por
     `odelin' e `contrib_ode'.  A definição e o uso dessas funções pode
     mudar em futuras versões do maxima.

     Veja também `gauss_b', `dgauss_a' e `gauss_b'.


 -- Função: gauss_b (<a>, <b>, <c>, <x>)
     Veja `gauss_a'.

 -- Função: dgauss_a (<a>, <b>, <c>, <x>)
     A derivada em relação a x de `gauss_a(a,b,c,x)'.

 -- Função: dgauss_b (<a>, <b>, <c>, <x>)
     A derivada em relação a x de `gauss_b(a,b,c,x)'.

 -- Função: kummer_m (<a>, <b>, <x>)
     A função  M de Kummer, como definida em Abramowitz e Stegun,
     Handbook of Mathematical Functions, Section 13.1.2.

     O único uso dessas funções é em soluções de EDO's retornadas por
     `odelin' e `contrib_ode'.  A definição e o uso dessas funções pode
     mudar em futuras versões do maxima.

     Veja também `kummer_u', `dkummer_m' e `dkummer_u'.

 -- Função: kummer_u (<a>, <b>, <x>)
     A função U de Kummer, como definida em Abramowitz e Stegun,
     Handbook of Mathematical Functions, Section 13.1.3.

     Veja `kummer_m'.

 -- Função: dkummer_m (<a>, <b>, <x>)
     A derivada com relação a x de `kummer_m(a,b,x)'.

 -- Função: dkummer_u (<a>, <b>, <x>)
     A derivada com relação a x de  `kummer_u(a,b,x)'.


File: maxima.info,  Node: Possibilidades de melhorias em contrib_ode,  Next: Casos de teste para contrib_ode,  Prev: Funções e Variáveis Definidas para contrib_ode,  Up: contrib_ode

44.3 Possibilidades de melhorias em contrib_ode
===============================================

Essas rotinas aida estão sendo aperfeiçoadas.  É necessário ainda:

   * Extender o método FACTOR `ode1_factor' para trabalhar com raízes
     multiplas.

   * Extender o método FACTOR  `ode1_factor' para tentar resolver
     fatores   de mais alta ordem.  Atualmente somente tenta resolver
     fatores lineares.

   * Corrigir a rotina de LAGRANGE `ode1_lagrange' para preferiraízes
     reais a   raízes complexas.

   * Aumentar a quantidade de métodos adicionais para equações de
     Riccati.

   * Melhorar a detecção de equações de Abel do segundo tipo.  O modelo
      existente de coincidência é fraco.

   * Trabalho sobre a rotina do grupo de simetria de Lie `ode1_lie'.
     Existem poucos porém   grandes problemas com essa rotina: algumas
     partes precisam de implementação; alguns casos de teste   parecem
     executar indefinidamente; outros casos de teste abortam
     inesplicavelmente; outros ainda retorna "soluções"   muito
     complexas.  Seria surpreendente se estivesse pronto para se
     liberar uma versão estável.

   * Adicionar mais casos de teste.



File: maxima.info,  Node: Casos de teste para contrib_ode,  Next: Referências bibliográficas para contrib_ode,  Prev: Possibilidades de melhorias em contrib_ode,  Up: contrib_ode

44.4 Casos de teste para contrib_ode
====================================

Asrotinas foram tesadas sobre aproximadamente mil casos de teste por
Murphy, Kamke, Zwillinger e outros.  Esses testes estão incluídos no
subdiretório de testes.

   * A rotina de Clairault `ode1_clairault' encontra todas as
     soluções conhecidas,   incluindo soluções singulares, das
     equações de Clairault em Murphy e   Kamke.

   * As outras rotinas muitas vezes retornam uma solução simples quando
     existem   multiplas soluções.

   * Algumas das "soluções" de `ode1_lie' são extremamente complexas e
     impossíveis de verificar.

   * Existe algumas interrupções inexplicávies de execução.



File: maxima.info,  Node: Referências bibliográficas para contrib_ode,  Prev: Casos de teste para contrib_ode,  Up: contrib_ode

44.5 Referências bibliográficas para contrib_ode
================================================

  1. E Kamke, Differentialgleichungen Losungsmethoden und Losungen, Vol
     1,     Geest & Portig, Leipzig, 1961

  2. G M Murphy, Ordinary Differential Equations and Their Solutions,
      Van Nostrand, New York, 1960

  3. D Zwillinger, Handbook of Differential Equations, 3rd edition,
     Academic Press, 1998

  4. F Schwarz, Symmetry Analysis of Abel's Equation, Studies in
     Applied Mathematics, 100:269-294 (1998)

  5. F Schwarz, Algorithmic Solution of Abel's Equation,     Computing
     61, 39-49 (1998)

  6. E. S. Cheb-Terrab, A. D. Roche, Symmetries and First Order     EDO
     Patterns, Computer Physics Communications 113 (1998), p 239.
     (http://lie.uwaterloo.ca/papers/ode_vii.pdf)

  7. E. S. Cheb-Terrab, T. Koloknikov,  First Order EDO's,
     Symmetries and Linear Transformations, European Journal of
     Applied Mathematics, Vol. 14, No. 2, pp. 231-246 (2003).
     (http://arxiv.org/abs/math-ph/0007023)
     (http://lie.uwaterloo.ca/papers/ode_iv.pdf)

  8. G W Bluman, S C Anco, Symmetry and Integration Methods for
     Differential Equations, Springer, (2002)

  9. M Bronstein, S Lafaille, Solutions of linear ordinary equações
     diferenciais in terms of special functions, Proceedings of ISSAC
     2002, Lille, ACM Press, 23-28.
     (http://www-sop.inria.fr/cafe/Manuel.Bronstein/publications/issac2002.pdf)



File: maxima.info,  Node: descriptive,  Next: diag,  Prev: contrib_ode,  Up: Top

45 descriptive
**************

* Menu:

* Introdução ao pacote descriptive::
* Funções e Variáveis Definidas para manipulação da dados::
* Funções e Variáveis Definidas para estatística descritiva::
* Funções e Variáveis Definidas específicas para estatística descritiva de várias variáveis::
* Funções e Variáveis Definidas para gráficos estatísticos::


File: maxima.info,  Node: Introdução ao pacote descriptive,  Next: Funções e Variáveis Definidas para manipulação da dados,  Prev: descriptive,  Up: descriptive

45.1 Introdução ao pacote descriptive
=====================================

O pacote `descriptive' contém um conjunto de funções para fazer
cálculos de estatística descritiva e desenhar gráficos. Juntamente com
o código fonte três conjuntos de dados em suar árvore do Maxima:
`pidigits.data', `wind.data' e `biomed.data'. Eles também podem ser
baixados a partir de `www.biomates.net'.

   Qualque manual de estatística pode ser usado como referência para as
funções no pacote `descriptive'.

   Para comentários, erros ou sugestões, por favor entre em contato
comigo em <'mario AT edu DOT xunta DOT es'>.

   Aqui está um exemplo sobre como as funções de estatística descritiva
no pacote `descriptive' fazem esse trabalho, dependendo da natureza de
seus argumentos, listas e matrizes,

     (%i1) load (descriptive)$
     (%i2) /* univariate sample */   mean ([a, b, c]);
                                 c + b + a
     (%o2)                       ---------
                                     3
     (%i3) matrix ([a, b], [c, d], [e, f]);
                                 [ a  b ]
                                 [      ]
     (%o3)                       [ c  d ]
                                 [      ]
                                 [ e  f ]
     (%i4) /* amostra de várias variáveis */ mean (%);
                           e + c + a  f + d + b
     (%o4)                [---------, ---------]
                               3          3

   Note que em amostras de várias variáveis a média é calculada em cada
coluna.

   No caso de muitas amostras amostras com possíveis tamanhos
diferentes, A função do Maxima `map' pode ser usada para pegar os
resultados desejados de cada amostra,

     (%i1) load (descriptive)$
     (%i2) map (mean, [[a, b, c], [d, e]]);
                             c + b + a  e + d
     (%o2)                  [---------, -----]
                                 3        2

   Nesse caso, duas amostras de tamanhos 3 e 2 foram armazenadas em uma
lista.

   Amostras de uma única variável devem ser armazenadas em listas como

     (%i1) s1 : [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5];
     (%o1)           [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]

   e amostras de várias variáveis em matrizes como em

     (%i1) s2 : matrix ([13.17, 9.29], [14.71, 16.88], [18.50, 16.88],
                  [10.58, 6.63], [13.33, 13.25], [13.21,  8.12]);
                             [ 13.17  9.29  ]
                             [              ]
                             [ 14.71  16.88 ]
                             [              ]
                             [ 18.5   16.88 ]
     (%o1)                   [              ]
                             [ 10.58  6.63  ]
                             [              ]
                             [ 13.33  13.25 ]
                             [              ]
                             [ 13.21  8.12  ]

   Nesse caso, o número de colunas é igual à dimensão (ao número) de
variáveis e o n;umero de linhas é o tamano da amostra.

   Dados podem ser introduzidos manualmente, mas grandes amostras são
usualmente armazenadas em arquivos no formato texto plano. Por exemplo,
o arquivo `pidigits.data' contém os primeiros 100 dígitos do número
`%pi':
           3
           1
           4
           1
           5
           9
           2
           6
           5
           3 ...

   Com o objetivo de chamar esses dígitos no Maxima,

     (%i1) load (numericalio)$
     (%i2) s1 : read_list (file_search ("pidigits.data"))$
     (%i3) length (s1);
     (%o3)                          100

   Por outro lado, o arquivo `wind.data' contém a média diária de
velocidades do ventoem 5 estações meteorológicas na República da
Irlanda (Esses dados são parte de um conjunto de dados tomados em 12
estações meteorológicas. O arquivo original está disponivel livremente
para download no Repositório de Dados StatLib e sua análise é discutida
em Haslett, J., Raftery, A. E. (1989) <Space-time Modelling with
Long-memory Dependence: Assessing Ireland's Wind Power Resource, with
Discussion>. Applied Statistics 38, 1-50). As linhas seguintes mostram
como tornar os dados disponíveis para o Maxima:

     (%i1) load (numericalio)$
     (%i2) s2 : read_matrix (file_search ("wind.data"))$
     (%i3) length (s2);
     (%o3)                          100
     (%i4) s2 [%]; /* last record */
     (%o4)            [3.58, 6.0, 4.58, 7.62, 11.25]

   Algumas amostras possuem dados não numéricos. Como um exemplo, o
arquivo `biomed.data' (que é parte de outro grande arquivo tomado do
Repósitório de Dados StatLib) contém quatro medidas sangüíneas tomadas
de dois grupos de pacientes, `A' e `B', de diferentes idades,

     (%i1) load (numericalio)$
     (%i2) s3 : read_matrix (file_search ("biomed.data"))$
     (%i3) length (s3);
     (%o3)                          100
     (%i4) s3 [1]; /* first record */
     (%o4)            [A, 30, 167.0, 89.0, 25.6, 364]

   O primeiro indivíduo pertence ao grupo `A', com 30 anos de idade e
suas medidas sangüíneas foram 167.0, 89.0, 25.6 e 364.

   Se deve tomar cuidado quando se trabalha com dados divididos por
categorias. no exemplo seguinte, ao símbolo `a' é atribuído um valor em
algum momento anterior e então a amostra com valores divididos por
categoria `a' é interpretada como,

     (%i1) a : 1$
     (%i2) matrix ([a, 3], [b, 5]);
                                 [ 1  3 ]
     (%o2)                       [      ]
                                 [ b  5 ]


File: maxima.info,  Node: Funções e Variáveis Definidas para manipulação da dados,  Next: Funções e Variáveis Definidas para estatística descritiva,  Prev: Introdução ao pacote descriptive,  Up: descriptive

45.2 Funções e Variáveis Definidas para manipulação da dados
============================================================

 -- Função: continuous_freq (<list>)
 -- Função: continuous_freq (<list>, <m>)
     O argumetno de `continuous_freq' deve ser uma lista de números,
     que serão então agrupadas em intervalos e contado quantos desses
     dados pertencem a cada grupo. Opcionalmente, a função
     `continuous_freq' admite um segundo argumento indicando o número
     de classes, 10 é o valor padrão,

          (%i1) load (numericalio)$
          (%i2) load (descriptive)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) continuous_freq (s1, 5);
          (%o4) [[0, 1.8, 3.6, 5.4, 7.2, 9.0], [16, 24, 18, 17, 25]]

     A primeira lista contém os limites de intervalos e o segundo a
     correspondente contagem: existem 16 algarismos da parte decimal de
     `%pi' dentro do intervalo `[0, 1.8]', isto é 0's e 1's, 24
     algarismos em `(1.8, 3.6]', isto é 2's e 3's, e assim por diante.

 -- Função: discrete_freq (<list>)
     Conta as freqüências absolutas em amostras discretas, em amostras
     numéricas e em amostras divididas em categorias. Seu único
     argumento é uma lista,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"));
          (%o3) [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9, 3, 2, 3, 8,
          4, 6, 2, 6, 4, 3, 3, 8, 3, 2, 7, 9, 5, 0, 2, 8, 8, 4, 1, 9, 7,
          1, 6, 9, 3, 9, 9, 3, 7, 5, 1, 0, 5, 8, 2, 0, 9, 7, 4, 9, 4, 4,
          5, 9, 2, 3, 0, 7, 8, 1, 6, 4, 0, 6, 2, 8, 6, 2, 0, 8, 9, 9, 8,
          6, 2, 8, 0, 3, 4, 8, 2, 5, 3, 4, 2, 1, 1, 7, 0, 6, 7]
          (%i4) discrete_freq (s1);
          (%o4) [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
                                       [8, 8, 12, 12, 10, 8, 9, 8, 12, 13]]

     A primeira lista fornece os valores da amostra e a segunda seuas
     freqüências absolutas. Os comandos `? col' e `? transpose' podem
     ajudar a você a entender a última entrada.

 -- Função: subsample (<matriz_de_dados>, <expressão_lógica>)
 -- Função: subsample (<matriz_de_dados>, <expressão_lógica>,
          <col_num>, <col_num>, ...)
     Essas funções são um tipo de variação da função `submatrix' do
     Maxima. O primeiro argumento é o nome da matriz de dados, o
     segundo argumento é uma expressão lógica que recebeu apóstrofo e
     os argumentos opcionais adicionais são o número de colunas a serem
     tomadas. Esse comportamento é melhor entendido com exemplos,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) subsample (s2, '(%c[1] > 18));
                        [ 19.38  15.37  15.12  23.09  25.25 ]
                        [                                   ]
                        [ 18.29  18.66  19.08  26.08  27.63 ]
          (%o4)         [                                   ]
                        [ 20.25  21.46  19.95  27.71  23.38 ]
                        [                                   ]
                        [ 18.79  18.96  14.46  26.38  21.84 ]

     Existem registros de várias variáveis nos quais a velocidade do
     vento na primeira estação meteorológica foram maiores que 18. Veja
     que na expressão lógica que recebeu apóstrofo o <i>-ésimo
     componente é referenciado como `%c[i]'. O símbolo `%c[i]' é usado
     dentro da função `subsample', portanto quando usado como uma
     variável de uma categoria, Maxima fica confuso. No seguinte
     exemplo, requisitamos somente o primeiro, o segundo e o quinto
     componentes desses registro com velocidades de vento maiores que
     ou igual a 16 nós na estação meteorológica número 1 e menor que 25
     nós na estação meteorológica número 4,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) subsample (s2, '(%c[1] >= 16 and %c[4] < 25), 1, 2, 5);
                               [ 19.38  15.37  25.25 ]
                               [                     ]
                               [ 17.33  14.67  19.58 ]
          (%o4)                [                     ]
                               [ 16.92  13.21  21.21 ]
                               [                     ]
                               [ 17.25  18.46  23.87 ]

     Aqui está um exemplo com as variáveis divididas em categorias do
     arquivo `biomed.data'. Queremos os registros correspondentes a
     aqueles pacientes no grupo `B' que possuem idade maior que 38 anos,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) subsample (s3, '(%c[1] = B and %c[2] > 38));
                          [ B  39  28.0  102.3  17.1  146 ]
                          [                               ]
                          [ B  39  21.0  92.4   10.3  197 ]
                          [                               ]
                          [ B  39  23.0  111.5  10.0  133 ]
                          [                               ]
                          [ B  39  26.0  92.6   12.3  196 ]
          (%o4)           [                               ]
                          [ B  39  25.0  98.7   10.0  174 ]
                          [                               ]
                          [ B  39  21.0  93.2   5.9   181 ]
                          [                               ]
                          [ B  39  18.0  95.0   11.3  66  ]
                          [                               ]
                          [ B  39  39.0  88.5   7.6   168 ]

     Probavelmente, a análise estatística irá envolver somente as
     medidas sangüíneas,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) subsample (s3, '(%c[1] = B and %c[2] > 38), 3, 4, 5, 6);
                             [ 28.0  102.3  17.1  146 ]
                             [                        ]
                             [ 21.0  92.4   10.3  197 ]
                             [                        ]
                             [ 23.0  111.5  10.0  133 ]
                             [                        ]
                             [ 26.0  92.6   12.3  196 ]
          (%o4)              [                        ]
                             [ 25.0  98.7   10.0  174 ]
                             [                        ]
                             [ 21.0  93.2   5.9   181 ]
                             [                        ]
                             [ 18.0  95.0   11.3  66  ]
                             [                        ]
                             [ 39.0  88.5   7.6   168 ]

     Essa é a média de várias variáveis de `s3',

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) mean (s3);
                 65 B + 35 A  317          6 NA + 8145.0
          (%o4) [-----------, ---, 87.178, -------------, 18.123,
                     100      10                100
                                                              3 NA + 19587
                                                              ------------]
                                                                  100
     Aqui, a primeira componente é sem sentido, uma vez que `A' e `B'
     são categorias, o segundo componente é a idade média dos
     indivíduos na forma racional, e o quarto eo último valores exibem
     um comportamento estranho. Isso ocorre porque o símbolo `NA' é
     usado aqui para indicar dado não disponível (<non available> em
     inglês), e as duas médias são certamente sem sentido. Uma
     solução possível pode ser jogar fora a matriz cujas linhas possuam
     símbolos `NA', embora isso cause alguma perda de informação,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) mean (subsample (s3, '(%c[4] # NA and %c[6] # NA), 3, 4, 5, 6));
          (%o4) [79.4923076923077, 86.2032967032967, 16.93186813186813,
                                                                      2514
                                                                      ----]
                                                                       13


File: maxima.info,  Node: Funções e Variáveis Definidas para estatística descritiva,  Next: Funções e Variáveis Definidas específicas para estatística descritiva de várias variáveis,  Prev: Funções e Variáveis Definidas para manipulação da dados,  Up: descriptive

45.3 Funções e Variáveis Definidas para estatística descritiva
==============================================================

 -- Função: mean (<lista>)
 -- Função: mean (<matriz>)
     Essa função calcula a média de uma amostra, definida como
                                 n
                               ====
                       _   1   \
                       x = -    >    x
                           n   /      i
                               ====
                               i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) mean (s1);
                                         471
          (%o4)                          ---
                                         100
          (%i5) %, numer;
          (%o5)                         4.71
          (%i6) s2 : read_matrix (file_search ("wind.data"))$
          (%i7) mean (s2);
          (%o7)     [9.9485, 10.1607, 10.8685, 15.7166, 14.8441]

 -- Função: var (<list>)
 -- Função: var (<matrix>)
     This is the sample variance, defined as
                               n
                             ====
                     2   1   \          _ 2
                    s  = -    >    (x - x)
                         n   /       i
                             ====
                             i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) var (s1), numer;
          (%o4)                   8.425899999999999

     See also function `var1'.

 -- Função: var1 (<lista>)
 -- Função: var1 (<matriz>)
     Essa função calcula a variância da amostra, definida como
                               n
                             ====
                         1   \          _ 2
                        ---   >    (x - x)
                        n-1  /       i
                             ====
                             i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) var1 (s1), numer;
          (%o4)                    8.5110101010101
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) var1 (s2);
          (%o6) [17.39586540404041, 15.13912778787879, 15.63204924242424,
                                      32.50152569696971, 24.66977392929294]

     See also function `var'.

 -- Função: std (<lista>)
 -- Função: std (<matriz>)
     A raíz quadrada da função `var', a variância com denominador n.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) std (s1), numer;
          (%o4)                   2.902740084816414
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) std (s2);
          (%o6) [4.149928523480858, 3.871399812729241, 3.933920277534866,
                                      5.672434260526957, 4.941970881136392]

     Veja também as funções `var' e `std1'.

 -- Função: std1 (<lista>)
 -- Função: std1 (<matriz>)
     É a raíz quadrada da função `var1', a variância com denominador
     n-1.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) std1 (s1), numer;
          (%o4)                   2.917363553109228
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) std1 (s2);
          (%o6) [4.17083509672109, 3.89090320978032, 3.953738641137555,
                                      5.701010936401517, 4.966867617451963]

     Veja também as funções `var1' e `std'.

 -- Função: noncentral_moment (<lista>, <k>)
 -- Função: noncentral_moment (<matriz>, <k>)
     O momento não central de ordem k, definido como
                                 n
                               ====
                           1   \      k
                           -    >    x
                           n   /      i
                               ====
                               i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) noncentral_moment (s1, 1), numer; /* the mean */
          (%o4)                         4.71
          (%i6) s2 : read_matrix (file_search ("wind.data"))$
          (%i7) noncentral_moment (s2, 5);
          (%o7) [319793.8724761506, 320532.1923892463, 391249.5621381556,
                                      2502278.205988911, 1691881.797742255]

     Veja também a função `central_moment'.

 -- Função: central_moment (<lista>, <k>)
 -- Função: central_moment (<matriz>, <k>)
     O momento central de ordem k, definido como
                              n
                            ====
                        1   \          _ k
                        -    >    (x - x)
                        n   /       i
                            ====
                            i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) central_moment (s1, 2), numer; /* a variância */
          (%o4)                   8.425899999999999
          (%i6) s2 : read_matrix (file_search ("wind.data"))$
          (%i7) central_moment (s2, 3);
          (%o7) [11.29584771375004, 16.97988248298583, 5.626661952750102,
                                       37.5986572057918, 25.85981904394192]

     Veja também as funções `central_moment' e `mean'.

 -- Função: cv (<lista>)
 -- Função: cv (<matriz>)
     O coeficiente de variação é o quociente entre o desvio padrão da
     amostra (`std') e a média `mean',

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) cv (s1), numer;
          (%o4)                   .6193977819764815
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) cv (s2);
          (%o6) [.4192426091090204, .3829365309260502, 0.363779605385983,
                                      .3627381836021478, .3346021393989506]

     Veja também as funções `std' e `mean'.

 -- Função: mini (<lista>)
 -- Função: mini (<matriz>)
     É o valor mínimo da amostra <lista>,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) mini (s1);
          (%o4)                           0
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) mini (s2);
          (%o6)             [0.58, 0.5, 2.67, 5.25, 5.17]

     Veja também função `maxi'.

 -- Função: maxi (<lista>)
 -- Função: maxi (<matriz>)
     É o valor máximo da amostra <lista>,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) maxi (s1);
          (%o4)                           9
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) maxi (s2);
          (%o6)          [20.25, 21.46, 20.04, 29.63, 27.63]

     Veja também a função `mini'.

 -- Função: range (<lista>)
 -- Função: range (<matriz>)
     A amplitude é a diferença entre os valores de maximo e de mínimo.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) range (s1);
          (%o4)                           9
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) range (s2);
          (%o6)          [19.67, 20.96, 17.37, 24.38, 22.46]

 -- Função: quantile (<lista>, <p>)
 -- Função: quantile (<matriz>, <p>)
     É o <p>-`quantile' (quantil de ordem <p>), com <p> sendo um número
     em [0, 1] (intervalo fechado), da amostra <lista>.  Embora exista
     muitas definições para quantil de uma amostra (Hyndman, R. J.,
     Fan, Y. (1996) <Sample quantiles in statistical packages>.
     American Statistician, 50, 361-365), aquela que se baseia em
     interpolação linear é a que foi implementada no pacote
     `descriptive'.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) /* 1st and 3rd quartiles */ [quantile (s1, 1/4), quantile (s1, 3/4)], numer;
          (%o4)                      [2.0, 7.25]
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) quantile (s2, 1/4);
          (%o6)    [7.2575, 7.477500000000001, 7.82, 11.28, 11.48]

 -- Função: median (<lista>)
 -- Função: median (<matriz>)
     Uma vez que a amostra está ordenada, se o tamanho da amostra for
     ímpar a mediana é o valor central, de outra forma a mediana será a
     média dos dois valores centrais.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) median (s1);
                                          9
          (%o4)                           -
                                          2
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) median (s2);
          (%o6)         [10.06, 9.855, 10.73, 15.48, 14.105]

     A mediana é o 1/2-`quantil'.

     Veja também function `quantile'.

 -- Função: qrange (<lista>)
 -- Função: qrange (<matriz>)
     A amplitude do interquartil é a diferença entre o terceiro e o
     primeiro quartil, `quantile(<lista>,3/4) - quantile(<lista>,1/4)',

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) qrange (s1);
                                         21
          (%o4)                          --
                                         4
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) qrange (s2);
          (%o6) [5.385, 5.572499999999998, 6.0225, 8.729999999999999,
                                                         6.650000000000002]

     Veja também a função `quantile'.

 -- Função: mean_deviation (<lista>)
 -- Função: mean_deviation (<matriz>)
     O desvio médio, definido como
                               n
                             ====
                         1   \          _
                         -    >    |x - x|
                         n   /       i
                             ====
                             i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) mean_deviation (s1);
                                         51
          (%o4)                          --
                                         20
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) mean_deviation (s2);
          (%o6) [3.287959999999999, 3.075342, 3.23907, 4.715664000000001,
                                                         4.028546000000002]

     Veja também a função `mean'.

 -- Função: median_deviation (<lista>)
 -- Função: median_deviation (<matriz>)
     O desvio da mediana, definido como
                           n
                         ====
                     1   \
                     -    >    |x - med|
                     n   /       i
                         ====
                         i = 1
     onde `med' é a mediana da <lista>.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) median_deviation (s1);
                                          5
          (%o4)                           -
                                          2
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) median_deviation (s2);
          (%o6)           [2.75, 2.755, 3.08, 4.315, 3.31]

     Veja também a função `mean'.

 -- Função: harmonic_mean (<lista>)
 -- Função: harmonic_mean (<matriz>)
     A média harmônica, definida como
                            n
                         --------
                          n
                         ====
                         \     1
                          >    --
                         /     x
                         ====   i
                         i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) y : [5, 7, 2, 5, 9, 5, 6, 4, 9, 2, 4, 2, 5]$
          (%i4) harmonic_mean (y), numer;
          (%o4)                   3.901858027632205
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) harmonic_mean (s2);
          (%o6) [6.948015590052786, 7.391967752360356, 9.055658197151745,
                                      13.44199028193692, 13.01439145898509]

     Veja também as funções `mean' e `geometric_mean'.

 -- Função: geometric_mean (<lista>)
 -- Função: geometric_mean (<matriz>)
     A média geométrica, definida como
                           /  n      \ 1/n
                           | /===\   |
                           |  ! !    |
                           |  ! !  x |
                           |  ! !   i|
                           | i = 1   |
                           \         /

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) y : [5, 7, 2, 5, 9, 5, 6, 4, 9, 2, 4, 2, 5]$
          (%i4) geometric_mean (y), numer;
          (%o4)                   4.454845412337012
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) geometric_mean (s2);
          (%o6) [8.82476274347979, 9.22652604739361, 10.0442675714889,
                                      14.61274126349021, 13.96184163444275]

     Veja também as funções `mean' e `harmonic_mean'.

 -- Função: kurtosis (<lista>)
 -- Função: kurtosis (<matriz>)
     O coeficiente de curtose, definido como
                              n
                            ====
                      1     \          _ 4
                     ----    >    (x - x)  - 3
                        4   /       i
                     n s    ====
                            i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) kurtosis (s1), numer;
          (%o4)                  - 1.273247946514421
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) kurtosis (s2);
          (%o6) [- .2715445622195385, 0.119998784429451,
             - .4275233490482866, - .6405361979019522, - .4952382132352935]

     Veja também as funções `mean', `var' e `skewness'.

 -- Função: skewness (<lista>)
 -- Função: skewness (<matriz>)
     O coeficiente de assimetria, definido como
                              n
                            ====
                      1     \          _ 3
                     ----    >    (x - x)
                        3   /       i
                     n s    ====
                            i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) skewness (s1), numer;
          (%o4)                  .009196180476450306
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) skewness (s2);
          (%o6) [.1580509020000979, .2926379232061854, .09242174416107717,
                                      .2059984348148687, .2142520248890832]

     Veja também as funções `mean', `var' e `kurtosis'.

 -- Função: pearson_skewness (<lista>)
 -- Função: pearson_skewness (<matriz>)
     O coeficiente de assimetria de pearson, definido como
                          _
                       3 (x - med)
                       -----------
                            s
     onde <med> é a mediana de <lista>.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) pearson_skewness (s1), numer;
          (%o4)                   .2159484029093895
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) pearson_skewness (s2);
          (%o6) [- .08019976629211892, .2357036272952649,
                   .1050904062491204, .1245042340592368, .4464181795804519]

     Veja também as funções `mean', `var' e `median'.

 -- Função: quartile_skewness (<lista>)
 -- Função: quartile_skewness (<matriz>)
     O coeficiented de assimetria do quartil, definido como
                         c    - 2 c    + c
                          3/4      1/2    1/4
                         --------------------
                             c    - c
                              3/4    1/4
     onde c_p é o quartil de ordem <p> da amostra <lista>.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) quartile_skewness (s1), numer;
          (%o4)                  .04761904761904762
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) quartile_skewness (s2);
          (%o6) [- 0.0408542246982353, .1467025572005382,
                 0.0336239103362392, .03780068728522298, 0.210526315789474]

     Veja também a função `quantile'.


File: maxima.info,  Node: Funções e Variáveis Definidas específicas para estatística descritiva de várias variáveis,  Next: Funções e Variáveis Definidas para gráficos estatísticos,  Prev: Funções e Variáveis Definidas para estatística descritiva,  Up: descriptive

45.4 Funções e Variáveis Definidas específicas para estatística descritiva de várias variáveis
==============================================================================================

 -- Função: cov (<matriz>)
     A matriz de covariância da amostra de várias variáveis, definida
     como
                        n
                       ====
                    1  \           _        _
                S = -   >    (X  - X) (X  - X)'
                    n  /       j        j
                       ====
                       j = 1
     onde X_j é a j-ésima linha da matriz de amostra.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) fpprintprec : 7$  /* modifique a precisão para obter uma saída melhor */
          (%i5) cov (s2);
                [ 17.22191  13.61811  14.37217  19.39624  15.42162 ]
                [                                                  ]
                [ 13.61811  14.98774  13.30448  15.15834  14.9711  ]
                [                                                  ]
          (%o5) [ 14.37217  13.30448  15.47573  17.32544  16.18171 ]
                [                                                  ]
                [ 19.39624  15.15834  17.32544  32.17651  20.44685 ]
                [                                                  ]
                [ 15.42162  14.9711   16.18171  20.44685  24.42308 ]

     Veja também a função `cov1'.

 -- Função: cov1 (<matriz>)
     A matriz de covariância da amostra de várias variáveis, definida
     como
                        n
                       ====
                   1   \           _        _
             S  = ---   >    (X  - X) (X  - X)'
              1   n-1  /       j        j
                       ====
                       j = 1
     where X_j is the j-th row of the sample matrix.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) fpprintprec : 7$ /* modifique a precisão para obter uma saída melhor */
          (%i5) cov1 (s2);
                [ 17.39587  13.75567  14.51734  19.59216  15.5774  ]
                [                                                  ]
                [ 13.75567  15.13913  13.43887  15.31145  15.12232 ]
                [                                                  ]
          (%o5) [ 14.51734  13.43887  15.63205  17.50044  16.34516 ]
                [                                                  ]
                [ 19.59216  15.31145  17.50044  32.50153  20.65338 ]
                [                                                  ]
                [ 15.5774   15.12232  16.34516  20.65338  24.66977 ]

     Veja também a função `cov'.

 -- Função: global_variances (<matriz>)
 -- Função: global_variances (<matriz>, <valor_lógico>)
     A função `global_variances' retorna uma lista de medidas de
     variância global:

        * <variância total>: `trace(S_1)',

        * <variância média>: `trace(S_1)/p',

        * <variância generalizada>: `determinant(S_1)',

        * <desvio padrão generalizado>: `sqrt(determinant(S_1))',

        * <variância efetiva> `determinant(S_1)^(1/p)', (defined in:
          Peña, D. (2002) <Análisis de datos multivariantes>;
          McGraw-Hill, Madrid.)

        * <desvio padrão efetivo>: `determinant(S_1)^(1/(2*p))'.
     onde <p> é a dimensão das várias variáveis aleatórias e S_1 a
     matriz de covariância retornada por `cov1'.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) global_variances (s2);
          (%o4) [105.338342060606, 21.06766841212119, 12874.34690469686,
                   113.4651792608502, 6.636590811800794, 2.576158149609762]

     A função `global_variances' tem um argumento lógico opcional:
     `global_variances(x,true)' diz ao Maxima que `x' é a matriz de
     dados, fazendo o mesmo que `global_variances(x)'. Por outro lado,
     `global_variances(x,false)' significa que `x' não é a matriz de
     dados, mas a matriz de covariância, evitando a repetição seu
     cálculo,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) s : cov1 (s2)$
          (%i5) global_variances (s, false);
          (%o5) [105.338342060606, 21.06766841212119, 12874.34690469686,
                   113.4651792608502, 6.636590811800794, 2.576158149609762]

     Veja também `cov' e `cov1'.

 -- Função: cor (<matriz>)
 -- Função: cor (<matriz>, <valor_lógico>)
     A matriz de correlação da maostra de várias variáveis.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) fpprintprec:7$
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) cor (s2);
                [   1.0     .8476339  .8803515  .8239624  .7519506 ]
                [                                                  ]
                [ .8476339    1.0     .8735834  .6902622  0.782502 ]
                [                                                  ]
          (%o5) [ .8803515  .8735834    1.0     .7764065  .8323358 ]
                [                                                  ]
                [ .8239624  .6902622  .7764065    1.0     .7293848 ]
                [                                                  ]
                [ .7519506  0.782502  .8323358  .7293848    1.0    ]

     A função `cor' tem um argumento lógico opcional: `cor(x,true)' diz
     ao Maxima que `x' é a matriz de dados, fazendo o mesmo que
     `cor(x)'. Por outro lado, `cor(x,false)' significa que `x' não é a
     matriz de dados, mas a matriz de covariância, evitando a
     repetição de seu cálculo,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) fpprintprec:7$
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) s : cov1 (s2)$
          (%i6) cor (s, false); /* this is faster */
                [   1.0     .8476339  .8803515  .8239624  .7519506 ]
                [                                                  ]
                [ .8476339    1.0     .8735834  .6902622  0.782502 ]
                [                                                  ]
          (%o6) [ .8803515  .8735834    1.0     .7764065  .8323358 ]
                [                                                  ]
                [ .8239624  .6902622  .7764065    1.0     .7293848 ]
                [                                                  ]
                [ .7519506  0.782502  .8323358  .7293848    1.0    ]

     Veja também `cov' e `cov1'.

 -- Função: list_correlations (<matriz>)
 -- Função: list_correlations (<matriz>, <valor_lógico>)
     A função `list_correlations' retorna uma lista de medidas de
     correlação:

        * <matriz de precisão>: o inverso da matriz de covariância S_1,
                      -1     ij
                     S   = (s  )
                      1         i,j = 1,2,...,p

        * <vetor de correlação multipla>:  (R_1^2, R_2^2, ..., R_p^2),
          com
                      2          1
                     R  = 1 - -------
                      i        ii
                              s   s
                                   ii
          sendo um indicador do melhor do ajuste do modelo de regressão
          linear de várias variáveis dobre X_i quando o resto das
          variáveis são usados como regressores.

        * <matriz de correlação parcial>: como elemento (i, j) sendo
                                        ij
                                       s
                     r        = - ------------
                      ij.rest     / ii  jj\ 1/2
                                  |s   s  |
                                  \       /


     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) z : list_correlations (s2)$
          (%i5) fpprintprec : 5$ /* for pretty output */
          (%i6) z[1];  /* precision matrix */
                [  .38486   - .13856   - .15626   - .10239    .031179  ]
                [                                                      ]
                [ - .13856   .34107    - .15233    .038447   - .052842 ]
                [                                                      ]
          (%o6) [ - .15626  - .15233    .47296    - .024816  - .10054  ]
                [                                                      ]
                [ - .10239   .038447   - .024816   .10937    - .034033 ]
                [                                                      ]
                [ .031179   - .052842  - .10054   - .034033   .14834   ]
          (%i7) z[2];  /* multiple correlation vector */
          (%o7)       [.85063, .80634, .86474, .71867, .72675]
          (%i8) z[3];  /* partial correlation matrix */
                 [  - 1.0     .38244   .36627   .49908   - .13049 ]
                 [                                                ]
                 [  .38244    - 1.0    .37927  - .19907   .23492  ]
                 [                                                ]
          (%o8)  [  .36627    .37927   - 1.0    .10911    .37956  ]
                 [                                                ]
                 [  .49908   - .19907  .10911   - 1.0     .26719  ]
                 [                                                ]
                 [ - .13049   .23492   .37956   .26719    - 1.0   ]

     A função `list_correlations' também tem um argumento lógico
     opcional: `list_correlations(x,true)' diz ao Maxima que `x' é a
     matriz de dados, fazendo o mesmo que `list_correlations(x)'. Por
     outro lado, `list_correlations(x,false)' significa que `x' não é a
     matriz de correlação, mas a matriz de covariancia, evitando a
     repetição de seu cálculo.

     Veja também `cov' e `cov1'.


File: maxima.info,  Node: Funções e Variáveis Definidas para gráficos estatísticos,  Prev: Funções e Variáveis Definidas específicas para estatística descritiva de várias variáveis,  Up: descriptive

45.5 Funções e Variáveis Definidas para gráficos estatísticos
=============================================================

 -- Função: dataplot (<lista>)
 -- Função: dataplot (<lista>, <opção_1>, <opção_2>, ...)
 -- Função: dataplot (<matriz>)
 -- Função: dataplot (<matriz>, <opção_1>, <opção_2>, ...)
     A função `dataplot' permite visualização direta de dados de
     amostra, ambas d uma única variável (<lista>) e de várias
     variáveis (<matriz>). Fornecendo valores para as seguintes
     <opções> que são alguns aspéctos de impressão que podem ser
     controlados:

        * `'outputdev', o valor padrão é `"x"', indica o formato de
          dispositivo/arquivo da figura de saída; valores corretos são
          `"x"', `"eps"' e `"png"', para a tela, formato de arquivo
          postscript e formato de arquivo png, respectivamente.

        * `'maintitle', o valor padrão é `""', é o título principal
          entre aspas duplas.

        * `'axisnames', o valor padrão é `["x","y","z"]', é uma lista
          de nomes dos eixos `x', `y' e `z'.

        * `'joined', o valor padrão é `false', um valor lógico para
          selecionar pontos em 2D para serem unidos ou isolados.

        * `'picturescales', o valor padrão é `[1.0, 1.0]', fator de
          proporcionalidade para o tamanho do gráfico.

        * `'threedim', o valor padrão é `true', diz ao Maxima se ou
          monta-se o gráfico de uma matriz de três colunas como um
          diagrama 3D ou se monta-se o gráfico como um diagrama de
          dispersão de várias variáveis. Veja exemplos abaixo.

        * `'axisrot', o valor padrão é `[60, 30]', modifica o ponto de
          visualização quando `'threedim' for escolhido para `true'
          dados forem armazenados em uma matriz de três colunas. O
          primeiro número é o ângulo de rotação do eixo <x>, e o
          segundo número é o angulo de rotação do eixo <z>-axis, ambas
          as medidas em graus.

        * `'nclasses', o valor padrão é `10', é o número de classes
          para histogramas na diagonal de gráficos de dispersão de
          várias variáveis.

        * `'pointstyle', o valor padrão é `1', é um inteiro que indica
          como mostrar pontos de amostra.


     Por exemplo, com a seguite entrada um gráfico simples dos
     primeiros vinte dígitos de `%pi' é requisitado e a saída é
     armazenada em um arquivo no formato eps.

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) dataplot (makelist (s1[k], k, 1, 20), 'pointstyle = 3)$

     Note que dados unidimensionais são colocados no gráfico como uma
     série de tempo. No caso seguinte, ocorre a mesma coisa só que com
     mais dados e com mais configurações,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) dataplot (makelist (s1[k], k, 1, 50), 'maintitle = "Primeiros dígitos de pi",
           'axisnames = ["ordem do dígito", "valor do dígito"], 'pointstyle = 2,
           'joined = true)$

     A função `dataplot' pode ser usada para montar gráficos de pontos
     no plano. O exemplo seguinte é gráfico de dispersão de pares de
     pontos de velocidades de vento para o primeira e para o quinta
     estação meteorológica,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) dataplot (submatrix (s2, 2, 3, 4), 'pointstyle = 2,
           'maintitle = "Pares de medidas de velocidade do vento em nós",
           'axisnames = ["Velocidade do vento em A", "Velocidade do vento em E"])$

     Se pontos forem armazenados em uma matriz de duas colunas,
     `dataplot' pode montar o gráfico desses pontos diretamente, mas se
     eles forem formatados em uma lista de pares, essa lista deve ser
     transformada em uma matriz como no seguinte exemplo.

          (%i1) load (descriptive)$
          (%i2) x : [[-1, 2], [5, 7], [5, -3], [-6, -9], [-4, 6]]$
          (%i3) dataplot (apply ('matrix, x), 'maintitle = "Pontos",
           'joined = true, 'axisnames = ["", ""], 'picturescales = [0.5, 1.0])$

     Pontos no espaço tridimensional podem ser vistos como uma
     projeção no plano. Nesse exemplo, o gráfico de velocidades do
     vento correspondendo a três estações meteorológicas são
     requisitados, primeiramente em um gráfico em 3D e a seguir em um
     gráfico de dispers@~ao de várias variáveis.

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) /* 3D plot */ dataplot (submatrix (s2, 4, 5), 'pointstyle = 2,
           'maintitle = "Pares de medidas de velocidades do vento em nós",
           'axisnames = ["Estação A", "Estação B", "Estação C"])$
          (%i5) /* Gráfico de dispersão de várias variáveis */ dataplot (submatrix (s2, 4, 5),
           'nclasses = 6, 'threedim = false)$
     Note que no último exemplo, o número de classes no histogramas da
     diagonal é escolhido para 6, e aquela opção `'threedim' for
     escolhida para `false'.

     Para mais que três dimensões somente gráficos de dispersão de
     várias variáveis são possível, como em

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) dataplot (s2)$

 -- Função: histogram (<lista>)
 -- Função: histogram (<lista>, <opção_1>, <opção_2>, ...)
 -- Função: histogram (<one_column_matrix>)
 -- Função: histogram (<one_column_matrix>, <opção_1>, <opção_2>, ...)
     Essa função monta um gráfico de um histograma. Dados de amostras
     devem ser armazenados em uma lista de números ou em uma matriz de
     uma coluna. Fornecendo valores para as seguintes <opções> alguns
     aspéctos do gráfico podem ser controlados:

        * `'outputdev', o valor padrão é `"x"', indica o formato de
          arquivo da figura de saída; valores corretos são `"x"',
          `"eps"' e `"png"', para a tela, formato de arquivo postscript
          e formato de arquivo png, respectivamente.

        * `'maintitle', o valor padrão é `""', é o título principal
          entre aspas duplas.

        * `'axisnames', o valor padrão é `["x", "Fr."]', é uma lista de
          nomes dos eixos `x' e `y'.

        * `'picturescales', o valor padrão é `[1.0, 1.0]', fator de
          proporcionalidade para o tamanho do gráfico.

        * `'nclasses', o valor padrão é `10', é o número de classes ou
          o número de barras.

        * `'relbarwidth', o valor padrão é `0.9', um número decimao
          entre 0 e 1 para controlar a largura das barras.

        * `'barcolor', o valor padrão é `1', um inteiro para indicar a
          cor das barras.

        * `'colorintensity', o valor padrão é `1', um número decimal
          entre 0 e 1 para estabelecer a intensidade da cor.


     Nos próximos dois exemplos, histogramas são requisitados para os
     primeiros 100 dígitos do número `%pi' e para velocidades do vento
     na terceira estação meteorológica.

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) histogram (s1, 'maintitle = "dígitos de pi", 'axisnames = ["", "Freqüência absoluta"],
           'relbarwidth = 0.2, 'barcolor = 3, 'colorintensity = 0.6)$
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) histogram (col (s2, 3), 'colorintensity = 0.3)$
     Note tque no primeiro caso, `s1' é uma lista  e o segundo exemplo,
     `col(s2,3)' é uma matriz.

     Veja também a função `barsplot'.

 -- Função: barsplot (<lista>)
 -- Função: barsplot (<lista>, <opção_1>, <opção_2>, ...)
 -- Função: barsplot (<one_column_matrix>)
 -- Função: barsplot (<one_column_matrix>, <opção_1>, <opção_2>, ...)
     Similar a `histogram' mas para variáveis estatísticas, numéricas
     ou divididas em categorias. As opções estão abaixo,

        * `'outputdev', o valor padrão é `"x"', indica o formato de
          arquivo da figura de saída; valores corretos são `"x"',
          `"eps"' e `"png"', para a tela, formato de arquivo postscript
          e formato de arquivo png, respectivamente.

        * `'maintitle', o valor padrão é `""', é o título principal
          entre aspas duplas.

        * `'axisnames', o valor padrão é `["x", "Fr."]', é uma lista de
          nomes dos eixos `x' e `y'.

        * `'picturescales', o valor padrão é `[1.0, 1.0]', fator de
          proporcionalidade para o tamanho do gráfico.

        * `'relbarwidth', o valor padrão é `0.9', um número decimao
          entre 0 e 1 para controlar a largura das barras.

        * `'barcolor', o valor padrão é `1', um inteiro para indicar a
          cor das barras.

        * `'colorintensity', o valor padrão é `1', um número decimal
          entre 0 e 1 para estabelecer a intensidade da cor.


     Esse exemplo monta um gráfico de barras para os grupos `A' e `B'
     de pacientes na amostra `s3',

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) barsplot (col (s3, 1), 'maintitle = "Grupos de pacientes",
           'axisnames = ["Grupo", "# de indivíduos"], 'colorintensity = 0.2)$
     A primeira coluna na amostra `s3' armazena os valores das
     categorias `A' e `B', também conhecidos algumas vezes como
     fatores. Por outro lado, os números inteiros positivos na segunda
     coluna sào idades, em anos, que se comportam como variável
     discreta, então podemos montar um gráfico as freqüências absolutas
     para esses valores,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) barsplot (col (s3, 2), 'maintitle = "Idades",
           'axisnames = ["Anos", "# dos indivíduos"], 'colorintensity = 0.2,
           'relbarwidth = 0.6)$

     Veja também a função `histogram'.

 -- Função: boxplot (<data>)
 -- Função: boxplot (<data>, <opção_1>, <opção_2>, ...)
     Essa função monta diagramas em caixas. O argumento <data> pode ser
     uma lista, que não é de grande interesse, uma vez que esses
     diagramas são principalmente usados para comparação entre
     diferentes amostras, ou uma matriz, eentão é possível comparar
     dois ou mais componentes de uma variável estatística de várias
     variáveis. Mas é também permitido <data> se uma lista de amostras
     com tamanhos diferentes de amostra, de fato essa é aa única
     função no pacote `descriptive' que admite esse tipo de estrutura
     de dados. Veja o exemplo abaixo.  Abaixo etão as opções,

        * `'outputdev', o valor padrão é `"x"', indica o formato de
          arquivo da figura de saída; valores corretos são `"x"',
          `"eps"' e `"png"', para a tela, formato de arquivo postscript
          e formato de arquivo png, respectivamente.

        * `'maintitle', o valor padrão é `""', é o título principal
          entre aspas duplas.

        * `'axisnames', o valor padrão é `["sample", "y"]', é uma lista
          de nomes dos eixos `x' e `y'.

        * `'picturescales', o valor padrão é `[1.0, 1.0]', fator de
          proporcionalidade para o tamanho do gráfico.


     Examples:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) boxplot (s2, 'maintitle = "Velocidade do vento em nós",
           'axisnames = ["Estação do ano", ""])$
          (%i5) A :
           [[6, 4, 6, 2, 4, 8, 6, 4, 6, 4, 3, 2],
            [8, 10, 7, 9, 12, 8, 10],
            [16, 13, 17, 12, 11, 18, 13, 18, 14, 12]]$
          (%i6) boxplot (A)$


File: maxima.info,  Node: diag,  Next: distrib,  Prev: descriptive,  Up: Top

46 diag
*******

* Menu:

* Funções e Variáveis Definidas para diag::


File: maxima.info,  Node: Funções e Variáveis Definidas para diag,  Prev: diag,  Up: diag

46.1 Funções e Variáveis Definidas para diag
============================================

 -- Função: diag (<lm>)
     Constrói a matriz quadrada com as matrizes de <lm> na diagonal.
     <lm> é uma lista de matrizes ou escalares.

     Exemplo:
          (%i1) load("diag")$

          (%i2) a1:matrix([1,2,3],[0,4,5],[0,0,6])$

          (%i3) a2:matrix([1,1],[1,0])$

          (%i4) diag([a1,x,a2]);
                             [ 1  2  3  0  0  0 ]
                             [                  ]
                             [ 0  4  5  0  0  0 ]
                             [                  ]
                             [ 0  0  6  0  0  0 ]
          (%o4)              [                  ]
                             [ 0  0  0  x  0  0 ]
                             [                  ]
                             [ 0  0  0  0  1  1 ]
                             [                  ]
                             [ 0  0  0  0  1  0 ]

     Para usar essa função escreva primeiramente `load("diag")'.

 -- Função: JF (<lambda>,<n>)
     Retorna a célula de Jordan de ordem <n> com autovalor <lambda>.

     Exemplo:
          (%i1) load("diag")$

          (%i2) JF(2,5);
                              [ 2  1  0  0  0 ]
                              [               ]
                              [ 0  2  1  0  0 ]
                              [               ]
          (%o2)               [ 0  0  2  1  0 ]
                              [               ]
                              [ 0  0  0  2  1 ]
                              [               ]
                              [ 0  0  0  0  2 ]
          (%i3) JF(3,2);
                                   [ 3  1 ]
          (%o3)                    [      ]
                                   [ 0  3 ]

     Para usar essa função escreva primeiramente `load("diag")'.

 -- Função: jordan (<mat>)
     Retorna a forma de Jordan da matriz <mat>, mas codificada em uma
     lista do Maxima.  Para pegar a matriz correspondente à
     codificação, chame a função `dispJordan' sando como argumento a
     saída de `JF'.

     Exemplo:
          (%i1) load("diag")$

          (%i3) a:matrix([2,0,0,0,0,0,0,0],
                         [1,2,0,0,0,0,0,0],
                         [-4,1,2,0,0,0,0,0],
                         [2,0,0,2,0,0,0,0],
                         [-7,2,0,0,2,0,0,0],
                         [9,0,-2,0,1,2,0,0],
                         [-34,7,1,-2,-1,1,2,0],
                         [145,-17,-16,3,9,-2,0,3])$

          (%i34) jordan(a);
          (%o4)             [[2, 3, 3, 1], [3, 1]]
          (%i5) dispJordan(%);
                          [ 2  1  0  0  0  0  0  0 ]
                          [                        ]
                          [ 0  2  1  0  0  0  0  0 ]
                          [                        ]
                          [ 0  0  2  0  0  0  0  0 ]
                          [                        ]
                          [ 0  0  0  2  1  0  0  0 ]
          (%o5)           [                        ]
                          [ 0  0  0  0  2  1  0  0 ]
                          [                        ]
                          [ 0  0  0  0  0  2  0  0 ]
                          [                        ]
                          [ 0  0  0  0  0  0  2  0 ]
                          [                        ]
                          [ 0  0  0  0  0  0  0  3 ]

     Para usar essa função escreva primeiramente `load("diag")'. Veja
     também `dispJordan' e `minimalPoly'.

 -- Função: dispJordan (<l>)
     Retorna a matriz de Jordan associada à codificação fornecida pela
     lista do Maxima <l>, que é a saída fornecida pela função `jordan'.

     Exemplo:
          (%i1) load("diag")$

          (%i2) b1:matrix([0,0,1,1,1],
                          [0,0,0,1,1],
                          [0,0,0,0,1],
                          [0,0,0,0,0],
                          [0,0,0,0,0])$

          (%i3) jordan(b1);
          (%o3)                  [[0, 3, 2]]
          (%i4) dispJordan(%);
                              [ 0  1  0  0  0 ]
                              [               ]
                              [ 0  0  1  0  0 ]
                              [               ]
          (%o4)               [ 0  0  0  0  0 ]
                              [               ]
                              [ 0  0  0  0  1 ]
                              [               ]
                              [ 0  0  0  0  0 ]

     Para usar essa função escreva primeiramente `load("diag")'. Veja
     também `jordan' e `minimalPoly'.

 -- Função: minimalPoly (<l>)
     Retorna o menor polinômio associado à codificação fornecida pela
     lista do Maxima <l>, que é a saída fornecida pela função `jordan'.

     Exemplo:
          (%i1) load("diag")$

          (%i2) a:matrix([2,1,2,0],
                         [-2,2,1,2],
                         [-2,-1,-1,1],
                         [3,1,2,-1])$

          (%i3) jordan(a);
          (%o3)               [[- 1, 1], [1, 3]]
          (%i4) minimalPoly(%);
                                      3
          (%o4)                (x - 1)  (x + 1)

     Para usar essa função escreva primeiramente `load("diag")'. Veja
     também `jordan' e `dispJordan'.

 -- Função: ModeMatrix (<A>,<l>)
     Retorna a matriz <M> tal que (M^^-1).A.M=J, onde <J> é a forma de
     Jordan de <A>. A lista do Maxima <l> é a codificação da forma de
     Jordan como retornado pela função `jordan'.

     Exemplo:
          (%i1) load("diag")$

          (%i2) a:matrix([2,1,2,0],
                    [-2,2,1,2],
                    [-2,-1,-1,1],
                    [3,1,2,-1])$

          (%i3) jordan(a);
          (%o3)               [[- 1, 1], [1, 3]]
          (%i4) M: ModeMatrix(a,%);
                            [  1    - 1   1   1 ]
                            [                   ]
                            [   1               ]
                            [ - -   - 1   0   0 ]
                            [   9               ]
                            [                   ]
          (%o4)             [   13              ]
                            [ - --   1   - 1  0 ]
                            [   9               ]
                            [                   ]
                            [  17               ]
                            [  --   - 1   1   1 ]
                            [  9                ]
          (%i5) is(  (M^^-1).a.M = dispJordan(%o3)  );
          (%o5)                      true
     Note que `dispJordan(%o3)' é a forma de Jordan da matriz `a'.

     Para usa essa função escreva primeiramente `load("diag")'. Veja
     também `jordan' e `dispJordan'.

 -- Função: mat_function (<f>,<mat>)
     Retorna f(mat), onde <f> é uma função analítica e <mat> uma
     matriz. Essa computação é baseada na fórmula da integral de
     Cauchy, que estabelece que se `f(x)' for analítica e

          mat=diag([JF(m1,n1),...,JF(mk,nk)]),

     então

          f(mat)=ModeMatrix*diag([f(JF(m1,n1)),...,f(JF(mk,nk))])*ModeMatrix^^(-1)

     Note que existem entre 6 ou 8 outros métodos para esse cálculo.

     Segue-se alguns exemplos.

     Exemplo 1:
          (%i1) load("diag")$

          (%i2) b2:matrix([0,1,0], [0,0,1], [-1,-3,-3])$

          (%i3) mat_function(exp,t*b2);
                         2   - t
                        t  %e          - t     - t
          (%o3) matrix([-------- + t %e    + %e   ,
                           2
                  - t     - t                           - t
           2    %e      %e        - t           - t   %e
          t  (- ----- - ----- + %e   ) + t (2 %e    - -----)
                  t       2                             t
                         t
                                   - t          - t     - t
                 - t       - t   %e        2  %e      %e
           + 2 %e   , t (%e    - -----) + t  (----- - -----)
                                   t            2       t
                         2   - t            - t     - t
               - t      t  %e        2    %e      %e        - t
           + %e   ], [- --------, - t  (- ----- - ----- + %e   ),
                           2                t       2
                                                   t
                  - t     - t      2   - t
             2  %e      %e        t  %e          - t
          - t  (----- - -----)], [-------- - t %e   ,
                  2       t          2
                  - t     - t                           - t
           2    %e      %e        - t           - t   %e
          t  (- ----- - ----- + %e   ) - t (2 %e    - -----),
                  t       2                             t
                         t
                - t     - t                 - t
           2  %e      %e            - t   %e
          t  (----- - -----) - t (%e    - -----)])
                2       t                   t
          (%i4) ratsimp(%);
                         [   2              - t ]
                         [ (t  + 2 t + 2) %e    ]
                         [ -------------------- ]
                         [          2           ]
                         [                      ]
                         [         2   - t      ]
          (%o4)  Col 1 = [        t  %e         ]
                         [      - --------      ]
                         [           2          ]
                         [                      ]
                         [     2          - t   ]
                         [   (t  - 2 t) %e      ]
                         [   ----------------   ]
                         [          2           ]
                   [      2        - t    ]
                   [    (t  + t) %e       ]
                   [                      ]
           Col 2 = [     2            - t ]
                   [ - (t  - t - 1) %e    ]
                   [                      ]
                   [     2          - t   ]
                   [   (t  - 3 t) %e      ]
                   [        2   - t       ]
                   [       t  %e          ]
                   [       --------       ]
                   [          2           ]
                   [                      ]
                   [      2          - t  ]
           Col 3 = [    (t  - 2 t) %e     ]
                   [  - ----------------  ]
                   [           2          ]
                   [                      ]
                   [   2              - t ]
                   [ (t  - 4 t + 2) %e    ]
                   [ -------------------- ]
                   [          2           ]

     Exemplo 2:
          (%i5) b1:matrix([0,0,1,1,1],
                          [0,0,0,1,1],
                          [0,0,0,0,1],
                          [0,0,0,0,0],
                          [0,0,0,0,0])$

          (%i6) mat_function(exp,t*b1);
                            [              2     ]
                            [             t      ]
                            [ 1  0  t  t  -- + t ]
                            [             2      ]
                            [                    ]
          (%o6)             [ 0  1  0  t    t    ]
                            [                    ]
                            [ 0  0  1  0    t    ]
                            [                    ]
                            [ 0  0  0  1    0    ]
                            [                    ]
                            [ 0  0  0  0    1    ]
          (%i7) minimalPoly(jordan(b1));
                                       3
          (%o7)                       x
          (%i8) ident(5)+t*b1+1/2*(t^2)*b1^^2;
                            [              2     ]
                            [             t      ]
                            [ 1  0  t  t  -- + t ]
                            [             2      ]
                            [                    ]
          (%o8)             [ 0  1  0  t    t    ]
                            [                    ]
                            [ 0  0  1  0    t    ]
                            [                    ]
                            [ 0  0  0  1    0    ]
                            [                    ]
                            [ 0  0  0  0    1    ]
          (%i9) mat_function(exp,%i*t*b1);
                       [                           2 ]
                       [                          t  ]
                       [ 1  0  %i t  %i t  %i t - -- ]
                       [                          2  ]
                       [                             ]
          (%o9)        [ 0  1   0    %i t    %i t    ]
                       [                             ]
                       [ 0  0   1     0      %i t    ]
                       [                             ]
                       [ 0  0   0     1        0     ]
                       [                             ]
                       [ 0  0   0     0        1     ]
          (%i10) mat_function(cos,t*b1)+%i*mat_function(sin,t*b1);
                        [                           2 ]
                        [                          t  ]
                        [ 1  0  %i t  %i t  %i t - -- ]
                        [                          2  ]
                        [                             ]
          (%o10)        [ 0  1   0    %i t    %i t    ]
                        [                             ]
                        [ 0  0   1     0      %i t    ]
                        [                             ]
                        [ 0  0   0     1        0     ]
                        [                             ]
                        [ 0  0   0     0        1     ]

     Exemplo 3:
          (%i11) a1:matrix([2,1,0,0,0,0],
                           [-1,4,0,0,0,0],
                           [-1,1,2,1,0,0],
                           [-1,1,-1,4,0,0],
                           [-1,1,-1,1,3,0],
                           [-1,1,-1,1,1,2])$

          (%i12) fpow(x):=block([k],declare(k,integer),x^k)$

          (%i13) mat_function(fpow,a1);
                          [  k      k - 1 ]         [      k - 1    ]
                          [ 3  - k 3      ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [  k      k - 1 ]
                          [  - k 3        ]         [ 3  + k 3      ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
          (%o13)  Col 1 = [               ] Col 2 = [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                   [       0       ]         [       0       ]
                   [               ]         [               ]
                   [       0       ]         [       0       ]
                   [               ]         [               ]
                   [  k      k - 1 ]         [      k - 1    ]
                   [ 3  - k 3      ]         [   k 3         ]
                   [               ]         [               ]
           Col 3 = [       k - 1   ] Col 4 = [  k      k - 1 ]
                   [  - k 3        ]         [ 3  + k 3      ]
                   [               ]         [               ]
                   [       k - 1   ]         [      k - 1    ]
                   [  - k 3        ]         [   k 3         ]
                   [               ]         [               ]
                   [       k - 1   ]         [      k - 1    ]
                   [  - k 3        ]         [   k 3         ]
                   [    0    ]
                   [         ]         [ 0  ]
                   [    0    ]         [    ]
                   [         ]         [ 0  ]
                   [    0    ]         [    ]
                   [         ]         [ 0  ]
           Col 5 = [    0    ] Col 6 = [    ]
                   [         ]         [ 0  ]
                   [    k    ]         [    ]
                   [   3     ]         [ 0  ]
                   [         ]         [    ]
                   [  k    k ]         [  k ]
                   [ 3  - 2  ]         [ 2  ]

     Para usar essa função escreva primeiramente `load("diag")'.


File: maxima.info,  Node: distrib,  Next: draw,  Prev: diag,  Up: Top

47 distrib
**********

* Menu:

* Introdução a distrib::
* Funções e Variáveis Definidas para distribuições contínuas::
* Funções e Variáveis Definidas para distribuições discretas::


File: maxima.info,  Node: Introdução a distrib,  Next: Funções e Variáveis Definidas para distribuições contínuas,  Prev: distrib,  Up: distrib

47.1 Introdução a distrib
=========================

Pacote `distrib' contém um conjunto de funções para fazer cálculos
envolvendo probabilidades de modelos de uma única variável estatística
e de ambos os tipos discreta e contínua.

   O que segue é um curto resumo de definiçoes básicas relacionadas à
teoria das probabilidades.

   Seja f(x) a <função densidade de probabilidade> absoluta de uma
variável aleatória contínua X. A <função distribuição de probabilidade>
é definida como
                            x
                           /
                           [
                    F(x) = I     f(u) du
                           ]
                           /
                            minf
   que é igual à probabilidade <Pr(X <= x)>.

   O valor <médio> é um parâmetro de localização e está definido como
                          inf
                         /
                         [
                E[X]  =  I   x f(x) dx
                         ]
                         /
                          minf

   A <variância> é uma medida de variação,
                      inf
                     /
                     [                    2
              V[X] = I     f(x) (x - E[X])  dx
                     ]
                     /
                      minf
   que é um número real positivo. A raíz quadrada da variância é o
<desvio padrão>, D[X]=sqrt(V[X]), e esse <desvio padrão> é outra medida
de variação.

   O <coeficiente de assimetria> é uma medida de não simetria,
                      inf
                     /
                 1   [                    3
       SK[X] = ----- I     f(x) (x - E[X])  dx
                   3 ]
               D[X]  /
                      minf

   E o <coeficiente de curtose> mede o grau de achatamento de uma
distribuição,
                      inf
                     /
                 1   [                    4
       KU[X] = ----- I     f(x) (x - E[X])  dx - 3
                   4 ]
               D[X]  /
                      minf
   Se X for gaussiana, KU[X]=0. De fato, ambos assimetria e curtose são
parâmetros de ajuste usados para medir a não gaussianidade de uma
distribuição.

   Se a variável aleatória X for discreta, a função densidade de
probabilidade, ou simplesmente <probabilidade>, f(x) toma valores
positivos dentro de certos conjuntos contáveis de números x_i, e zero
em caso contrário. Nesse caso, a função distribuição de probabilidade é
                            ====
                            \
                     F(x) =  >    f(x )
                            /        i
                            ====
                           x <= x
                            i

   A média, variância, desvio padrão, coeficiente de assimetria e
coeficiente de curtose tomam a forma
                            ====
                            \
                     E[X] =  >  x  f(x ) ,
                            /    i    i
                            ====
                             x
                              i

                     ====
                     \                     2
             V[X] =   >    f(x ) (x - E[X])  ,
                     /        i    i
                     ====
                      x
                       i

                    D[X] = sqrt(V[X]),

                          ====
                   1      \                     3
       SK[X] =  -------    >    f(x ) (x - E[X])
                D[X]^3    /        i    i
                          ====
                           x
                            i
   and
                          ====
                   1      \                     4
       KU[X] =  -------    >    f(x ) (x - E[X])   - 3 ,
                D[X]^4    /        i    i
                          ====
                           x
                            i
   respectively.

   O Pacote `distrib' inclui funções para simulação de variáveis
estatísticas pseudo-aleatórias. Algumas dessas funções fazem uso de
variáveis opcionais que indicam o algorítmo a ser usado.  O método
inverso genérico (baseado no fato que se <u> for um número aleatório
uniforme no intervalo (0,1), então <F^(-1)(u)> é uma variável
estatística pseudo-aleatória com distribuição F) está implementada para
a maioria dos casos; isso é um método subótimo em termos de
cronometragem, mas útil para fazer comparações com outros algorítmos.
Nesse exemplo, a `perandom_formance' dos algorítmos `ahrens_cheng' e
`inverse' em simular  variáveis chi-quadradas (letra grega "chi") são
comparadas por meio de seus histogramas:

     (%i1) load(distrib)$
     (%i2) load(descriptive)$
     (%i3) showtime: true$
     Evaluation took 0.00 seconds (0.00 elapsed) using 32 bytes.
     (%i4) random_chi2_algorithm: 'ahrens_cheng$ histogram(random_chi2(10,500))$
     Evaluation took 0.00 seconds (0.00 elapsed) using 40 bytes.
     Evaluation took 0.69 seconds (0.71 elapsed) using 5.694 MB.
     (%i6) random_chi2_algorithm: 'inverse$ histogram(random_chi2(10,500))$
     Evaluation took 0.00 seconds (0.00 elapsed) using 32 bytes.
     Evaluation took 10.15 seconds (10.17 elapsed) using 322.098 MB.

   Com o objetivo de fazer comparações visuais entre algorítmos para uma
variável estatística discreta, a função `barsplot' do pacote
`descriptive' pode ser usada.

   Note que algum trabalho resta para ser realizado, uma vez que essas
funções de simulação não foram ainda verificadas pelos mais
rigorosamente melhores dos testes de ajuste.

   Por favor, consulte um manual introdutório sobre probabilidade e
estatística para maiores informações sobre todo esse material
matemático.

   Existe uma convenção de nome no pacote `distrib'. Todo nome de
função tem duas partes, a primeira faz referência à função ou ao
parâmetro que queremos calcular,
     Funções:
        função densidade de probabilidade            (pdf_*)
        função distribuição de probabilidade       (cdf_*)
        Quartil                    (quantile_*)
        Média                        (mean_*)
        Variância                    (var_*)
        Desvio padrão          (std_*)
        Coeficiente de assimetria        (skewness_*)
        Coeficiente de curtose        (kurtosis_*)
        Variável estatística pseudo-aleatória              (random_*)

   A segunda parte é uma referência explícita ao modelo probabilístico,
     Distribuíções contínuas:
        Normal              (*normal)
        Student             (*student_t)
        Chi^2               (*chi2)
        F                   (*f)
        Exponencial         (*exp)
        Lognormal           (*lognormal)
        Gama               (*gamma)
        Beta                (*beta)
        contínua uniforme  (*continuous_uniform)
        Logística            (*logistic)
        Pareto              (*pareto)
        Weibull             (*weibull)
        Rayleigh            (*rayleigh)
        Laplace             (*laplace)
        Cauchy              (*cauchy)
        Gumbel              (*gumbel)

     Distribuições discretas:
        Binomial             (*binomial)
        Poisson              (*poisson)
        Bernoulli            (*bernoulli)
        Geométrica            (*geometric)
        discreta uniforme     (*discrete_uniform)
        hipergeométrica       (*hypergeometric)
        Binomial Negativa    (*negative_binomial)

   Por exemplo, `pdf_student_t(x,n)' é a função densidade de
probabilidade da distribuição de Student com <n> graus de liberdade,
`std_pareto(a,b)' é o desvio padrão da distribuição de Pareto com
parâmetros <a> e <b> e `kurtosis_poisson(m)' é o coeficiente de curtose
da distribuição de Poisson com média <m>.

   Com o objetivo de fazer uso do pacote `distrib' você precisa primeiro
tornar esse pacote disponível para uso escrevendo
     (%i1) load(distrib)$

   Para comentários, melhorias ou sugestões, por favor contacte o autor
em <'mario AT edu DOT xunta DOT es'>.


File: maxima.info,  Node: Funções e Variáveis Definidas para distribuições contínuas,  Next: Funções e Variáveis Definidas para distribuições discretas,  Prev: Introdução a distrib,  Up: distrib

47.2 Funções e Variáveis Definidas para distribuições contínuas
===============================================================

 -- Função: pdf_normal (<x>,<m>,<s>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Normal(m,s), com s>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_normal (<x>,<m>,<s>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma  variável aleatória Normal(m,s), com s>0. Essa função é
     definida em termos de funções de erro internas do Maxima, `erf'.

          (%i1) load (distrib)$
          (%i2) assume(s>0)$ cdf_normal(x,m,s);
                                       x - m
                                 erf(---------)
                                     sqrt(2) s    1
          (%o3)                  -------------- + -
                                       2          2

     Veja também `erf'.

 -- Função: quantile_normal (<q>,<m>,<s>)
     Retorna o <q>-quantil de uma variável aleatória Normal(m,s), com
     s>0; em outras palavras, isso é o inverso de `cdf_normal'. O
     argumento <q> deve ser um elemento de [0,1]. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: mean_normal (<m>,<s>)
     Retorna a média de uma  variável aleatória Normal(m,s), com s>0, a
     saber <m>. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: var_normal (<m>,<s>)
     Retorna a variância de uma  variável aleatória Normal(m,s), com
     s>0, a saber <s^2>. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: std_normal (<m>,<s>)
     Retorna o desvio padrão de uma  variável aleatória Normal(m,s),
     com s>0, a saber <s>. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: skewness_normal (<m>,<s>)
     Retorna o coeficiente de assimetria de uma  variável aleatória
     Normal(m,s), com s>0, que é sempre igual  a 0. Para fazer uso
     dessa função,escreva primeiramente `load(distrib)'.

 -- Função: kurtosis_normal (<m>,<s>)
     Retorna o coeficiente de curtose de uma  variável aleatória
     Normal(m,s), com s>0, que é sempre igual  a 0. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Variável de opção: random_normal_algorithm
     Valor padrão: `box_mueller'

     Esse é o algorítmo selecionado para simular variáveis aleatórias
     normais.  O algorítmos implementados são `box_mueller' e `inverse':
        * `box_mueller', Baseado no algorítmo descrito em Knuth, D.E.
          (1981) <Seminumerical Algorithms. The Art of Computer
          Programming.> Addison-Wesley.

        * `inverse', baseado no método inverso genérico.

     Veja também `random_normal'.

 -- Função: random_normal (<m>,<s>)
 -- Função: random_normal (<m>,<s>,<n>)
     Retorna uma variável estatística pseudo-aleatória Normal(m,s), com
     s>0. Chamando `random_normal' com um terceiro argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Existem dois algorítmos implementados para essa função, e o
     algorítmo a ser usado pode ser selecionado fornecendo um certo
     valor para a variável global `random_normal_algorithm', cujo valor
     padrão é `box_mueller'.

     Veja também `random_normal_algorithm'. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_student_t (<x>,<n>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória de Student t(n), com n>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_student_t (<x>,<n>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória de Student t(n), com n>0. Essa função não
     tem uma forma definitiva e é calculada numericamente se a variável
     global `numer' for igual a `true',  de outra froma `cdf_student_t'
     retorna uma expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_student_t(1/2, 7/3);
                                               1  7
          (%o2)                  cdf_student_t(-, -)
                                               2  3
          (%i3) %,numer;
          (%o3)                   .6698450596140417

 -- Função: quantile_student_t (<q>,<n>)
     Retorna o <q>-quantil de uma variável aleatória de Student t(n),
     com n>0; em outras palavras, `quantile_student_t' é o inverso de
     `cdf_student_t'. O argumento <q> deve ser um elemento de [0,1].
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: mean_student_t (<n>)
     Retorna a média de uma variável aleatória de Student t(n), com
     n>0, que é sempre igual a 0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: var_student_t (<n>)
     Retorna a variância de uma variável aleatória de Student t(n), com
     n>2.

          (%i1) load (distrib)$
          (%i2) assume(n>2)$  var_student_t(n);
                                          n
          (%o3)                         -----
                                        n - 2

 -- Função: std_student_t (<n>)
     Retorna o desvio padrão de uma variável aleatória de Student t(n),
     com n>2. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_student_t (<n>)
     Retorna o coeficiente de assimetria de uma variável aleatória de
     Student t(n), com n>3, que é sempre igual a 0. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: kurtosis_student_t (<n>)
     Retorna o coeficiente de curtose de uma variável aleatória de
     Student t(n), com n>4. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Variável de opção: random_student_t_algorithm
     Valor padrão: `ratio'

     Esse é o  algorítmo selecionado para simular variáveis
     estatísticas pseudo-aleatórias de Student. Algorítmos
     implementados são `inverse' e `ratio':
        * `inverse', baseado no método inverso genérico.

        * `ratio', baseado no fato que se <Z> for uma variável
          aleatória normal N(0,1) e S^2 for uma variável aleatória chi
          quadrada com <n> graus de liberdade, Chi^2(n), então
                                          Z
                                X = -------------
                                    /   2  \ 1/2
                                    |  S   |
                                    | ---  |
                                    \  n   /
          é uma variável aleatória de Student com <n> graus de
          liberdade, t(n).

     Veja também `random_student_t'.

 -- Função: random_student_t (<n>)
 -- Função: random_student_t (<n>,<m>)
     Retorna uma variável estatística pseudo-aleatória de Student t(n),
     com n>0. Chamando `random_student_t' com um segundo argumento <m>,
     uma amostra aleatória de tamanho <m> será simulada.

     Existem dois algorítmos implementados para essa função, se pode
     selecionar o algorítmo a ser usado fornecendo um certo valor à
     variável global `random_student_t_algorithm', cujo valor padrão é
     `ratio'.

     Veja também `random_student_t_algorithm'. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_chi2 (<x>,<n>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Chi-quadrada Chi^2(n), com n>0.

     A  variável aleatória Chi^2(n) é equivalente a Gamma(n/2,2),
     portanto quando Maxima não tiver informação para pegar o
     resultado, uma forma nomial baseada na função de densidade
     densidade de probabilidade da função  gama é retornada.

          (%i1) load (distrib)$
          (%i2) pdf_chi2(x,n);
                                              n
          (%o2)                  pdf_gamma(x, -, 2)
                                              2
          (%i3) assume(x>0, n>0)$  pdf_chi2(x,n);
                                   n/2 - 1   - x/2
                                  x        %e
          (%o4)                   ----------------
                                    n/2       n
                                   2    gamma(-)
                                              2

 -- Função: cdf_chi2 (<x>,<n>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Chi-quadrada Chi^2(n), com n>0.

     Essa função não possui uma forma fechada e é calculada
     numericamante se a variável global `numer' for igual a `true',  de
     outra forma essa função retorna uma expressão nominal baseada na
     distribuição gama, uma vez que a variável aleatória Chi^2(n) é
     equivalente a    é equivalente a Gamma(n/2,2).

          (%i1) load (distrib)$
          (%i2) cdf_chi2(3,4);
          (%o2)                  cdf_gamma(3, 2, 2)
          (%i3) cdf_chi2(3,4),numer;
          (%o3)                   .4421745996289249

 -- Função: quantile_chi2 (<q>,<n>)
     Retorna o <q>-quantilede uma variável aleatória Chi-quadrada
     Chi^2(n), com n>0; em outras palavras, essa função é a inversa da
     função `cdf_chi2'. O argumento <q> deve ser um elemento de [0,1].

     This função não possui uma forma fechada e é calculada
     numericamante se a variável global `numer' for igual a `true',  de
     outra forma essa função retorna uma expressão nominal baseada no
     quantil da função gama, uma vez que a variável aleatória Chi^2(n)
     é equivalente a Gamma(n/2,2).

          (%i1) load (distrib)$
          (%i2) quantile_chi2(0.99,9);
          (%o2)                   21.66599433346194
          (%i3) quantile_chi2(0.99,n);
                                                  n
          (%o3)              quantile_gamma(0.99, -, 2)
                                                  2

 -- Função: mean_chi2 (<n>)
     Retorna a média de uma variável aleatória Chi-quadrada Chi^2(n),
     com n>0.

     A variável aleatória Chi^2(n) é equivalente a Gamma(n/2,2), embora
     quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na média da função gama é
     retornada.

          (%i1) load (distrib)$
          (%i2) mean_chi2(n);
                                             n
          (%o2)                   mean_gamma(-, 2)
                                             2
          (%i3) assume(n>0)$ mean_chi2(n);
          (%o4)                           n

 -- Função: var_chi2 (<n>)
     Retorna a variância de uma variável aleatória Chi-quadrada
     Chi^2(n), com n>0.

     A variável aleatória Chi^2(n) é equivalente a Gamma(n/2,2), embora
     quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na variância da função gama é
     retornada.

          (%i1) load (distrib)$
          (%i2) var_chi2(n);
                                             n
          (%o2)                    var_gamma(-, 2)
                                             2
          (%i3) assume(n>0)$ var_chi2(n);
          (%o4)                          2 n

 -- Função: std_chi2 (<n>)
     Retorna o desvio padrão de uma variável aleatória Chi-quadrada
     Chi^2(n), com n>0.

     A variável aleatória Chi^2(n) é equivalente a Gamma(n/2,2), embora
     quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no desvio padrão da função
     gama é retornada.

          (%i1) load (distrib)$
          (%i2) std_chi2(n);
                                             n
          (%o2)                    std_gamma(-, 2)
                                             2
          (%i3) assume(n>0)$ std_chi2(n);
          (%o4)                    sqrt(2) sqrt(n)

 -- Função: skewness_chi2 (<n>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Chi-quadrada Chi^2(n), com n>0.

     A variável aleatória Chi^2(n) é equivalente a Gamma(n/2,2), embora
     quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de assimetria
     da função gama é retornada.

          (%i1) load (distrib)$
          (%i2) skewness_chi2(n);
                                               n
          (%o2)                 skewness_gamma(-, 2)
                                               2
          (%i3) assume(n>0)$ skewness_chi2(n);
                                      2 sqrt(2)
          (%o4)                       ---------
                                       sqrt(n)

 -- Função: kurtosis_chi2 (<n>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Chi-quadrada Chi^2(n), com n>0.

     A variável aleatória Chi^2(n) é equivalente a Gamma(n/2,2), embora
     quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de curtose da
     função gama é retornada.

          (%i1) load (distrib)$
          (%i2) kurtosis_chi2(n);
                                               n
          (%o2)                 kurtosis_gamma(-, 2)
                                               2
          (%i3) assume(n>0)$ kurtosis_chi2(n);
                                         12
          (%o4)                          --
                                         n

 -- Variável de opção: random_chi2_algorithm
     Valor padrão: `ahrens_cheng'

     Esse é o algorítmo selecionado para simular variáveis estatística
     pseudo-aleatórias Chi-quadradas. Os algorítmos implementados são
     `ahrens_cheng' e `inverse':
        * `ahrens_cheng', baseado na simulação aleatória de variáveis
          gama.  Veja `random_gamma_algorithm' para mais detalhes.

        * `inverse', baseado no método inverso genérico.


     Veja também `random_chi2'.

 -- Função: random_chi2 (<n>)
 -- Função: random_chi2 (<n>,<m>)
     Retorna uma variável estatística pseudo-aleatória Chi-square
     Chi^2(n), com n>0. Chamando `random_chi2' com um segundo argumento
     <m>, uma amostra aleatória de tamanho <m> será simulada.

     Existem dois algorítmos implementados para essa função, se pode
     selecionar o algorítmo a ser usado fornecendo um certo valor à
     variável global `random_chi2_algorithm', cujo valor padrão é
     `ahrens_cheng'.

     Veja também `random_chi2_algorithm'. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_f (<x>,<m>,<n>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória F, F(m,n), com m,n>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_f (<x>,<m>,<n>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória F, F(m,n), com m,n>0. Essa função não
     possui uma forma definitiva e é calculada numericamente se a
     variável global `numer' for igual a `true',  de outra forma
     retorna uma expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_f(2,3,9/4);
                                               9
          (%o2)                    cdf_f(2, 3, -)
                                               4
          (%i3) %,numer;
          (%o3)                   0.66756728179008

 -- Função: quantile_f (<q>,<m>,<n>)
     Retorna o <q>-quantil de uma variável aleatória F, F(m,n), com
     m,n>0; em outras palavras, essa função é o inverso de `cdf_f'. O
     argumento <q> deve ser um elemento de [0,1].

     Essa função não possui uma forma fechada e é calculada
     numericamante se a variável global `numer' for igual a `true',  de
     outra forma essa função retorna uma expressão nominal.

          (%i1) load (distrib)$
          (%i2) quantile_f(2/5,sqrt(3),5);
                                         2
          (%o2)               quantile_f(-, sqrt(3), 5)
                                         5
          (%i3) %,numer;
          (%o3)                   0.518947838573693

 -- Função: mean_f (<m>,<n>)
     Retorna a média de uma variável aleatória F, F(m,n), com m>0, n>2.
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: var_f (<m>,<n>)
     Retorna a variância de uma variável aleatória F, F(m,n), com m>0,
     n>4.  Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: std_f (<m>,<n>)
     Retorna o desvio padrão de uma variável aleatória F, F(m,n), com
     m>0, n>4.  Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_f (<m>,<n>)
     Retorna o coeficiente de assimetria de uma variável aleatória F,
     F(m,n), com m>0, n>6. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: kurtosis_f (<m>,<n>)
     Retorna o coeficiente de curtose de uma variável aleatória F,
     F(m,n), com m>0, n>8. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Variável de opção: random_f_algorithm
     Valor padrão: `inverse'

     Esse é o algorítmo selecionado para simular variáveis estatísticas
     pseudo-aleatórias F. Os algorítmos implementados são `ratio' e
     `inverse':
        * `ratio', baseado no fato de que se <X> for uma variável
          aleatória Chi^2(m) e Y for uma variável aleatória Chi^2(n),
          então
                                       n X
                                   F = ---
                                       m Y
          é uma variável aleatória F com <m> e <n> graus de liberdade,
          F(m,n).

        * `inverse', baseado no método inverso genérico.


     Veja também `random_f'.

 -- Função: random_f (<m>,<n>)
 -- Função: random_f (<m>,<n>,<k>)
     Retorna uma variável estatística pseudo-aleatória F, F(m,n), com
     m,n>0. Chamando `random_f' com um terceiro argumento <k>, uma
     amostra aleatória de tamanho <k> será simulada.

     Existem dois algorítmos implementados para essa função, se pode
     selecionar o algorítmo a ser usado fornecendo um certo valor à
     variável global `random_f_algorithm', cujo valor padrão é
     `inverse'.

     Veja também `random_f_algorithm'. Para fazer uso dessa função,
     escreva primeiramente `load(distrib)'.

 -- Função: pdf_exp (<x>,<m>)
     Retorna o valor em <x> da função densidade de probabilidade
     variável aleatória Exponential(m), com m>0.

     A variável aleatória Exponential(m) é equivalente a
     Weibull(1,1/m), embora quando Maxima não tiver informação
     disponível para pegar o resultado, uma forma nominal baseada na
     função de densidade de probabilidade de Weibull éretornada.

          (%i1) load (distrib)$
          (%i2) pdf_exp(x,m);
                                                  1
          (%o2)                 pdf_weibull(x, 1, -)
                                                  m
          (%i3) assume(x>0,m>0)$  pdf_exp(x,m);
                                          - m x
          (%o4)                       m %e

 -- Função: cdf_exp (<x>,<m>)
     Retorna o valor em <x> da função distribuição de probabilidade
     variável aleatória Exponential(m), com m>0.

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na distribuição de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) cdf_exp(x,m);
                                                  1
          (%o2)                 cdf_weibull(x, 1, -)
                                                  m
          (%i3) assume(x>0,m>0)$  cdf_exp(x,m);
                                           - m x
          (%o4)                      1 - %e

 -- Função: quantile_exp (<q>,<m>)
     Retorna o <q>-quantil variável aleatória Exponential(m), com m>0;
     em outras palavras, essa função é inversa da função `cdf_exp'.  O
     argumento <q> deve ser um elemento de [0,1].

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no qualtil de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) quantile_exp(0.56,5);
          (%o2)                   .1641961104139661
          (%i3) quantile_exp(0.56,m);
                                                      1
          (%o3)             quantile_weibull(0.56, 1, -)
                                                      m

 -- Função: mean_exp (<m>)
     Retorna a média de uma variável aleatória Exponential(m), com m>0.

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na média de Weibull é
     reornada.

          (%i1) load (distrib)$
          (%i2) mean_exp(m);
                                                 1
          (%o2)                  mean_weibull(1, -)
                                                 m
          (%i3) assume(m>0)$  mean_exp(m);
                                          1
          (%o4)                           -
                                          m

 -- Função: var_exp (<m>)
     Retorna a variância de uma variável aleatória Exponential(m), com
     m>0.

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na variância de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) var_exp(m);
                                                 1
          (%o2)                   var_weibull(1, -)
                                                 m
          (%i3) assume(m>0)$  var_exp(m);
                                         1
          (%o4)                          --
                                          2
                                         m

 -- Função: std_exp (<m>)
     Retorna o desvio padrão de uma variável aleatória Exponential(m),
     com m>0.

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no desvio padrão de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) std_exp(m);
                                                 1
          (%o2)                   std_weibull(1, -)
                                                 m
          (%i3) assume(m>0)$  std_exp(m);
                                          1
          (%o4)                           -
                                          m

 -- Função: skewness_exp (<m>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Exponential(m), com m>0.

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de assimetria
     de Weibull é retornada.

          (%i1) load (distrib)$
          (%i2) skewness_exp(m);
                                                   1
          (%o2)                skewness_weibull(1, -)
                                                   m
          (%i3) assume(m>0)$  skewness_exp(m);
          (%o4)                           2

 -- Função: kurtosis_exp (<m>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Exponential(m), com m>0.

     A variável aleatória Exponential(m) é equivalente a
     Weibull(1,1/m), embora quando Maxima não tiver informação
     disponível para pegar o resultado, uma forma nominal baseada no
     coeficiente de curtose de Weibull é retornada.

          (%i1) load (distrib)$
          (%i2) kurtosis_exp(m);
                                                   1
          (%o2)                kurtosis_weibull(1, -)
                                                   m
          (%i3) assume(m>0)$  kurtosis_exp(m);
          (%o4)                           6

 -- Variável de opção: random_exp_algorithm
     Valor padrão: `inverse'

     Esse é o algorítmo selecionado para simular variáveis exponenciais
     estatística pseudo-aleatórias. Os algorítmos implementados são
     `inverse', `ahrens_cheng' e `ahrens_dieter'
        * `inverse', baseado no método inverso genérico.

        * `ahrens_cheng', baseado no fato de que a variável aleatória
          Exp(m) é equivalente a Gamma(1,1/m). Veja
          `random_gamma_algorithm' para maiores detalhes.

        * `ahrens_dieter', baseado no algorítmo descrito em Ahrens,
          J.H. e Dieter, U. (1972) <Computer methods for sampling from
          the exponential and normal distributions.> Comm, ACM, 15,
          Oct.,  873-882.


     Veja também `random_exp'.

 -- Função: random_exp (<m>)
 -- Função: random_exp (<m>,<k>)
     Retorna uma variável estatística pseudo-aleatória Exponential(m),
     com m>0. Chamando `random_exp' com um segundo argumento <k>, uma
     amostra aleatória de tamanho <k> será simulada.

     Existem três algorítmos implementados para essa função, se pode
     selecionar o algorítmo a ser usado fornecendo um certo valor à
     variável global `random_exp_algorithm', cujo valor padrão é
     `inverse'.

     Veja também `random_exp_algorithm'. Para fazer uso dessa função,
     escreva primeiramente `load(distrib)'.

 -- Função: pdf_lognormal (<x>,<m>,<s>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Lognormal(m,s), com s>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_lognormal (<x>,<m>,<s>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Lognormal(m,s), com s>0. Essa função é
     definida em termos de funções `erf'de erro internas do Maxima.

          (%i1) load (distrib)$
          (%i2) assume(x>0, s>0)$  cdf_lognormal(x,m,s);
                                     log(x) - m
                                 erf(----------)
                                     sqrt(2) s     1
          (%o3)                  --------------- + -
                                        2          2

     Veja também `erf'.

 -- Função: quantile_lognormal (<q>,<m>,<s>)
     Retorna o <q>-quantil de uma variável aleatória Lognormal(m,s),
     com s>0; em outras palavras, essa função é a inversa da função
     `cdf_lognormal'. O argumento <q> deve ser um elemento de [0,1].
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: mean_lognormal (<m>,<s>)
     Retorna a média de uma variável aleatória Lognormal(m,s), com s>0.
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: var_lognormal (<m>,<s>)
     Retorna a variância de uma variável aleatória Lognormal(m,s), com
     s>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: std_lognormal (<m>,<s>)
     Retorna o desvio padrão de uma variável aleatória Lognormal(m,s),
     com s>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_lognormal (<m>,<s>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Lognormal(m,s), com s>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: kurtosis_lognormal (<m>,<s>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Lognormal(m,s), com s>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: random_lognormal (<m>,<s>)
 -- Função: random_lognormal (<m>,<s>,<n>)
     Retorna uma variável estatística pseudo-aleatória Lognormal(m,s),
     com s>0. Chamando `random_lognormal' com um terceiro argumento
     <n>, uma amostra aleatória de tamanho <n> será simulada.

     Variáveis Log-normal são simuladas por meio de variáveis
     estatísticas normais pseudo-aleatórias. Existem dois algorítmos
     implementados para essa função, se pode selecionar o algorítmo a
     ser usado fornecendo um certo valor à variável global
     `random_normal_algorithm', cujo valor padrão é `box_mueller'.

     Veja também `random_normal_algorithm'. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_gamma (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Gamma(a,b), com a,b>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_gamma (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Gamma(a,b), com a,b>0.

     Essa função não possui uma forma fechada e é calculada
     numericamante se a variável global `numer' for igual a `true',  de
     outra forma essa função retorna uma expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_gamma(3,5,21);
          (%o2)                  cdf_gamma(3, 5, 21)
          (%i3) %,numer;
          (%o3)                 4.402663157135039E-7

 -- Função: quantile_gamma (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Gamma(a,b), com
     a,b>0; em outras palavras, essa função é a inversa da função
     `cdf_gamma'. O argumento <q> deve ser um elemento de [0,1]. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: mean_gamma (<a>,<b>)
     Retorna a média de uma variável aleatória Gamma(a,b), com a,b>0.
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: var_gamma (<a>,<b>)
     Retorna a variância de uma variável aleatória Gamma(a,b), com
     a,b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: std_gamma (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Gamma(a,b), com
     a,b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_gamma (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Gamma(a,b), com a,b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: kurtosis_gamma (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Gamma(a,b), com a,b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Variável de opção: random_gamma_algorithm
     Valor padrão: `ahrens_cheng'

     Esse é o algorítmo selecionado para simular variáveis estatística
     gama pseudo-aleatórias. Os algorítmos implementados são
     `ahrens_cheng' e `inverse'
        * `ahrens_cheng', essa é uma combinação de dois processos,
          dependendo do valor do parâmetro <a>:

          For a>=1, Cheng, R.C.H. e Feast, G.M. (1979). <Some simple
          gamma variate generators>. Appl. Stat., 28, 3, 290-295.

          For 0<a<1, Ahrens, J.H. e Dieter, U. (1974). <Computer
          methods for sampling from gamma, beta, poisson and binomial
          cdf_tributions>. Computing, 12, 223-246.

        * `inverse', baseado no método inverso genérico.


     Veja também `random_gamma'.

 -- Função: random_gamma (<a>,<b>)
 -- Função: random_gamma (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Gamma(a,b), com
     a,b>0. Chamando `random_gamma' com um terceiro argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Existem dois algorítmos implementados para essa função, se pode
     selecionar o algorítmo a ser usado fornecendo um certo valor à
     variável global `random_gamma_algorithm', cujo valor padrão é
     `ahrens_cheng'.

     Veja também `random_gamma_algorithm'. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_beta (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Beta(a,b), com a,b>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_beta (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Beta(a,b), com a,b>0.

     Essa função não possui uma forma fechada e é calculada
     numericamante se a variável global `numer' for igual a `true',  de
     outra forma essa função retorna uma expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_beta(1/3,15,2);
                                           1
          (%o2)                   cdf_beta(-, 15, 2)
                                           3
          (%i3) %,numer;
          (%o3)                 7.666089131388224E-7

 -- Função: quantile_beta (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Beta(a,b), com
     a,b>0; em outras palavras, essa função é a inversa da função
     `cdf_beta'. O argumento <q> deve ser um elemento de [0,1]. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: mean_beta (<a>,<b>)
     Retorna a média de uma variável aleatória Beta(a,b), com a,b>0.
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: var_beta (<a>,<b>)
     Retorna a variância de uma variável aleatória Beta(a,b), com a,b>0.
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: std_beta (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Beta(a,b), com
     a,b>0.  Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_beta (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Beta(a,b), com a,b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: kurtosis_beta (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Beta(a,b), com a,b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Variável de opção: random_beta_algorithm
     Valor padrão: `cheng'

     Esse é o algorítmo selecionado para simular variáveis estatísticas
     beta pseudo-aleatórias. Os algorítmos implementados são `cheng',
     `inverse' e `ratio'
        * `cheng', esse é o algorítmo definido em Cheng, R.C.H.  (1978).
          <Generating Beta Variates with Nonintegral Shape Parameters>.
          Communications of the ACM, 21:317-322

        * `inverse', baseado no método inverso genérico.

        * `ratio', baseado no fato de que se <X> for uma variável
          aleatória Gamma(a,1) e <Y> for Gamma(b,1), então a razão
          X/(X+Y) está distribuída como Beta(a,b).


     Veja também `random_beta'.

 -- Função: random_beta (<a>,<b>)
 -- Função: random_beta (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Beta(a,b), com
     a,b>0. Chamando `random_beta' com um terceiro argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Existem três algorítmos implementados para essa função, se pode
     selecionar o algorítmo a ser usado fornecendo um certo valor à
     variável global `random_beta_algorithm', cujo valor padrão é
     `cheng'.

     Veja também `random_beta_algorithm'. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_continuous_uniform (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Continuous Uniform(a,b), com a<b.  Para fazer
     uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_continuous_uniform (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Continuous Uniform(a,b), com a<b.  Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: quantile_continuous_uniform (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Continuous
     Uniform(a,b), com a<b; em outras palavras, essa função é a inversa
     da função `cdf_continuous_uniform'. O argumento <q> deve ser um
     elemento de [0,1].  Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: mean_continuous_uniform (<a>,<b>)
     Retorna a média de uma variável aleatória Continuous Uniform(a,b),
     com a<b. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: var_continuous_uniform (<a>,<b>)
     Retorna a variância de uma variável aleatória Continuous
     Uniform(a,b), com a<b. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: std_continuous_uniform (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Continuous
     Uniform(a,b), com a<b. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: skewness_continuous_uniform (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Continuous Uniform(a,b), com a<b. Para fazer uso dessa função,
     escreva primeiramente `load(distrib)'.

 -- Função: kurtosis_continuous_uniform (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Continuous Uniform(a,b), com a<b. Para fazer uso dessa função,
     escreva primeiramente `load(distrib)'.

 -- Função: random_continuous_uniform (<a>,<b>)
 -- Função: random_continuous_uniform (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Continuous
     Uniform(a,b), com a<b. Chamando `random_continuous_uniform' com um
     terceiro argumento <n>, uma amostra aleatória de tamanho <n> será
     simulada.

     Essa é uma aplicação direta da função `random' interna do Maxima.

     Veja também `random'. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: pdf_logistic (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Logistic(a,b) , com b>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_logistic (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Logistic(a,b), com b>0. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: quantile_logistic (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Logistic(a,b) , com
     b>0; em outras palavras, essa função é a inversa da função
     `cdf_logistic'. O argumento <q> deve ser um elemento de [0,1].
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: meanlog (<a>,<b>)
     Retorna a média de uma Logistic(a,b) variável aleatória , com b>0.
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: var_logistic (<a>,<b>)
     Retorna a variância de uma variável aleatória Logistic(a,b) , com
     b>0.  Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: std_logistic (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Logistic(a,b) ,
     com b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_logistic (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Logistic(a,b) , com b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: kurtosis_logistic (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Logistic(a,b) , com b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: random_logistic (<a>,<b>)
 -- Função: random_logistic (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Logistic(a,b),
     com b>0.  Chamando `random_logistic' com um terceiro argumento
     <n>, uma amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado. Para fazer
     uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_pareto (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Pareto(a,b), com a,b>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_pareto (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Pareto(a,b), com a,b>0. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: quantile_pareto (<q>,<a>,<b>)
     Retorna o <q>-quantile de uma variável aleatória Pareto(a,b), com
     a,b>0; em outras palavras, essa função é a inversa da função
     `cdf_pareto'. O argumento <q> deve ser um elemento de [0,1]. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: mean_pareto (<a>,<b>)
     Retorna a média de uma variável aleatória Pareto(a,b), com
     a>1,b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: var_pareto (<a>,<b>)
     Retorna a variância de uma variável aleatória Pareto(a,b), com
     a>2,b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: std_pareto (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Pareto(a,b), com
     a>2,b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_pareto (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Pareto(a,b), com a>3,b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: kurtosis_pareto (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Pareto(a,b), com a>4,b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: random_pareto (<a>,<b>)
 -- Função: random_pareto (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Pareto(a,b), com
     a>0,b>0. Chamando `random_pareto' com um terceiro argumento <n>,
     uma amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_weibull (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Weibull(a,b), com a,b>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_weibull (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Weibull(a,b), com a,b>0. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: quantile_weibull (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Weibull(a,b), com
     a,b>0; em outras palavras, essa função é a inversa da função
     `cdf_weibull'. O argumento <q> deve ser um elemento de [0,1]. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: mean_weibull (<a>,<b>)
     Retorna a média de uma variável aleatória Weibull(a,b), com a,b>0.
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: var_weibull (<a>,<b>)
     Retorna a variância de uma variável aleatória Weibull(a,b), com
     a,b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: std_weibull (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Weibull(a,b),
     com a,b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_weibull (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Weibull(a,b), com a,b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: kurtosis_weibull (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Weibull(a,b), com a,b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: random_weibull (<a>,<b>)
 -- Função: random_weibull (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Weibull(a,b),
     com a,b>0. Chamando `random_weibull' com um terceiro argumento
     <n>, uma amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado. Para fazer
     uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_rayleigh (<x>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Rayleigh(b), com b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na função densidade de
     probabilidade de Weibull é retornada.

          (%i1) load (distrib)$
          (%i2) pdf_rayleigh(x,b);
                                                  1
          (%o2)                 pdf_weibull(x, 2, -)
                                                  b
          (%i3) assume(x>0,b>0)$ pdf_rayleigh(x,b);
                                              2  2
                                     2     - b  x
          (%o4)                   2 b  x %e

 -- Função: cdf_rayleigh (<x>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Rayleigh(b), com b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na distribuição de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) cdf_rayleigh(x,b);
                                                  1
          (%o2)                 cdf_weibull(x, 2, -)
                                                  b
          (%i3) assume(x>0,b>0)$ cdf_rayleigh(x,b);
                                             2  2
                                          - b  x
          (%o4)                     1 - %e

 -- Função: quantile_rayleigh (<q>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Rayleigh(b), com
     b>0; em outras palavras, essa função é a inversa da função
     `cdf_rayleigh'. O argumento <q> deve ser um elemento de [0,1].

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no quantil de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) quantile_rayleigh(0.99,b);
                                                      1
          (%o2)             quantile_weibull(0.99, 2, -)
                                                      b
          (%i3) assume(x>0,b>0)$ quantile_rayleigh(0.99,b);
                                  2.145966026289347
          (%o4)                   -----------------
                                          b

 -- Função: mean_rayleigh (<b>)
     Retorna a média de uma variável aleatória Rayleigh(b), com b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na meia de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) mean_rayleigh(b);
                                                 1
          (%o2)                  mean_weibull(2, -)
                                                 b
          (%i3) assume(b>0)$ mean_rayleigh(b);
                                      sqrt(%pi)
          (%o4)                       ---------
                                         2 b

 -- Função: var_rayleigh (<b>)
     Retorna a variância de uma variável aleatória Rayleigh(b), com b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na variância de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) var_rayleigh(b);
                                                 1
          (%o2)                   var_weibull(2, -)
                                                 b
          (%i3) assume(b>0)$ var_rayleigh(b);
                                           %pi
                                       1 - ---
                                            4
          (%o4)                        -------
                                          2
                                         b

 -- Função: std_rayleigh (<b>)
     Retorna o desvio padrão de uma variável aleatória Rayleigh(b), com
     b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na Weibull desvio padrão é
     retornada.

          (%i1) load (distrib)$
          (%i2) std_rayleigh(b);
                                                 1
          (%o2)                   std_weibull(2, -)
                                                 b
          (%i3) assume(b>0)$ std_rayleigh(b);
                                             %pi
                                    sqrt(1 - ---)
                                              4
          (%o4)                     -------------
                                          b

 -- Função: skewness_rayleigh (<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Rayleigh(b), com b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de assimetria
     de Weibull  é retornada.

          (%i1) load (distrib)$
          (%i2) skewness_rayleigh(b);
                                                   1
          (%o2)                skewness_weibull(2, -)
                                                   b
          (%i3) assume(b>0)$ skewness_rayleigh(b);
                                   3/2
                                %pi      3 sqrt(%pi)
                                ------ - -----------
                                  4           4
          (%o4)                 --------------------
                                         %pi 3/2
                                    (1 - ---)
                                          4

 -- Função: kurtosis_rayleigh (<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Rayleigh(b), com b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de curtose de
     Weibull é retornada.

          (%i1) load (distrib)$
          (%i2) kurtosis_rayleigh(b);
                                                   1
          (%o2)                kurtosis_weibull(2, -)
                                                   b
          (%i3) assume(b>0)$ kurtosis_rayleigh(b);
                                            2
                                       3 %pi
                                   2 - ------
                                         16
          (%o4)                    ---------- - 3
                                        %pi 2
                                   (1 - ---)
                                         4

 -- Função: random_rayleigh (<b>)
 -- Função: random_rayleigh (<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Rayleigh(b), com
     b>0.  Chamando `random_rayleigh' com um segundo argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado. Para fazer
     uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_laplace (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Laplace(a,b), com b>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_laplace (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Laplace(a,b), com b>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: quantile_laplace (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Laplace(a,b), com
     b>0; em outras palavras, essa função é a inversa da função
     `cdf_laplace'. O argumento <q> deve ser um elemento de [0,1]. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: mean_laplace (<a>,<b>)
     Retorna a média de uma variável aleatória Laplace(a,b), com b>0.
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: var_laplace (<a>,<b>)
     Retorna a variância de uma variável aleatória Laplace(a,b), com
     b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: std_laplace (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Laplace(a,b),
     com b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_laplace (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Laplace(a,b), com b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: kurtosis_laplace (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Laplace(a,b), com b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: random_laplace (<a>,<b>)
 -- Função: random_laplace (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Laplace(a,b),
     com b>0.  Chamando `random_laplace' com um terceiro argumento <n>,
     uma amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado. Para fazer
     uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_cauchy (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Cauchy(a,b), com b>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_cauchy (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Cauchy(a,b), com b>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: quantile_cauchy (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Cauchy(a,b), com
     b>0; em outras palavras, essa função é a inversa da função
     `cdf_cauchy'. O argumento <q> deve ser um elemento de [0,1]. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: random_cauchy (<a>,<b>)
 -- Função: random_cauchy (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo aleatória Cauchy(a,b), com
     b>0.  Chamando `random_cauchy' com um terceiro argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado. Para fazer
     uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_gumbel (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Gumbel(a,b), com b>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_gumbel (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Gumbel(a,b), com b>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: quantile_gumbel (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Gumbel(a,b), com
     b>0; em outras palavras, essa função é a inversa da função
     `cdf_gumbel'. O argumento <q> deve ser um elemento de [0,1]. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: mean_gumbel (<a>,<b>)
     Retorna a média de uma variável aleatória Gumbel(a,b), com b>0.

          (%i1) load (distrib)$
          (%i2) assume(b>0)$  mean_gumbel(a,b);
          (%o3)                     %gamma b + a
     onde o símbolol `%gamma' representa a constante de
     Euler-Mascheroni.  Veja também `%gamma'.

 -- Função: var_gumbel (<a>,<b>)
     Retorna a variância de uma variável aleatória Gumbel(a,b), com
     b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: std_gumbel (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Gumbel(a,b), com
     b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_gumbel (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Gumbel(a,b), com b>0.

          (%i1) load (distrib)$
          (%i2) assume(b>0)$ skewness_gumbel(a,b);
                                 12 sqrt(6) zeta(3)
          (%o3)                  ------------------
                                           3
                                        %pi
          (%i4) numer:true$ skewness_gumbel(a,b);
          (%o5)                   1.139547099404649
     onde `zeta' representa a função zeta de Riemann.

 -- Função: kurtosis_gumbel (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Gumbel(a,b), com b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: random_gumbel (<a>,<b>)
 -- Função: random_gumbel (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Gumbel(a,b), com
     b>0. Chamando `random_gumbel' com um terceiro argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado. Para fazer
     uso dessa função, escreva primeiramente `load(distrib)'.


File: maxima.info,  Node: Funções e Variáveis Definidas para distribuições discretas,  Prev: Funções e Variáveis Definidas para distribuições contínuas,  Up: distrib

47.3 Funções e Variáveis Definidas para distribuições discretas
===============================================================

 -- Função: pdf_binomial (<x>,<n>,<p>)
     Retorna o valor em <x> da função de probabilidade de uma
     Binomial(n,p) variável aleatória, com 0<p<1 e n um inteiro
     positivo. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: cdf_binomial (<x>,<n>,<p>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma Binomial(n,p) variável aleatória, com 0<p<1 e n um inteiro
     positivo.

     `cdf_binomial' é calculada numéricamente se a variável global
     `numer' for igual a `true',  de outra forma `cdf_binomial' retorna
     uma expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_binomial(5,7,1/6);
                                                   1
          (%o2)                 cdf_binomial(5, 7, -)
                                                   6
          (%i3) cdf_binomial(5,7,1/6), numer;
          (%o3)                   .9998713991769548

 -- Função: quantile_binomial (<q>,<n>,<p>)
     Retorna o <q>-quantil de uma variável aleatória Binomial(n,p), com
     0<p<1 e n um inteiro positivo; em outras palavras, essa função é a
     inversa da função `cdf_binomial'. O argumento <q> deve ser um
     elemento de [0,1]. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: mean_binomial (<n>,<p>)
     Retorna a média de uma variável aleatória Binomial(n,p), com 0<p<1
     e n um inteiro positivo. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: var_binomial (<n>,<p>)
     Retorna a variância de uma variável aleatória Binomial(n,p), com
     0<p<1 e n um inteiro positivo. Para fazer uso dessa função,
     escreva primeiramente `load(distrib)'.

 -- Função: std_binomial (<n>,<p>)
     Retorna o desvio padrão de uma variável aleatória Binomial(n,p),
     com 0<p<1 e n um inteiro positivo. Para fazer uso dessa função,
     escreva primeiramente `load(distrib)'.

 -- Função: skewness_binomial (<n>,<p>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Binomial(n,p), com 0<p<1 e n um inteiro positivo. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: kurtosis_binomial (<n>,<p>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Binomial(n,p), com 0<p<1 e n um inteiro positivo. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Variável de opção: random_binomial_algorithm
     Valor padrão: `kachit'

     Esse é o algorítmo selecionado para simular rvariáveis
     estatísticas pseudo-aleatórias binomiais. Os algorítmos
     implementados são `kachit', `bernoulli' e `inverse':
        * `kachit', baseado no algorítmo descrito em Kachitvichyanukul,
          V. and Schmeiser, B.W. (1988) <Binomial Random Variate
          Generation>. Communications of the ACM, 31, Feb., 216.

        * `bernoulli', baseado na simulação testes de Bernoulli.

        * `inverse', baseado no método inverso genérico.


     Veja também `random_binomial'.

 -- Função: random_binomial (<n>,<p>)
 -- Função: random_binomial (<n>,<p>,<m>)
     Retorna uma variável estatística pseudo-aleatória Binomial(n,p),
     com 0<p<1 e n um inteiro positivo. Chamando `random_binomial' com
     um terceiro argumento <m>, uma amostra aleatória de tamanho <m>
     será simulada.

     Existem três algorítmos implementado para essa função, se pode
     selecionar o algorítmo a ser usado fornecendo um certo valor à
     variável global `random_binomial_algorithm', cujo valor padrão é
     `kachit'.

     Veja também `random_binomial_algorithm'. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_poisson (<x>,<m>)
     Retorna o valor em <x> da função de probabilidade de uma variável
     aleatória Poisson(m), com m>0. Para fazer uso dessa função,
     escreva primeiramente `load(distrib)'.

 -- Função: cdf_poisson (<x>,<m>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Poisson(m), com m>0.

     Essa função é calculada numéricamente se a variável global `numer'
     for igual a `true',  de outra forma essa função retorna uma
     expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_poisson(3,5);
          (%o2)                   cdf_poisson(3, 5)
          (%i3) cdf_poisson(3,5), numer;
          (%o3)                   .2650259152973617

 -- Função: quantile_poisson (<q>,<m>)
     Retorna o <q>-quantil de uma variável aleatória Poisson(m), com
     m>0; em outras palavras, essa função é a inversa da função
     `cdf_poisson'. O argumento <q> deve ser um elemento de [0,1]. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: mean_poisson (<m>)
     Retorna a média de uma variável aleatória Poisson(m), com m>0.
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: var_poisson (<m>)
     Retorna a variância de uma variável aleatória Poisson(m), com
     m>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: std_poisson (<m>)
     Retorna o desvio padrão de uma variável aleatória Poisson(m), com
     m>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_poisson (<m>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Poisson(m), com m>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: kurtosis_poisson (<m>)
     Retorna o coeficiente de curtose de uma Poisson variável aleatória
     Poi(m), com m>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Variável de opção: random_poisson_algorithm
     Valor padrão: `ahrens_dieter'

     Esse é o algorítmo selecionado para simular variáveis estatísticas
     pseudo-aleatórias de Poisson.Os algorítmos implementados são
     `ahrens_dieter' e `inverse':
        * `ahrens_dieter', baseado no algorítmo descrito em Ahrens,
          J.H. and Dieter, U. (1982) <Computer Generation of Poisson
          Deviates From Modified Normal Distributions>.  ACM Trans.
          Math. Software, 8, 2, June,163-179.

        * `inverse', baseado no método inverso genérico.


     Veja também `random_poisson'.

 -- Função: random_poisson (<m>)
 -- Função: random_poisson (<m>,<n>)
     Retorna uma variável estatística pseudo-aleatória Poisson(m), com
     m>0.  Chamando `random_poisson' com um segundo argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Existem dois algorítmos implementado para essa função, se pode
     selecionar o algorítmo a ser usado fornecendo um certo valor à
     variável global `random_poisson_algorithm', cujo valor padrão é
     `ahrens_dieter'.

     Veja também `random_poisson_algorithm'. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_bernoulli (<x>,<p>)
     Retorna o valor em <x> da função de probabilidade de uma variável
     aleatória Bernoulli(p), com 0<p<1.

     A variável aleatória Bernoulli(p) é equivalente a Binomial(1,p),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na função binomial de
     probabilidade é retornada.

          (%i1) load (distrib)$
          (%i2) pdf_bernoulli(1,p);
          (%o2)                 pdf_binomial(1, 1, p)
          (%i3) assume(0<p,p<1)$ pdf_bernoulli(1,p);
          (%o4)                           p

 -- Função: cdf_bernoulli (<x>,<p>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Bernoulli(p), com 0<p<1.  Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: quantile_bernoulli (<q>,<p>)
     Retorna o <q>-quantil de uma variável aleatória Bernoulli(p), com
     0<p<1; em outras palavras, essa função é a inversa da função
     `cdf_bernoulli'. O argumento <q> deve ser um elemento de [0,1].
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: mean_bernoulli (<p>)
     Retorna a média de uma variável aleatória Bernoulli(p), com 0<p<1.

     A variável aleatória Bernoulli(p) é equivalente a Binomial(1,p),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na média binomial é retornada.

          (%i1) load (distrib)$
          (%i2) mean_bernoulli(p);
          (%o2)                  mean_binomial(1, p)
          (%i3) assume(0<p,p<1)$ mean_bernoulli(p);
          (%o4)                           p

 -- Função: var_bernoulli (<p>)
     Retorna a variância de uma variável aleatória Bernoulli(p), com
     0<p<1.

     A variável aleatória Bernoulli(p) é equivalente a Binomial(1,p),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na variância binomial é
     retornada.

          (%i1) load (distrib)$
          (%i2) var_bernoulli(p);
          (%o2)                  var_binomial(1, p)
          (%i3) assume(0<p,p<1)$ var_bernoulli(p);
          (%o4)                       (1 - p) p

 -- Função: std_bernoulli (<p>)
     Retorna o desvio padrão de uma variável aleatória Bernoulli(p),
     com 0<p<1.

     A variável aleatória Bernoulli(p) é equivalente a Binomial(1,p),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no desvio padrão binomial é
     retornada.

          (%i1) load (distrib)$
          (%i2) std_bernoulli(p);
          (%o2)                  std_binomial(1, p)
          (%i3) assume(0<p,p<1)$ std_bernoulli(p);
          (%o4)                  sqrt(1 - p) sqrt(p)

 -- Função: skewness_bernoulli (<p>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Bernoulli(p), com 0<p<1.

     A variável aleatória Bernoulli(p) é equivalente a Binomial(1,p),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de assimetria
     binomial é retornada.

          (%i1) load (distrib)$
          (%i2) skewness_bernoulli(p);
          (%o2)                skewness_binomial(1, p)
          (%i3) assume(0<p,p<1)$ skewness_bernoulli(p);
                                       1 - 2 p
          (%o4)                  -------------------
                                 sqrt(1 - p) sqrt(p)

 -- Função: kurtosis_bernoulli (<p>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Bernoulli(p), com 0<p<1.

     A variável aleatória Bernoulli(p) é equivalente a Binomial(1,p),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de curtose
     binomial é retornada.

          (%i1) load (distrib)$
          (%i2) kurtosis_bernoulli(p);
          (%o2)                kurtosis_binomial(1, p)
          (%i3) assume(0<p,p<1)$ kurtosis_bernoulli(p);
                                   1 - 6 (1 - p) p
          (%o4)                    ---------------
                                      (1 - p) p

 -- Função: random_bernoulli (<p>)
 -- Função: random_bernoulli (<p>,<n>)
     Retorna uma variável estatística pseudo-aleatória Bernoulli(p),
     com 0<p<1. Chamando `random_bernoulli' com um segundo argumento
     <n>, uma amostra aleatória de tamanho <n> será simulada.

     Essa é uma aplicação direta da função `random' built-in função do
     Maxima.

     Veja também `random'. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: pdf_geometric (<x>,<p>)
     Retorna o valor em <x> da função de probabilidade de uma variável
     aleatória Geometric(p), com 0<p<1. Para fazer uso dessa função,
     escreva primeiramente `load(distrib)'.

 -- Função: cdf_geometric (<x>,<p>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Geometric(p), com 0<p<1. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: quantile_geometric (<q>,<p>)
     Retorna o <q>-quantil de uma variável aleatória Geometric(p), com
     0<p<1; em outras palavras, essa função é a inversa da função
     `cdf_geometric'. O argumento <q> deve ser um elemento de [0,1].
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: mean_geometric (<p>)
     Retorna a média de uma variável aleatória Geometric(p), com 0<p<1.
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: var_geometric (<p>)
     Retorna a variância de uma variável aleatória Geometric(p), com
     0<p<1. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: std_geometric (<p>)
     Retorna o desvio padrão de uma variável aleatória Geometric(p),
     com 0<p<1. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_geometric (<p>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Geometric(p), com 0<p<1. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: kurtosis_geometric (<p>)
     Retorna o coeficiente de curtose de uma geometric variável
     aleatória  Geo(p), com 0<p<1. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Variável de opção: random_geometric_algorithm
     Valor padrão: `bernoulli'

     Esse é o algorítmo selecionado para simular variáveis estatísticas
     pseudo-aleatórias geométricas. Algorítmos implementados são
     `bernoulli', `devroye' e `inverse':
        * `bernoulli', baseado na simulação de testes de Bernoulli.

        * `devroye', baseado no algorítmo descrito em Devroye, L. (1986)
          <Non-Uniform Random Variate Generation.> Springer Verlag, p.
          480.

        * `inverse', baseado no método inverso genérico.


     Veja também `random_geometric'.

 -- Função: random_geometric (<p>)
 -- Função: random_geometric (<p>,<n>)
     Retorna um Geometric(p) variável estatística pseudo-aleatória, com
     0<p<1.  Chamando `random_geometric' com um segundo argumento <n>,
     uma amostra aleatória de tamanho <n> será simulada.

     Existem três algorítmos implementados para essa função, se pode
     selecionar o algorítmo a ser usado fornecendo um certo valor à
     variável global `random_geometric_algorithm', cujo valor padrão é
     `bernoulli'.

     Veja também `random_geometric_algorithm'. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_discrete_uniform (<x>,<n>)
     Retorna o valor em <x> da função de probabilidade de uma variável
     aleatória Discrete Uniform(n), com n a strictly positive integer.
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_discrete_uniform (<x>,<n>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Discrete Uniform(n), com n inteiro
     estritamente positivo. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: quantile_discrete_uniform (<q>,<n>)
     Retorna o <q>-quantil de uma variável aleatória Discrete
     Uniform(n), com n um inteiro estritamente positivo; em outras
     palavras, essa função é a inversa da função
     `cdf_discrete_uniform'. O argumento <q> deve ser um elemento de
     [0,1]. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: mean_discrete_uniform (<n>)
     Retorna a média de uma variável aleatória Discrete Uniform(n), com
     n um inteiro estritamente positivo. Para fazer uso dessa função,
     escreva primeiramente `load(distrib)'.

 -- Função: var_discrete_uniform (<n>)
     Retorna a variância de uma variável aleatória Discrete Uniform(n),
     com n um inteiro estritamente positivo. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: std_discrete_uniform (<n>)
     Retorna o desvio padrão de uma variável aleatória Discrete
     Uniform(n), com n um inteiro estritamente positivo. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: skewness_discrete_uniform (<n>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Discrete Uniform(n), com n um inteiro estritamente positivo. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: kurtosis_discrete_uniform (<n>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Discrete Uniform(n), com n um inteiro estritamente positivo. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: random_discrete_uniform (<n>)
 -- Função: random_discrete_uniform (<n>,<m>)
     Retorna uma variável estatística pseudo-aleatória Discrete
     Uniform(n), com n um inteiro estritamente positivo. Chamando
     `random_discrete_uniform' com um segundo argumento <m>, uma
     amostra aleatória de tamanho <m> será simulada.

     Isso é uma aplicação direta da função `random' built-in função do
     Maxima.

     Veja também `random'. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: pdf_hypergeometric (<x>,<n1>,<n2>,<n>)
     Retorna o valor em <x> da função de probabilidade de uma variável
     aleatória Hypergeometric(n1,n2,n), com <n1>, <n2> e <n> inteiros
     não negativos e n<=n1+n2. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: cdf_hypergeometric (<x>,<n1>,<n2>,<n>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Hypergeometric(n1,n2,n), com <n1>, <n2> e
     <n> inteiros não negativos e n<=n1+n2. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: quantile_hypergeometric (<q>,<n1>,<n2>,<n>)
     Retorna o <q>-quantil de uma variável aleatória
     Hypergeometric(n1,n2,n), com <n1>, <n2> e <n> inteiros não
     negativos e n<=n1+n2; em outras palavras, essa função é a inversa
     da função `cdf_hypergeometric'.  O argumento <q> deve ser um
     elemento de [0,1]. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: mean_hypergeometric (<n1>,<n2>,<n>)
     Retorna a média de uma variável aleatória discreta univorme
     Hyp(n1,n2,n), com <n1>, <n2> e <n> inteiros não negativos e
     n<=n1+n2. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: var_hypergeometric (<n1>,<n2>,<n>)
     Retorna a variância de uma variável aleatória hipergeométrica
     Hyp(n1,n2,n), com <n1>, <n2> e <n> inteiros não negativos e
     n<=n1+n2. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: std_hypergeometric (<n1>,<n2>,<n>)
     Retorna o desvio padrão de uma variável aleatória
     Hypergeometric(n1,n2,n), com <n1>, <n2> e <n> inteiros não
     negativos e n<=n1+n2. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: skewness_hypergeometric (<n1>,<n2>,<n>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Hypergeometric(n1,n2,n), com <n1>, <n2> e <n> inteiros não
     negativos e n<=n1+n2. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: kurtosis_hypergeometric (<n1>,<n2>,<n>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Hypergeometric(n1,n2,n), com <n1>, <n2> e <n> inteiros não
     negativos e n<=n1+n2. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Variável de opção: random_hypergeometric_algorithm
     Valor padrão: `kachit'

     Esse é o algorítmo selecionado para simular variáveis estatísticas
     pseudo aleatórias hipergeométricas.Os algorítmos implementados são
     `kachit' e `inverse':
        * `kachit', baseado no algorítmo descrito em Kachitvichyanukul,
          V., Schmeiser, B.W. (1985) <Computer generation of
          hypergeometric variáveis estatística pseudo-aleatórias.>
          Journal of Statistical Computation and Simulation 22, 127-145.

        * `inverse', baseado no método inverso genérico.


     Veja também `random_hypergeometric'.

 -- Função: random_hypergeometric (<n1>,<n2>,<n>)
 -- Função: random_hypergeometric (<n1>,<n2>,<n>,<m>)
     Retorna uma variável estatística pseudo-aleatória
     Hypergeometric(n1,n2,n), com <n1>, <n2> e <n> inteiros não
     negativos e n<=n1+n2. Chamando `random_hypergeometric' com um
     quarto argumento <m>, uma amostra aleatória de tamanho <m> será
     simulada.

     Existem dois algorítmos implementados para essa função, se pode
     selecionar o algorítmo a ser usado fornecendo um certo valor à
     variável global `random_hypergeometric_algorithm', cujo valor
     padrão é `kachit'.

     Veja também `random_hypergeometric_algorithm'. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_negative_binomial (<x>,<n>,<p>)
     Retorna o valor em <x> da função de probabilidade de uma variável
     aleatória Negative Binomial(n,p), com 0<p<1 e n um inteiro
     positivo. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: cdf_negative_binomial (<x>,<n>,<p>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma Negative Binomial(n,p) variável aleatória, com 0<p<1 e n um
     inteiro positivo.

     Essa função é calculada numéricamente se a variável global `numer'
     for igual a `true',  de outra forma essa função retorna uma
     expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_negative_binomial(3,4,1/8);
                                                       1
          (%o2)            cdf_negative_binomial(3, 4, -)
                                                       8
          (%i3) cdf_negative_binomial(3,4,1/8), numer;
          (%o3)                  .006238937377929698

 -- Função: quantile_negative_binomial (<q>,<n>,<p>)
     Retorna o <q>-quantil de uma variável aleatória Negative
     Binomial(n,p), com 0<p<1 e n um inteiro positivo; em outras
     palavras, essa função é a inversa da função
     `cdf_negative_binomial'. O argumento <q> deve ser um elemento de
     [0,1]. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: mean_negative_binomial (<n>,<p>)
     Retorna a média de uma variável aleatória Negative Binomial(n,p),
     com 0<p<1 e n um inteiro positivo. Para fazer uso dessa função,
     escreva primeiramente `load(distrib)'.

 -- Função: var_negative_binomial (<n>,<p>)
     Retorna a variância de uma variável aleatória Negative
     Binomial(n,p), com 0<p<1 e n um inteiro positivo. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: std_negative_binomial (<n>,<p>)
     Retorna o desvio padrão de uma variável aleatória Negative
     Binomial(n,p), com 0<p<1 e n um inteiro positivo. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: skewness_negative_binomial (<n>,<p>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Negative Binomial(n,p), com 0<p<1 e n um inteiro positivo. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: kurtosis_negative_binomial (<n>,<p>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Negative Binomial(n,p), com 0<p<1 e n um inteiro positivo. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Variável de opção: random_negative_binomial_algorithm
     Valor padrão: `bernoulli'

     Esse é o algorítmo selecionado para simular variáveis estatísticas
     pseuso-aleatórias binomiais negativas. Os algorítmos implementados
     são `devroye', `bernoulli' e `inverse':
        * `devroye', baseado no algorítmo descrito em Devroye, L. (1986)
          <Non-Uniform Random Variate Generation>. Springer Verlag, p.
          480.

        * `bernoulli', baseado na simulação de testes de Bernoulli.

        * `inverse', baseado no método inverso genérico.


     Veja também `random_negative_binomial'.

 -- Função: random_negative_binomial (<n>,<p>)
 -- Função: random_negative_binomial (<n>,<p>,<m>)
     Retorna uma variável estatística pseudo-aleatória Negative
     Binomial(n,p), com 0<p<1 e n um inteiro positivo. Chamando
     `random_negative_binomial' com um terceiro argumento <m>, uma
     amostra aleatória de tamanho <m> será simulada.

     Existem três algorítmos implementados para essa função, se pode
     selecionar o algorítmo a ser usado fornecendo um certo valor à
     variável global `random_negative_binomial_algorithm', cujo valor
     padrão é `bernoulli'.

     Veja também `random_negative_binomial_algorithm'. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.


File: maxima.info,  Node: draw,  Next: dynamics,  Prev: distrib,  Up: Top

48 draw
*******

* Menu:

* Introdução a draw::
* Funções e Variáveis Definidas para draw::


File: maxima.info,  Node: Introdução a draw,  Next: Funções e Variáveis Definidas para draw,  Prev: draw,  Up: draw

48.1 Introdução a draw
======================

`draw' é uma interface entre o Maxima e o Gnuplot.

   Existem três funções a serem usadas n nível do Maxima: `draw2d',
`draw3d' e `draw'.

   Siga o link abaixo para exemplos mais elaborados deste pacote:

   `http://es.geocities.com/riotorto/maxima/gpdraw'

   Voce precisará do Gnuplot 4.2 para executar este programa.


File: maxima.info,  Node: Funções e Variáveis Definidas para draw,  Prev: Introdução a draw,  Up: draw

48.2 Funções e Variáveis Definidas para draw
============================================

 -- Opção gráfica: xrange
     Valor padrão: `false'

     Se `xrange' for `false', o intevalo para a coordenada <x> é
     calculado automaticamente.

     Caso o usuário deseje um intervalo específico para <x>, esse
     intervalo deve ser fornecido como uma lista da forma definida pelo
     Maxima, como em `xrange=[-2, 3]'.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange = [-3,5],
                       explicit(x^2,x,-1,1))$

     Veja também `yrange' e `zrange'.

 -- Opção gráfica: yrange
     Valor padrão: `false'

     Se `yrange' for `false', the range for the <y> coordinate is
     computed automatically.

     Se o usuário sesejar um intervalo específico para <y>, esse
     intervalo deve ser fornecido como uma lista da forma definida pelo
     Maxima, como em `yrange=[-2, 3]'.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(yrange = [-2,3],
                       explicit(x^2,x,-1,1),
                       xrange = [-3,3])$

     Veja também `xrange' e `zrange'.

 -- Opção gráfica: zrange
     Valor padrão: `false'

     Se `zrange' for `false', o intervalo para a coordenada <z> é
     calculado automaticamente.

     Se o usuário sesejar um intervalo específico para <z>, esse
     intervalo deve ser fornecido como uma lista da forma definida pelo
     Maxima, como em `zrange=[-2, 3]'.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw3d(yrange = [-3,3],
                       zrange = [-2,5],
                       explicit(x^2+y^2,x,-1,1,y,-1,1),
                       xrange = [-3,3])$

     Veja também `yrange' e `zrange'.

 -- Opção gráfica: logx
     Valor padrão: `false'

     Se `logx' for `true', o eixo <x>será desenhado em escala
     logarítmica.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(log(x),x,0.01,5),
                       logx = true)$

     Veja também `logy' e `logz'.

 -- Opção gráfica: logy
     Valor padrão: `false'

     Se `logy' for `true', o eixo <y>será desenhado em escala
     logarítmica.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(logy = true,
                       explicit(exp(x),x,0,5))$

     Veja também `logx' e `logz'.

 -- Opção gráfica: logz
     Valor padrão: `false'

     Se `logz' for `true', o eixo <z>será desenhado em escala
     logarítmica.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw3d(logz = true,
                       explicit(exp(u^2+v^2),u,-2,2,v,-2,2))$

     Veja também `logx' e `logy'.

 -- Opção gráfica: terminal
     Valor padrão: `screen'

     Seleciona o terminal a ser usado pelo Gnuplot; os valores
     possíveis são: `screen' (o valor padrão), `png', `jpg', `eps', e
     `eps_color'.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante. Pode também ser usada como um
     argumento da função `draw'

     Exemplos:

          (%i1) load(draw)$
          (%i2) /* screen terminal (default) */
                draw2d(explicit(x^2,x,-1,1))$
          (%i3) /* png file */
                draw2d(terminal  = 'png,
                       pic_width = 300,
                       explicit(x^2,x,-1,1))$
          (%i4) /* jpg file */
                draw2d(terminal   = 'jpg,
                       pic_width  = 300,
                       pic_height = 300,
                       explicit(x^2,x,-1,1))$
          (%i5) /* eps file */
                draw2d(file_name = "myfile",
                       explicit(x^2,x,-1,1),
                       terminal  = 'eps)$

     Veja também `file_name', `pic_width', e `pic_height'.

 -- Opção gráfica: grid
     Valor padrão: `false'

     Se `grid' for `true', uma malha será desenhada sobre o plano <xy>.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(grid = true,
                       explicit(exp(u),u,-2,2))$

 -- Opção gráfica: title
     Valor padrão: `""' (a seqüência de caracteres vazia)

     A opção `title' armazena uma seqüência de caracteres do Maxima com
     o título principal de um fundo gráfico.  Por padrão, nenhum título
     é escrito.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(exp(u),u,-2,2),
                       title = "Exponential function")$

 -- Opção gráfica: xlabel
     Valor padrão: `""' (a seqüência de caracteres vazia)

     A opção `xlabel' armazena uma seqüência de caracteres do Maxima
     com o rótulo para o eixo <x>.  Por padrão, nenhum rótulo é escrito.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xlabel = "Time",
                       explicit(exp(u),u,-2,2),
                       ylabel = "Population")$

     Veja também `ylabel', e `zlabel'.

 -- Opção gráfica: ylabel
     Valor padrão: `""' (a seqüência de caracteres vazia)

     A opção `ylabel' armazena uma seqüência de caracteres do Maxima
     com o rótulo para o eixo <y>.  Por padrão, nenhum rótulo é escrito.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xlabel = "Time",
                       ylabel = "Population",
                       explicit(exp(u),u,-2,2) )$

     Veja também `xlabel', e `zlabel'.

 -- Opção gráfica: zlabel
     Valor padrão: `""' (a seqüência de caracteres vazia)

     A opção `zlabel' armazena uma seqüência de caracteres do Maxima
     com o rótulo para o eixo <z>.  Por padrão, nenhum rótulo é escrito.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw3d(zlabel = "Z variable",
                       ylabel = "Y variable",
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2),
                       xlabel = "X variable" )$

     Veja também `xlabel', e `ylabel'.

 -- Opção gráfica: xtics
     Valor padrão: `true'

     Se `xtics' for `true', a marcação numérica será feitas sobre o
     eixo <x>.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) /* No tics in the x-axis */
                draw2d(xtics = false,
                       explicit(exp(u),u,-2,2))$

     Veja também `ytics', e `ztics'.

 -- Opção gráfica: ytics
     Valor padrão: `true'

     Se `ytics' for `true', a marcação numérica será feitas sobre o
     eixo <y>.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(ytics = false,
                       explicit(exp(u),u,-2,2),
                       xtics = false)$

     Veja também `xtics', e `ztics'.

 -- Opção gráfica: ztics
     Valor padrão: `true'

     Se `ztics' for `true', a marcação numérica será feitas sobre o
     eixo <z>.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) /* No tics in the z-axis */
                draw3d(ztics = false,
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$

     Veja também `xtics', e `ytics'.

 -- Opção gráfica: rot_vertical
     Valor padrão: 60

     `rot_vertical' é o ângulo (em graus) da rotação vertical (em torno
     do eixo <x>) para escolher o ponto de visualização em fundos
     gráficos tridimensionais.

     O ângulo é associado ao intervalo [0, 180].

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw3d(rot_vertical = 170,
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$

     Veja também `rot_horizontal'.

 -- Opção gráfica: rot_horizontal
     Valor padrão: 30

     `rot_horizontal' é o ângulo (em graus) da rotação horizontal (em
     torno do eixo <z>)  para escolher o ponto de visualização em
     fundos gráficos tridimensionais.

     O ângulo é associado ao intervalo [0, 180].

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw3d(rot_vertical = 170,
                       rot_horizontal = 360,
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$

     Veja também `rot_vertical'.

 -- Opção gráfica: xy_file
     Valor padrão: `""' (a seqüência de caracteres vazia)

     `xy_file' é o nome do arquivo onde as coordenada serão armazenadas
     após um clique com o botão do mouse e pressionar a tecla 'x'. Por
     padrão, nenhuma coordenada é armazenada.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

 -- Opção gráfica: user_preamble
     Valor padrão: `""' (a seqüência de caracteres vazia)

     Usuários experientes de Gnuplot podem fazer uso dessa opção para
     ajuste fino do comportamento do Gnuplot escolhendo opções para
     serem enviadas antes do comando `plot' ou do comando `splot'.

     O valor dessa opção deve ser uma seqüência de caracteres ou uma
     lista de seqüência de caracteres (um por linha).

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

     O terminal dumb não é suportado pelo pacote `draw', mas é possível
     escolher o terminal dumb fazendo uso da opção `user_preamble',
          (%i1) load(draw)$
          (%i2) draw2d(explicit(exp(x)-1,x,-1,1),
                       parametric(cos(u),sin(u),u,0,2*%pi),
                       user_preamble="set terminal dumb")$

 -- Opção gráfica: file_name
     Valor padrão: `"maxima_out"'

     Esse é o nome do arquivo onde os terminais `png', `jpg', `eps' e
     `eps_color' guardarão o gráfico.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante. Pode também ser usada como um
     argumento da função `draw'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(file_name = "myfile",
                       explicit(x^2,x,-1,1),
                       terminal  = 'png)$

     Veja também `terminal', `pic_width', e `pic_height'.

 -- Opção gráfica: pic_width
     Valor padrão: 640

     Essa é a largura do arquivo de bitmap gerado pelos terminais `png'
     e `jpg'.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante. Pode também ser usada como um
     argumento da função `draw'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(terminal   = 'png,
                       pic_width  = 300,
                       pic_height = 300,
                       explicit(x^2,x,-1,1))$

     Veja também `terminal', `file_name', e `pic_height'.

 -- Opção gráfica: pic_height
     Valor padrão: 640

     Essa é a altura do arquivo de bitmap gerado pelos terminais `png'
     e `jpg'.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante. Pode também ser usada como um
     argumento da função `draw'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(terminal   = 'png,
                       pic_width  = 300,
                       pic_height = 300,
                       explicit(x^2,x,-1,1))$

     Veja também `terminal', `file_name', e `pic_width'.

 -- Opção gráfica: eps_width
     Valor padrão: 12

     Essa é a largura (medida em cm) do arquivo Postscript gerado pelos
     terminais `eps' e `eps_color'.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo gráfico não é importante. Pode também ser usada
     como um argumento da função `draw'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(terminal   = 'eps,
                       eps_width  = 3,
                       eps_height = 3,
                       explicit(x^2,x,-1,1))$

     Veja também `terminal', `file_name', e `eps_height'.

 -- Opção gráfica: eps_height
     Valor padrão: 8

     Essa é a altura (medida em cm) do arquivo Postscript gerado pelos
     terminais `eps' e `eps_color'.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo gráfico não é importante. Pode também ser usada
     como um argumento da função `draw'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(terminal   = 'eps,
                       eps_width  = 3,
                       eps_height = 3,
                       explicit(x^2,x,-1,1))$

     Veja também `terminal', `file_name', e `eps_width'.

 -- Opção gráfica: axis_bottom
     Valor padrão: `true'

     Se `axis_bottom' for `true', o eixo inferior é mostrado em fundos
     gráficos bidimensionais.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_bottom = false,
                       explicit(x^3,x,-1,1))$

     Veja também `axis_left',  `axis_top', `axis_right', e `axis_3d'.

 -- Opção gráfica: axis_left
     Valor padrão: `true'

     Se `axis_left' for `true', o eixo da esquerda é mostrado em fundos
     gráficos bidimensionais.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_left = false,
                       explicit(x^3,x,-1,1))$

     Veja também `axis_bottom',  `axis_top', `axis_right', e `axis_3d'.

 -- Opção gráfica: axis_top
     Valor padrão: `true'

     Se `axis_top' for `true', o eixo superior é mostrado em fundos
     gráficos bidimensionais.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_top = false,
                       explicit(x^3,x,-1,1))$

     Veja também `axis_bottom',  `axis_left', `axis_right', e `axis_3d'.

 -- Opção gráfica: axis_right
     Valor padrão: `true'

     Se `axis_right' for `true', o eixo da direita é mostrado em fundos
     gráficos bidimensionais.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_right = false,
                       explicit(x^3,x,-1,1))$

     Veja também `axis_bottom',  `axis_left', `axis_top', e `axis_3d'.

 -- Opção gráfica: axis_3d
     Valor padrão: `true'

     Se `axis_3d' for `true', os eixos <x>, <y> e <z> são mostrados em
     fundos gráficos tridimensionais.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw3d(axis_3d = false,
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$

     Veja também `axis_bottom',  `axis_left', `axis_top', e
     `axis_right' para eixos em duas dimensões.

 -- Opção gráfica: palette
     Valor padrão: `color'

     `palette' indica como mapear os valores reais de uma matriz
     passada para o objeto `image' sobre componentes de cor.

     `palette' é um vetor comprimento três com componentes variando de
     -36 a +36; cada valor é um índice para uma fórmula mapeando os
     níveis sobre as cores vermelho, verde e blue, respectivamente:
           0: 0               1: 0.5           2: 1
           3: x               4: x^2           5: x^3
           6: x^4             7: sqrt(x)       8: sqrt(sqrt(x))
           9: sin(90x)       10: cos(90x)     11: |x-0.5|
          12: (2x-1)^2       13: sin(180x)    14: |cos(180x)|
          15: sin(360x)      16: cos(360x)    17: |sin(360x)|
          18: |cos(360x)|    19: |sin(720x)|  20: |cos(720x)|
          21: 3x             22: 3x-1         23: 3x-2
          24: |3x-1|         25: |3x-2|       26: (3x-1)/2
          27: (3x-2)/2       28: |(3x-1)/2|   29: |(3x-2)/2|
          30: x/0.32-0.78125 31: 2*x-0.84     32: 4x;1;-2x+1.84;x/0.08-11.5
          33: |2*x - 0.5|    34: 2*x          35: 2*x - 0.5
          36: 2*x - 1
     números negativos significam componentes negativos de cores.

     `palette = gray' and `palette = color' are short cuts for `palette
     = [3,3,3]' and `palette = [7,5,15]', respectively.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo do gráfico não é importante.

     Exemplos:

          (%i1) load(draw)$
          (%i2) im: apply(
                     'matrix,
                      makelist(makelist(random(200),i,1,30),i,1,30))$
          (%i3) /* palette = color, default */
                draw2d(image(im,0,0,30,30))$
          (%i4) draw2d(palette = gray, image(im,0,0,30,30))$
          (%i5) draw2d(palette = [15,20,-4],
                       colorbox=false,
                       image(im,0,0,30,30))$

     Veja também `colorbox'.

 -- Opção gráfica: colorbox
     Valor padrão: `true'

     If `colorbox' is `true', a color scale is drawn together with
     `image' objects.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Exemplo:

          (%i1) load(draw)$
          (%i2) im: apply('matrix,
                           makelist(makelist(random(200),i,1,30),i,1,30))$
          (%i3) draw2d(image(im,0,0,30,30))$
          (%i4) draw2d(colorbox=false, image(im,0,0,30,30))$

     Veja também `palette'.

 -- Opção gráfica: enhanced3d
     Valor padrão: `false'

     Se `enhanced3d' for `true', superfícies são coloridas em gráficos
     tridimensionais; em outras palavras, pode escolher o modo pm3d do
     Gnuplot.

     Veja a opção `palette' para aprender como paletas são
     especificadas.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw3d(surface_hide = true,
                       enhanced3d   = true,
                       palette      = gray,
                       explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3))$

 -- Opção gráfica: point_size
     Valor padrão: 1

     `point_size' escolhe o tamanho para os pontos do gráfico. Esse
     valor deve ser um número não negativo.

     Essa opção afeta os seguintes objetos gráficos:
        * `gr2d': `points'.

        * `gr3d': `points'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(points(makelist([random(20),random(50)],k,1,10)),
                       point_size = 5,
                       points(makelist(k,k,1,20),makelist(random(30),k,1,20)))$

 -- Opção gráfica: point_type
     Valor padrão: 1

     `point_type' indica como pontos isolados são mostrados; o valor
     dessa opção pode ser qualquer índice inteiro maior que ou igual a
     -1, ou o nome de um estilo de ponto: `$none' (-1), `dot' (0),
     `plus' (1), `multiply' (2), `asterisk' (3), `square' (4),
     `filled_square' (5), `circle' (6), `filled_circle' (7),
     `up_triangle' (8), `filled_up_triangle' (9), `down_triangle' (10),
     `filled_down_triangle' (11), `diamant' (12) e `filled_diamant'
     (13).

     Essa opção afeta os seguintes objetos gráficos:
        * `gr2d': `points'.

        * `gr3d': `points'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange = [0,10],
                       yrange = [0,10],
                       point_size = 3,
                       point_type = 1,
                       points([[1,1],[5,1],[9,1]]),
                       point_type = 2,
                       points([[1,2],[5,2],[9,2]]),
                       point_type = asterisk,
                       points([[1,3],[5,3],[9,3]]),
                       point_type = 4,
                       points([[1,4],[5,4],[9,4]]),
                       point_type = 5,
                       points([[1,5],[5,5],[9,5]]),
                       point_type = 6,
                       points([[1,6],[5,6],[9,6]]),
                       point_type = filled_circle,
                       points([[1,7],[5,7],[9,7]]),
                       point_type = 8,
                       points([[1,8],[5,8],[9,8]]),
                       point_type = filled_diamant,
                       points([[1,9],[5,9],[9,9]]) )$

 -- Opção gráfica: points_joined
     Valor padrão: `false'

     Se `points_joined' for `true', pontos são unidos por linhas retas.

     Essa opção afeta os seguintes objetos gráficos:
        * `gr2d': `points'.

        * `gr3d': `points'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange        = [0,10],
                       yrange        = [0,4],
                       point_size    = 3,
                       point_type    = 1,
                       line_type     = 3,
                       points([[1,1],[5,1],[9,1]]),
                       points_joined = true,
                       point_type    = 3,
                       line_type     = 5,
                       points([[1,2],[5,2],[9,2]]),
                       point_type    = 5,
                       line_type     = 8,
                       line_width    = 7,
                       points([[1,3],[5,3],[9,3]]) )$

 -- Opção gráfica: filled_func
     Valor padrão: `false'

     `filled_func' indica se uma função é preenchida (`true') ou não
     (`false').

     Essa opção afeta somente objetos gráfico bidimensional `explicit'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(fill_color  = red,
                       filled_func = true,
                       explicit(sin(x),x,0,10) )$

     Veja também `fill_color'.

 -- Opção gráfica: transparent
     Valor padrão: `false'

     Se `transparent' for `true', regiões internas de poligonos são
     preenchidas de acordo com `fill_color'.

     Essa opção afeta os seguintes objetos gráficos:
        * `gr2d': `polygon', `rectangle', e `ellipse'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(polygon([[3,2],[7,2],[5,5]]),
                       transparent = true,
                       color       = blue,
                       polygon([[5,2],[9,2],[7,5]]) )$

 -- Opção gráfica: border
     Valor padrão: `true'

     Se `border' for `true', bordas de polígonos são colorizadas de
     acordo com `line_type' e `line_width'.

     Essa opção afeta os seguintes objetos gráficos:
        * `gr2d': `polygon', `rectangle', e `ellipse'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(color       = brown,
                       line_width  = 8,
                       polygon([[3,2],[7,2],[5,5]]),
                       border      = false,
                       fill_color  = blue,
                       polygon([[5,2],[9,2],[7,5]]) )$

 -- Opção gráfica: head_both
     Valor padrão: `false'

     Se `head_both' for `true', vetores são mostrados com seta dupla na
     ponta.  Se `false', somente uma seta é mostrada.

     Essa opção somente é relevante para objetos do tipo `vector'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,8],
                       yrange      = [0,8],
                       head_length = 0.7,
                       vector([1,1],[6,0]),
                       head_both   = true,
                       vector([1,7],[6,0]) )$

     Veja também `head_length', `head_angle', e `head_type'.

 -- Opção gráfica: head_length
     Valor padrão: 2

     `head_length' indica, em unidades do eixo <x>, o comprimento da
     ponta da seta do vetor.

     Essa opção é relevante somente para objetos do tipo `vector'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,12],
                       yrange      = [0,8],
                       vector([0,1],[5,5]),
                       head_length = 1,
                       vector([2,1],[5,5]),
                       head_length = 0.5,
                       vector([4,1],[5,5]),
                       head_length = 0.25,
                       vector([6,1],[5,5]))$

     Veja também `head_both', `head_angle', e `head_type'.

 -- Opção gráfica: head_angle
     Valor padrão: 45

     `head_angle' indica o ângulo, em graus, entre a ponta da seta do
     vetor e o segmento que forma o corpo do vetor.

     Essa opção é relevante somente para objetos do tipo `vector'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,10],
                       yrange      = [0,9],
                       head_length = 0.7,
                       head_angle  = 10,
                       vector([1,1],[0,6]),
                       head_angle  = 20,
                       vector([2,1],[0,6]),
                       head_angle  = 30,
                       vector([3,1],[0,6]),
                       head_angle  = 40,
                       vector([4,1],[0,6]),
                       head_angle  = 60,
                       vector([5,1],[0,6]),
                       head_angle  = 90,
                       vector([6,1],[0,6]),
                       head_angle  = 120,
                       vector([7,1],[0,6]),
                       head_angle  = 160,
                       vector([8,1],[0,6]),
                       head_angle  = 180,
                       vector([9,1],[0,6]) )$

     Veja também `head_both', `head_length', e `head_type'.

 -- Opção gráfica: head_type
     Valor padrão: `filled'

     `head_type' é usada para especificar como a ponta é mostrada.
     Valores possíveis são: `filled' (ponta fechada e preenchida),
     `empty' (ponta fechada mas não preenchida), e `nofilled' (ponta
     aberta).

     Essa opção é relevante somente para objetos do tipo `vector'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,12],
                       yrange      = [0,10],
                       head_length = 1,
                       vector([0,1],[5,5]), /* default type */
                       head_type = 'empty,
                       vector([3,1],[5,5]),
                       head_type = 'nofilled,
                       vector([6,1],[5,5]))$

     Veja também `head_both', `head_angle', e `head_length'.

 -- Opção gráfica: label_alignment
     Valor padrão: `center'

     `label_alignment' é usado para especificar onde escrever rótulos
     com relação às coordenadas fornecidas. Valores possíveis são:
     `center', `left', e `right'.

     Essa opção é relevante somente para objetos do tipo `label'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange          = [0,10],
                       yrange          = [0,10],
                       points_joined   = true,
                       points([[5,0],[5,10]]),
                       color           = blue,
                       label("Centered alignment (default)",5,2),
                       label_alignment = 'left,
                       label("Left alignment",5,5),
                       label_alignment = 'right,
                       label("Right alignment",5,8))$

     Veja também `label_orientation', e `color'.

 -- Opção gráfica: label_orientation
     Valor padrão: `horizontal'

     `label_orientation' é usada para especificar a orientação dos
     rótulos.  Valores possíveis são: `horizontal', e `vertical'.

     Essa opção é relevante somente para objetos do tipo `label'.

     Exemplo:

     Nesse exemplo, um ponto fictício é adicionado para firmar uma
     imagem.  o pacote `draw' precisa sempre de dados para montar um
     fundo.
          (%i1) load(draw)$
          (%i2) draw2d(xrange     = [0,10],
                       yrange     = [0,10],
                       point_size = 0,
                       points([[5,5]]),
                       color      = navy,
                       label("Horizontal orientation (default)",5,2),
                       label_orientation = 'vertical,
                       color             = "#654321",
                       label("Vertical orientation",1,5))$

     Veja também `label_alignment', e `color'.

 -- Opção gráfica: color
     Valor padrão: `"black"'

     `color' especifica a cor para o desenho de linhas, pontos, bordas
     de polígonos e rótulos.

     Cores podem ser fornecidas como nomes ou em código hexadecimal rgb.

     Nomes de cores disponíveis atualmente são: `"white"', `"black"',
     `"gray0"', `"grey0"', `"gray10"', `"grey10"', `"gray20"',
     `"grey20"', `"gray30"', `"grey30"', `"gray40"', `"grey40"',
     `"gray50"', `"grey50"', `"gray60"', `"grey60"', `"gray70"',
     `"grey70"', `"gray80"', `"grey80"', `"gray90"', `"grey90"',
     `"gray100"', `"grey100"', `"gray"', `"grey"', `"light-gray"',
     `"light-grey"', `"dark-gray"', `"dark-grey"', `"red"',
     `"light-red"', `"dark-red"', `"yellow"', `"light-yellow"',
     `"dark-yellow"', `"green"', `"light-green"', `"dark-green"',
     `"spring-green"', `"forest-green"', `"sea-green"', `"blue"',
     `"light-blue"', `"dark-blue"', `"midnight-blue"', `"navy"',
     `"medium-blue"', `"royalblue"', `"skyblue"', `"cyan"',
     `"light-cyan"', `"dark-cyan"', `"magenta"', `"light-magenta"',
     `"dark-magenta"', `"turquoise"', `"light-turquoise"',
     `"dark-turquoise"', `"pink"', `"light-pink"', `"dark-pink"',
     `"coral"', `"light-coral"', `"orange-red"', `"salmon"',
     `"light-salmon"', `"dark-salmon"', `"aquamarine"', `"khaki"',
     `"dark-khaki"', `"goldenrod"', `"light-goldenrod"',
     `"dark-goldenrod"', `"gold"', `"beige"', `"brown"', `"orange"',
     `"dark-orange"', `"violet"', `"dark-violet"', `"plum"' and
     `"purple"'.

     Componentes cromáticos em código hexadecimal são introduzidos na
     forma `"#rrggbb"'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^2,x,-1,1), /* default is black */
                       color = "red",
                       explicit(0.5 + x^2,x,-1,1),
                       color = blue,
                       explicit(1 + x^2,x,-1,1),
                       color = "light-blue", /* double quotes if - is used */
                       explicit(1.5 + x^2,x,-1,1),
                       color = "#23ab0f",
                       label("Esse é um rótulo",0,1.2)  )$

     Veja também `fill_color'.

 -- Opção gráfica: fill_color
     Valor padrão: `"red"'

     `fill_color' especifica a cor para preenchimento de polígonos e
     funções explicitamente bidimensionais.

     Veja `color' para aprender como cores são especificadas.

 -- Opção gráfica: line_width
     Valor padrão: 1

     `line_width' é a lagura das linhas do gráfico.  Seu valor deve ser
     um número positivo.

     Essa opção afeta os seguintes objetos gráficos:
        * `gr2d': `points', `polygon', `rectangle', `ellipse',
          `vector', `explicit', `implicit', `parametric' e `polar'.

        * `gr3d': `points' e `parametric'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^2,x,-1,1), /* default width */
                       line_width = 5.5,
                       explicit(1 + x^2,x,-1,1),
                       line_width = 10,
                       explicit(2 + x^2,x,-1,1))$

     Veja também `line_type'.

 -- Opção gráfica: line_type
     Valor padrão: `solid'

     `line_type' indica como linhas são mostradas; valores possíveis são
     `solid' e `dots'.

     Essa opção afeta os seguintes objetos gráficos:
        * `gr2d': `points', `polygon', `rectangle', `ellipse',
          `vector', `explicit', `implicit', `parametric' e `polar'.

        * `gr3d': `points', `explicit', `parametric' e
          `parametric_surface'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(line_type = dots,
                       explicit(1 + x^2,x,-1,1),
                       line_type = solid, /* default */
                       explicit(2 + x^2,x,-1,1))$

     Veja também `line_width'.

 -- Opção gráfica: nticks
     Valor padrão: 30

     `nticks' é o número de amostra de pontos usado pelas rotinas de
     montagem de gráfico.

     Essa opção afeta os seguintes objetos gráficos:
        * `gr2d': `ellipse', `explicit', `parametric' e `polar'.

        * `gr3d': `parametric'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(transparent = true,
                       ellipse(0,0,4,2,0,180),
                       nticks = 5,
                       ellipse(0,0,4,2,180,180) )$

 -- Opção gráfica: adapt_depth
     Valor padrão: 10

     `adapt_depth' é o número máximo de quebras usado pelas rotinas
     adaptativos de impressão.

     Essa opção é relevante somente para funções 2d `explicitas'.

 -- Opção gráfica: key
     Valor padrão: `""' (a seqüência de caracteres vazia)

     `key' é o nome de uma função na legenda. Se `key' é uma seqüência
     de caracteres vazia, nenhuma chave é atribuída à função.

     Essa opção afeta os seguintes objetos gráficos:
        * `gr2d': `points', `polygon', `rectangle', `ellipse',
          `vector', `explicit', `implicit', `parametric', e `polar'.

        * `gr3d': `points', `explicit', `parametric', e
          `parametric_surface'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(key = "Seno",
                       explicit(sin(x),x,0,10),
                       key = "Cosseno",
                       line_type = 3,
                       explicit(cos(x),x,0,10) )$

 -- Opção gráfica: xu_grid
     Valor padrão: 30

     `xu_grid' é o número de coordenadas da primeira variável (`x' na
     forma explícita e o número de coordenadas de `u' em superfícies
     tridimensionais na forma paramétrica) para contruir a grade dos
     pontos de amostra.

     Essa opção afeta os seguintes objetos gráficos:
        * `gr3d': `explicit' e `parametric_surface'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw3d(xu_grid = 10,
                       yv_grid = 50,
                       explicit(x^2+y^2,x,-3,3,y,-3,3) )$

     Veja também `yv_grid'.

 -- Opção gráfica: yv_grid
     Valor padrão: 30

     `yv_grid' é o número de coordenadas da segunda variável (`y' na
     forma explícita e o número de coordenadas de `v' em superfícies
     tridimensionais na forma paramétrica) para construir a grade dos
     pontos de amostra.

     Essa opção afeta os seguintes objetos gráficos:
        * `gr3d': `explicit' e `parametric_surface'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw3d(xu_grid = 10,
                       yv_grid = 50,
                       explicit(x^2+y^2,x,-3,3,y,-3,3) )$

     Veja também `xu_grid'.

 -- Opção gráfica: surface_hide
     Valor padrão: `false'

     Se `surface_hide' for `true', partes escondidas não são mostradas
     no gráfico em superfícies tridimensioais.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw(columns=2,
                     gr3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3)),
                     gr3d(surface_hide = true,
                          explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3)) )$

 -- Opção gráfica: contour
     Valor padrão: `none'

     Option `contour' torna o usuário capaz de selecionar onde imprimir
     linhas de contorno.  Valores possíveis são:

        * `none': nenhuma linha de contorno é mostrada.

        * `base': linhas de contorno são projetadas no plano xy.

        * `surface': linhas de contorno são mostradas sobre a
          superfície.

        * `both': duas linhas de contorno são mostradas: no plano xy e
          sobre a superfície.

        * `map': linhas de contorno são projetadas sobre o plano xy, e
          o ponto de boservação é escolhido na vertical.


     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = 15,
                       contour        = both,
                       surface_hide   = true) $

 -- Opção gráfica: contour_levels
     Valor padrão: 5

     `contour_levels' é o número de níveis em gráficos de contorno.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = 15,
                       contour        = both,
                       surface_hide   = true) $

 -- Opção gráfica: columns
     Valor padrão: 1

     `columns' é o número de colunas em gráficos multiplos.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo do gráfico não é importante. Pode também ser
     usado como um argumento da função `draw'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) scene1: gr2d(title="Elipse",
                             nticks=30,
                             parametric(2*cos(t),5*sin(t),t,0,2*%pi))$
          (%i3) scene2: gr2d(title="Triângulo",
                             polygon([4,5,7],[6,4,2]))$
          (%i4) draw(scene1, scene2, columns = 2)$


 -- Opção gráfica: ip_grid
     Valor padrão: `[50, 50]'

     `ip_grid' escolhe a grade para a primeira amostragem em gráficos
     implícitos.

     Essa opção é relevante somente para `implicit' objects.

 -- Opção gráfica: ip_grid_in
     Valor padrão: `[5, 5]'

     `ip_grid_in' escolhe a grade para a segunda amostragem em gráficos
     implícitos.

     Essa opção é relevante somente para `implicit' objects.

 -- Construtor de fundo gráfico: gr2d (<opção gráfica>, ..., <objeto
          gráfico>, ...)
     A função `gr2d' constrói um objeto descrevendo um fundo gráfico em
     duas dimensões. Arguments are opções gráficas e objetos gráficos.
     Esse fundo gráfico é interpretado seqüêncialmente: opções gráficas
     afetam aqueles objetos gráficos colocados imediatamente à sua
     direita.

     Para fazer uso dessa função escreva primeiramente `load(draw)'.

     Adiante encontra-se uma lista de objetos gráficos disponívies para
     fundos gráficos em duas dimensões:

        * `points([[x1,y1], [x2,y2], [x3,y3],...])' ou
          `points([x1,x2,x3,...], [y1,y2,y3,...])': posiciona os pontos
          `[x1,y1]', `[x2,y2]', `[x2,y2]', ... no gráfico.

          Esse objeto é efetado pelas seguintes opções gráficas:
          `point_size', `point_type', `points_joined', `line_width',
          `key', `line_type' e `color'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw2d(key           = "Small points",
                            points(makelist([random(20),random(50)],k,1,10)),
                            point_type    = 6,
                            point_size    = 3,
                            points_joined = true,
                            key           = "Great points",
                            points(makelist(k,k,1,20),makelist(random(30),k,1,20)))$

        * `polygon([[x1,y1], [x2,y2], [x3,y3],...])' ou
          `polygon([x1,x2,x3,...], [y1,y2,y3,...])': desenha um
          polígono com vértices `[x1,y1]', `[x2,y2]', `[x2,y2]', ... no
          plano.

          Esse objeto é afetado pelas seguintes opçs gráficas:
          `transparent', `fill_color', `border', `line_width', `key',
          `line_type' `color'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw2d(color      = "#e245f0",
                            line_width = 8,
                            polygon([[3,2],[7,2],[5,5]]),
                            border      = false,
                            fill_color  = yellow,
                            polygon([[5,2],[9,2],[7,5]]) )$

        * `rectangle([x1,y1], [x2,y2])': desenha um retângulo partindo
          do vértice `[x1,y1]' e terminando no vértice `[x2,y2]' oposto
          ao primeiro.

          Esse objeto é afetado pelas seguintes opções gráficas:
          `transparent', `fill_color', `border', `line_width', `key',
          `line_type' e `color'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw2d(fill_color  = red,
                            line_width  = 6,
                            line_type   = dots,
                            transparent = false,
                            fill_color   = blue,
                            rectangle([-2,-2],[8,-1]),   /* opposite vertices */
                            transparent = true,
                            line_type   = solid,
                            line_width  = 1,
                            rectangle([9,4],[2,-1.5]),
                            xrange      = [-3,10],
                            yrange      = [-3,4.5] )$

        * `ellipse(xc, yc, a, b, ang1, ang2)': desenha uma elipse com
          centro em `[xc, yc]' com semi-eixo maior `a' e semi-eixo
          menor `b' traçando um arco de elipse que se inicia no ângulo
          `ang1' e que vai até o ângulo `ang2'.  semi axis `a' e `b',
          respectively, from angle `ang1' to angle `ang2'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          `nticks', `transparent', `fill_color', `border', `line_width',
          `line_type', `key' e `color'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw2d(transparent = false,
                            fill_color  = 8,
                            color       = gray30,
                            transparent = false,
                            line_width  = 5,
                            ellipse(0,6,3,2,270,-270),  /* center (x,y), a, b, start & end in degrees */
                            transparent = true,
                            color       = blue,
                            line_width  = 3,
                            ellipse(2.5,6,2,3,30,-90),
                            xrange      = [-3,6],
                            yrange      = [2,9] )$

        * `label(rótulo,x,y)': escreve o `rótulo' no ponto `[x,y]'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          `label_alignment', `label_orientation' e `color'.

          Exemplo:

          Nesse exemplo, um ponto imaginário é adicionado para firmar a
          imagem.  O pacote `draw' precisa sempre da dados para
          desenhar um fundo.  Essas cores podem mudar em diferentes
          terminais.
               (%i1) load(draw)$
               (%i2) draw2d(explicit(x^2,x,-1,1),
                            color = "red",
                            label("Label in red",0,0.3),
                            color = "#0000ff",
                            label("Label in blue",0,0.6),
                            color = "light-blue", /* double quotes if - is used */
                            label("Rótulo em light-blue",0,0.9)  )$

        * `vector([x,y], [dx,dy])': desenha um vetor de componentes
          ortogonais `[dx,dy]' com orígem eno ponto `[x,y]'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          `head_both', `head_length', `head_angle', `head_type',
          `line_width', `line_type' e `key'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw2d(xrange      = [0,12],
                            yrange      = [0,10],
                            head_length = 1,
                            vector([0,1],[5,5]), /* default type */
                            head_type = 'empty,
                            vector([3,1],[5,5]),
                            head_both = true,
                            head_type = 'nofilled,
                            line_type = dots,
                            vector([6,1],[5,5]))$

        * `explicit(fcn,var,minval,maxval)': monta o gráfico da
          função explícita `fcn', com variável `var' assumindo valores
          de `minval' a `maxval'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          `nticks', `adapt_depth', `line_width', `line_type', `key',
          `filled_func', `fill_color' e `color'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw2d(line_width = 3,
                            color      = blue,
                            explicit(x^2,x,-3,3) )$
               (%i3) draw2d(fill_color  = brown,
                            filled_func = true,
                            explicit(x^2,x,-3,3) )$

        *
          `implicit(fcn,x-var,x-minval,x-maxval,y-var,y-minval,y-maxval)':
          monta o gráfico da função implícita definida por `fcn', com
          variável `x-var' assumindo de `x-minval' a `x-maxval', e
          variável `y-var' assumindo valores de `y-minval' a `y-maxval'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          `ip_grid', `ip_grid_in', `line_width', `line_type', `key' e
          `color'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw2d(terminal  = eps,
                            grid      = true,
                            line_type = solid,
                            key       = "y^2=x^3-2*x+1",
                            implicit(y^2=x^3-2*x+1, x, -4,4, y, -4,4),
                            line_type = dots,
                            key       = "x^3+y^3 = 3*x*y^2-x-1",
                            implicit(x^3+y^3 = 3*x*y^2-x-1, x, -4,4, y, -4,4),
                            title     = "Duas funções implícitas" )$

        * `polar(radius,ang,minang,maxang)': plots function
          `radius(ang)' defined in polar coordinates, com a variável
          `ang' assumindo valores de `minang' a `maxang'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          `nticks', `line_width', `line_type', `key' e `color'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw2d(user_preamble = "set grid polar",
                            nticks        = 200,
                            xrange        = [-5,5],
                            yrange        = [-5,5],
                            line_type     = 6,
                            line_width    = 3,
                            title         = "Hyperbolic Spiral",
                            polar(10/theta,theta,1,10*%pi) )$

        * `parametric(xfun,yfun,par,parmin,parmax)': monta o gráfico da
          função paramétrica `[xfun,yfun]', com parâmetro `par'
          assumindo valores de `parmin' a `parmax'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          `nticks', `line_width', `line_type', `key' e `color'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw2d(explicit(exp(x),x,-1,3),
                            color = red,
                            key   = "Esse é a unidade paramétrica!!",
                            parametric(2*cos(rrr),rrr^2,rrr,0,2*%pi))$

        * `image(im,x0,y0,width,height)': monta o gráfico da imágem
          `im' em uma região retangular do vértice `(x0,y0)' ao vértice
          `(x0+width,y0+height)' no plano real. O argumeto `im' deve
          ser uma matriz de números reais, ou uma matriz de vetores de
          comprimento três.

          Se `im' for uma matriz de números reais, valores de pixel são
          interpretados conforme a opção gráfica `palette', que é um
          vetor de comprimento três com componentes numéricas variando
          de -36 a +36; cada valor é um índice para uma fórmula
          mapeando os níveis sobre as cores vermelha, verde e azul,
          respectivamente:
                0: 0               1: 0.5           2: 1
                3: x               4: x^2           5: x^3
                6: x^4             7: sqrt(x)       8: sqrt(sqrt(x))
                9: sin(90x)       10: cos(90x)     11: |x-0.5|
               12: (2x-1)^2       13: sin(180x)    14: |cos(180x)|
               15: sin(360x)      16: cos(360x)    17: |sin(360x)|
               18: |cos(360x)|    19: |sin(720x)|  20: |cos(720x)|
               21: 3x             22: 3x-1         23: 3x-2
               24: |3x-1|         25: |3x-2|       26: (3x-1)/2
               27: (3x-2)/2       28: |(3x-1)/2|   29: |(3x-2)/2|
               30: x/0.32-0.78125 31: 2*x-0.84     32: 4x;1;-2x+1.84;x/0.08-11.5
               33: |2*x - 0.5|    34: 2*x          35: 2*x - 0.5
               36: 2*x - 1
          números negativos significam componente de cor negativa.

          `palette = gray' e `palette = color' são atalhos para
          `palette = [3,3,3]' e `palette = [7,5,15]', respectivamente.

          Se `im' for uma matriz de vetores de comprimento três, eles
          são interpretados como componenetes das cores vermelho, verde
          e azul.

          Exemplos:

          se `im' for uma matriz de números reais, valores de pixel são
          interpretados conforme a opção gráfica `palette'.
               (%i1) load(draw)$
               (%i2) im: apply(
                          'matrix,
                           makelist(makelist(random(200),i,1,30),i,1,30))$
               (%i3) /* palette = color, default */
                     draw2d(image(im,0,0,30,30))$
               (%i4) draw2d(palette = gray, image(im,0,0,30,30))$
               (%i5) draw2d(palette = [15,20,-4],
                            colorbox=false,
                            image(im,0,0,30,30))$

          Veja também `colorbox'.

          Se `im' for uma matriz de vetores de comprimento três, eles
          são interpretados como componentes da cores vermelho, verde e
          azul.
               (%i1) load(draw)$
               (%i2) im: apply(
                           'matrix,
                            makelist(
                              makelist([random(300),
                                        random(300),
                                        random(300)],i,1,30),i,1,30))$
               (%i3) draw2d(image(im,0,0,30,30))$


     Veja também as seguintes opções gráficas: `xrange', `yrange',
     `logx', `logy', `terminal', `grid', `title', `xlabel', `ylabel',
     `xtics', `ytics', `xy_file', `file_name', `pic_width',
     `pic_height', `eps_width', `eps_height', `user_preamble',
     `axis_bottom', `axis_left', `axis_top', e `axis_right'.


 -- Scene constructor: gr3d (<opção gráfica>, ..., <objeto gráfico>,
          ...)
     A função `gr3d' constrói um objeto descrevendo um fundo gráfico
     tridimensional. Argumentos são opções gráficas e objetos gráficos.
     Esse fundo gráfico é interpretado seqüêncialmente: opções gráficas
     afetam aqueles objetos gráficos colocados imediatamente à sua
     direita.

     Para fazer uso dessa função escreva primeiramente `load(draw)'.

     Essa é a lista dos objetos gráficos disponíveis para fundos
     gráficos tridimensionais:

        * `points([[x1,y1,z1], [x2,y2,z2], [x3,y3,z3],...])' ou
          `points([x1,x2,x3,...], [y1,y2,y3,...], [z1,z2,z3,...])':
          posiciona os pontos `[x1,y1,z1]', `[x2,y2,z2]', `[x2,y2,z3]',
          ... no gráfico.

          Esse objeto é afetado pelas seguintes opções gráficas:
          `point_size', `point_type', `points_joined', `line_width',
          `key', `line_type' e `color'.

          Exemplos:

          Uma amostra tridimensional,
               (%i1) load(draw)$
               (%i2) load (numericalio)$
               (%i3) s2 : read_matrix (file_search ("wind.data"))$
               (%i4) draw3d(title      = "Velocidades diárias de ventos disponíveis",
                            point_size = 2,
                            points(args(submatrix (s2, 4, 5))) )$

          Duas amostras tridimensionais,
               (%i1) load(draw)$
               (%i2) load (numericalio)$
               (%i3) s2 : read_matrix (file_search ("wind.data"))$
               (%i4) draw3d(title      = "Velocidades diárias de ventos disponíveis. Dois conjuntos de dados",
                            point_size = 2,
                            key        = "Amostras das estações 1, 2 e 3",
                            points(args(submatrix (s2, 4, 5))),
                            point_type = 4,
                            key        = "Amostras das estações 1, 4 e 5",
                            points(args(submatrix (s2, 2, 3))) )$

        * `label(rótulo,x,y,z)': escreve `rótulo' no ponto `[x,y,z]'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          `label_alignment', `label_orientation' e `color'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3),
                            color = red,
                            label("SUBINDO",-2,0,3),
                            color = blue,
                            label("DESCENDO",2,0,-3) )$

        * `vector([x,y,z], [dx,dy,dz])': monta o gráfico do vetor
          `[dx,dy,dz]' com orígem em `[x,y,z]'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          `head_both', `head_type', `line_width', `line_type', `key' e
          `color'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw3d(color = cyan,
                            vector([0,0,0],[1,1,1]/sqrt(3)),
                            vector([0,0,0],[1,-1,0]/sqrt(2)),
                            vector([0,0,0],[1,1,-2]/sqrt(6)) )$

        * `explicit(fcn,var1,minval1,maxval1,var2,minval2,maxval2)':
          monta o gráfico da função explícita `fcn', com a variável
          `var1' assumindo valores de `minval1' a `maxval1' e variável
          `var2' assumindo valores de `minval2' a `maxval2'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          `xu_grid', `yv_grid', `line_type', `key' e `color'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw3d(key   = "Gauss",
                            color = "#a02c00",
                            explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3),
                            color = blue,
                            key   = "Plane",
                            explicit(x+y,x,-5,5,y,-5,5),
                            surface_hide = true)$

        * `parametric(xfun,yfun,zfun,par,parmin,parmax)': monta o
          gráfico da curva paramétrica `[xfun,yfun,zfun]', com
          parâmetro `par' assumindo valores de `parmin' a `parmax'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          `nticks', `line_width', `line_type', `key' e `color'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3),
                            color = royalblue,
                            parametric(cos(5*u)^2,sin(7*u),u-2,u,0,2),
                            color      = turquoise,
                            line_width = 2,
                            parametric(t^2,sin(t),2+t,t,0,2),
                            surface_hide = true,
                            title = "Surface & curves" )$

        *
          `parametric_surface(xfun,yfun,zfun,par1,par1min,par1max,par2,par2min,par2max)':
          monta o gráfico da superfície paramétrica `[xfun,yfun,zfun]',
          com parâmetro `par1' assumindo valores de `par1min' a
          `par1max' e o parâmetro `par2' assumindo valores de `par2min'
          a `par2max'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          `xu_grid', `yv_grid', `line_type', `key' e `color'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw3d(title          = "Concha do mar",
                            xu_grid        = 100,
                            yv_grid        = 25,
                            rot_vertical   = 100,
                            rot_horizontal = 20,
                            surface_hide   = true,
                            parametric_surface(0.5*u*cos(u)*(cos(v)+1),
                                               0.5*u*sin(u)*(cos(v)+1),
                                               u*sin(v) - ((u+3)/8*%pi)^2 - 20,
                                               u, 0, 13*%pi, v, -%pi, %pi) )$


     Veja também as seguintes opções gráficas: `xrange', `yrange',
     `zrange', `logx', `logy', `logz', `terminal', `grid', `title',
     `xlabel', `ylabel', `zlabel', `xtics', `ytics', `ztics', `xy_file',
     `user_preamble', `axis_bottom', `axis_left', `axis_top',
     `file_name', `pic_width', `pic_height', `eps_width', `eps_height',
     `axis_right', `rot_vertical', `rot_horizontal', `axis_3d',
     `xu_grid', `yv_grid', `surface_hide', `contour', `contour_levels',
     `palette', `colorbox' e `enhanced3d'.


 -- Function: draw (<gr2d>, ..., <gr3d>, ..., <opções>, ...)
     Monta o fundo de uma série de gráficos; seus argumentos são
     objetos `gr2d' e `gr3d', juntamente com algumas opções. Por
     padrão, o fundos gráficos são colocados juntos em uma coluna.

     A função `draw' aceita duas opções possíveis: `terminal' e
     `columns'.

     As funções `draw2d' e `draw3d' são atalhos para serem usados
     quando somente um fundo gráfico é requerido, em duas ou três
     dimensões, respectivamente.

     Para fazer uso dessa função escreva primeiramente `load(draw)'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) scene1: gr2d(title="Ellipse",
                             nticks=30,
                             parametric(2*cos(t),5*sin(t),t,0,2*%pi))$
          (%i3) scene2: gr2d(title="Triangle",
                             polygon([4,5,7],[6,4,2]))$
          (%i4) draw(scene1, scene2, columns = 2)$

 -- Função: draw2d (<opção>, <objeto gráfico>, ...)
     Essa função é um atalho para `draw2d(gr2d(<opções>, ..., <objeto
     gráfico>, ...))'.

     Pode ser usada para montar gráfico de um único fundo bidimensional.

     Para fazer uso dessa função escreva primeiramente `load(draw)'.


 -- Função: draw3d (<opção>, <graphic object>, ...)
     Essa função é um atalho para `draw3d(gr3d(<opções>, ..., <objeto
     gráfico>, ...))'.

     Pode ser usada para montar o fundo gráfico único tridmensional.

     Para fazer uso dessa função escreva primeiramente `load(draw)'.


 -- Variável: draw_pipes
     Valor padrão: `true'

     Quando `draw_pipes' for `true', Maxima comunica-se com Gnuplot
     diretamente (via pipes). Se `draw_pipes' for `false', Maxima
     comunica-se com Gnuplot via arquivos. Essa opção não está
     disponível para usuários windows.



File: maxima.info,  Node: dynamics,  Next: eval_string,  Prev: draw,  Up: Top

49 dynamics
***********

* Menu:

* Introdução a dynamics::
* Funções e Variáveis Definidas para dynamics::


File: maxima.info,  Node: Introdução a dynamics,  Next: Funções e Variáveis Definidas para dynamics,  Prev: dynamics,  Up: dynamics

49.1 Introdução a dynamics
==========================

O pacote adicional `dynamics' inclui muitas funções para criar várias
representações gráficas de sistemas dinâmicos discretos e fractais, e
uma implementação deo método numérico de Runge-Kutta de quarta ordem
para a resolução de sistemas de equações diferenciais.

   Para usar as funções nesse pacote você deve primeiramente torná-lo
disponível para uso com `load("dynamics")'.

   Modificações introduzidas no Maxima 5.12

   Iniciando no Maxima 5.12, o pacote dynamics agora utiliza a
função `plot2d' para monar os gráficos. Os comandos que produzem
gráficos (com exceção de `julia' e de `mandelbrot') agora aceitam
qualquer opção de `plot2d', incluindo a opção que modificam o montante
das várias interfaces gráficas, usando diferentes estilos de montagem
de gráfico e cores, e representando um ou ambos os eixos em uma escala
logarítmica. As antigas opções <domain>, <pointsize>, <xcenter>,
<xradius>, <ycenter>, <yradius>, <xaxislabel> e <yaxislabel> não são
aceitas nessa nova versão.

   Todos os programas irão agora aceitar quaisquer nomes de variáveis,
e não apenas <x> e <y> como nas antigas versões. Dois parâmetros
requeridos tiveram modificações em dois desses programas: `evolution2d'
agora requer uma lista nomeando explicitamente as duas variáveis
independentes, e o intervalo horizontal para `orbits' não mais requer
um tamanho de passo; o intervalo pode somente espcificar o nome da
variável, e o menor e o maior valores; o número de passos pode agora
ser modificado com a opção <nticks>.



Local Variables:
coding: iso-8859-1
End:
