This is maxima.info, produced by makeinfo version 4.13 from
/home/vttoth/dev/maxima/doc/info/es//include-maxima.texi.

Este es el Manual de Maxima en versión Texinfo

Copyright 1994, 2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).  Un sistema de cálculo simbólico
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Top,  Next: Introducción a Maxima,  Prev: (dir),  Up: (dir)

Manual de Maxima 5.38.1
***********************

_Maxima es un sistema de cálculo simbólico escrito en Lisp._

Maxima desciende del sistema Macsyma, desarrollado en el MIT
(Massachusetts Institute of Technology) entre los años 1968 y 1982 como
parte del proyecto MAC. El MIT pasó una copia del código fuente al DOE
(Department of Energy) en 1982, en una versión conocida como
DOE-Macsyma. Una de estas copias fue mantenida por el Profesor William
F. Schelter de la Universidad de Texas desde el año 1982 hasta su
fallecimiento en 2001.  En 1998 Schelter había obtenido del
Departamento de Energía permiso para distribuir el código fuente de
DOE-Macsyma bajo licencia GNU-GPL, iniciando en el año 2000 el proyecto
Maxima en SourceForge con el fin de mantener y seguir desarrollando
DOE-Macsyma, ahora con el nombre de Maxima.


Los usuarios de habla hispana disponen de una lista de correos en la
que podrán participar para recabar información, proponer ideas y
comentar sus experiencias con Maxima:

`https://lists.sourceforge.net/lists/listinfo/maxima-lang-es'


Nota de la traducción: Este manual es una traducción de la versión
original en inglés. En la versión 5.25 se han introducido cambios
sustanciales que afectan, fundamentalmente, a una reordenación de los
contenidos, a la desaparición de algunas secciones y a la aparición de
otras nuevas. Además, se han añadido introducciones a algunas secciones
provenientes de la versión alemana; me ha parecido conveniente
incorporarlas a la versión española por ser clarificadoras de algunos
conceptos básicos de Maxima, aunque todavía no forman parte de la
versión inglesa de referencia.


Mario Rodríguez Riotorto. (`mario ARROBA edu PUNTO xunta PUNTO es')

* Menu:


Infraestructura de Maxima

* Introducción a Maxima::            Muestra de sesiones con Maxima.
* Detección e informe de fallos::    Gestión de fallos.
* Ayuda::                              Solicitando ayuda desde una sesión de Maxima.
* Línea de comandos::    Sintaxis de los comandos de Maxima.
* Tipos de datos y estructuras::       Números, cadenas de texto, listas, arrays y estructuras.
* Operadores::                         Operadores internos y definidos por el usuario.
* Evaluación::                       Evaluando expresiones.
* Expresiones::                        Expresiones de Maxima.
* Simplificación::                   Simplificando expresiones.
* Funciones matemáticas::            Funciones matemáticas en Maxima.
* Base de datos de Maxima::            Declaraciones, contextos, hechos y propiedades.
* Gráficos::                         Gráficos en dos y tres dimensiones.
* Lectura y escritura::                Lectura y escritura de archivos.

Soporte para campos más específicos de las matemáticas

* Polinomios::                         Operaciones con polinomios.
* Funciones Especiales::               Funciones especiales.
* Funciones elípticas::  Funciones e integrales elípticas.
* Límites::              Cálculo de límites.
* Diferenciación::                   Cálculo diferencial.
* Integración::                      Cálculo integral.
* Ecuaciones::                         Definición y resolución de ecuaciones.
* Ecuaciones Diferenciales::           Definición y resolución de ecuaciones diferenciales.
* Métodos numéricos::              Integración numérica, transformadas de Fourier, etc.
* Matrices y Álgebra Lineal::        Operaciones matriciales.
* Afines::
* itensor::                            Manipulación indexada de tensores
* ctensor::                            Manipulación por componentes de tensores
* atensor::                            Manipulación algebraica de tensores
* Sumas productos y series::           Sumas, productos, Taylor y series de potencias.
* Teoría de Números::  Teoría de números.
* Simetrías::
* Grupos::                             Álgebra abstracta.

Funcionalidades avanzadas y programación

* Entorno de Ejecución::      Personalización de Maxima.
* Miscelánea de opciones::    Opciones que afectan globalmente el comportamiento de Maxima.
* Reglas y patrones::           Patrones de definidos por el usuario y
                                reglas de simplificación.
* Conjuntos::                   Operaciones con conjuntos.
* Definición de Funciones::   Programando funciones.
* Programación::              Programación en Maxima.
* Depurado::                    Depuración de fallos en programas Maxima.

Paquetes adicionales

* augmented_lagrangian::        Paquete augmented_lagrangian.
* Bernstein::                   Polinomios de Bernstein.
* bode::                        Gráficos de Bode.
* cobyla::                      Optimización no lineal con restricciones en desigualdades.
* contrib_ode::                 Procedimientos adicionales para EDOs.
* descriptive::                 Estadística descriptiva.
* diag::                        Matrices de Jordan.
* distrib::                     Distribuciones de probabilidad.
* draw::                        Un interfaz Maxima-Gnuplot.
* drawdf::                      Dibuja campos de direcciones con Gnuplot.
* dynamics::                    Visualización 3D, animaciones y sistemas dinámicos.
* ezunits::                     Magnitudes dimensionales.
* f90::                         Traductor de Maxima fortran.
* finance::                     Cálculo financiero.
* fractals::                    Fractales.
* ggf::                         Expresión general de sucesiones.
* graphs::                      Teoría de grafos.
* grobner::                     Funciones para trabajar con bases de Groebner.
* impdiff::                     Derivadas implícitas.
* interpol::                    Interpolación.
* lapack::                      Paquete LAPACK para álgebra lineal.
* lbfgs::                       Paquete L-BFGS para minimización sin restricciones.
* lindstedt::                   Paquete Lindstedt.
* linearalgebra::               Funciones de álgebra lineal.
* lsquares::                    Mínimos cuadrados.
* makeOrders::                  Utilidad sobre polinomios.
* minpack::                     Funciones MINPACK para optimización y cálculo de raíces
* mnewton::                     Método de Newton.
* numericalio::                 Lectura y escritura de ficheros.
* opsubst::                     Utilidad para sustituciones.
* orthopoly::                   Polinomios ortogonales.
* romberg::                     Integración numérica por el método de Romberg.
* simplex::                     Programación lineal.
* simplification::              Reglas y funciones de simplificación.
* solve_rec::                   Recurrencias lineales.
* stats::                       Inferencia estadística.
* stirling::                    Fórmula de Stirling.
* stringproc::                  Procesamiento de cadenas.
* to_poly_solve::               Paquete to_poly_solve.
* unit::                        Unidades físicas y dimensiones.
* zeilberger::                  Funciones para series hipergeométricas.


Índice

* Índice de Funciones y Variables::  Índice.

 --- Listado detallado de los nodos ---

Introducción

* Introducción a Maxima::

Detección e informe de fallos

* Funciones y variables para la detección e informe de fallos::

Ayuda

* Documentación::
* Funciones y variables para la ayuda::

Línea de comandos

* Introducción a la línea de comandos::
* Funciones y variables para la línea de comandos::
* Funciones y variables para la impresión::

Tipos de datos y estructuras

* Números::
* Cadenas de texto::
* Constantes::
* Listas::
* Arrays::
* Estructuras::

Operadores

* Introducción a los operadores::
* Operadores aritméticos::
* Operadores relacionales::
* Operadores lógicos::
* Operadores para ecuaciones::
* Operadores de asignación::
* Operadores definidos por el usuario::

Evaluación

* Introducción a la evaluación::
* Funciones y variables para la evaluación::

Expresiones

* Introducción a las expresiones::
* Nombres y verbos::
* Identificadores::
* Desigualdades::
* Funciones y variables para expresiones::

Simplificación

* Introducción a la simplificación::
* Funciones y variables para simplificación::

Funciones matemáticas

* Funciones para los números::
* Funciones para los números complejos::
* Funciones combinatorias::
* Funciones radicales exponenciales y logarítmicas::
* Funciones trigonométricas::
* Números aleatorios::

Base de datos de Maxima

* Introducción a la base de datos de Maxima::
* Funciones y variables para las propiedades::
* Funciones y variables para los hechos::
* Funciones y variables para los predicados::

Gráficos

* Introducción a los gráficos::
* Formatos gráficos::
* Funciones y variables para gráficos::
* Opciones gráficas::
* Opciones para Gnuplot::
* Funciones para el formato Gnuplot_pipes::

Lectura y escritura

* Comentarios::
* Archivos::
* Funciones y variables para lectura y escritura::
* Funciones y variables para salida TeX::
* Funciones y variables para salida Fortran::

Polinomios

* Introducción a los polinomios::
* Funciones y variables para polinomios::

Funciones Especiales

* Introducción a las funciones especiales::
* Funciones de Bessel::
* Funciones de Airy::
* Funciones Gamma y factorial::
* Integral exponencial::
* Función de error::
* Funciones de Struve::
* Funciones hipergeométricas::
* Funciones de cilindro parabólico::
* Funciones y variables para las funciones especiales::

Funciones elípticas

* Introducción a las funciones e integrales elípticas::
* Funciones y variables para funciones elípticas::
* Funciones y variables para integrales elípticas::

Límites

* Funciones y variables para límites::

Diferenciación

* Funciones y variables para la diferenciación::

Integración

* Introducción a la integración::
* Funciones y variables para integración::

Ecuaciones

* Funciones y variable para las ecuaciones::

Ecuaciones Diferenciales

* Introducción a las ecuaciones diferenciales::
* Funciones y variables para ecuaciones diferenciales::

Métodos numéricos

* Introducción a la transformada rápida de Fourier::
* Funciones y variables para la transformada rápida de Fourier::
* Funciones para la resolución numérica de ecuaciones::
* Introducción a la resolución numérica de ecuaciones diferenciales::
* Funciones para la resolución numérica de ecuaciones diferenciales::

Matrices y Álgebra Lineal

* Introducción a las matrices y el álgebra lineal::
* Funciones y variables para las matrices y el álgebra lineal::

Afines

* Funciones y variables para Afines::

itensor

* Introducción a itensor::
* Funciones y variables para itensor::

ctensor

* Introducción a ctensor::
* Funciones y variables para ctensor::

atensor

* Introducción a atensor::
* Funciones y variables para atensor::

Sumas productos y series

* Funciones y variables para sumas y productos::
* Introducción a las series::
* Funciones y variables para las series::
* Introducción a las series de Fourier
* Funciones y variables para series de Fourier::
* Funciones y variables para series de Poisson::

Teoría de Números

* Funciones y variables para teoría de números::

Simetrías

* Funciones y variables para simetrías::

Grupos

* Funciones y variables para grupos::

Entorno de Ejecución

* Introducción al entorno de ejecución::
* Interrupciones::
* Funciones y variables para el entorno de ejecución::

Miscelánea de opciones

* Introducción a la miscelánea de opciones::
* Share::
* Funciones y variables para la miscelánea de opciones::

Reglas y patrones

* Introducción a reglas y patrones::
* Funciones y variables sobre reglas y patrones::

Conjuntos

* Introducción a los conjuntos::
* Funciones y variables para los conjuntos::

Definición de Funciones

* Introducción a la definición de funciones::
* Funciones::
* Macros::
* Funciones y variables para la definición de funciones::

Programación

* Lisp y Maxima::
* Recolector de basura::
* Introducción a la programación::
* Funciones y variables para la programación::

Depurado

* Depuración del código fuente::
* Claves de depuración::
* Funciones y variables para depurado::

augmented_lagrangian

* Funciones y variables para augmented_lagrangian::

Bernstein

* Funciones y variables para Bernstein::

bode

* Funciones y variables para bode::

cobyla

* Introducción a cobyla::
* Funciones y variables para cobyla::
* Ejemplos para cobyla::

contrib_ode

* Introducción a contrib_ode::
* Funciones y variables para contrib_ode::
* Posibles mejoras a contrib_ode::
* Pruebas realizadas con contrib_ode::
* Referencias para contrib_ode::

descriptive

* Introducción a descriptive::
* Funciones y variables para el tratamiento de datos::
* Funciones y variables de parámetros descriptivos::
* Funciones y variables para gráficos estadísticos::

diag

* Funciones y variables para diag::

distrib

* Introducción a distrib::
* Funciones y variables para distribuciones continuas::
* Funciones y variables para distribuciones discretas::

draw

* Introducción a draw::
* Funciones y variables para draw::
* Funciones y variables para picture::
* Funciones y variables para worldmap::

drawdf

* Introducción a drawdf::
* Funciones y variables para drawdf::

dynamics

* El paquete dynamics::
* Análisis gráfico de sistemas dinámicos discretos::
* Visualización usando VTK::

ezunits

* Introducción a ezunits::
* Introducción a physical_constants::
* Funciones y variables para ezunits::

f90

* Funciones y variables para f90::

finance

* Introducción a finance::
* Funciones y Variables para finance::

* fractals

* Introducción a fractals::
* Definiciones para IFS fractals::
* Definiciones para fractales complejos::
* Definiciones para cops de Koch::
* Definiciones para curvas de Peano::

ggf

* Funciones y variables para ggf::

graphs

* Introducción a graphs::
* Funciones y variables para graphs::

grobner

* Introducción a grobner::
* Funciones y variables para grobner::

impdiff

* Funciones y variables para impdiff::

interpol

* Introducción a interpol::
* Funciones y variables para interpol::

lapack

* Introducción a lapack::
* Funciones y variables para lapack::

lbfgs

* Introducción a lbfgs::
* Funciones y variables para lbfgs::

lindstedt

* Funciones y variables para lindstedt::

linearalgebra

* Introducción a linearalgebra::
* Funciones y variables para linearalgebra::

lsquares

* Funciones y variables para lsquares::

makeOrders

* Funciones y variables para makeOrders::

minpack

* Introducción a minpack::
* Funciones y variables para minpack::

mnewton

* Funciones y variables para mnewton::

numericalio

* Introducción a numericalio::
* Funciones y variables para entrada y salida en formato texto::
* Funciones y variables para entrada y salida en formato binario::

opsubst

* Funciones y variables para opsubst::

orthopoly

* Introducción a polinomios ortogonales::
* Funciones y variables para polinomios ortogonales::

romberg

* Funciones y variables para romberg::

simplex

* Introducción a simplex::
* Funciones y variables para simplex::

simplification

* Introducción a simplification::
* Paquete absimp::
* Paquete facexp::
* Paquete functs::
* Paquete ineq::
* Paquete rducon::
* Paquete scifac::
* Paquete sqdnst::

solve_rec

* Introducción a solve_rec::
* Funciones y variables para solve_rec::

stats

* Introducción a stats::
* Funciones y variables para inference_result::
* Funciones y variables para stats::
* Funciones y variables para distribuciones especiales::

stirling

* Funciones y variables para stirling::

stringproc

* Introducción al procesamiento de cadenas::
* Funciones y variables para entrada y salida::
* Funciones y variables para caracteres::
* Funciones y variables para cadenas::

to_poly_solve

* Funciones y variables para to_poly_solve::

unit

* Introducción a units::
* Funciones y variables para units::

zeilberger

* Introducción a zeilberger::
* Funciones y variables para zeilberger::


File: maxima.info,  Node: Introducción a Maxima,  Next: Detección e informe de fallos,  Prev: Top,  Up: Top

1 Introducción a Maxima
***********************

Se puede iniciar Maxima con el comando "maxima". Maxima desplegará
alguna información importante acerca de la versión que se está usando y
un prompt. Cada comando que vaya a ser ejecutado por Maxima debe
terminar con un punto y coma. Para finalizar una sesión en Maxima se
emplea el comando "quit();". A continuación se presenta un breve
ejemplo de sesión:

     [wfs@chromium]$ maxima
     Maxima 5.9.1 http://maxima.sourceforge.net
     Using Lisp CMU Common Lisp 19a
     Distributed under the GNU Public License. See the file COPYING.
     Dedicated to the memory of William Schelter.
     This is a development version of Maxima. The function bug_report()
     provides bug reporting information.
     (%i1) factor(10!);
                                 8  4  2
     (%o1)                      2  3  5  7
     (%i2) expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o2) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i3) factor (x^6 - 1);
                                   2            2
     (%o3)       (x - 1) (x + 1) (x  - x + 1) (x  + x + 1)
     (%i4) quit();
     [wfs@chromium]$

Maxima puede hacer consultas en la documentación. La instrucción
`describe' mostrará información sobre una función o la lista de todas
las funciones y variables que contengan el texto pasado a `describe'.
La interrogación `?' (búsqueda exacta) y la doble interrogación `??'
(búsqueda aproximada) son abreviaturas de la instrucción `describe':

     (%i1) ?? integ
      0: Functions and Variables for Elliptic Integrals
      1: Functions and Variables for Integration
      2: Introduction to Elliptic Functions and Integrals
      3: Introduction to Integration
      4: askinteger  (Functions and Variables for Simplification)
      5: integerp  (Functions and Variables for Miscellaneous Options)
      6: integer_partitions  (Functions and Variables for Sets)
      7: integrate  (Functions and Variables for Integration)
      8: integrate_use_rootsof  (Functions and Variables for Integration)
      9: integration_constant_counter  (Functions and Variables for
         Integration)
      10: nonnegintegerp  (Functions and Variables for linearalgebra)
     Enter space-separated numbers, `all' or `none': 5 4

      -- Function: integerp (<expr>)
          Returns `true' if <expr> is a literal numeric integer, otherwise
          `false'.

          `integerp' returns false if its argument is a symbol, even if the
          argument is declared integer.

          Examples:

               (%i1) integerp (0);
               (%o1)                         true
               (%i2) integerp (1);
               (%o2)                         true
               (%i3) integerp (-17);
               (%o3)                         true
               (%i4) integerp (0.0);
               (%o4)                         false
               (%i5) integerp (1.0);
               (%o5)                         false
               (%i6) integerp (%pi);
               (%o6)                         false
               (%i7) integerp (n);
               (%o7)                         false
               (%i8) declare (n, integer);
               (%o8)                         done
               (%i9) integerp (n);
               (%o9)                         false

      -- Function: askinteger (<expr>, integer)
      -- Function: askinteger (<expr>)
      -- Function: askinteger (<expr>, even)
      -- Function: askinteger (<expr>, odd)
          `askinteger (<expr>, integer)' attempts to determine from the
          `assume' database whether <expr> is an integer.  `askinteger'
          prompts the user if it cannot tell otherwise, and attempt to
          install the information in the database if possible.  `askinteger
          (<expr>)' is equivalent to `askinteger (<expr>, integer)'.

          `askinteger (<expr>, even)' and `askinteger (<expr>, odd)'
          likewise attempt to determine if <expr> is an even integer or odd
          integer, respectively.

     (%o1)                                true

Para usar posteriormente un resultado, se puede asignar dicho resultado
a una variable o referirse a él por medio de la etiqueta asociada
(`%i*' o `%o*').  Además, se puede utilizar `%' para referirse al
último resultado obtenido.

     (%i1) u: expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o1) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i2) diff (u, x);
              5         4       2  3       3  2       4        5
     (%o2) 6 y  + 30 x y  + 60 x  y  + 60 x  y  + 30 x  y + 6 x
     (%i3) factor (%o2);
                                         5
     (%o3)                      6 (y + x)

Maxima manipula sin ningún problema números complejos y constantes
numéricas:

     (%i1) cos(%pi);
     (%o1)                          - 1
     (%i2) exp(%i*%pi);
     (%o2)                          - 1

Maxima puede hacer derivadas  e integrales:

     (%i1) u: expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o1) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i2) diff (%, x);
              5         4       2  3       3  2       4        5
     (%o2) 6 y  + 30 x y  + 60 x  y  + 60 x  y  + 30 x  y + 6 x
     (%i3) integrate (1/(1 + x^3), x);
                                       2 x - 1
                     2            atan(-------)
                log(x  - x + 1)        sqrt(3)    log(x + 1)
     (%o3)    - --------------- + ------------- + ----------
                       6             sqrt(3)          3

Maxima puede resolver sistemas de ecuaciones lineales y cúbicas:

     (%i1) linsolve ([3*x + 4*y = 7, 2*x + a*y = 13], [x, y]);
                             7 a - 52        25
     (%o1)              [x = --------, y = -------]
                             3 a - 8       3 a - 8
     (%i2) solve (x^3 - 3*x^2 + 5*x = 15, x);
     (%o2)       [x = - sqrt(5) %i, x = sqrt(5) %i, x = 3]

Maxima puede resolver sistemas de ecuaciones no lineales. Tenga en
cuenta que si usted no desea que el resultado sea impreso, puede
finalizar el comando con `$' en vez de `;'.

     (%i1) eq_1: x^2 + 3*x*y + y^2 = 0$
     (%i2) eq_2: 3*x + y = 1$
     (%i3) solve ([eq_1, eq_2]);
                   3 sqrt(5) + 7      sqrt(5) + 3
     (%o3) [[y = - -------------, x = -----------],
                         2                 2

                                    3 sqrt(5) - 7        sqrt(5) - 3
                               [y = -------------, x = - -----------]]
                                          2                   2

Maxima puede generar gráficos de una o más funciones:

     (%i1) plot2d (sin(x)/x, [x, -20, 20])$

     (%i2) plot2d ([atan(x), erf(x), tanh(x)], [x, -5, 5], [y, -1.5, 2])$

     (%i3) plot3d (sin(sqrt(x^2 + y^2))/sqrt(x^2 + y^2),
              [x, -12, 12], [y, -12, 12])$


File: maxima.info,  Node: Detección e informe de fallos,  Next: Ayuda,  Prev: Introducción a Maxima,  Up: Top

2 Detección e informe de fallos
*******************************

* Menu:

* Funciones y variables para la detección e informe de fallos::


File: maxima.info,  Node: Funciones y variables para la detección e informe de fallos,  Prev: Detección e informe de fallos,  Up: Detección e informe de fallos

2.1 Funciones y variables para la detección e informe de fallos
===============================================================

 -- Función: run_testsuite ([<options>])
     Ejecuta el conjunto de pruebas de Maxima. Los tests que producen
     las respuestas deseadas son considerados como "pruebas superadas",
     como los tests que no producen las respuestas deseadas, son
     marcados como fallos conocidos.

     `run_testsuite' admite las siguientes opciones:

    `display_all'
          Muestra todas las pruebas. Normalmente no se muestran las
          pruebas, a menos que produzcan fallos. (Su valor por defecto
          es `false').

    `display_known_bugs'
          Muestra las pruebas marcadas como fallos ya conocidos. (Su
          valor por defecto es `false').

    `tests'
          Esta es la lista de las pruebas que se deben ejecutar. Cada
          prueba se puede especificar, tanto mediante una cadena de
          texto como por un símbolo. Por defecto, todas las pruebas se
          ejecutan. El conjunto completo de pruebas está especificado
          en `testsuite_files'.

    `time'
          Muestra información sobre tiempos de ejecución. Si vale
          `true', se muestran los tiempos de los ficheros de prueba. Si
          vale `all', se muestran los tiempos de cada prueba individual
          si `display_all' vale `true'. El valor por defecto es
          `false', por lo que no se muestra información temporal alguna.

     Por ejemplo, `run_testsuite(display_known_bugs = true,
     tests=[rtest5])' ejecuta la prueba `rtest5' y muestra si está
     marcada como fallo conocido.

     `run_testsuite(display_all = true, tests=["rtest1", rtest1a])'
     ejecutará las pruebas `rtest1' y `rtest2', mostrando cada una de
     ellas.

     `run_testsuite' cambia el entorno de Maxima.  Típicamente un
     script de test ejecuta `kill' para establecer un entorno conocido
     (llámese uno sin funciones ni variables definidas por el usuario)
     y entonces define una serie de funciones y variables apropiadas
     para el test.

     `run_testsuite' retorna `done'.

 -- Variable opcional: testsuite_files
     `testsuite_files' es el conjunto de tests a ejecutar por
     `run_testsuite'. Se trata de una lista con los nombres de los
     ficheros que contienen los tests a ejecutar. Si se sabe que alguno
     de los tests de un fichero falla, entonces en lugar de listar el
     nombre del fichero, se utiliza una lista que contiene el nombre
     del fichero y los números de los tests que fallan.

     Por ejemplo, esta es una parte de los tests por defecto:

           ["rtest13s", ["rtest14", 57, 63]]

     Con esto se especifica que el conjunto de tests está formado por
     los ficheros "rtest13s"  y "rtest14", pero que "rtest14" contiene
     dos tests que se sabe que causan fallos, el 57 y el 63.

 -- Función: bug_report ()
     Imprime las versiones de Maxima y de Lisp y proporciona un enlace
     a la página web sobre informe de fallos del proyecto Maxima.  La
     información respecto a las versiones es la misma que reporta la
     función `build_info'.

     Cuando se informa sobre un fallo, es de gran ayuda que se copie la
     información relacionada con la versión de Maxima y de Lisp usada,
     dentro del propio informe.

     `bug_report' retorna una cadena vacía `""'.

 -- Función: build_info ()
     Devuelve un resumen de los parÃ¡metros con los que se ha compilado
     Maxima en formato de estructura `defstruct'. Los campos de la
     estructura son: `version', `timestamp', `host', `lisp_name' y
     `lisp_version'.  Cuando `display2d' toma el valor `true', la
     estructura se muestra como una pequeña tabla.

     Véase también `bug_report'.

     Ejemplos:

          (%i1) build_info ();
          (%o1)
          Maxima version: "5.26.0_16_gb72c64c_dirty"
          Maxima build date: "2012-01-29 12:29:04"
          Host type: "i686-pc-linux-gnu"
          Lisp implementation type: "CMU Common Lisp"
          Lisp implementation version: "CVS release-19a 19a-release-20040728 + minimal debian patches"
          (%i2) x : build_info ()$
          (%i3) x@version;
          (%o3)               5.26.0_16_gb72c64c_dirty
          (%i4) x@timestamp;
          (%o4)                  2012-01-29 12:29:04
          (%i5) x@host;
          (%o5)                   i686-pc-linux-gnu
          (%i6) x@lisp_name;
          (%o6)                    CMU Common Lisp
          (%i7) x@lisp_version;
          (%o7)
              CVS release-19a 19a-release-20040728 + minimal debian patches
          (%i8) x;
          (%o8)
          Maxima version: "5.26.0_16_gb72c64c_dirty"
          Maxima build date: "2012-01-29 12:29:04"
          Host type: "i686-pc-linux-gnu"
          Lisp implementation type: "CMU Common Lisp"
          Lisp implementation version: "CVS release-19a 19a-release-20040728 + minimal debian patches"


File: maxima.info,  Node: Ayuda,  Next: Línea de comandos,  Prev: Detección e informe de fallos,  Up: Top

3 Ayuda
*******

* Menu:

* Documentación::
* Funciones y variables para la ayuda::


File: maxima.info,  Node: Documentación,  Next: Funciones y variables para la ayuda,  Prev: Ayuda,  Up: Ayuda

3.1 Documentación
=================

El manual en línea del usuario de Maxima puede ser visto en diferentes
formas.  Desde el prompt interactivo de Maxima, el manual de usuario es
visto como texto plano por medio del comando  `?' (i.e., la función
`describe').  El manual de usuario también puede ser visto como
hipertexto tipo `info' por medio del programa `info' y como una página
web a través de cualquier navegador.

El comando `example' muestra ejemplos para muchas funciones Maxima.
Por ejemplo:

     (%i1) example (integrate);

produce:

     (%i2) test(f):=block([u],u:integrate(f,x),ratsimp(f-diff(u,x)))
     (%o2) test(f) := block([u], u : integrate(f, x),

                                              ratsimp(f - diff(u, x)))
     (%i3) test(sin(x))
     (%o3)                           0
     (%i4) test(1/(x+1))
     (%o4)                           0
     (%i5) test(1/(x^2+1))
     (%o5)                           0

y salidas adicionales.


File: maxima.info,  Node: Funciones y variables para la ayuda,  Prev: Documentación,  Up: Ayuda

3.2 Funciones y variables para la ayuda
=======================================

 -- Función: apropos (<string>)
     Busca los símbolos de Maxima en los cuales aparezca <cadena> en
     cualquier lugar dentro de su nombre. Así, `apropos (exp)' devuelve
     una lista con todas las variables y funciones que tengan  `exp'
     formando parte de sus nombres, como  `expand', `exp' y
     `exponentialize'.  De esta forma, si el usuario tan solo recuerda
     parte del nombre de algo, puede utilizar este comando para
     encontrar el resto del nombre.  De manera semejante, también se
     puede hacer `apropos (tr_)' para encontrar una lista de muchas de
     las variables relacionadas con el traductor, buena parte de las
     cuales comienzan con `tr_'.

     `apropos("")' devuelve una lista con todos los nombres de Maxima.

     En caso de no encontrar información relevante, `apropos' devuelve
     la lista vacía `[]'.

     Ejemplo:

     Devuelve todos los símbolos de Maxima que contienen la subcadena
     `"gamma"' en su nombre:

          (%i1) apropos("gamma");
          (%o1) [%gamma, gamma, gammalim, gamma_expand, gamma_greek,
          gamma_incomplete, gamma_incomplete_generalized,
          gamma_incomplete_regularized, Gamma, log_gamma, makegamma,
          prefer_gamma_incomplete,
          gamma_incomplete_generalized_regularized]


 -- Función: demo (<archivo>)
     Evalua las expresiones Maxima contenidas en <archivo> y muestra
     los resultados.  `demo' hace pausas después de evaluar  cada
     expresión y continua después de que el usuario ingrese un retorno
     de carro.  (Si se ejecuta en Xmaxima, `demo' puede que necesite un
     punto y coma `;' a continuación del retorno de carro.)

     `demo' busca la lista de directorios `file_search_demo' para
     encontrar `archivo'.  Si el archivo tiene el sufijo `dem', el
     sufijo puede ser omitido.  Ver también `file_search'.

     `demo' evalua su argumento.  `demo' retorna el nombre del archivo
     demostración.

     Ejemplo:

          (%i1) demo ("disol");

          batching /home/wfs/maxima/share/simplification/disol.dem
           At the _ prompt, type ';' followed by enter to get next demo
          (%i2)                      load(disol)

          _
          (%i3)           exp1 : a (e (g + f) + b (d + c))
          (%o3)               a (e (g + f) + b (d + c))

          _
          (%i4)                disolate(exp1, a, b, e)
          (%t4)                         d + c

          (%t5)                         g + f

          (%o5)                   a (%t5 e + %t4 b)

          _
          (%i5) demo ("rncomb");

          batching /home/wfs/maxima/share/simplification/rncomb.dem
           At the _ prompt, type ';' followed by enter to get next demo
          (%i6)                     load(rncomb)

          _
                                       z         x
          (%i7)               exp1 : ----- + ---------
                                     y + x   2 (y + x)
                                    z         x
          (%o7)                   ----- + ---------
                                  y + x   2 (y + x)

          _
          (%i8)                     combine(exp1)
                                    z         x
          (%o8)                   ----- + ---------
                                  y + x   2 (y + x)

          _
          (%i9)                     rncombine(%)
                                       2 z + x
          (%o9)                       ---------
                                      2 (y + x)

          _
                                       d   c   b   a
          (%i10)                exp2 : - + - + - + -
                                       3   3   2   2
                                    d   c   b   a
          (%o10)                    - + - + - + -
                                    3   3   2   2

          _
          (%i11)                    combine(exp2)
                                2 d + 2 c + 3 (b + a)
          (%o11)                ---------------------
                                          6

          _
          (%i12)                   rncombine(exp2)
                                2 d + 2 c + 3 b + 3 a
          (%o12)                ---------------------
                                          6

          _
          (%i13)

 -- Función: describe (<string>)
 -- Función: describe (<string>, exact)
 -- Función: describe (<string>, inexact)
     La sentencia `describe(<string>)' equivale a `describe(<string>,
     exact)'.

     La sentencia `describe(<string>, exact)' encuentra el elemento, si
     existe, cuyo título coincide exactamente con <string> (ignorando
     la diferencia entre mayúsculas y minúsculas).

     La sentencia `describe(<string>, inexact)' encuentra todos los
     elementos documentados que contengan <string> en sus títulos.

     Si hay más de una opción, Maxima preguntará al usuario para que
     seleccione las opciones que desee consultar.

     La sentencia `? foo' (con espacio entre `?' y `foo') equivale a
     `describe("foo", exact)', mientras que `?? foo' equivale a
     `describe("foo", inexact)'.

     `describe ("", inexact)' produce una lista de todos los temas
     documentados en el manual en línea.

     `describe' no evalúa su argumento. La función `describe' devuelve
     `true' si encuentra la documentación solicitada y `false' en caso
     contrario.

     Véase también `Documentación'.

     Ejemplo:

          (%i1) ?? integ
           0: Functions and Variables for Elliptic Integrals
           1: Functions and Variables for Integration
           2: Introduction to Elliptic Functions and Integrals
           3: Introduction to Integration
           4: askinteger  (Functions and Variables for Simplification)
           5: integerp  (Functions and Variables for Miscellaneous Options)
           6: integer_partitions  (Functions and Variables for Sets)
           7: integrate  (Functions and Variables for Integration)
           8: integrate_use_rootsof  (Functions and Variables for
              Integration)
           9: integration_constant_counter  (Functions and Variables for
              Integration)
           10: nonnegintegerp  (Functions and Variables for linearalgebra)
          Enter space-separated numbers, `all' or `none': 7 8

           -- Function: integrate (<expr>, <x>)
           -- Function: integrate (<expr>, <x>, <a>, <b>)
               Attempts to symbolically compute the integral of <expr> with
               respect to <x>.  `integrate (<expr>, <x>)' is an indefinite
               integral, while `integrate (<expr>, <x>, <a>, <b>)' is a
               definite integral, [...]

           -- Option variable: integrate_use_rootsof
               Default value: `false'

               When `integrate_use_rootsof' is `true' and the denominator of
               a rational function cannot be factored, `integrate' returns
               the integral in a form which is a sum over the roots (not yet
               known) of the denominator.
               [...]

     En este ejemplo fueron seleccionadas las opciones 7 y 8 (la salida
     ha sido recortada, tal como indica `[...]').  Todas o ninguna de
     las opciones pueden ser seleccionadas escribiendo `all' o `none',
     las cuales pueden ser abreviadas por `a' o `n', respectivamente.


 -- Función: example (<topic>)
 -- Función: example ()
     `example (<topic>)' muestra algunos ejemplos sobre <topic>, el
     cual debe ser un símbolo o cadena de texto. Para ver ejemplos
     sobre operadores como `if', `do' o `lambda' el argumento debe ser
     necesariamente una cadena de texto, como `example ("do")'. La
     función `example' no distingue entre minúsculas y mayúsculas. La
     mayor parte de ejemplos versan sobre funciones.

     La sentencia `example ()' devuelve la lista de todos los ejemplos
     existentes.

     El nombre del fichero que contine los ejemplos existentes se
     guarda en la variable global `manual_demo', cuyo valor por defecto
     es `"manual.demo"'.

     La función `example' no evalúa su argumento.

     Ejemplos:

          (%i1) example(append);
          (%i2) append([x+y,0,-3.2],[2.5E+20,x])
          (%o2)                    [y + x, 0, - 3.2, 2.5E+20, x]
          (%o2)                                done
          (%i3) example("lambda");
          (%i4) lambda([x,y,z],z^2+y^2+x^2)
                                                     2    2    2
          (%o4)                   lambda([x, y, z], z  + y  + x )
          (%i5) %(1,2,a)
                                               2
          (%o5)                               a  + 5
          (%i6) a+2+1
          (%o6)                                a + 3
          (%o6)                                done
          (%i7) example("allROOTS");
          (%i8) (1+2*x)^3 = 13.5*(1+x^5)
                                             3          5
          (%o8)                     (2 x + 1)  = 13.5 (x  + 1)
          (%i9) allroots(%)
          (%o9) [x = .8296749902129361, x = - 1.015755543828121,
          x = .9659625152196369 %i - .4069597231924075,
          x = - .9659625152196369 %i - .4069597231924075, x = 1.0]
          (%o9)                                done


 -- Variable opcional: manual_demo
     Valor por defecto: `"manual.demo"'

     `manual_demo' especifica el nombre del fichero que contiene los
     ejemplo para la función `example'.

     Véase `example'.



File: maxima.info,  Node: Línea de comandos,  Next: Tipos de datos y estructuras,  Prev: Ayuda,  Up: Top

4 Línea de comandos
*******************

* Menu:

* Introducción a la línea de comandos::
* Funciones y variables para la línea de comandos::
* Funciones y variables para la impresión::


File: maxima.info,  Node: Introducción a la línea de comandos,  Next: Funciones y variables para la línea de comandos,  Prev: Línea de comandos,  Up: Línea de comandos

4.1 Introducción a la línea de comandos
=======================================

Consola
-------

Existen distintos interfaces para Maxima, tales como wxMaxima, Xmaxima,
Imaxima y la consola o terminal de texto.

La consola trabaja en modo texto, al tiempo que para introducir
instrucciones con ayuda de un menú y obtener resultados en modo gráfico
es necesario instalar otros interfaces.

A lo largo de este manual se utilizará la consola, la cual está
disponible en cualquiera de los sistemas operativos en los que trabaja
Maxima. El usuario puede introducir todas las funciones de Maxima desde
la consola; en el modo texto, los resultados se devolverán normalmente
en un formato ASCII bidimensional, mientras que los gráficos necesitan
de un programa adicional tal como Gnuplot.

Entrada, Evaluación, Simplificación y Salida
--------------------------------------------

Desde que el usuario introduce una solicitud de cálculo hasta que
obtiene el resultado en la consola, se desarrolla un proceso que consta
de cuatro fases:

  1. Bien sea desde un teclado o desde un fichero se lee una expresión
     que el analizador sintáctico se encargará de transformar en una
     cierta representación interna. En esta primera fase, se utilizan
     principalmente operadores tales como "+", "/" o "do".

  2. La expresión leída por el analizador sintáctico es evaluada
     durante la segunda fase. Las variables se substituyen por sus
     valores y se ejecutan funciones tales como la derivación o la
     integración. El resultado de esta fase es una expresión evaluada.

  3. La expresión evaluada de la fase anterior se simplifica en esta
     tercera fase, en la que una expresión tal como `a+a' se reduce a
     `2*a', o `sin(%pi/2)' se simplifica a `1'.

  4. Tras la tercera fase se dispone de una expresión que ha sido
     evaluada y posteriormente simplificada. Ya en la cuarta y última
     fase, se prepara el resultado para ser mostrado a través de la
     consola.

El usuario puede tomar el control en cualquiera de las cuatro fases
recién descritas. En diferentes capítulos de este manual se detallan
estas posibilidades, pero en éste se describen aquellas instrucciones
relacionadas con las fases primera y cuarta, relacionadas con la
entrada y salida a través de la consola.  Los capítulos sobre
Evaluación y Simplificación tratan de las otras dos fases intermedias.

Marcas
------

Maxima almacena todas las entradas con la marca `%i' seguida de un
número entero en orden creciente, así como las salidas o resultados con
la marca `%o' también seguida de un número de orden. Además, ciertas
funciones utilizan la marca intermedia `%t'. Otras variables del
sistema almacenan el último resultado devuelto por Maxima o la última
entrada efectuada por el usuario. Los siguientes símbolos indican
variables y funciones para la gestión de las marcas:

   __          _
   %           %%           %th
   inchar      linechar     outchar
   linenum     nolabels

Listas informativas
-------------------

Maxima gestiona listas informativas, cuyos nombres se guardan en la
variable del sistema `infolists'. En el presente capítulo se describen
las listas `labels', `values' y `myoptions'.  Los siguientes símbolos
indican variables y funciones relacionadas con las listas informativas
y variables opcionales.

   infolists     labels        values
   myoptions     optionset

Otras listas informativas, que se describirán en otros capítulos, son:

   functions      arrays         macros
   rules          aliases        dependencies
   gradefs        props          let_rule_packages
   structures     namespaces

Borrado y reiniciación
----------------------

A fin de establecer el contexto en el que trabaje Maxima, en el que no
haya variables o funciones definidas, o en el que se eliminen
hipótesis, propiedades o definiciones concretas, se dispone de las
siguientes funciones:

   kill     reset     reset_verbosely

Otras instrucciones
-------------------

Se puede acceder a la documentación con los símbolos `?' y `??'. En
caso de que se utilice `?' a modo de prefijo de un símbolo, éste se
interpretará como símbolo de Lisp. Hay instrucciones para terminar una
sesión de Maxima o para cambiar a una sesión de Lisp. También es
posible conocer el tiempo que ha necesitado Maxima para realizar un
cálculo. Para este tipo de cuestiones, Maxima dispone de las siguientes
instrucciones:

   ?            ??
   playback     prompt     showtime
   quit         to_lisp

Las funciones `read' und `readonly' imprimen texto en la consola y leen
la información introducida por el usuario.

Salida por consola
------------------

Antes de mostrar un resultado, se transforma su representación interna
a otra externa. Por ejemplo, la representación interna de `sqrt(x)' es
`x^(1/2)', y ambos formatos pueden ser devueltos por Maxima en función
del valor que guarde la variable opcional `sqrtdispflag'.

Los siguientes símbolos y variables opcionales controlan la salida de
resultados por consola:

   %edispflag         absboxchar       display2d
   display_format_internal             exptdispflag
   expt               nexpt            ibase
   linel              lispdisp         negsumdispflag
   obase              pfeformat        powerdisp
   sqrtdispflag       stardisp         ttyoff

Con las siguientes funciones es posible formatear los resultados:

   disp               display          dispterms
   grind              ldisp            ldisplay
   print


File: maxima.info,  Node: Funciones y variables para la línea de comandos,  Next: Funciones y variables para la impresión,  Prev: Introducción a la línea de comandos,  Up: Línea de comandos

4.2 Funciones y variables para la línea de comandos
===================================================

 -- Variable del sistema: __
     `__' es la expresión de entrada que está siendo actualmente
     evaluada.  Esto es, mientras se está evaluando una expresión de
     entrada, `__' es igual a <expr>.

     A `__' se le asigna la expresión de entrada antes de que ésta sea
     simplificada o evaluada. Sin embargo, el valor de `__' es
     simplificado, pero no evaluado, cuando su valor es mostrado en el
     terminal.

     La variable `__' es reconocida por  `batch' y por `load'.  Cuando
     un fichero es procesado por `batch', la variable `__' tiene el
     mismo significado que en el modo interactivo.  Cuando un fichero
     es procesado por `load', a la variable `__' se le asigna la última
     expresión introducida, bien desde el modo interactivo, bien en un
     fichero por lotes; en ningún caso se le asigna a `__' una
     expresión de entrada del fichero que está siendo procesado.  En
     particular, si `load (<filename>)' es ejecutado desde el modo
     interactivo, entonces `__' almacena la expresión `load
     (<filename>)' mientras el fichero está siendo procesado.

     Véanse también `_' y `%'.

     Ejemplos:

          (%i1) print ("I was called as", __);
          I was called as print(I was called as, __)
          (%o1)              print(I was called as, __)
          (%i2) foo (__);
          (%o2)                     foo(foo(__))
          (%i3) g (x) := (print ("Current input expression =", __), 0);
          (%o3) g(x) := (print("Current input expression =", __), 0)
          (%i4) [aa : 1, bb : 2, cc : 3];
          (%o4)                       [1, 2, 3]
          (%i5) (aa + bb + cc)/(dd + ee + g(x));
                                      cc + bb + aa
          Current input expression = --------------
                                     g(x) + ee + dd
                                          6
          (%o5)                        -------
                                       ee + dd


 -- Variable del sistema: _
     El símbolo `_' representa la última expresión de entrada (esto es,
     `%i1', `%i2', `%i3', ...).

     Al símbolo `_' se le asigna la expresión de entrada antes de que
     ésta sea simplificada o evaluada. Sin embargo, el valor de `_' se
     simplifica (pero no se evalúa) cuando se muestra en el terminal.

     La variable `_' es reconocida por  `batch' y por `load'.  Cuando
     un fichero es procesado por `batch', la variable `_' tiene el
     mismo significado que en el modo interactivo.  Cuando un fichero
     es procesado por `load', a la variable `_' se le asigna la última
     expresión introducida, bien desde el modo interactivo, bien en un
     fichero por lotes; en ningún caso se le asigna a `_' una expresión
     de entrada del fichero que está siendo procesado.

     Véanse también `__' y `%'.

     Ejemplos:

          (%i1) 13 + 29;
          (%o1)                          42
          (%i2) :lisp $_
          ((MPLUS) 13 29)
          (%i2) _;
          (%o2)                          42
          (%i3) sin (%pi/2);
          (%o3)                           1
          (%i4) :lisp $_
          ((%SIN) ((MQUOTIENT) $%PI 2))
          (%i4) _;
          (%o4)                           1
          (%i5) a: 13$
          (%i6) b: 29$
          (%i7) a + b;
          (%o7)                          42
          (%i8) :lisp $_
          ((MPLUS) $A $B)
          (%i8) _;
          (%o8)                         b + a
          (%i9) a + b;
          (%o9)                          42
          (%i10) ev (_);
          (%o10)                         42


 -- Variable del sistema: %
     El símbolo `%' representa la expresión de salida (esto es, `%o1',
     `%o2', `%o3', ...)  más reciente calculada por Maxima,
     independientemente de que la haya mostrado o no.

     La variable `%' es reconocida por  `batch' y por `load'.  Cuando
     un fichero es procesado por `batch', la variable `%' tiene el
     mismo significado que en el modo interactivo.  Cuando un fichero
     es procesado por `load', a la variable `%' se le asigna la última
     expresión introducida, bien desde el modo interactivo, bien en un
     fichero por lotes; en ningún caso se le asigna a `%' una expresión
     de entrada del fichero que está siendo procesado.

     Véanse también `_', `%%' y `%th'.


 -- Variable del sistema: %%
     En una sentencia compuesta, como `block', `lambda' o `(<s_1>, ...,
     <s_n>)', `%%' es el valor de la sentencia previa.

     La variable `%%' no estÃ¡ definida cuando se utiliza en la primera
     sentencia, o fuera de una sentencia compuesta.

     `%%' se puede utilizar con `batch' y `load', manteniendo en ambos
     casos el mismo significado que en el modo interactivo.

     Véase también `%'

     Ejemplos:

     Los siguientes dos ejemplos devuelven el mismo resultado.

          (%i1) block (integrate (x^5, x), ev (%%, x=2) - ev (%%, x=1));
                                         21
          (%o1)                          --
                                         2
          (%i2) block ([prev], prev: integrate (x^5, x),
                         ev (prev, x=2) - ev (prev, x=1));
                                         21
          (%o2)                          --
                                         2

     Una sentencia compuesta puede contener otras sentencias compuestas.
     Independientemente de que una sentencia sea simple o compuesta,
     `%%' es el valor de la sentencia previa.

          (%i3) block (block (a^n, %%*42), %%/6);
                                           n
          (%o3)                         7 a

     Dentro de una sentencia compuesta, el valor de `%%' puede
     inspeccionarse en un punto de interrupción que se abra ejecutando
     la función `break'.  Por ejemplo, escribiendo `%%;' en el
     siguiente ejemplo se obtiene `42'.

          (%i4) block (a: 42, break ())$

          Entering a Maxima break point. Type 'exit;' to resume.
          _%%;
          42
          _

 -- Función: %th (<i>)
     Es el valor de la expresión de la <i>-ésima salida anterior.  Esto
     es, si la siguiente expresión a calcular es la salida <n>-ésima,
     `%th (<m>)' es la salida  (<n> - <m>)-ésima.

     `%th' es reconocido por `batch' y `load', interpretándose de la
     misma manera que se acaba de indicar. Cuando un fichero es
     procesado por `load', `%th' se refiere a los cálculos más
     recientes; `%th' no hace referencia a las expresiones de salida
     incluidas en el propio fichero que se está procesando.

     Véanse también `%' y `%%'

     Ejemplo:

     `%th' es útil en ficheros `batch' para hacer referencia a grupos
     de resultados recién obtenidos.  En este ejemplo se asigna a `s'
     la suma de los cinco resultados.

          (%i1) 1;2;3;4;5;
          (%o1)                           1
          (%o2)                           2
          (%o3)                           3
          (%o4)                           4
          (%o5)                           5
          (%i6) block (s: 0, for i:1 thru 5 do s: s + %th(i), s);
          (%o6)                          15

 -- Símbolo especial: ?
     Como prefijo de una función o nombre de variable, `?' significa
     que el nombre es de Lisp, no de Maxima.  Por ejemplo, `?round'
     representa la función de Lisp `ROUND'.  Véase `Lisp y Maxima' para
     más información.

     La notación `? word' (un símbolo de interrogación seguido de una
     palabra y separados por un espacio) equivale a `describe ("word")'.
     El símbolo de interrogación debe escribirse al comienzo de la
     línea de entrada; en caso contrario no se reconoce como una
     solicitud de documentación.


 -- Símbolo especial: ??
     La notación `?? palabra' (`??' seguido de un espacio y una
     palabra) equivale a `describe("palabra", inexact)'.  El símbolo de
     interrogación debe escribirse al comienzo de la línea de entrada;
     en caso contrario no se reconoce como una solicitud de
     documentación.


 -- Variable opcional: inchar
     Valor por defecto: `%i'

     La variable `inchar' es el prefijo de las etiquetas de las
     expresiones introducidas por el usuario. Maxima crea
     automáticamente una etiqueta para cada expresión de entrada
     concatenando `inchar' y `linenum'.

     A `inchar' se le puede asignar cualquier símbolo o cadena, no
     necesariamente un caracácter sencillo. Puesto que internamente
     Maxima solo tiene en cuenta el primer carácter del prefijo, los
     prefijos `inchar', `outchar' y `linechar' deben comenzar con
     caracteres diferentes; en caso contrario, sentencias como
     `kill(inlables)' pueden dar resultados inesperados.

     Véase también `labels'.

     Ejemplo:

          (%i1) inchar: "input";
          (%o1)                         input
          (input2) expand((a+b)^3);
                               3        2      2      3
          (%o2)               b  + 3 a b  + 3 a  b + a
          (input3)


 -- Variable del sistema: infolists
     Valor por defecto: `[]'

     La variable `infolists' es una lista con los nombres de todas las
     listas que guardan información sobre Maxima. Estas son:

    `labels'
          Todas las etiquetas `%i', `%o' y `%t' con valores asignados.

    `values'
          Todos los átomos que son variables de usuario, no opciones de
          Maxima creadas con  `:' o `::'.

    `functions'
          Todas las funciones de usuario creadas con `:=' o `define'.

    `arrays'
          Arreglos declarados y no declarados, creados por `:', `::' o
          `:='.

    `macros'
          Cualquier macro definida por el usuario.

    `myoptions'
          Todas las opciones inicializadas por el usuario,
          independientemente de que posteriormente hayan sido devueltas
          a sus valores por defecto.

    `rules'
          Reglas de patrones y simplificación definidas por el usuario,
          creadas con `tellsimp', `tellsimpafter', `defmatch' o
          `defrule'.

    `aliases'
          Átomos que tienen un "alias" definido por el usuario, creado
          por las funciones `alias', `ordergreat' o `orderless' o por
          haber declarado el átomo como `noun' (nombre) con `declare'.

    `dependencies'
          Átomos que tienen dependencias funcionales, creados por las
          funciones `depends' o `gradef'.

    `gradefs'
          Funciones que tienen derivadas definidas por el usuario,
          creadas por la función `gradef'.

    `props'
          Todos los átomos que tengan cualquier propiedad que no sea de
          las mencionadas hasta ahora, como las establecidas por
          `atvalue', `matchdeclare', etc., así como propiedadas
          especificadas en la función `declare'.

    `let_rule_packages'
          Todos los paquetes de reglas `let' definidos por el usuario,
          junto con el paquete especial `default_let_rule_package';
          `default_let_rule_package' es el nombre del paquete de reglas
          utilizado cuando no se use ningún otro especificado por el
          usuario.


 -- Función: kill (<a_1>, ..., <a_n>)
 -- Función: kill (labels)
 -- Función: kill (inlabels, outlabels, linelabels)
 -- Función: kill (<n>)
 -- Función: kill ([<m>, <n>])
 -- Función: kill (values, functions, arrays, ...)
 -- Función: kill (all)
 -- Función: kill (allbut (<a_1>, ..., <a_n>))
     Elimina todas las asignaciones (valor, función, arreglo o regla)
     hechas a los argumentos <a_1>, ..., <a_n>.  Un argumento <a_k>
     puede ser un símbolo o el elemento de un array. Si <a_k> es
     elemento de un array, `kill' elimina la asignación hecha a este
     elemento sin afectar al resto del array.

     Se reconocen varios argumentos especiales.  Se pueden combinar
     diferentes clases de argumentos, como por ejemplo, `kill
     (inlabels, functions, allbut (foo, bar))'.

     La instrucción `kill (labels)' borra todas las asignaciones
     asociadas a las etiquetas de entrada, de salida e intermedias
     creadas hasta el momento. La instrucción `kill (inlabels)' elimina
     únicamente las asignaciones de las etiquetas de entrada que
     comienzan con el valor actual de `inchar'. Del mismo modo, `kill
     (outlabels)' elimina únicamente las asignaciones de las etiquetas
     de salida que comienzan con el valor actual de `outchar'.
     Finalmente, `kill (linelabels)' elimina únicamente las asignaciones
     de las etiquetas de las expresiones intermedias que comienzan con
     el valor actual de `linechar'.

     La instrucción `kill (<n>)', siendo <n> un entero, elimina las
     asignaciones de las últimas <n> etiquetas, tanto de entrada como
     de salida.

     La instrucción `kill ([<m>, <n>])' elimina las asignaciones hechas
     a las etiquetas de entrada y salida desde la <m> hasta la<n>.

     La instrucción `kill (<infolist>)', siendo <infolist> cualquier
     elemento de `infolists' (como `values', `functions' o `arrays'),
     elimina todas las asignaciones hechas a los elementos de
     <infolist>. Véase también `infolists'.

     La instrucción `kill (all)' elimina todas las asignaciones de
     todas las variables, pero no reinicia las variables globales a sus
     valores por defecto. Véase también `reset'.

     La instrucción `kill (allbut (<a_1>, ..., <a_n>))' elimina las
     asignaciones hechas a todas las variables, excepto a <a_1>, ...,
     <a_n>; la instrucción `kill (allbut (<infolist>))' elimina todas
     las asignaciones, excepto las de los elementos de <infolist>,
     pudiendo ser <infolist> igual a `values', `functions', `arrays',
     etc.

     La memoria reservada para una asignación no se libera hasta que no
     se vacíen todos los símbolos asociados con esta asignación; por
     ejemplo, para liberar la memoria del valor de un símbolo es
     necesario eliminar tanto la asignación de la etiqueta de salida
     que muestra el resultado, como la del propio símbolo.

     La función `kill' no evalua sus argumentos.  El operador
     comilla-comilla, `''', obliga a que se realice la evaluación.

     La llamada `kill (<symbol>)' elimina todas las propiedades de
     <symbol>.  Por el contrario, `remvalue', `remfunction', `remarray'
     y `remrule' eliminan propiedades específicas.

     `kill' siempre devuelve `done', incluso cuando alguno de sus
     argumentos carecía de asignación previa.


 -- Función: labels (<symbol>)
 -- Variable del sistema: labels
     Retorna la lista de etiquetas de entrada, salida o de expresiones
     intermedias las cuales empiezan con <symbol>.  Típicamente
     <symbol> es el valor de las variables `inchar', `outchar' o
     `linechar'.  El caractér de etiqueta puede ser pasado con o sin
     signo de porcentaje, así, por ejemplo, `i' y `%i' producen el
     mismo resultado.

     Si ninguna etiqueta empieza con <symbol>, `labels' retorna a una
     lista vacía.

     La función `labels' no evalua su argumento.  El operador
     comilla-comilla, `''', obliga a que se realice la evaluación.  Por
     ejemplo, `labels (''inchar)' devuelve las etiquetas de entrada que
     empiezan con el caractér de etiqueta de entrada actual.

     La variable `labels' es una lista de las etiquetas de entrada,
     salida y expresiones intermedias, incluyendo todas las etiquetas
     anteriores en el caso de que `inchar', `outchar' o `linechar'
     hayan sido redefinidas.

     Por defecto, Maxima muestra el resultado de cada expresión
     introducida por el usuario, asignando al resultado una etiqueta de
     salida.  La salida (es decir el resultado) puede ser suprimida
     terminando la expresión de entrada con un `$' (signo de dólar) en
     vez de un `;' (punto y coma).  En este caso, se crea la etiqueta
     de salida y se le asigna el resultado, aunque éste no se muestre;
     aún así, la etiqueta puede ser referenciada de la misma forma que
     se hace con aquéllas cuyos resultados sí son mostrados.

     Véanse también: `%', `%%' y `%th'.

     Las etiquetas de expresiones intermedias pueden ser generadas por
     algunas funciones. El interruptor `programmode' controla si
     `solve' y algunas otras funciones generan etiquetas de expresiones
     intermedias en vez de retornar una lista de expresiones.  Algunas
     otras funciones, tales como `ldisplay', siempre generan etiquetas
     de expresiones intermedias.

     Véase también: `inchar', `outchar', `linechar' y `infolists'.


 -- Variable opcional: linechar
     Valor por defecto: `%t'

     La variable `linechar' es el prefijo de las etiquetas que genera
     Maxima para expresiones intermedias. Cuando sea necesario, Maxima
     creará una etiqueta para cada expresión intermedia concatenando
     `linechar' y `linenum'.

     A `linechar' se le puede asignar cualquier símbolo o cadena, no
     necesariamente un caracácter sencillo. Puesto que internamente
     Maxima solo tiene en cuenta el primer carácter del prefijo, los
     prefijos `inchar', `outchar' y `linechar' deben comenzar con
     caracteres diferentes; en caso contrario, sentencias como
     `kill(inlables)' pueden dar resultados inesperados.

     Las expresiones intermedias pueden ser mostradas o no.  Véanse
     también `programmode' y `labels'.


 -- Variable del sistema: linenum
     El número de la línea del par de expresiones de entrada y salida
     actuales.

 -- Variable del sistema: myoptions
     Valor por defecto: `[]'

     `myoptions' es la lista de todas las opciones que nunca fueron
     reconfiguradas por el usuario, aunque éstas hayan sido
     reconfiguradas a su valor por defecto.


 -- Variable opcional: nolabels
     Valor por defecto: `false'

     Cuando `nolabels' vale `true', las etiquetas de entrada y salida
     (`%i' y `%o', respectivamente) son mostradas, pero a éstas no se
     les asignan los resultados; además, las etiquetas no se incorporan
     a la lista `labels'.  Puesto que a las etiquetas no se les asignan
     resultados, el colector de basura puede recuperar la memoria
     ocupada por éstos.

     En el caso contrario, a las etiquetas de entrada y salida se les
     asignan los resultados correspondientes y son añadidas a la lista
     `labels'.

     Las etiquetas de expresiones intermedias (`%t') no se ven
     afectadas por la variable `nolabels'; independientemente de que
     `nolabels' valga `true' o `false', a las etiquetas de expresiones
     intermedias se les asignan siempre valores, además de ser añadidas
     a la lista `labels'.

     Véanse también `batch', `batchload' y `labels'.


 -- Variable opcional: optionset
     Valor por defecto: `false'

     Cuando `optionset' tiene como valor `true', Maxima imprime un
     mensaje cada vez que una opción de Maxima es reconfigurada. Esto es
     muy útil si el usuario duda con frecuencia de la correctitud de
     alguna opción y quiere estar seguro de la variable a la que él
     asignó un valor fue verdaramente una variable opción (o
     interruptor).

     Ejemplo:

          (%i1) optionset:true;
          assignment: assigning to option optionset
          (%o1)                         true
          (%i2) gamma_expand:true;
          assignment: assigning to option gamma_expand
          (%o2)                         true

 -- Variable opcional: outchar
     Valor por defecto: `%o'

     La variable `outchar' es el prefijo de las etiquetas de las
     expresiones calculadas por Maxima. Maxima crea automáticamente una
     etiqueta para cada expresión calculada concatenando `outchar' y
     `linenum'.

     A `outchar' se le puede asignar cualquier símbolo o cadena, no
     necesariamente un caracácter sencillo. Puesto que internamente
     Maxima solo tiene en cuenta el primer carácter del prefijo, los
     prefijos `inchar', `outchar' y `linechar' deben comenzar con
     caracteres diferentes; en caso contrario, sentencias como
     `kill(inlables)' pueden dar resultados inesperados.

     Véase también `labels'.

     Ejemplo:

          (%i1) outchar: "output";
          (output1)                    output
          (%i2) expand((a+b)^3);
                               3        2      2      3
          (output2)           b  + 3 a b  + 3 a  b + a
          (%i3)

 -- Función: playback ()
 -- Función: playback (<n>)
 -- Función: playback ([<m>, <n>])
 -- Función: playback ([<m>])
 -- Función: playback (input)
 -- Función: playback (slow)
 -- Función: playback (time)
 -- Función: playback (grind)
     Muestra las entradas, salidas y expresiones intermedias sin
     recalcularlas.  `playback' sólo muestra las expresiones asociadas
     con etiquetas; cualquier otra salida (tal como texto impreso por
     `print' o `describe', o mensajes de error) no es mostrada.  Véase
     también: `labels'.

     `playback' no evalua sus argumentos.  El operador comilla-comilla,
     `''', obliga a que se realice la evaluación.  `playback' siempre
     devuelve `done'.

     `playback ()' (sin argumentos) muestra todas las entradas, salidas
     y expresiones intermedias generadas hasta el momento.  Una
     expresión de salida es mostrada incluso si ésta fue suprimida por
     el caracter de terminación `$', cuando fue originalmente calculada.

     `playback (<n>)'  muestra las <n> expresiones más recientes. Cada
     entrada, salida y expresión intermedia cuenta como una.

     `playback ([<m>, <n>])' muestra entradas, salidas y expresiones
     intermedias con los números desde <m> hasta <n>, ambos inclusive.

     `playback ([<m>])' es equivalente a `playback ([<m>, <m>])'; esto
     usualmente imprime un par de expresiones de entrada y salida.

     `playback (input)' muestra todas las expresiones de entrada
     generadas hasta el momento.

     `playback (slow)' hace pausas entre expresiones y espera a que el
     usuario pulse la tecla `enter' para continuar.  Esto es un
     comportamiento similar a `demo'.

     `playback (slow)' es muy útil en conjunción con `save' o
     `stringout' cuando se crea un archivo secundario de almacenamiento
     con el objetivo de elegir cuidadosamente las expresiones realmente
     útiles.

     `playback (time)' muestra el tiempo de computo por cada expresión.

     `playback (grind)' muestra las expresiones de entrada en el mismo
     formato como la función `grind'.  Las expresiones de salida no se
     ven afectadas por la opción `grind'.  Vea `grind'.  Los argumentos
     pueden ser combinados, por ejemplo, `playback ([5, 10], grind,
     time, slow)'.


 -- Variable opcional: prompt
     Valor por defecto: `_'

     `prompt' es el símbolo del prompt de la función `demo', del modo
     `playback (slow)' y del bucle de interrupción de Maxima (el que se
     invoca con `break').


 -- Función: quit ()
     Termina una sesión de Maxima.  Nótese que la función debe ser
     invocada como `quit();' o `quit()$', no como `quit'.

     Para parar un cálculo muy demorado pulse `Control-C'.  La acción
     por defecto es retornar a prompt de Maxima.  Si `*debugger-hook*'
     tiene como valor `nil', pulsar `Control-C' abrirá el depurador de
     Lisp.  Vea también: `debugging'.


 -- Función: read (<expr_1>, ..., <expr_n>)
     Imprime <expr_1>, ..., <expr_n> y a continuación lee una expresión
     desde la consola y devuelve la expresión evaluada. La expresión
     termina con un punto y coma `;' o con el símbolo de dólar `$'.

     Véase también `readonly'.

          (%i1) foo: 42$
          (%i2) foo: read ("foo vale", foo, " -- nuevo valor.")$
          foo vale 42  -- nuevo valor.
          (a+b)^3;
          (%i3) foo;
                                               3
          (%o3)                         (b + a)


 -- Función: readonly (<expr_1>, ..., <expr_n>)
     Imprime <expr_1>, ..., <expr_n> y a continuación lee una expresión
     desde la consola y devuelve la expresión sin evaluar. La expresión
     termina con un punto y coma `;' o con el símbolo de dólar `$'.

          (%i1) aa: 7$
          (%i2) foo: readonly ("Introducir expresion:");
          Introducir expresion:
          2^aa;
                                            aa
          (%o2)                            2
          (%i3) foo: read ("Introducir expresion:");
          Introducir expresion:
          2^aa;
          (%o3)                            128

     Véase también `read'.


 -- Función: reset ()
     Reconfigura muchas variables y opciones globales y algunas otras
     variables a sus valores por defecto.

     `reset' procesa las variables que se encuentran en la lista Lisp
     `*variable-initial-values*'.  La macro Lisp `defmvar' pone las
     variables en ésta lista (entre otras acciones).  Muchas, pero no
     todas, las variables y opciones globales son definidas por
     `defmvar', y algunas variables definidas por `defmvar' no son ni
     variables ni opciones globales.


 -- Variable opcional: showtime
     Valor por defecto: `false'

     Cuando `showtime' tiene como valor `true', el tiempo de cálculo y
     el tiempo de retardo se imprimen junto con la salida de cada
     expresión.

     El tiempo de cálculo se almacena siempre, de manera que `time' y
     `playback' puedan mostrar el tiempo de cálculo incluso cuando
     `showtime' vale `false'.

     Véase también `timer'.


 -- Function: to_lisp ()
     Entra en el intérprete Lisp bajo Maxima. `(to-maxima)' retorna de
     nuevo a Maxima.

     Ejemplo:

     Define una función y entra en el nivel Lisp. La definición se
     consulta en la lista de propiedades, luego se extrae la definición
     de la función, se factoriza y almacena el resultado en la variable
     `$result'.  Esta variable se puede utilizar luego una vez se haya
     vuelto al nivel de Maxima.

          (%i1) f(x):=x^2+x;
                                                   2
          (%o1)                           f(x) := x  + x
          (%i2) to_lisp();
          Type (to-maxima) to restart, ($quit) to quit Maxima.

          MAXIMA> (symbol-plist '$f)
          (MPROPS (NIL MEXPR ((LAMBDA) ((MLIST) $X) ((MPLUS) ((MEXPT) $X 2) $X))))
          MAXIMA> (setq $result ($factor (caddr (mget '$f 'mexpr))))
          ((MTIMES SIMP FACTORED) $X ((MPLUS SIMP IRREDUCIBLE) 1 $X))
          MAXIMA> (to-maxima)
          Returning to Maxima
          (%o2)                                true
          (%i3) result;
          (%o3)                              x (x + 1)

 -- Variable del sistema: values
     Valor inicial: `[]'

     `values' es una lista de todas las variables que el usuario ha
     creado (no incluye las opciones de Maxima ni los interruptores).
     La lista comprende los símbolos a los que se ha asignado un valor
     mediante `:' o `::'.

     Si el valor de una variable se borra con cualquiera de las
     instrucciones `kill', `remove' o `remvalue', dicha variable
     desaparece de la lista `values'.

     Véase `functions' para una lista de funciones definidas por el
     usuario.

     Ejemplos:

     Primero, `values' muestra los símbolos `a', `b' y `c', pero no
     `d', pues no tiene valor asignado, ni la función de usuario `f'.
     Luego los valores de las variables se borran y `values' queda como
     una lista vacía.

          (%i1) [a:99, b::a-90, c:a-b, d, f(x):= x^2];
                                                            2
          (%o1)                     [99, 9, 90, d, f(x) := x ]
          (%i2) values;
          (%o2)                              [a, b, c]
          (%i3) [kill(a), remove(b,value), remvalue(c)];
          (%o3)                          [done, done, [c]]
          (%i4) values;
          (%o4)                                 []



File: maxima.info,  Node: Funciones y variables para la impresión,  Prev: Funciones y variables para la línea de comandos,  Up: Línea de comandos

4.3 Funciones y variables para la impresión
===========================================

 -- Variable opcional: %edispflag
     Valor por defecto: `false'

     Si `%edispflag' vale `true', Maxima muestra `%e' elevado a un
     exponente negativo como un cociente. Por ejemplo, `%e^-x' se
     muestra como `1/%e^x'. Véase también `exptdispflag'.

     Ejemplo:

          (%i1) %e^-10;
                                         - 10
          (%o1)                        %e
          (%i2) %edispflag:true$
          (%i3) %e^-10;
                                         1
          (%o3)                         ----
                                          10
                                        %e

 -- Variable opcional: absboxchar
     Valor por defecto: `!'

     La variable `absboxchar' es el carácter utilizado para representar
     el valor absoluto de una expresión que ocupa más de una línea de
     altura.

     Ejemplo:

          (%i1) abs((x^3+1));
                                      ! 3    !
          (%o1)                       !x  + 1!

 -- Función: disp (<expr_1>, <expr_2>, ...)
     Es como `display' pero sólo se muestran los valores de los
     argumentos, no las ecuaciones. Es útil para argumentos complicados
     que no tienen nombre o en situaciones en las que solamente es de
     interés el valor del argumento pero no su nombre.

     Véanse también `ldisp' y `print'.

     Ejemplos:

          (%i1) b[1,2]:x-x^2$
          (%i2) x:123$
          (%i3) disp(x, b[1,2], sin(1.0));
                                         123

                                            2
                                       x - x

                                  .8414709848078965

          (%o3)                         done

 -- Función: display (<expr_1>, <expr_2>, ...)
     Muestra las ecuaciones cuyos miembros izquierdos son <expr_i> sin
     evaluar y cuyos miembros derechos son los valores de las
     expresiones. Esta función es útil en los bloques y en las
     sentencias `for' para mostrar resultados intermedios.  Los
     argumentos de `display' suelen ser átomos, variables subindicadas
     o llamadas a funciones.

     Véanse también `ldisplay', `disp' y `ldisp'.

     Ejemplos:

          (%i1) b[1,2]:x-x^2$
          (%i2) x:123$
          (%i3) display(x, b[1,2], sin(1.0));
                                       x = 123

                                                2
                                   b     = x - x
                                    1, 2

                            sin(1.0) = .8414709848078965

          (%o3)                         done

 -- Variable opcional: display2d
     Valor por defecto: `true'

     Si `display2d' vale `false', la salida por consola es una cadena
     unidimensional, en lugar de una expresión bidimensional.

     Véase también `leftjust' para cambiar la justificación a la
     izquierda o el centrado de la ecuación.

     Ejemplo:

          (%i1) x/(x^2+1);
                                         x
          (%o1)                        ------
                                        2
                                       x  + 1
          (%i2) display2d:false$
          (%i3) x/(x^2+1);
          (%o3) x/(x^2+1)

 -- Variable opcional: display_format_internal
     Valor por defecto: `false'

     Si `display_format_internal' vale `true', las expresiones se
     muestran sin ser transformadas de manera que oculten su
     representación matemática interna. Se representa lo que la función
     `inpart' devolvería, en oposición a `part'.

     Ejemplos:

          User     part       inpart
          a-b;      a - b     a + (- 1) b

                     a            - 1
          a/b;       -         a b
                     b
                                 1/2
          sqrt(x);   sqrt(x)    x

                    4 X        4
          X*4/3;    ---        - X
                     3         3


 -- Función: dispterms (<expr>)
     Muestra <expr> en partes, una debajo de la otra.  Esto es, primero
     se muestra el operador de <expr>, luego cada término si se trata
     de una suma, o cada factor si es un producto, o si no se muestra
     separadamente la parte de una expresión más general. Es útil si
     <expr> es demasiado grande para representarla de otra forma.  Por
     ejemplo, si `P1', `P2', ...  son expresiones muy grandes, entonces
     el programa de representación puede superar el espacio de
     almacenamiento tratando de mostrar `P1 + P2 + ...' todo junto.
     Sin embargo, `dispterms (P1 + P2 + ...)' muestra `P1', debajo
     `P2', etc.  Cuando una expresión exponencial es demasiado ancha
     para ser representada como `A^B', si no se utiliza `dispterms',
     entonces aparecerá como `expt (A, B)' (o como `ncexpt (A, B)', en
     lugar de `A^^B').

     Ejemplo:

          (%i1) dispterms(2*a*sin(x)+%e^x);

          +

          2 a sin(x)

            x
          %e

          (%o1)                         done

 -- Símbolo especial: expt (<a>, <b>)
 -- Símbolo especial: ncexpt (<a>, <b>)
     Si una expresión exponencial es demasiado ancha para ser mostrada
     como `<a>^<b>' aparecerá como `expt (<a>, <b>)' (o como `ncexpt
     (<a>, <b>)' en lugar de `<a>^^<b>').

     Las funciones `expt' y `ncexpt' no se reconocen en una entrada.


 -- Variable opcional: exptdispflag
     Valor por defecto: `true'

     Si `exptdispflag' vale `true', Maxima muestra las expresiones con
     exponentes negativos como cocientes. Véase también `%edispflag'.

     Ejemplo:

          (%i1) exptdispflag:true;
          (%o1)                         true
          (%i2) 10^-x;
                                          1
          (%o2)                          ---
                                           x
                                         10
          (%i3) exptdispflag:false;
          (%o3)                         false
          (%i4) 10^-x;
                                          - x
          (%o4)                         10


 -- Función: grind (<expr>)
 -- Variable opcional: grind
     La función `grind' imprime <expr> en la consola en un formato
     admisible como entrada para Maxima. La función `grind' devuelve
     siempre `done'.

     Cuando <expr> es el nombre de una función o macro, `grind' muestra
     la definición de la función o de la macro en lugar de sólo su
     nombre.

     Véase también `string', que devuelve una cadena en lugar de
     imprimir la salida. La función `grind' intenta imprimir la
     expresión de forma que sea lago más sencilla de leer que la salida
     de `string'.

     Cuando la variable `grind' vale `true', la salida de `string' y
     `stringout' tienen el mismo formato que la de `grind'; en caso
     contrario no se formatea la salida de esas funciones.  El valor
     por defecto de la variable `grind' es `false'.

     La variable `grind' también se puede utilizar como  argumento en
     `playback'.  Si `grind' está presente, `playback' imprime las
     expresiones de entrada en el mismo formato que lo hace la función
     `grind'; en caso contrario no se formatean la expresiones de
     entrada.

     La función `grind' evalúa sus argumentos.

     Ejemplos:

          (%i1) aa + 1729;
          (%o1)                       aa + 1729
          (%i2) grind (%);
          aa+1729$
          (%o2)                         done
          (%i3) [aa, 1729, aa + 1729];
          (%o3)                 [aa, 1729, aa + 1729]
          (%i4) grind (%);
          [aa,1729,aa+1729]$
          (%o4)                         done
          (%i5) matrix ([aa, 17], [29, bb]);
                                     [ aa  17 ]
          (%o5)                      [        ]
                                     [ 29  bb ]
          (%i6) grind (%);
          matrix([aa,17],[29,bb])$
          (%o6)                         done
          (%i7) set (aa, 17, 29, bb);
          (%o7)                   {17, 29, aa, bb}
          (%i8) grind (%);
          {17,29,aa,bb}$
          (%o8)                         done
          (%i9) exp (aa / (bb + 17)^29);
                                          aa
                                      -----------
                                               29
                                      (bb + 17)
          (%o9)                     %e
          (%i10) grind (%);
          %e^(aa/(bb+17)^29)$
          (%o10)                        done
          (%i11) expr: expand ((aa + bb)^10);
                   10           9        2   8         3   7         4   6
          (%o11) bb   + 10 aa bb  + 45 aa  bb  + 120 aa  bb  + 210 aa  bb
                   5   5         6   4         7   3        8   2
           + 252 aa  bb  + 210 aa  bb  + 120 aa  bb  + 45 aa  bb
                  9        10
           + 10 aa  bb + aa
          (%i12) grind (expr);
          bb^10+10*aa*bb^9+45*aa^2*bb^8+120*aa^3*bb^7+210*aa^4*bb^6
               +252*aa^5*bb^5+210*aa^6*bb^4+120*aa^7*bb^3+45*aa^8*bb^2
               +10*aa^9*bb+aa^10$
          (%o12)                        done
          (%i13) string (expr);
          (%o13) bb^10+10*aa*bb^9+45*aa^2*bb^8+120*aa^3*bb^7+210*aa^4*bb^6\
          +252*aa^5*bb^5+210*aa^6*bb^4+120*aa^7*bb^3+45*aa^8*bb^2+10*aa^9*\
          bb+aa^10
          (%i14) cholesky (A):= block ([n : length (A), L : copymatrix (A),
            p : makelist (0, i, 1, length (A))], for i thru n do
            for j : i thru n do
            (x : L[i, j], x : x - sum (L[j, k] * L[i, k], k, 1, i - 1),
            if i = j then p[i] : 1 / sqrt(x) else L[j, i] : x * p[i]),
            for i thru n do L[i, i] : 1 / p[i],
            for i thru n do for j : i + 1 thru n do L[i, j] : 0, L)$
          (%i15) grind (cholesky);
          cholesky(A):=block(
                   [n:length(A),L:copymatrix(A),
                    p:makelist(0,i,1,length(A))],
                   for i thru n do
                       (for j from i thru n do
                            (x:L[i,j],x:x-sum(L[j,k]*L[i,k],k,1,i-1),
                             if i = j then p[i]:1/sqrt(x)
                                 else L[j,i]:x*p[i])),
                   for i thru n do L[i,i]:1/p[i],
                   for i thru n do (for j from i+1 thru n do L[i,j]:0),L)$
          (%o15)                        done
          (%i16) string (fundef (cholesky));
          (%o16) cholesky(A):=block([n:length(A),L:copymatrix(A),p:makelis\
          t(0,i,1,length(A))],for i thru n do (for j from i thru n do (x:L\
          [i,j],x:x-sum(L[j,k]*L[i,k],k,1,i-1),if i = j then p[i]:1/sqrt(x\
          ) else L[j,i]:x*p[i])),for i thru n do L[i,i]:1/p[i],for i thru \
          n do (for j from i+1 thru n do L[i,j]:0),L)

 -- Variable opcional: ibase
     Valor por defecto: `10'

     `ibase' es la base en la que Maxima lee valores enteros.

     A `ibase' se le puede asignar cualquier entero entre 2 y 36 (base
     decimal), ambos inclusive.  Si `ibase' es mayor que 10, las cifras
     a utilizar serán los dígitos de 0 a 9, junto con las letras del
     alfabeto A, B, C, ..., tantas como sean necesarias para completar
     la base `ibase'.  Las letras se interpretarán como cifras sólo
     cuando el primer dígito sea un valor entre 9.  Es indiferente
     hacer uso de letras mayúsculas o minúsculas.  Las cifras para la
     base 36, la mayor posible, son los dígitos numéricos de 0 a 9 y
     las letras desde la A hasta la Z.

     Cualquiera que sea el valor de `ibase', si un entero termina con
     un punto decimal, se interpretará en base 10.

     Véase también `obase'.

     Ejemplos:

     `ibase' menor que 10.

          (%i1) ibase : 2 $
          (%i2) obase;
          (%o2)                          10
          (%i3) 1111111111111111;
          (%o3)                         65535

     `ibase' mayor que 10.  Las letras se interpretan como dígitos sólo
     si el primer dígito es una cifra entre 0 y 9.

          (%i1) ibase : 16 $
          (%i2) obase;
          (%o2)                          10
          (%i3) 1000;
          (%o3)                         4096
          (%i4) abcd;
          (%o4)                         abcd
          (%i5) symbolp (abcd);
          (%o5)                         true
          (%i6) 0abcd;
          (%o6)                         43981
          (%i7) symbolp (0abcd);
          (%o7)                         false

     Independientemente del valor de `ibase', si el entero termina con
     un punto decimal, se interpretará en base diez.

          (%i1) ibase : 36 $
          (%i2) obase;
          (%o2)                          10
          (%i3) 1234;
          (%o3)                         49360
          (%i4) 1234.;
          (%o4)                         1234

 -- Función: ldisp (<expr_1>, ..., <expr_n>)
     Muestra las expresiones <expr_1>, ..., <expr_n> en la consola con
     el formato de salida; `ldisp' asigna una etiqueta a cada argumento
     y devuelve la lista de etiquetas.

     Véanse también `disp', `display' y `ldisplay'.

          (%i1) e: (a+b)^3;
                                             3
          (%o1)                       (b + a)
          (%i2) f: expand (e);
                               3        2      2      3
          (%o2)               b  + 3 a b  + 3 a  b + a
          (%i3) ldisp (e, f);
                                             3
          (%t3)                       (b + a)

                               3        2      2      3
          (%t4)               b  + 3 a b  + 3 a  b + a

          (%o4)                      [%t3, %t4]
          (%i4) %t3;
                                             3
          (%o4)                       (b + a)
          (%i5) %t4;
                               3        2      2      3
          (%o5)               b  + 3 a b  + 3 a  b + a


 -- Función: ldisplay (<expr_1>, ..., <expr_n>)
     Muestra las expresiones <expr_1>, ..., <expr_n> en la consola con
     el formato de salida.  Cad expresión se muestra como una ecuación
     de la forma `lhs = rhs' en la que `lhs' es uno de los argumentos
     de `ldisplay' y `rhs' su valor. Normalmente, cada argumento será
     el nombre de una variable. La función `ldisp' asigna una etiqueta
     a cada ecuación y devuelve la lista de etiquetas.

     Véanse también `disp', `display' y `ldisp'.

          (%i1) e: (a+b)^3;
                                             3
          (%o1)                       (b + a)
          (%i2) f: expand (e);
                               3        2      2      3
          (%o2)               b  + 3 a b  + 3 a  b + a
          (%i3) ldisplay (e, f);
                                               3
          (%t3)                     e = (b + a)

                                 3        2      2      3
          (%t4)             f = b  + 3 a b  + 3 a  b + a

          (%o4)                      [%t3, %t4]
          (%i4) %t3;
                                               3
          (%o4)                     e = (b + a)
          (%i5) %t4;
                                 3        2      2      3
          (%o5)             f = b  + 3 a b  + 3 a  b + a


 -- Variable opcional: linel
     Valor por defecto: `79'

     La variable `linel' es la anchura (medida en número de caracteres)
     de la consola que se le da a Maxima para que muestre las
     expresiones. A `linel' se le puede asignar cualquier valor, pero
     si éste es muy pequeño o grande resultará de poca utilidad. El
     texto que impriman las funciones internas de Maxima, como los
     mensajes de error y las salidas de la función `describe', no se ve
     afectado por el valor de `linel'.


 -- Variable opcional: lispdisp
     Valor por defecto: `false'

     Si `lispdisp' vale `true', los símbolos de Lisp se muestran
     precedidos del carácter de interrogación `?'. En caso contrario,
     los símbolos de Lisp se muestran sin esta marca.

     Ejemplos:

          (%i1) lispdisp: false$
          (%i2) ?foo + ?bar;
          (%o2)                       foo + bar
          (%i3) lispdisp: true$
          (%i4) ?foo + ?bar;
          (%o4)                      ?foo + ?bar


 -- Variable opcional: negsumdispflag
     Valor por defecto: `true'

     Si `negsumdispflag' vale `true', `x - y' se muestra como `x - y'
     en lugar de `- y + x'.  Dándole el valor `false' se realiza un
     análisis adicional para que no se representen de forma muy
     diferente dos expresiones similares.  Una aplicación puede ser
     para que `a + %i*b' y `a - %i*b' se representen ambas de la misma
     manera.


 -- Variable opcional: obase
     Valor por defecto: `10'

     `obase' es la base en la que Maxima imprime los números enteros.

     A `obase' se le puede asignar cualquier entero entre 2 y 36 (base
     decimal), ambos inclusive.  Si `obase' es mayor que 10, las cifras
     a utilizar serán los dígitos de 0 a 9, junto con las letras del
     alfabeto A, B, C, ..., tantas como sean necesarias para completar
     la base `obase'.  Si el primer dígito resulta ser una letra, se le
     añadirá el cero como prefijo.  Las cifras para la base 36, la
     mayor posible, son los dígitos numéricos de 0 a 9 y las letras
     desde la A hasta la Z.

     Véase también `ibase'.

     Ejemplos:

          (%i1) obase : 2;
          (%o1)                          10
          (%i2) 2^8 - 1;
          (%o10)                      11111111
          (%i3) obase : 8;
          (%o3)                          10
          (%i4) 8^8 - 1;
          (%o4)                       77777777
          (%i5) obase : 16;
          (%o5)                          10
          (%i6) 16^8 - 1;
          (%o6)                       0FFFFFFFF
          (%i7) obase : 36;
          (%o7)                          10
          (%i8) 36^8 - 1;
          (%o8)                       0ZZZZZZZZ

 -- Variable opcional: pfeformat
     Valor por defecto: `false'

     Si `pfeformat' vale `true', una fracción de enteros será mostrada
     con el carácter de barra inclinada `/' entre ellos.

          (%i1) pfeformat: false$
          (%i2) 2^16/7^3;
                                        65536
          (%o2)                         -----
                                         343
          (%i3) (a+b)/8;
                                        b + a
          (%o3)                         -----
                                          8
          (%i4) pfeformat: true$
          (%i5) 2^16/7^3;
          (%o5)                       65536/343
          (%i6) (a+b)/8;
          (%o6)                      1/8 (b + a)


 -- Variable opcional: powerdisp
     Valor por defecto: `false'

     Si `powerdisp' vale `true', se muestran las sumas con sus términos
     ordenados de menor a mayor potencia. Así, un polinomio se presenta
     como una serie de potencias truncada con el término constante al
     principio y el de mayor potencia al final.

     Por defecto, los términos de una suma se muestran en el orden de
     las potencias decrecientes.

     Ejemplo:

          (%i1) powerdisp:true;
          (%o1)                         true
          (%i2) x^2+x^3+x^4;
                                     2    3    4
          (%o2)                     x  + x  + x
          (%i3) powerdisp:false;
          (%o3)                         false
          (%i4) x^2+x^3+x^4;
                                     4    3    2
          (%o4)                     x  + x  + x

 -- Función: print (<expr_1>, ..., <expr_n>)
     Evalúa y muestra las expresiones  <expr_1>, ..., <expr_n>
     secuencialmente de izquierda a derecha, comenzando la impresión
     por el borde izquierdo de la consola.

     El valor devuelto por `print' es el valor de su último argumento.
     La función `print' no genera etiquetas para las expresiones
     intermedias.

     Véanse también `display', `disp', `ldisplay' y `ldisp', que
     muestran una expresión por línea, mientras que `print' trata de
     mostrar dos o más expresiones por línea.

     Para mostrar el contenido de un archivo véase `printfile'.

          (%i1) r: print ("(a+b)^3 is", expand ((a+b)^3), "log (a^10/b) is",
                radcan (log (a^10/b)))$
                      3        2      2      3
          (a+b)^3 is b  + 3 a b  + 3 a  b + a  log (a^10/b) is

                                                        10 log(a) - log(b)
          (%i2) r;
          (%o2)                  10 log(a) - log(b)
          (%i3) disp ("(a+b)^3 is", expand ((a+b)^3), "log (a^10/b) is",
                radcan (log (a^10/b)))$
                                     (a+b)^3 is

                               3        2      2      3
                              b  + 3 a b  + 3 a  b + a

                                   log (a^10/b) is

                                 10 log(a) - log(b)


 -- Variable opcional: sqrtdispflag
     Valor por defecto: `true'

     Si `sqrtdispflag' vale `false', hará que `sqrt' se muestre con el
     exponente 1/2.

 -- Variable opcional: stardisp
     Valor por defecto: `false'

     Si `stardisp' vale `true', la multiplicación se muestra con un
     asterisco `*' entre los operandos.


 -- Variable opcional: ttyoff
     Valor por defecto: `false'

     Si `ttyoff' vale `true', no se muestran las expresiones
     resultantes, pero éstas se calculan de todos modos y se les
     asignan etiquetas. Véase `labels'.

     El texto que escriban las funciones internas de Maxima, tales como
     los mensajes de error y las salidas de `describe', no se ven
     afectadas por `ttyoff'.



File: maxima.info,  Node: Tipos de datos y estructuras,  Next: Operadores,  Prev: Línea de comandos,  Up: Top

5 Tipos de datos y estructuras
******************************

* Menu:

* Números::
* Cadenas de texto::
* Constantes::
* Listas::
* Arrays::
* Estructuras::


File: maxima.info,  Node: Números,  Next: Cadenas de texto,  Prev: Tipos de datos y estructuras,  Up: Tipos de datos y estructuras

5.1 Números
===========

* Menu:

* Introducción a los números::
* Funciones y variables para los números::


File: maxima.info,  Node: Introducción a los números,  Next: Funciones y variables para los números,  Prev: Números,  Up: Números

5.1.1 Introducción a los números
--------------------------------

Números enteros y racionales
----------------------------

Los cálculos aritméticos con números enteros y racionales son exactos.
En principio, los números enteros y racionales admiten una cantidad
arbitraria de cifras, con la única limitación que impongan las
capacidades de memoria del sistema.

     (%i1) 1/3+5/4+3;
                                    55
     (%o1)                          --
                                    12
     (%i2) 100!;
     (%o2) 9332621544394415268169923885626670049071596826438162146859\
     2963895217599993229915608941463976156518286253697920827223758251\
     185210916864000000000000000000000000
     (%i3) 100!/101!;
                                     1
     (%o3)                          ---
                                    101

Funciones disponibles para los números enteros y racionales:

   integerp       numberp       nonnegintegerp
   oddp           evenp
   ratnump        rationalize

Números decimales en coma flotante
----------------------------------

Maxima hace los cálculos con números decimales en coma flotante en
doble precisión. Además, Maxima puede hacer cl'culos con números
decimales grandes en coma flotante (bigfloats, en inglés), que, en
principio, admiten precisión arbitraria.

La coma de los números decimales en coma flotante se escribe con un
punto y el exponente se puede indicar con "f", "e" o "d". Por defecto,
Maxima hace los cálculos en doble precisión y muestra el exponente como
"e" en el resultado, mientras que representa el exponente con la letra
"b" en el caso de decimales grandes de precisión arbitraria.  Maxima no
distingue si la letra del exponente se escribe en minúscula o mayúscula.

     (%i1) [2.0,1f10,1,e10,1d10,1d300];
     (%o1)        [2.0, 1.e+10, 1, e10, 1.e+10, 1.e+300]
     (%i2) [2.0b0,1b10,1b300];
     (%o2)               [2.0b0, 1.0b10, 1.0b300]

Si en un cálculo aritmético aparece un número decimal en coma flotante,
se producirá un efecto de contagio que hará que el resultado se devuelva
también como decimal. Esto también es cierto para el caso de decimales
grandes de precisión arbitraria.

     (%i1) 2.0+1/2+3;
     (%o1)                                 5.5
     (%i2) 2.0b0+1/2+3;
     (%o2)                                5.5b0

Con las funciones `float' y `bfloat' se puede convertir un número en
decimal de doble precisión, o de precisión arbitraria, respectivamente:

     (%i1) float([2,1/2,1/3,2.0b0]);
     (%o1)          [2.0, 0.5, .3333333333333333, 2.0]
     (%i2) bfloat([2,1/2,1/3,2.0b0]);
     (%o2)     [2.0b0, 5.0b-1, 3.333333333333333b-1, 2.0b0]

Funciones y variables disponibles para números decimales:

   float        floatnump
   bfloat       bfloatp       fpprec
   float2bf     bftorat       ratepsilon

   number_pbranch
   m1pbranch

Números complejos
-----------------

Maxima no tiene un tipo de dato especíco para números complejos; éstos
se representan internamente como la suma de la parte real y la
imaginaria multiplicada por el símbolo `%i', que hace las veces de
unidad imaginaria. Por ejemplo, las raíces de la ecuación `x^2 - 4*x +
13 = 0' se representan como `2 + 3*%i' y `2 - 3*%i'.

Maxima no simplifica automáticamente productos, cocientes, raíces y
otras expresiones con números complejos.  Por ejemplo, para hacer la
multiplicación de números complejos se puede utilizar la función
`expand'.

Funciones disponibles para los números complejos:

   realpart     imagpart      rectform     polarform
   cabs         carg          conjugate    csign


File: maxima.info,  Node: Funciones y variables para los números,  Prev: Introducción a los números,  Up: Números

5.1.2 Funciones y variables para los números
--------------------------------------------

 -- Función: bfloat (<expr>)
     Convierte todos los números y  funciones numéricas a números
     decimales de punto flotante grandes ("bigfloats").  El número de
     dígitos significativos de los "bigfloats" resultantes se
     especifica mediante la variable global `fpprec'.

     Si `float2bf' vale `false' se mostrará un mensaje de aviso cuando
     un número en punto flotante se convierte a decimal de tipo
     "bigfloats", puesto que tal transformación puede conllevar pérdida
     de precisión.


 -- Función: bfloatp (<expr>)
     Devuelve `true' si <expr> es un número decimal en punto flotante
     grande ("bigfloats"), en caso contrario devuelve `false'.


 -- Variable optativa: bftorat
     Valor por defecto: `false'

     La variable `bftorat' controla la conversión de números decimales
     de punto flotante grandes ("bigfloats") a números racionales. Si
     `bftorat' vale `false', se utilizará `ratepsilon' para controlar
     la conversión  (lo cual resulta en números racionales
     relativamente pequeños). Si  `bftorat' vale `true', el número
     racional generado representará exactamente al número decimal de
     punto flotante grande ("bigfloat").


 -- Variable optativa: bftrunc
     Valor por defecto: `true'

     La variable `bftrunc' provoca la eliminación de ceros en números
     decimales grandes no nulos para que no se muestren.  Así, si
     `bftrunc' vale `false', `bfloat (1)' se muestra como
     `1.000000000000000B0'. En otro caso, se mostrará como `1.0B0'.


 -- Función: evenp (<expr>)
     Devuelve `true' si <expr> es un entero par y `false' en cualquier
     otro caso.


 -- Función: float (<expr>)
     Convierte los enteros, números racionales y los decimales de punto
     flotante grandes ("bigfloats") que están presentes en <expr> a
     números de punto flotante. También actúa como símbolo `evflag'.


 -- Variable optativa: float2bf
     Valor por defecto: `true'

     Si `float2bf' vale `false' se mostrará un mensaje de aviso cuando
     un número en punto flotante se convierte a decimal de tipo
     "bigfloats", puesto que tal transformación puede conllevar pérdida
     de precisión.


 -- Función: floatnump (<expr>)
     Devuelve `true' si <expr> es un número de punto flotante, en caso
     contario retorna `false'.


 -- Variable optativa: fpprec
     Valor por defecto: 16

     La variable `fpprec' guarda el número de dígitos significativos en
     la aritmética con números decimales de punto flotante grandes
     ("bigfloats"). La variable `fpprec' no afecta a los cálculos con
     números decimales de punto flotante ordinarios.

     Véanse también `bfloat' y `fpprintprec'.


 -- Variable optativa: fpprintprec
     Valor por defecto: 0

     La variable `fpprintprec' guarda el número de dígitos a imprimir
     de los números decimales en coma flotante, tanto los ordinarios
     como los de precisión ilimitada (bigfloats).

     En el caso de los decimales ordinarios, si `fpprintprec' toma un
     valor entre 2 y 16 (inclusive), el número de dígitos que se
     imprimen es igual a `fpprintprec'. En caso contrario,
     `fpprintprec' es 0 o mayor que 16, siendo el número de dígitos a
     imprimir en todos loa casos igual a 16.

     En el caso de los decimales de precisión ilimitada (bigfloats), si
     `fpprintprec' toma un valor entre 2 y 16 (inclusive), el número de
     dígitos que se imprimen es igual a `fpprintprec'. En caso
     contrario, `fpprintprec' es 0 o mayor que `fpprec', siendo el
     número de dígitos a imprimir igual a `fpprec'.

     La variable `fpprintprec' no admite el valor 1.

 -- Función: integerp (<expr>)
     Devuelve `true' si <expr> es un número entero y `false' en
     cualquier otro caso.

     La función `integerp' devuelve `false' si su argumento es un
     símbolo, incluso cuando éste ha sido declarado como entero.

     Ejemplos:

          (%i1) integerp (0);
          (%o1)                         true
          (%i2) integerp (1);
          (%o2)                         true
          (%i3) integerp (-17);
          (%o3)                         true
          (%i4) integerp (0.0);
          (%o4)                         false
          (%i5) integerp (1.0);
          (%o5)                         false
          (%i6) integerp (%pi);
          (%o6)                         false
          (%i7) integerp (n);
          (%o7)                         false
          (%i8) declare (n, integer);
          (%o8)                         done
          (%i9) integerp (n);
          (%o9)                         false


 -- Variable opcional: m1pbranch
     Valor por defecto: `false'

     La variable `m1pbranch' es la rama principal de `-1' elevado a una
     potencia. Cantidades como `(-1)^(1/3)' (esto es, un exponente
     racional impar) y `(-1)^(1/4)' (esto es, un exponente racional
     par) son tratados como sigue:

                        dominio real

          (-1)^(1/3):      -1
          (-1)^(1/4):   (-1)^(1/4)

                       dominio complejo
          m1pbranch:false          m1pbranch:true
          (-1)^(1/3)               1/2+%i*sqrt(3)/2
          (-1)^(1/4)              sqrt(2)/2+%i*sqrt(2)/2


 -- Función: nonnegintegerp (<n>)
     Devuelve `true' si y solo si `<n> >= 0', siendo <n> un entero.


 -- Función: numberp (<expr>)
     Devuelve `true' si <expr> es un enúmero entero, racional, de coma
     flotante o "bigfloat", en caso contrario devuelve `false'.

     La función `numberp' devuelve `false' si su argumento es un
     símbolo, incluso cuando el argumento es un número simbólico como
     `%pi' o `%i', o aunque haya sido declarado como `even' (par),
     `odd' (impar), `integer' (entero), `rational' (racional),
     `irrational' (irracional), `real' (real), `imaginary' (imaginario)
     o `complex' (complejo).

     Ejemplos:

          (%i1) numberp (42);
          (%o1)                         true
          (%i2) numberp (-13/19);
          (%o2)                         true
          (%i3) numberp (3.14159);
          (%o3)                         true
          (%i4) numberp (-1729b-4);
          (%o4)                         true
          (%i5) map (numberp, [%e, %pi, %i, %phi, inf, minf]);
          (%o5)      [false, false, false, false, false, false]
          (%i6) declare (a, even, b, odd, c, integer, d, rational,
               e, irrational, f, real, g, imaginary, h, complex);
          (%o6)                         done
          (%i7) map (numberp, [a, b, c, d, e, f, g, h]);
          (%o7) [false, false, false, false, false, false, false, false]


 -- Variable opcional: numer
     La variable `numer' hace algunas funciones matemáticas con
     argumentos numéricos se evalúen como decimales de punto flotante.
     También hace que las variables de una expresión a las cuales se
     les ha asignado un número sean sustituidas por sus valores.
     Además, activa la variable `float'.

     Véase también `%enumer'.

     Ejemplos:

          (%i1) [sqrt(2), sin(1), 1/(1+sqrt(3))];
                                                         1
          (%o1)                   [sqrt(2), sin(1), -----------]
                                                    sqrt(3) + 1
          (%i2) [sqrt(2), sin(1), 1/(1+sqrt(3))],numer;
          (%o2) [1.414213562373095, .8414709848078965, .3660254037844387]

 -- Variable opcional: numer_pbranch
     Valor por defecto: `false'

     La variable opcional `numer_pbranch' controla la evaluación
     numérica de las potencias de números enteros, racionales y
     decimales negativos. Si `numer_pbranch' vale `true' y el exponente
     es decimal o la variable opcional `numer' vale `true', Maxima
     evalúa el resultado numérico utilizando la rama principal. En caso
     contrario, se devuleve un resultado simplificado pero no evaluado.

     Ejemplos:

          (%i1) (-2)^0.75;
          (%o1) (-2)^0.75

          (%i2) (-2)^0.75,numer_pbranch:true;
          (%o2) 1.189207115002721*%i-1.189207115002721

          (%i3) (-2)^(3/4);
          (%o3) (-1)^(3/4)*2^(3/4)

          (%i4) (-2)^(3/4),numer;
          (%o4) 1.681792830507429*(-1)^0.75

          (%i5) (-2)^(3/4),numer,numer_pbranch:true;
          (%o5) 1.189207115002721*%i-1.189207115002721


 -- Función: numerval (<x_1>, <expr_1>, ..., <var_n>, <expr_n>)
     Declara las variables `x_1', ..., <x_n> asignándoles los valores
     numéricos `expr_1', ..., `expr_n'.  El valor numérico se evalúa y
     sustituye a la variable en cualquier expresión en la que ésta
     aparezca si `numer' toma el valor `true'. Véase también `ev'.

     Las expresiones `expr_1', ..., `expr_n' pueden ser expresiones no
     necesariamente numéricas.

 -- Función: oddp (<expr>)
     Devuelve `true' si <expr> es un entero impar y `false' en caso
     contrario.

 -- Variable opcional: ratepsilon
     Valor por defecto: 2.0e-8

     La variable `ratepsilon' guarda la tolerancia utilizada en la
     conversión de números decimales en coma flotante a números
     racionales.


 -- Función: rationalize (<expr>)
     Convierte todos los números en coma flotante de doble precisión y
     grandes (big float) presentes en una expresión <expr> de Maxima a
     sus formas racionales exactas equivalentes. Si el usuario no está
     familiarizado con la representación binaria de números en coma
     flotante, le puede extrañar que `rationalize (0.1)' no sea igual
     que 1/10.  Este comportamiento no es único de Maxima, ya que el
     número 1/10 en su forma binaria es periódico y no exacto.

          (%i1) rationalize (0.5);
                                          1
          (%o1)                           -
                                          2
          (%i2) rationalize (0.1);
                                         1
          (%o2)                          --
                                         10
          (%i3) fpprec : 5$
          (%i4) rationalize (0.1b0);
                                       209715
          (%o4)                        -------
                                       2097152
          (%i5) fpprec : 20$
          (%i6) rationalize (0.1b0);
                               236118324143482260685
          (%o6)                ----------------------
                               2361183241434822606848
          (%i7) rationalize (sin (0.1*x + 5.6));
                                        x    28
          (%o7)                     sin(-- + --)
                                        10   5

 -- Función: ratnump (<expr>)
     Devuelve `true' si <expr> es un entero literal o una fracción de
     enteros literales, en caso contrario devuelve `false'.



File: maxima.info,  Node: Cadenas de texto,  Next: Constantes,  Prev: Números,  Up: Tipos de datos y estructuras

5.2 Cadenas de texto
====================

* Menu:

* Introducción a las cadenas de texto::
* Funciones y variables para las cadenas de texto::


File: maxima.info,  Node: Introducción a las cadenas de texto,  Next: Funciones y variables para las cadenas de texto,  Prev: Cadenas de texto,  Up: Cadenas de texto

5.2.1 Introducción a las cadenas de texto
-----------------------------------------

Las cadenas de caracteres deben ir acotadas por comillas dobles (`"')
al ser introducidas en Maxima, siendo luego mostradas con o sin ellas,
dependiendo del valor de la variable global `stringdisp'.

Las cadenas pueden contener todo tipo de caracteres, incluyendo
tabulaciones, caracteres de nueva línea y de retorno.  La secuencia
`\"' se reconoce literalmente como una comilla doble, al tiempo que
`\\' se interpreta como una barra invertida. Cuando la barra invertida
aparece al final de una línea, tanto la barra como el final de línea
(representado éste bien por el carácter de nueva línea o el de retorno)
son ignorados, de forma que la cadena continúa en el siguiente renglón.
No se reconocen más combinaciones especiales de la barra invertida con
otros caracteres aparte de las comentadas; de modo que si la barra
invertida aparece antes de cualquier otro carácter distinto de `"',
`\', o de un final de línea, dicha barra será ignorada.  No hay manera
de representar los caracteres especiales (tabulación, nueva línea o
retorno) de otra forma que no sea incluyéndolos literalmente en la
cadena.

No existe en Maxima el tipo de variable carácter, debiéndose
representar un carácter simple como una cadena de un solo carácter.

El paquete adicional `stringproc' contiene muchas funciones que
permiten trabajar con cadenas.

Ejemplos:

     (%i1) s_1 : "This is a string.";
     (%o1)               This is a string.
     (%i2) s_2 : "Embedded \"double quotes\" and backslash \\ characters.";
     (%o2) Embedded "double quotes" and backslash \ characters.
     (%i3) s_3 : "Embedded line termination
     in this string.";
     (%o3) Embedded line termination
     in this string.
     (%i4) s_4 : "Ignore the \
     line termination \
     characters in \
     this string.";
     (%o4) Ignore the line termination characters in this string.
     (%i5) stringdisp : false;
     (%o5)                         false
     (%i6) s_1;
     (%o6)               This is a string.
     (%i7) stringdisp : true;
     (%o7)                         true
     (%i8) s_1;
     (%o8)              "This is a string."


File: maxima.info,  Node: Funciones y variables para las cadenas de texto,  Prev: Introducción a las cadenas de texto,  Up: Cadenas de texto

5.2.2 Funciones y variables para las cadenas de texto
-----------------------------------------------------

 -- Función: concat (<arg_1>, <arg_2>, ...)
     Concatena sus argumentos, que deben ser todos átomos.  El valor
     devuelto es un símbolo si el primer argumento es a su vez un
     símbolo, o una cadena en caso contrario.

     La función `concat' evalúa sus argumentos.  El apátrofo  `'' evita
     la evaluación.

          (%i1) y: 7$
          (%i2) z: 88$
          (%i3) concat (y, z/2);
          (%o3)                          744
          (%i4) concat ('y, z/2);
          (%o4)                          y44

     A un símbolo construido por `concat' se le puede asignar un valor
     y ser utilizado posteriormente en expresiones.  La asignación con
     el operador `::' evalúa su expresión izquierda.

          (%i5) a: concat ('y, z/2);
          (%o5)                          y44
          (%i6) a:: 123;
          (%o6)                          123
          (%i7) y44;
          (%o7)                          123
          (%i8) b^a;
                                         y44
          (%o8)                         b
          (%i9) %, numer;
                                         123
          (%o9)                         b

     Nótese que aunque `concat (1, 2)' parezca un número, se trata de
     una cadena.

          (%i10) concat (1, 2) + 3;
          (%o10)                       12 + 3


 -- Función: sconcat (<arg_1>, <arg_2>, ...)
     Concatena sus argumentos para producir una cadena.  Al contrario
     que `concat', sus argumentos no necesitan ser átomos.

     El resultado es una cadena.

          (%i1) sconcat ("xx[", 3, "]:", expand ((x+y)^3));
          (%o1)               xx[3]:y^3+3*x*y^2+3*x^2*y+x^3

 -- Función: string (<expr>)
     Convierte `expr' a la notación lineal de Maxima, tal como si fuese
     tecleada.

     El valor que retorna la función `string' es una cadena, por lo que
     no puede ser utilizada en los cálculos.


 -- Variable opcional: stringdisp
     Valor por defecto: `false'

     Si `stringdisp' vale `true', las cadenas alfanuméricas se muestran
     encerradas entre comillas dobles. En caso contrario, no se
     nuestran las comillas.

     La variable `stringdisp' vale siempre `true' cuando se muestra la
     definición de una función.

     Ejemplos:

          (%i1) stringdisp: false$
          (%i2) "This is an example string.";
          (%o2)              This is an example string.
          (%i3) foo () :=
                print ("This is a string in a function definition.");
          (%o3) foo() :=
                        print("This is a string in a function definition.")
          (%i4) stringdisp: true$
          (%i5) "This is an example string.";
          (%o5)             "This is an example string."



File: maxima.info,  Node: Constantes,  Next: Listas,  Prev: Cadenas de texto,  Up: Tipos de datos y estructuras

5.3 Constantes
==============

* Menu:

* Funciones y variables para Constantes::


File: maxima.info,  Node: Funciones y variables para Constantes,  Prev: Constantes,  Up: Constantes

5.3.1 Funciones y variables para Constantes
-------------------------------------------

 -- Constante: %e
     El símbolo `%e' representa a la base de los logaritmos naturales,
     también conocido como número de Euler. El valor numérico de `%e'
     es el número decimal en coma flotante 2.718281828459045d0.


 -- Constante: %i
     El símbolo `%i' representa la unidad imaginaria, sqrt(- 1).


 -- Constante: false
     El símbolo `false' representa al valor lógico "falso". Maxima
     implementa `false' con el valor `NIL' de Lisp.

 -- Constante: %gamma
     Es la constante de Euler-Mascheroni, 0.5772156649015329 ....


 -- Constante: ind
     `ind' representa un resultado acotado indeterminado.

     Véase también `limit'.

     Ejemplo:

          (%i1) limit (sin(1/x), x, 0);
          (%o1)                          ind

 -- Constante: inf
     El símbolo `inf' representa al infinito real positivo.

 -- Constante: infinity
     El símbolo `infinity' representa al infinito complejo.

 -- Constante: minf
     El símbolo `minf' representa al infinito real negativo.

 -- Constante: %phi
     El símbolo `%phi' representa a la llamada razón áurea, (1 +
     sqrt(5))/2.  El valor numérico de `%phi' es el número decimal en
     coma flotante 1.618033988749895d0.

     La función `fibtophi' expresa los números de Fibonacci `fib(n)' en
     términos de `%phi'.

     Por defecto, Maxima desconoce las propiedades algebraicas de
     `%phi'.  Tras evaluar `tellrat(%phi^2 - %phi - 1)' y `algebraic:
     true', `ratsimp' puede simplificar algunas expresiones que
     contengan `%phi'.

     Ejemplos:

     `fibtophi' expresa el número de Fibonacci `fib(n)' en términos de
     `%phi'.

          (%i1) fibtophi (fib (n));
                                     n             n
                                 %phi  - (1 - %phi)
          (%o1)                  -------------------
                                     2 %phi - 1
          (%i2) fib (n-1) + fib (n) - fib (n+1);
          (%o2)          - fib(n + 1) + fib(n) + fib(n - 1)
          (%i3) fibtophi (%);
                      n + 1             n + 1       n             n
                  %phi      - (1 - %phi)        %phi  - (1 - %phi)
          (%o3) - --------------------------- + -------------------
                          2 %phi - 1                2 %phi - 1
                                                    n - 1             n - 1
                                                %phi      - (1 - %phi)
                                              + ---------------------------
                                                        2 %phi - 1
          (%i4) ratsimp (%);
          (%o4)                           0

     Por defecto, Maxima desconoce las propiedades algebraicas de
     `%phi'.  Después de evaluar `tellrat (%phi^2 - %phi - 1)' y
     `algebraic: true', `ratsimp' puede simplificar algunas expresiones
     que contengan `%phi'.

          (%i1) e : expand ((%phi^2 - %phi - 1) * (A + 1));
                           2                      2
          (%o1)        %phi  A - %phi A - A + %phi  - %phi - 1
          (%i2) ratsimp (e);
                            2                     2
          (%o2)        (%phi  - %phi - 1) A + %phi  - %phi - 1
          (%i3) tellrat (%phi^2 - %phi - 1);
                                      2
          (%o3)                  [%phi  - %phi - 1]
          (%i4) algebraic : true;
          (%o4)                         true
          (%i5) ratsimp (e);
          (%o5)                           0


 -- Constante: %pi
     El símbolo `%pi' representa la razón entre la longitud de una
     circunferencia y su radio.  El valor numérico de `%pi' es el
     número decimal en coma flotante 3.141592653589793d0.

 -- Constante: true
     El símbolo `true' representa al valor lógico "verdadero". Maxima
     implementa `true' con el valor `T' de Lisp.

 -- Constante: und
     `und' representa un resultado indefinido.

     Véase también `limit'.

     Ejemplo:

          (%i1) limit (x*sin(x), x, inf);
          (%o1)                          und


 -- Constante: zeroa
     `zeroa' representa un infinitesimal mayor que cero.  `zeroa' puede
     utilizarse en expresiones. `limit' simplifica expresiones que
     contienen infinitesimales.

     Véanse también `zerob' y `limit'.

     Ejemplo:

     `limit' simplifica expresiones que contienen infinitesimales:

          (%i1) limit(zeroa);
          (%o1)                                  0
          (%i2) limit(x+zeroa);
          (%o2)                                  x


 -- Constante: zerob
     `zerob' representa un infinitesimal menor que cero.  `zerob' puede
     utilizarse en expresiones. `limit' simplifica expresiones que
     contienen infinitesimales.

     Véanse también `zeroa' y `limit'.


File: maxima.info,  Node: Listas,  Next: Arrays,  Prev: Constantes,  Up: Tipos de datos y estructuras

5.4 Listas
==========

* Menu:

* Introducción a las listas::
* Funciones y variables para listas::


File: maxima.info,  Node: Introducción a las listas,  Next: Funciones y variables para listas,  Prev: Listas,  Up: Listas

5.4.1 Introducción a las listas
-------------------------------

Las listas son bloques de construcción básica para Maxima y Lisp. Todos
los tipos de datos diferentes a los arreglos, tablas mixtas o números
son representados como listas Lisp, estas listas Lisp tienen la forma

     ((MPLUS) $A 2)

para indicar la expresión `a+2'. Al nivel de Maxima se observará la
notación infija `a+2'. Maxima también tiene listas con el formato

     [1, 2, 7, x+y]

para una lista de 4 elementos. Internamente esto se corresponde con una
lista Lisp de la forma

     ((MLIST) 1  2  7  ((MPLUS)  $X $Y ))

El elemento que denota el tipo de expresión en Maxima es también una
lista, la cual tras ser analizada y simplificada tomará la forma

     ((MLIST SIMP) 1 2 7 ((MPLUS SIMP) $X $Y))


File: maxima.info,  Node: Funciones y variables para listas,  Prev: Introducción a las listas,  Up: Listas

5.4.2 Funciones y variables para listas
---------------------------------------

 -- Operador: [
 -- Operador: ]
     `[' y `]' marcan, respectivamente, el comienzo y el final de una
     lista.

     `[' y `]' también se utilizan para indicar los subíndices de una
     lista o de un array.

     Ejemplos:

          (%i1) x: [a, b, c];
          (%o1)                       [a, b, c]
          (%i2) x[3];
          (%o2)                           c
          (%i3) array (y, fixnum, 3);
          (%o3)                           y
          (%i4) y[2]: %pi;
          (%o4)                          %pi
          (%i5) y[2];
          (%o5)                          %pi
          (%i6) z['foo]: 'bar;
          (%o6)                          bar
          (%i7) z['foo];
          (%o7)                          bar
          (%i8) g[k] := 1/(k^2+1);
                                            1
          (%o8)                     g  := ------
                                     k     2
                                          k  + 1
          (%i9) g[10];
                                          1
          (%o9)                          ---
                                         101


 -- Función: append (<lista_1>, ..., <lista_n>)
     Devuelve una lista cuyos elementos son los de la lista <lista_1>
     seguidos de los de <lista_2>, ...  La función `append' también
     opera con expresiones generales, como la llamada `append (f(a,b),
     f(c,d,e));', de la que se obtiene `f(a,b,c,d,e)'.

     Tecléese `example(append);' para ver un ejemplo.


 -- Función: assoc (<clave>, <lista>, <valor_por_defecto>)
 -- Function: assoc (<clave>, <lista>)
     Esta función busca la <clave> en el lado derecho de la  <lista>,
     la cual es de la forma `[x,y,z,...]', donde cada elemento  es una
     expresión formada por un operador binario y dos elementos. Por
     ejemplo, `x=1', `2^3', `[a,b]' etc.  La <clave> se compara con el
     primer operando. La función `assoc' devuelve el segundo operando
     si se encuentra con que la `clave' coincide.  Si la `clave' no
     coincide entonces devuelve el valor <valor_por_defecto>. El
     argumento <valor_por_defecto> es opcional; en caso de no estar
     presente, se devolverá `false'.


 -- Función: cons (<expr>, <lista>)
     Devuelve una nueva lista en la que el elemento <expr> ocupa la
     primera posición, seguido de los elementos de <lista>. La función
     `cons' también opera con otro tipo de expresiones, como  `cons(x,
     f(a,b,c));'  ->  `f(x,a,b,c)'.


 -- Función: copylist (<lista>)
     Devuelve una copia de la <lista>.


 -- Función: create_list (<form>, <x_1>, <list_1>, ..., <x_n>, <list_n>)
     Crea una lista mediante la evaluación de <form> con <x_1> tomando
     cada uno de los valores de <list_1>, para cada uno de estos
     valores liga <x_2> con cada elemento de <list_2>, .... El número
     de elementos en el resultado será el producto del número de
     elementos en cada lista. Cada variable <x_i> debe ser un símbolo y
     no será evaluado.  La lista de argumentos será evaluada una vez al
     comienzo de la iteración.

     Ejemplos:

          (%i1) create_list (x^i, i, [1, 3, 7]);
                                          3   7
          (%o1)                      [x, x , x ]

     Con una doble iteración:

          (%i1) create_list ([i, j], i, [a, b], j, [e, f, h]);
          (%o1)   [[a, e], [a, f], [a, h], [b, e], [b, f], [b, h]]

     En lugar de <list_i> se pueden suministrar dos argumentos cada uno
     de los cuales debería poder evaluarse a un número, los cuales
     serán los límites inferior y superior, ambos inclusive, para cada
     iteración.

          (%i1) create_list ([i, j], i, [1, 2, 3], j, 1, i);
          (%o1)   [[1, 1], [2, 1], [2, 2], [3, 1], [3, 2], [3, 3]]

     Nótese que los límites o lista para la variable `j' pueden depender
     del valor actual de `i'.

 -- Función: delete (<expr_1>, <expr_2>)
 -- Función: delete (<expr_1>, <expr_2>, <n>)
     `delete(<expr_1>, <expr_2>)' elimina de <expr_2> cualesquiera
     argumentos del operador del nivel superior que sean iguales a
     <expr_1>.  Nótese que los argumentos de las subexpresiones no se
     ven afectados por esta función.

     <expr_1> puede ser un átomo o una expresión no atómica. <expr_2>
     puede ser cualquier expresión no atómica. La función `delete'
     devuelve una nueva expresión sin modificar <expr_2>.

     `delete(<expr_1>, <expr_2>, <n>)' elimina de <expr_2> los primeros
     <n> argumentos del operador del nivel superior que sean iguales a
     <expr_1>.  Si hay menos de <n> argumentos iguales, entonces se
     eliminan todos ellos.

     Ejemplos:

     Eliminando elementos de una lista.

          (%i1) delete (y, [w, x, y, z, z, y, x, w]);
          (%o1)                  [w, x, z, z, x, w]

     Eliminando términos de una suma.

          (%i1) delete (sin(x), x + sin(x) + y);
          (%o1)                         y + x

     Eliminando factores de un producto.

          (%i1) delete (u - x, (u - w)*(u - x)*(u - y)*(u - z));
          (%o1)                (u - w) (u - y) (u - z)

     Eliminando argumentos de una expresión arbitraria.

          (%i1) delete (a, foo (a, b, c, d, a));
          (%o1)                     foo(b, c, d)

     Limitando el número de argumentos a eliminar.

          (%i1) delete (a, foo (a, b, a, c, d, a), 2);
          (%o1)                    foo(b, c, d, a)

     Los argumentos se comparan respecto de "=".  Aquellos argumentos
     que verifiquen la condición `equal', pero no "=" no serán
     eliminados.

          (%i1) [is (equal (0, 0)), is (equal (0, 0.0)), is (equal (0, 0b0))];
          rat: replaced 0.0 by 0/1 = 0.0
          `rat' replaced 0.0B0 by 0/1 = 0.0B0
          (%o1)                  [true, true, true]
          (%i2) [is (0 = 0), is (0 = 0.0), is (0 = 0b0)];
          (%o2)                 [true, false, false]
          (%i3) delete (0, [0, 0.0, 0b0]);
          (%o3)                     [0.0, 0.0b0]
          (%i4) is (equal ((x + y)*(x - y), x^2 - y^2));
          (%o4)                         true
          (%i5) is ((x + y)*(x - y) = x^2 - y^2);
          (%o5)                         false
          (%i6) delete ((x + y)*(x - y), [(x + y)*(x - y), x^2 - y^2]);
                                        2    2
          (%o6)                       [x  - y ]

 -- Función: eighth (<expr>)
     Devuelve el octavo elemento de la lista o expresión <expr>. Véase
     `first' para más detalles.


 -- Función: endcons (<expr>, <lista>)
     Devuelve una nueva lista formada por los elementos de `lista'
     seguidos de los de <expr>. La función `endcons' también opera con
     expresiones generales, por ejemplo `endcons(x, f(a,b,c));'  ->
     `f(a,b,c,x)'.


 -- Función: fifth (<expr>)
     Devuelve el quinto elemento de la lista o expresión <expr>. Véase
     `first' para más detalles.


 -- Función: first (<expr>)
     Devuelve la primera parte de <expr>, que puede consistir en el
     primer elemento de una lista, la primera fila de una matriz, el
     primer término de una suma, etc. Nótese que tanto `first' como sus
     funciones relacionadas, `rest' y `last', operan sobre la forma en
     la que <expr> es mostrada por Maxima, no sobre la forma en la que
     es introducida la expresión. Sin embargo, cuando la variable
     `inflag' toma el valor `true' estas funciones tendrán en cuenta el
     formato interno de <expr>. Téngase en cuenta que el simplificador
     reordena las expresiones.  Así, `first(x+y)' devolverá `x' si
     `inflag' vale `true' y `y' cuando `inflag' tome el valor `false'
     (`first(y+x)' devuelve el mismo resultado). Las funciones `second'
     ... `tenth' devuelven desde el segundo hasta el décimo elemento
     del argumento de entrada.


 -- Función: fourth (<expr>)
     Devuelve el cuarto elemento de la lista o expresión <expr>. Véase
     `first' para más detalles.


 -- Función: join (<l>, <m>)
     Crea una nueva lista con los elementos de las listas <l> y <m>
     alternados.  El resultado tiene como elementos `[<l>[1], <m>[1],
     <l>[2], <m>[2], ...]'.  Las listas <l> y <m> pueden contener
     cualquier tipo de elementos.

     Si las listas son de diferente longitud, `join' ignora los
     elementos sobrantes de la lista más larga.

     Maxima da error si o bien <l> o <m> no son listas.

     Ejemplos:

          (%i1) L1: [a, sin(b), c!, d - 1];
          (%o1)                [a, sin(b), c!, d - 1]
          (%i2) join (L1, [1, 2, 3, 4]);
          (%o2)          [a, 1, sin(b), 2, c!, 3, d - 1, 4]
          (%i3) join (L1, [aa, bb, cc, dd, ee, ff]);
          (%o3)        [a, aa, sin(b), bb, c!, cc, d - 1, dd]


 -- Función: last (<expr>)
     Devuelve la última parte (término, fila, elemento, etc.) de <expr>.


 -- Función: length (<expr>)
     Devuelve (por defecto) el número de partes de que consta <expr> en
     la versión correspondiente a la que muestra.  En el caso de
     listas, se devuelve el número de elementos, si se trata de
     matrices el número de filas y se se trata de sumas el número de
     términos o sumandos (véase `dispform').

     La función `length' se ve afectada por el valor de la variable
     `inflag'.  Así, `length(a/(b*c));' devuelve 2 si `inflag' vale
     `false' (dando por hecho que `exptdispflag' vale `true'), pero
     devuelve 3 si `inflag' vale `true' (ya que la representación
     interna es `a*b^-1*c^-1').


 -- Variable opcional: listarith
     Valor por defecto: `true'

     Cuando vale `false' provoca que no se realicen operaciones
     aritméticas con listas;  cuando vale `true', las operaciones con
     listas y matrices son contagiosas, en el sentido de que las listas
     se transforman en matrices, retornando resultados de este último
     tipo. Sin embargo, operaciones que involucren listas con listas
     devolverán también listas.


 -- Función: listp (<expr>)
     Devuelve el valor `true' si <expr> es una lista, y `false' en caso
     contrario.


 -- Función: makelist ()
 -- Función: makelist (<expr>, <n>)
 -- Función: makelist (<expr>, <i>, <i_max>)
 -- Función: makelist (<expr>, <i>, <i_0>, <i_max>)
 -- Función: makelist (<expr>, <i>, <i_0>, <i_max>, <step>)
 -- Función: makelist (<expr>, <x>, <list>)
     El primer formato, `makelist ()', crea una lista vacía. El segundo
     formato, `makelist (<expr>)', crea una lista con <expr> como único
     elemento. `makelist (<expr>, <n>)' crea una lista de <n> elementos
     generados a partir de <expr>.

     El formato más general, `makelist (<expr>, <i>, <i_0>, <i_max>,
     <step>)', devuelve la lista de elementos obtenidos al aplicar `ev
     (<expr>, <i>=<j>)' a los elementos <j> de la secuencia <i_0>,
     <i_0> + <step>, <i_0> + 2*<step>, ..., siendo <|j|> menor o igual
     que <|i_max|>.

     El incremento <step> puede ser un número (positivo o negativo) o
     una expresión. En caso de omitirse, se utilizará 1 como valor por
     defecto.  Si se omiten  <i_0> y <step>, se le asignará a ambos 1
     como valor por defecto.

     `makelist (<expr>, <x>, <list>)' devuelve una lista, cuyo
     `j'-ésimo elemento es igual a `ev (<expr>, <x>=<list>[j])' tomando
     `j' valores desde 1 hasta `length (<list>)'.

     Ejemplos:

          (%i1) makelist (concat (x,i), i, 6);
          (%o1)               [x1, x2, x3, x4, x5, x6]
          (%i2) makelist (x=y, y, [a, b, c]);
          (%o2)                 [x = a, x = b, x = c]
          (%i3) makelist (x^2, x, 3, 2*%pi, 2);
          (%o3)                        [9, 25]
          (%i4) makelist (random(6), 4);
          (%o4)                     [2, 0, 2, 5]
          (%i5) flatten (makelist (makelist (i^2, 3), i, 4));
          (%o5)        [1, 1, 1, 4, 4, 4, 9, 9, 9, 16, 16, 16]
          (%i6) flatten (makelist (makelist (i^2, i, 3), 4));
          (%o6)         [1, 4, 9, 1, 4, 9, 1, 4, 9, 1, 4, 9]


 -- Función: member (<expr_1>, <expr_2>)
     Devuelve `true' si `is(<expr_1> = <a>)' para algún elemento <a> de
     `args(<expr_2>)', en caso contrario devuelve `false'.

     Normalmente, `expr_2' será una lista, en cuyo caso `args(<expr_2>)
     = <expr_2>', y la comprobación será si `is(<expr_1> = <a>)' para
     algún elemento <a> de `expr_2'.

     La función `member' no inspecciona las partes de los argumentos de
     `expr_2', por lo que puede devolver `false' si `expr_1' es parte
     de alguno de los argumentos de `expr_2'.

     Véase también `elementp'.

     Ejemplos:

          (%i1) member (8, [8, 8.0, 8b0]);
          (%o1)                         true
          (%i2) member (8, [8.0, 8b0]);
          (%o2)                         false
          (%i3) member (b, [a, b, c]);
          (%o3)                         true
          (%i4) member (b, [[a, b], [b, c]]);
          (%o4)                         false
          (%i5) member ([b, c], [[a, b], [b, c]]);
          (%o5)                         true
          (%i6) F (1, 1/2, 1/4, 1/8);
                                         1  1  1
          (%o6)                     F(1, -, -, -)
                                         2  4  8
          (%i7) member (1/8, %);
          (%o7)                         true
          (%i8) member ("ab", ["aa", "ab", sin(1), a + b]);
          (%o8)                         true

 -- Función: ninth (<expr>)
     Devuelve el noveno elemento de la lista o expresión <expr>. Véase
     `first' para más detalles.

 -- Función: pop (<list>)
     Borra el primer elemento de la lista <list> y devuelve este mismo
     elemento.

     Si el argumento <list> es una lista vacía, o simplemente no es una
     lista, Maxima devuelve un mensaje de error.

     Véase `push' para los ejemplos.

     Ejecútese `load(basic)' antes de utilizar esta función.

 -- Función: push (<item>, <list>)
     Añade al comienzo de la lista <list> el elemento <item>,
     devolviendo este mismo elemento. El argumento <list> debe ser
     necesariamente una lista, mientras que <item> puede ser cualquier
     símbolo o expresión.

     Si el argumento <list> no es una lista, Maxima devuelve un mensaje
     de error.

     Véase `pop' para eliminar el primer elemento de una lista.

     Ejecútese `load(basic)' antes de utilizar esta función.

     Ejemplos:

          (%i1) load ("basic")$
          (%i2) ll: [];
          (%o2)                          []
          (%i3) push (x, ll);
          (%o3)                          [x]
          (%i4) push (x^2+y, ll);
                                           2
          (%o4)                      [y + x , x]
          (%i5) a: push ("string", ll);
                                               2
          (%o5)                  [string, y + x , x]
          (%i6) pop (ll);
          (%o6)                        string
          (%i7) pop (ll);
                                            2
          (%o7)                        y + x
          (%i8) pop (ll);
          (%o8)                           x
          (%i9) ll;
          (%o9)                          []
          (%i10) a;
                                               2
          (%o10)                 [string, y + x , x]

 -- Función: rest (<expr>, <n>)
 -- Función: rest (<expr>)
     Devuelve <expr> sin sus primeros <n> elementos si <n> es positivo,
     o sus últimos `- <n>' elementos si <n> es negativo. En caso de que
     <n> tome el valor 1 puede ser omitido. La expresión  <expr> puede
     ser una lista, una matriz o cualquier otra expresión.


 -- Función: reverse (<lista>)
     Invierte el orden de los elementos de la <lista> (no los propios
     elementos). La función `reverse' también opera sobre expresiones
     generales, como en  `reverse(a=b);' gives `b=a'.


 -- Función: second (<expr>)
     Devuelve el segundo elemento de la lista o expresión <expr>. Véase
     `first' para más detalles.


 -- Función: seventh (<expr>)
     Devuelve el séptimo elemento de la lista o expresión <expr>. Véase
     `first' para más detalles.


 -- Función: sixth (<expr>)
     Devuelve el sexto elemento de la lista o expresión <expr>. Véase
     `first' para más detalles.


 -- Función: sort (<L>, <P>)
 -- Función: sort (<L>)
     `sort(<L>, <P>)' ordena la lista <L> de acuerdo con el predicado
     `P' de dos argumentos, el cual define un preorden total sobre los
     elementos de <L>.  Si `<P>(a, b)' vale `true', entonces `a'
     aparece antes que `b' en el resultado. Si ninguna de las
     expresiones `<P>(a, b)' y `<P>(b, a)' valen `true', entonces `a' y
     `b' son equivalentes y aparecen en el resultado en el mismo orden
     que a la entrada; esto es, `sort' es un orden estable.

     Si tanto `<P>(a, b)' como `<P>(b, a)' valen ambos `true' para
     algunos elementos de <L>, entonces <P> no es un predicado de orden
     correcto, siento entonces el resultado indefinido. Si `<P>(a, b)'
     toma un valor diferente a `true' o `false', entonces `sort'
     devuelve un error.

     El predicado puede especificarse como el nombre de una función, de
     una operación binaria infija o como una expresión `lambda'. Si se
     especifica con el nombre de un operador, dicho nombre debe
     encerrarse con comillas dobles.

     La lista ordenada se devuelve como un nuevo objeto, no
     modificándose el argumento <L>.

     `sort(<L>)' equivale a `sort(<L>, orderlessp)'.

     La ordenación por defecto es ascendente, tal como queda
     determinada por `orderlessp'.  El predicado `ordergreatp' ordena
     las listas en orden descendente.

     Todos los átomos y expresiones de Maxima son comparables respecto
     de los predicados `orderlessp' y `ordergreatp'.

     Los operadores `<' y `>' ordenan números, constantes y expresiones
     constantes por magnitud. Nótese que `orderlessp' y `ordergreatp'
     no ordenan números, constantes y expresiones constantes por
     magnitud.

     `ordermagnitudep' ordena números, constantes y expresiones
     constantes de igual modo que lo hace `<', y cualesquiera otros
     elementos lo hace igual que `orderlessp'.

     Ejemplos:

     `sort' ordena una lista respecto de un predicado de dos argumentos
     que define un preorden total en los elementos de la lista.

          (%i1) sort ([1, a, b, 2, 3, c], 'orderlessp);
          (%o1)                  [1, 2, 3, a, b, c]
          (%i2) sort ([1, a, b, 2, 3, c], 'ordergreatp);
          (%o2)                  [c, b, a, 3, 2, 1]

     El predicado puede especificarse con el nombre de una función, de
     un operador binario infijo o una expresión `lambda'. Si se
     especifica con el nombre de un operador, dicho nombre debe
     encerrarse con comillas dobles.

          (%i1) L : [[1, x], [3, y], [4, w], [2, z]];
          (%o1)           [[1, x], [3, y], [4, w], [2, z]]
          (%i2) foo (a, b) := a[1] > b[1];
          (%o2)                 foo(a, b) := a  > b
                                              1    1
          (%i3) sort (L, 'foo);
          (%o3)           [[4, w], [3, y], [2, z], [1, x]]
          (%i4) infix (">>");
          (%o4)                          >>
          (%i5) a >> b := a[1] > b[1];
          (%o5)                   a >> b := a  > b
                                             1    1
          (%i6) sort (L, ">>");
          (%o6)           [[4, w], [3, y], [2, z], [1, x]]
          (%i7) sort (L, lambda ([a, b], a[1] > b[1]));
          (%o7)           [[4, w], [3, y], [2, z], [1, x]]

     `sort(<L>)' equivale a `sort(<L>, orderlessp)'.

          (%i1) L : [a, 2*b, -5, 7, 1 + %e, %pi];
          (%o1)             [a, 2 b, - 5, 7, %e + 1, %pi]
          (%i2) sort (L);
          (%o2)             [- 5, 7, %e + 1, %pi, a, 2 b]
          (%i3) sort (L, 'orderlessp);
          (%o3)             [- 5, 7, %e + 1, %pi, a, 2 b]

     La ordenación por defecto es ascendente, tal como queda
     determinada por `orderlessp'.  El predicado `ordergreatp' ordena
     las listas en orden descendente.

          (%i1) L : [a, 2*b, -5, 7, 1 + %e, %pi];
          (%o1)                    [a, 2 b, - 5, 7, %e + 1, %pi]
          (%i2) sort (L);
          (%o2)                    [- 5, 7, %e + 1, %pi, a, 2 b]
          (%i3) sort (L, 'ordergreatp);
          (%o3)                    [2 b, a, %pi, %e + 1, 7, - 5]

     Todos los átomos y expresiones de Maxima son comparables respecto
     de los predicados `orderlessp' y `ordergreatp'.

          (%i1) L : [11, -17, 29b0, 9*c, 7.55, foo(x, y), -5/2, b + a];
                                                           5
          (%o1)  [11, - 17, 2.9b1, 9 c, 7.55, foo(x, y), - -, b + a]
                                                           2
          (%i2) sort (L, orderlessp);
                          5
          (%o2)  [- 17, - -, 7.55, 11, 2.9b1, b + a, 9 c, foo(x, y)]
                          2
          (%i3) sort (L, ordergreatp);
                                                            5
          (%o3)  [foo(x, y), 9 c, b + a, 2.9b1, 11, 7.55, - -, - 17]
                                                            2

     Los operadores `<' y `>' ordenan números, constantes y expresiones
     constantes por magnitud. Nótese que `orderlessp' y `ordergreatp'
     no ordenan números, constantes y expresiones constantes por
     magnitud.

          (%i1) L : [%pi, 3, 4, %e, %gamma];
          (%o1)                [%pi, 3, 4, %e, %gamma]
          (%i2) sort (L, ">");
          (%o2)                [4, %pi, 3, %e, %gamma]
          (%i3) sort (L, ordergreatp);
          (%o3)                [%pi, %gamma, %e, 4, 3]

     `ordermagnitudep' ordena números, constantes y expresiones
     constantes de igual modo que lo hace `<', y cualesquiera otros
     elementos lo hace igual que `orderlessp'.

          (%i1) L : [%i, 1+%i, 2*x, minf, inf, %e, sin(1), 0, 1, 2, 3, 1.0, 1.0b0];
          (%o1) [%i, %i + 1, 2 x, minf, inf, %e, sin(1), 0, 1, 2, 3, 1.0,
                                                                     1.0b0]
          (%i2) sort (L, ordermagnitudep);
          (%o2) [minf, 0, sin(1), 1, 1.0, 1.0b0, 2, %e, 3, inf, %i,
                                                               %i + 1, 2 x]
          (%i3) sort (L, orderlessp);
          (%o3) [0, 1, 1.0, 2, 3, %e, %i, %i + 1, inf, minf, sin(1),
                                                                1.0b0, 2 x]

 -- Función: sublist (<list>, <p>)
     Devuelve la lista de elementos de <list> para los cuales el
     predicado `p' retorna `true'.

     Ejemplo:

          (%i1) L: [1, 2, 3, 4, 5, 6];
          (%o1)                  [1, 2, 3, 4, 5, 6]
          (%i2) sublist (L, evenp);
          (%o2)                       [2, 4, 6]


 -- Función: sublist_indices (<L>, <P>)
     Devuelve los índices de los elementos `x' de la lista <L> para la
     cual el predicado `maybe(<P>(x))' devuelve `true', lo que excluye
     a `unknown' y a `false'.  <P> puede ser el nombre de una función o
     de una expresión lambda.  <L> debe ser una lista literal.

     Ejemplos:

          (%i1) sublist_indices ('[a, b, b, c, 1, 2, b, 3, b],
                                 lambda ([x], x='b));
          (%o1)                     [2, 3, 7, 9]
          (%i2) sublist_indices ('[a, b, b, c, 1, 2, b, 3, b], symbolp);
          (%o2)                  [1, 2, 3, 4, 7, 9]
          (%i3) sublist_indices ([1 > 0, 1 < 0, 2 < 1, 2 > 1, 2 > 0],
                                 identity);
          (%o3)                       [1, 4, 5]
          (%i4) assume (x < -1);
          (%o4)                       [x < - 1]
          (%i5) map (maybe, [x > 0, x < 0, x < -2]);
          (%o5)                [false, true, unknown]
          (%i6) sublist_indices ([x > 0, x < 0, x < -2], identity);
          (%o6)                          [2]


 -- Función: unique (<L>)
     Devuelve la lista <L> sin redundancias, es decir, sin elementos
     repetidos

     Cuando ninguno de los elementos de <L> está repetido, `unique'
     devuelve una réplica de <L>, no la propia <L>.

     Si <L> no es una lista, `unique' devuelve <L>.

     Ejemplo:

          (%i1) unique ([1, %pi, a + b, 2, 1, %e, %pi, a + b, [1]]);
          (%o1)              [1, 2, %e, %pi, [1], b + a]

 -- Función: tenth (<expr>)
     Devuelve el décimo elemento de la lista o expresión <expr>. Véase
     `first' para más detalles.


 -- Función: third (<expr>)
     Devuelve el tercer elemento de la lista o expresión <expr>. Véase
     `first' para más detalles.



File: maxima.info,  Node: Arrays,  Next: Estructuras,  Prev: Listas,  Up: Tipos de datos y estructuras

5.5 Arrays
==========

* Menu:

* Introducción a los arrays::
* Funciones y variables para los arrays::


File: maxima.info,  Node: Introducción a los arrays,  Next: Funciones y variables para los arrays,  Prev: Arrays,  Up: Arrays

5.5.1 Introducción a los arrays
-------------------------------

Los arrays más flexibles son aquellos que no necesitan ser declarados,
llamados también, en inglés, hashed-arrays, y se basan en que a una
variable subindicada se le puede asignar un valor cualquiera. Los
índices no necesitan ser números enteros, admitiéndose símbolos o
expresiones. Los arrays no declarados crecen dinámicamente según se le
van asignando valores a sus elementos. En el siguiente ejemplo se
muestra cómo se va construyendo un array no declarado `a'. Para obtener
un listado de los elementos de un array se utiliza la función
`listarray'.

     (%i1) a[1,2]: 99;
     (%o1)                          99
     (%i2) a[x,y]: x^y;
                                     y
     (%o2)                          x
     (%i3) listarray(a);
                                       y
     (%o3)                       [99, x ]

Otro tipo de arrays son los declarados, los cuales admiten hasta cinco
dimensiones y pueden guardar valores de un tipo concreto, como `fixnum'
para enteros o `flonum' para reales de coma flotante. Maxima distingue
dos tipos de arrays declarados; los primeros se pueden definir
declarando un símbolo como array, haciendo uso de la función `array';
los segundos son arrays de Lisp, en los que un símbolo se declara como
tal con la función `make_array'.

En el primer ejemplo se declara el símbolo `a' como array, mientras que
en el segundo se declara `b' como array de Lisp.

     (%i1) array(a, fixnum, 2, 2);
     (%o1)                           a
     (%i2) b: make_array(fixnum, 2, 2);
     (%o2)              {Array:  #2A((0 0) (0 0))}

Cuando a la variable opcional `use_fast_arrays' se le asigna el valor
`true', la función `array' también generará un array de Lisp.  Tal es
lo que sucede en el ejemplo siguiente, en el que el símbolo `c' queda
declarado como array de Lisp. Téngase en cuenta que por este método no
se puede asignar el tipo de array, ya que al introducirle el tipo
`fixnum' se genera un mensaje de error.

     (%i3) use_fast_arrays: true;
     (%o3)                         true
     (%i4) array(c, 2, 2);
     (%o4)    #2A((NIL NIL NIL) (NIL NIL NIL) (NIL NIL NIL))
     (%i5) c;
     (%o5)    #2A((NIL NIL NIL) (NIL NIL NIL) (NIL NIL NIL))
     (%i6) array(c, fixnum, 2, 2);

     make_array: dimensions must be integers; found [fixnum + 1, 3, 3]
      -- an error. To debug this try: debugmode(true);

Maxima también dispone de funciones array, que pueden almacenar valores
de funciones, y de funciones subindicadas.

Se puede encontrar más información en las descripciones de las
funciones. Los siguientes símbolos y funciones de Maxima permiten
trabajar con arrays:

   array         arrayapply     arrayinfo
   arraymake     arrays         fillarray
   listarray     make_array     rearray
   remarray      subvar         subvarp
   use_fast_arrays


File: maxima.info,  Node: Funciones y variables para los arrays,  Prev: Introducción a los arrays,  Up: Arrays

5.5.2 Funciones y variables para los arrays
-------------------------------------------

 -- Función: array (<nombre>, <dim_1>, ..., <dim_n>)
 -- Función: array (<nombre>, <type>, <dim_1>, ..., <dim_n>)
 -- Función: array ([<nombre_1>, ..., <nombre_m>], <dim_1>, ...,
          <dim_n>)
     Crea un array de dimensión n, que debe ser menor o igual que 5.
     Los subíndices de la i-ésima dimensión son enteros que toman
     valores entre 0 y <dim_i>.

     La llamada `array (<nombre>, <dim_1>, ..., <dim_n>)' crea un array
     de tipo general.

     La llamada `array (<nombre>, <type>, <dim_1>, ..., <dim_n>)' crea
     un array con sus elementos del tipo especificado. El tipo <type>
     puede ser `fixnum' para enteros de tamaño limitado o `flonum' para
     números decimales en coma flotante.

     La llamada `array ([<nombre_1>, ..., <nombre_m>], <dim_1>, ...,
     <dim_n>)' crea m arrays,  todos ellos de igual dimensión.

     Si el usuario asigna un valor a una variable subindicada antes de
     declarar el array correspondiente, entonces se construye un array
     no declarado. Los arrays no declarados, también conocidos por el
     nombre de "arrays de claves" (hashed arrays), son más generales
     que los arrays declarados. El usuario no necesita declarar su
     tamaño máximo y pueden ir creciendo de forma dinámica. Los
     subíndices de los arrays no declarados no necesitan ser
     necesariamente números. Sin embargo, a menos que un array tenga
     sus elementos dispersos, probablemente sea más eficiente
     declararlo siempre que sea posible antes que dejarlo como no
     declarado. La función `array' puede utilizarse para transformar un
     array no declarado a a uno declarado.


 -- Función: arrayapply (<A>, [<i_1>, ..., <i_n>])
     Evalúa `<A> [<i_1>, ..., <i_n>]', donde <A> es un array y <i_1>,
     ..., <i_n> son enteros.

     Esto es como `apply', excepto por el hecho de que el primer
     argumento es un array en lugar de una función.


 -- Función: arrayinfo (<A>)
     Devuelve información sobre el array<A>.  El argumento <A> puede
     ser un array declarado o no declarado, una función array o una
     función subindicada.

     En el caso de arrays declarados, `arrayinfo' devuelve una lista
     que contiene el átomo `declared', el número de dimensiones y el
     tamaño de cada dimensión.  Los elementos del array, tanto los que
     tienen valores asignados como los que no, son devueltos por
     `listarray'.

     En el caso de arrays no declarados (hashed arrays), `arrayinfo'
     devuelve una lista que contiene el átomo `hashed', el número de
     subíndices y los subíndices de aquellos elementos que guarden un
     valor. Los valores son devueltos por `listarray'.

     En el caso de funciones array, `arrayinfo' devuelve una lista que
     contiene el átomo `hashed', el número de subíndices y los
     subíndices para los que la función tiene valores almacenados.  Los
     valores almacenados de la función array son devueltos por
     `listarray'.

     En el caso de funciones subindicadas, `arrayinfo' devuelve una
     lista que contiene el átomo `hashed', el número de subíndices y
     los subíndices para los que hay expresiones lambda.  Las
     expresiones lambda son devueltas por `listarray'.

     Ejemplos:

     `arrayinfo' y `listarray' aplicadas a una array declarado.

          (%i1) array (aa, 2, 3);
          (%o1)                          aa
          (%i2) aa [2, 3] : %pi;
          (%o2)                          %pi
          (%i3) aa [1, 2] : %e;
          (%o3)                          %e
          (%i4) arrayinfo (aa);
          (%o4)                 [declared, 2, [2, 3]]
          (%i5) listarray (aa);
          (%o5) [#####, #####, #####, #####, #####, #####, %e, #####,
                                                  #####, #####, #####, %pi]

     `arrayinfo' y `listarray' aplicadas a una array no declarado
     (hashed arrays).

          (%i1) bb [FOO] : (a + b)^2;
                                             2
          (%o1)                       (b + a)
          (%i2) bb [BAR] : (c - d)^3;
                                             3
          (%o2)                       (c - d)
          (%i3) arrayinfo (bb);
          (%o3)               [hashed, 1, [BAR], [FOO]]
          (%i4) listarray (bb);
                                        3         2
          (%o4)                 [(c - d) , (b + a) ]

     `arrayinfo' y `listarray' aplicadas a una función array.

          (%i1) cc [x, y] := y / x;
                                               y
          (%o1)                      cc     := -
                                       x, y    x
          (%i2) cc [u, v];
                                          v
          (%o2)                           -
                                          u
          (%i3) cc [4, z];
                                          z
          (%o3)                           -
                                          4
          (%i4) arrayinfo (cc);
          (%o4)              [hashed, 2, [4, z], [u, v]]
          (%i5) listarray (cc);
                                        z  v
          (%o5)                        [-, -]
                                        4  u

     `arrayinfo' y `listarray' aplicadas a una función subindicada.

          (%i1) dd [x] (y) := y ^ x;
                                               x
          (%o1)                     dd (y) := y
                                      x
          (%i2) dd [a + b];
                                              b + a
          (%o2)                  lambda([y], y     )
          (%i3) dd [v - u];
                                              v - u
          (%o3)                  lambda([y], y     )
          (%i4) arrayinfo (dd);
          (%o4)             [hashed, 1, [b + a], [v - u]]
          (%i5) listarray (dd);
                                   b + a                v - u
          (%o5)      [lambda([y], y     ), lambda([y], y     )]


 -- Función: arraymake (<name>, [<i_1>, ..., <i_n>])
     El resultado es una referencia a array no evaluada.

     Devuelve la expresión `<name> [<i_1>, ..., <i_n>]'.

     Esta función es similar a `funmake', excepto que el valor
     retornado es referencia a un array no evaluado, en lugar de una
     llamada a una función no evaluada.

     Ejemplos:

          (%i1) arraymake (A, [1]);
          (%o1)                          A
                                          1
          (%i2) arraymake (A, [k]);
          (%o2)                          A
                                          k
          (%i3) arraymake (A, [i, j, 3]);
          (%o3)                       A
                                       i, j, 3
          (%i4) array (A, fixnum, 10);
          (%o4)                           A
          (%i5) fillarray (A, makelist (i^2, i, 1, 11));
          (%o5)                           A
          (%i6) arraymake (A, [5]);
          (%o6)                          A
                                          5
          (%i7) ''%;
          (%o7)                          36
          (%i8) L : [a, b, c, d, e];
          (%o8)                    [a, b, c, d, e]
          (%i9) arraymake ('L, [n]);
          (%o9)                          L
                                          n
          (%i10) ''%, n = 3;
          (%o10)                          c
          (%i11) A2 : make_array (fixnum, 10);
          (%o11)          {Array:  #(0 0 0 0 0 0 0 0 0 0)}
          (%i12) fillarray (A2, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o12)          {Array:  #(1 2 3 4 5 6 7 8 9 10)}
          (%i13) arraymake ('A2, [8]);
          (%o13)                         A2
                                           8
          (%i14) ''%;
          (%o14)                          9


 -- Variable del sistema: arrays
     Valor por defecto: `[]' La variable `arrays' es una lista con
     todos los arrays que han sido alojados, lo que comprende a los
     arrays declarados por `array', a los no declarados (hashed arrays)
     construidos implícitamente (asignando algo al elemento de un
     array) y a las funciones array definidas mediante `:=' y `define'.
     Los arrays definidos mediante `make_array' no se incluyen en este
     grupo.

     Véanse también `array', `arrayapply', `arrayinfo', `arraymake',
     `fillarray', `listarray' y `rearray'.

     Ejemplos:

          (%i1) array (aa, 5, 7);
          (%o1)                          aa
          (%i2) bb [FOO] : (a + b)^2;
                                             2
          (%o2)                       (b + a)
          (%i3) cc [x] := x/100;
                                             x
          (%o3)                      cc  := ---
                                       x    100
          (%i4) dd : make_array ('any, 7);
          (%o4)       {Array:  #(NIL NIL NIL NIL NIL NIL NIL)}
          (%i5) arrays;
          (%o5)                     [aa, bb, cc]


 -- Función: arraysetapply (<A>, [<i_1>, ..., <i_n>], <x>)
     Asigna <x> a `<A>[<i_1>, ..., <i_n>]', siendo <A> un array y
     <i_1>, ..., <i_n> enteros.

     `arraysetapply' evalúa sus argumentos.

 -- Función: fillarray (<A>, <B>)
     Rellena el array <A> con los valores de <B>, que puede ser una
     lista o array.

     Si se ha declarado <A> de un determinado tipo en el momento de su
     creación, sólo podrá contener elementos de ese tipo, produciéndose
     un error en caso de intentar asignarle un elemento de tipo
     distinto.

     Si las dimensiones de los arrays <A> y <B> son diferentes, <A> se
     rellena según el orden de las filas. Si no hay suficientes
     elementos en <B> el último elemento se utiliza para cubrir el
     resto de <A>. Si hay demasiados, los elementos sobrantes son
     ignorados.

     La función `fillarray' devuelve su primer argumento.

     Ejemplos:

     Creación de un array de 9 elementos y posterior relleno a partir
     de una lista.

          (%i1) array (a1, fixnum, 8);
          (%o1)                          a1
          (%i2) listarray (a1);
          (%o2)              [0, 0, 0, 0, 0, 0, 0, 0, 0]
          (%i3) fillarray (a1, [1, 2, 3, 4, 5, 6, 7, 8, 9]);
          (%o3)                          a1
          (%i4) listarray (a1);
          (%o4)              [1, 2, 3, 4, 5, 6, 7, 8, 9]

     Si no hay suficientes elementos para cubrir el array, se repite el
     último elemento. Si hay demasiados, los elementos sobrantes son
     ignorados.

          (%i1) a2 : make_array (fixnum, 8);
          (%o1)             {Array:  #(0 0 0 0 0 0 0 0)}
          (%i2) fillarray (a2, [1, 2, 3, 4, 5]);
          (%o2)             {Array:  #(1 2 3 4 5 5 5 5)}
          (%i3) fillarray (a2, [4]);
          (%o3)             {Array:  #(4 4 4 4 4 4 4 4)}
          (%i4) fillarray (a2, makelist (i, i, 1, 100));
          (%o4)             {Array:  #(1 2 3 4 5 6 7 8)}

     Arrays multidimensionales se rellenan según el orden de las filas.

          (%i1) a3 : make_array (fixnum, 2, 5);
          (%o1)        {Array:  #2A((0 0 0 0 0) (0 0 0 0 0))}
          (%i2) fillarray (a3, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o2)        {Array:  #2A((1 2 3 4 5) (6 7 8 9 10))}
          (%i3) a4 : make_array (fixnum, 5, 2);
          (%o3)     {Array:  #2A((0 0) (0 0) (0 0) (0 0) (0 0))}
          (%i4) fillarray (a4, a3);
          (%o4)     {Array:  #2A((1 2) (3 4) (5 6) (7 8) (9 10))}


 -- Función: listarray (<A>)
     Devuelve una lista con los elementos del array <A>.  El argumento
     <A> puede ser un array declarado o no declarado, una función array
     o una función subindicada.

     Los elementos se ordenan en primera instancia respecto del primer
     índice, después respecto del segundo índice y así sucesivamente.
     La ordenación de los índices es la misma que la establecida por
     `orderless'.

     En el caso de arrays no declarados, funciones array y funciones
     subindicadas, los elementos corresponden a los índices devueltos
     por `arrayinfo'.

     Los elementos de los arrays declarados que no tienen valores
     asignados (excepto `fixnum' y `flonum') se devuelven como `#####'.
     Los elementos sin valores asignados de los arrays `fixnum' y
     `flonum' son devueltos como 0 y 0.0, respectivamente.  Los
     elementos sin valor asignado de los arrays no declarados,
     funciones array y funciones subindicadas no son devueltos.

     Ejemplos:

     `listarray' y `arrayinfo' aplicadas a un array declarado.

          (%i1) array (aa, 2, 3);
          (%o1)                          aa
          (%i2) aa [2, 3] : %pi;
          (%o2)                          %pi
          (%i3) aa [1, 2] : %e;
          (%o3)                          %e
          (%i4) listarray (aa);
          (%o4) [#####, #####, #####, #####, #####, #####, %e, #####,
                                                  #####, #####, #####, %pi]
          (%i5) arrayinfo (aa);
          (%o5)                 [declared, 2, [2, 3]]

     `listarray' y `arrayinfo' aplicadas a un array no declarado
     (hashed array).

          (%i1) bb [FOO] : (a + b)^2;
                                             2
          (%o1)                       (b + a)
          (%i2) bb [BAR] : (c - d)^3;
                                             3
          (%o2)                       (c - d)
          (%i3) listarray (bb);
                                        3         2
          (%o3)                 [(c - d) , (b + a) ]
          (%i4) arrayinfo (bb);
          (%o4)               [hashed, 1, [BAR], [FOO]]

     `listarray' y `arrayinfo' aplicadas a una función array.

          (%i1) cc [x, y] := y / x;
                                               y
          (%o1)                      cc     := -
                                       x, y    x
          (%i2) cc [u, v];
                                          v
          (%o2)                           -
                                          u
          (%i3) cc [4, z];
                                          z
          (%o3)                           -
                                          4
          (%i4) listarray (cc);
                                        z  v
          (%o4)                        [-, -]
                                        4  u
          (%i5) arrayinfo (cc);
          (%o5)              [hashed, 2, [4, z], [u, v]]

     `listarray' y `arrayinfo' aplicadas a una función subindicada.

          (%i1) dd [x] (y) := y ^ x;
                                               x
          (%o1)                     dd (y) := y
                                      x
          (%i2) dd [a + b];
                                              b + a
          (%o2)                  lambda([y], y     )
          (%i3) dd [v - u];
                                              v - u
          (%o3)                  lambda([y], y     )
          (%i4) listarray (dd);
                                   b + a                v - u
          (%o4)      [lambda([y], y     ), lambda([y], y     )]
          (%i5) arrayinfo (dd);
          (%o5)             [hashed, 1, [b + a], [v - u]]


 -- Función: make_array (<tipo>, <dim_1>, ..., <dim_n>)
     Construye y devuelve un array de Lisp. El argumento <tipo> puede
     ser `any', `flonum', `fixnum', `hashed' o `functional'.  Hay n
     índices, y el índice i-ésimo va de  0 a <dim_i> - 1.

     La ventaja de `make_array' sobre `array' estriba en que el valor
     retornado no tiene nombre, y una vez que un puntero deja de
     referenciarlo, el valor desaparece. Por ejemplo, si `y: make_array
     (...)' entonces `y' apunta a un objeto que ocupa cierto espacio en
     la memoria, pero después de `y: false', `y' ya no apunta al
     objeto, por lo que éste puede ser considerado basura y
     posteriormente eliminado.

     Ejemplos:

          (%i1) A1 : make_array (fixnum, 10);
          (%o1)           {Array:  #(0 0 0 0 0 0 0 0 0 0)}
          (%i2) A1 [8] : 1729;
          (%o2)                         1729
          (%i3) A1;
          (%o3)          {Array:  #(0 0 0 0 0 0 0 0 1729 0)}
          (%i4) A2 : make_array (flonum, 10);
          (%o4) {Array:  #(0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0)}
          (%i5) A2 [2] : 2.718281828;
          (%o5)                      2.718281828
          (%i6) A2;
          (%o6)
               {Array:  #(0.0 0.0 2.718281828 0.0 0.0 0.0 0.0 0.0 0.0 0.0)}
          (%i7) A3 : make_array (any, 10);
          (%o7) {Array:  #(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)}
          (%i8) A3 [4] : x - y - z;
          (%o8)                      - z - y + x
          (%i9) A3;
          (%o9) {Array:  #(NIL NIL NIL NIL ((MPLUS SIMP) $X ((MTIMES SIMP)\
           -1 $Y) ((MTIMES SIMP) -1 $Z))
            NIL NIL NIL NIL NIL)}
          (%i10) A4 : make_array (fixnum, 2, 3, 5);
          (%o10) {Array:  #3A(((0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0)) ((0 0 \
          0 0 0) (0 0 0 0 0) (0 0 0 0 0)))}
          (%i11) fillarray (A4, makelist (i, i, 1, 2*3*5));
          (%o11) {Array:  #3A(((1 2 3 4 5) (6 7 8 9 10) (11 12 13 14 15))
              ((16 17 18 19 20) (21 22 23 24 25) (26 27 28 29 30)))}
          (%i12) A4 [0, 2, 1];
          (%o12)                         12


 -- Función: rearray (<A>, <dim_1>, ..., <dim_n>)
     Cambia las dimensiones de un array. El nuevo array será rellenado
     con los elementos del viejo según el orden de las filas. Si el
     array antiguo era demasiado pequeño, los elementos restantes se
     rellenan con `false', `0.0' o `0', dependiendo del tipo del array.
     El tipo del array no se puede cambiar.


 -- Función: remarray (<A_1>, ..., <A_n>)
 -- Función: remarray (all)
     Borra los arrays y las funciones relacionadas con ellos, liberando
     el espacio de memoria ocupado.  Los argumentos pueden ser arrays
     declarados, arrays no declarados (hashed arrays), funciones array
     y funciones subindicadas.

     La llamada `remarray (all)' borra todos los elementos de la lista
     global `arrays'.

     La función `remarray' devuelve la lista de los arrays borrados.

     La función `remarray' no evalúa sus argumentos.


 -- Función: subvar (<x>, <i>)
     Evalúa la expresión subindicada `<x>[<i>]'.

     La función `subvar' evalúa sus argumentos.

     La instrucción `arraymake (<x>, [<i>])' construye la expresión
     `<x>[<i>]', pero no la evalúa.

     Ejemplos:

          (%i1) x : foo $

          (%i2) i : 3 $

          (%i3) subvar (x, i);
          (%o3)                         foo
                                           3
          (%i4) foo : [aa, bb, cc, dd, ee]$

          (%i5) subvar (x, i);
          (%o5)                          cc
          (%i6) arraymake (x, [i]);
          (%o6)                         foo
                                           3
          (%i7) ''%;
          (%o7)                          cc


 -- Función: subvarp (<expr>)
     Devuelve `true' si <expr> es una variable subindicada, como `a[i]'.


 -- Variable opcional: use_fast_arrays
     Valor por defecto: `false'

     Si `use_fast_arrays' vale `true' entonces tan solo se reconocen
     dos tipos de arrays.



File: maxima.info,  Node: Estructuras,  Prev: Arrays,  Up: Tipos de datos y estructuras

5.6 Estructuras
===============

* Menu:

* Introducción a las estructuras::
* Funciones y variables para las estructuras::


File: maxima.info,  Node: Introducción a las estructuras,  Next: Funciones y variables para las estructuras,  Prev: Estructuras,  Up: Estructuras

5.6.1 Introducción a las estructuras
------------------------------------

Maxima dispone de estructuras para la agregación de datos.  Una
estructura es una expresión en la que los argumentos se definen con un
nombre (nombre del campo) y la estructura en su conjunto se define por
medio de su operador (nombre de la estructura). Los valores dados a los
campos pueden ser expresiones cualesquiera.

Una estructura se define con la función `defstruct', guardando la
variable `structures' la lista de todas las estructuras definidas por
el usuario. El operador `@' permite hacer referencias a los campos de
la estructura. Con `kill(<S>)' se borra la estructura <S> completa y
`kill(<x>@ <a>)' elimina la asignación actual del campo <a> en la
estructura <x>.

En la impresión por consola (con `display2d' igual a `true'), las
estructuras se representan con las asignaciones de los campos en forma
de ecuación, con el nombre del campo a la izquierda y su valor asociado
a la derecha. En la impresión unidimensional (mediante `grind' o
dándole a `display2d' el valor `false'), las estructuras se escriben
sin los nombres de los campos.

No es posible utilizar el nombre de un campo como nombre de función,
pero el valor de un campo sí puede ser una expresión lambda.  Tampoco
es posible restringir los valores de los campos a tipos de datos
concretos, siendo el caso que a cada campo se le puede asignar cualquier
tipo de expresión. Por último, no es posible hacer que ciertos campos
sean o no accesibles desde determinados contextos, ya que todos los
campos son siempre visibles.


File: maxima.info,  Node: Funciones y variables para las estructuras,  Prev: Introducción a las estructuras,  Up: Estructuras

5.6.2 Funciones y variables para las estructuras
------------------------------------------------

 -- Variable global: structures
     `structures' es la lista que contiene las estructuras definidas
     por el usuario con `defstruct'.


 -- Función: defstruct (<S>(<a_1>, ..., <a_n>))
 -- Función: defstruct (<S>(<a_1> = <v_1>, ..., <a_n> = <v_n>))
     Define una estructura, la cual es una lista de nombres de campos
     <a_1>, ..., <a_n> asociados a un símbolo <S>.  Todo individuo de
     una estructura dada consiste en una expresión con operador <S> y
     exactamente `n' argumentos. La sentencia `new(<S>)' crea un nuevo
     individuo con estructura <S>.

     Un argumento consistente en un símbolo <a> especifica el nombre de
     un campo. Un argumento consistente en una ecuación `<a> = <v>'
     especifica el nombre del campo <a> junto con su valor por defecto
     <v>. El valor por defecto puede ser cualquier tipo de expresión.

     La llamada a `defstruct' añade <S> a la lista de estructuras
     definidas por el usuario, `structures'.

     La sentencia `kill(<S>)' borra <S> de la lista de estructuras
     definidas por el usuario y elimina la definición de la estructura.

     Ejemplos:

          (%i1) defstruct (foo (a, b, c));
          (%o1)                    [foo(a, b, c)]
          (%i2) structures;
          (%o2)                    [foo(a, b, c)]
          (%i3) new (foo);
          (%o3)                     foo(a, b, c)
          (%i4) defstruct (bar (v, w, x = 123, y = %pi));
          (%o4)             [bar(v, w, x = 123, y = %pi)]
          (%i5) structures;
          (%o5)      [foo(a, b, c), bar(v, w, x = 123, y = %pi)]
          (%i6) new (bar);
          (%o6)              bar(v, w, x = 123, y = %pi)
          (%i7) kill (foo);
          (%o7)                         done
          (%i8) structures;
          (%o8)             [bar(v, w, x = 123, y = %pi)]


 -- Función: new (<S>)
 -- Función: new (<S> (<v_1>, ..., <v_n>))
     `new' crea nuevos individuos de estructuras declaradas.

     La sentencia `new(<S>)' crea un nuevo individuo de estructura <S>
     en el que cada campo toma su valor por defecto, si este fue
     definido, o sin valor alguno en caso de que no se haya fijado un
     valor por defecto en la definición de la estructura.

     La sentencia `new(<S>(<v_1>, ..., <v_n>))' crea un nuevo individuo
     de estructura <S> en el que los campos adquieren los valores
     <v_1>, ..., <v_n>.

     Ejemplos:

          (%i1) defstruct (foo (w, x = %e, y = 42, z));
          (%o1)              [foo(w, x = %e, y = 42, z)]
          (%i2) new (foo);
          (%o2)               foo(w, x = %e, y = 42, z)
          (%i3) new (foo (1, 2, 4, 8));
          (%o3)            foo(w = 1, x = 2, y = 4, z = 8)


 -- Operador: @
     `@' es el operador para acceder a los campos de las estructuras.

     La expresión `<x>@ <a>' hace referencia al valor del campo <a> del
     individuo <x> de una estructura dada. El nombre del campo no se
     evalúa.

     Si el campo <a> de <x> no tiene valor asignado, `<x>@ <a>' se
     evalúa a sí mismo; es decir, devuelve la propia expresión `<x>@
     <a>' tal cual.

     La sentencia `kill(<x>@ <a>)' elimina el valor del campo <a> de
     <x>.

     Ejemplos:

          (%i1) defstruct (foo (x, y, z));
          (%o1)                    [foo(x, y, z)]
          (%i2) u : new (foo (123, a - b, %pi));
          (%o2)           foo(x = 123, y = a - b, z = %pi)
          (%i3) u@z;
          (%o3)                          %pi
          (%i4) u@z : %e;
          (%o4)                          %e
          (%i5) u;
          (%o5)            foo(x = 123, y = a - b, z = %e)
          (%i6) kill (u@z);
          (%o6)                         done
          (%i7) u;
          (%o7)              foo(x = 123, y = a - b, z)
          (%i8) u@z;
          (%o8)                          u@z

     El nombre del campo no se evalúa.

          (%i1) defstruct (bar (g, h));
          (%o1)                      [bar(g, h)]
          (%i2) x : new (bar);
          (%o2)                       bar(g, h)
          (%i3) x@h : 42;
          (%o3)                          42
          (%i4) h : 123;
          (%o4)                          123
          (%i5) x@h;
          (%o5)                          42
          (%i6) x@h : 19;
          (%o6)                          19
          (%i7) x;
          (%o7)                    bar(g, h = 19)
          (%i8) h;
          (%o8)                          123



File: maxima.info,  Node: Operadores,  Next: Evaluación,  Prev: Tipos de datos y estructuras,  Up: Top

6 Operadores
************

* Menu:

* Introducción a los operadores::
* Operadores aritméticos::
* Operadores relacionales::
* Operadores lógicos::
* Operadores para ecuaciones::
* Operadores de asignación::
* Operadores definidos por el usuario::


File: maxima.info,  Node: Introducción a los operadores,  Next: Operadores aritméticos,  Prev: Operadores,  Up: Operadores

6.1 Introducción a los operadores
=================================

Maxima reconoce los operadores aritméticos, relacionales y lógicos
usuales de la matemática. Además, Maxima dispone de operadores para la
asignación de valores a variables y la definición de funciones.  La
siguiente tabla muestra los operadores que se describen en este
capítulo, en la que se incluye el nombre del operador, el rango de
enlace por la izquierda `lbp', el rango de enlace por la derecha `rbp',
el tipo de operador y un ejemplo, para finalizar, en cada caso, con su
formato interno tal como es leída por el analizador sintáctico.


Operador  lbp rbp  Tipo     Ejemplo  Formato interno

   +      100 134  nary     a+b      ((mplus) $A $B)
   -      100 134  prefix   -a       ((mminus) $A)
   *      120      nary     a*b      ((mtimes) $A $B)
   /      120 120  infix    a/b      ((mquotient) $A $B)
   ^      140 139  infix    a^b      ((mexpt) $A $B)
   **     140 139  infix    a**b     ((mexpt) $A $B)
   ^^     140 139  infix    a^^b     ((mncexpt) $A $B)
   .      130 129  infix    a.b      ((mnctimes) $A $B)

   <       80  80  infix    a<b      ((mlessp) $A $B)
   <=      80  80  infix    a<=b     ((mleqp) $A $B)
   >       80  80  infix    a>b      ((mqreaterp) $A $B)
   >=      80  80  infix    a>=b     ((mgeqp) $A $B)

   not         70  prefix   not a    ((mnot) $A)
   and     65      nary     a and b  ((mand) $A $B)
   or      60      nary     a or b   ((mor) $A $B)

   #       80  80  infix    a#b      ((mnotequal) $A $B)
   =       80  80  infix    a=b      ((mequal) $A $B)

   :      180  20  infix    a:b      ((msetq) $A $B)
   ::     180  20  infix    a::b     ((mset) $A $B)
   :=     180  20  infix    a:=b     ((mdefine) $A $B)
   ::=    180  20  infix    a::=b    ((mdefmacro) $A $B)

Con los rangos de enlace de los operadores se definen las reglas de
prioridad de cálculo de los mismos. Así, por ejemplo, el analizador
sintáctico interpreta la expresión ` a + b * c ' como ` a + (b * c) ',
pues el rango de enlace por la izquierda de la multiplicación es mayor
que rango de enlace por la izquierda de la suma.

Maxima clasifica los operadores de la siguiente manera:

_Prefijo (prefix)_
     Los operadores prefijos son unarios con un único operando que se
     escribe a continuación del operando. Ejemplos son `-' y `not'.

_Sufijo (postfix)_
     Los operadores sufijos son unarios con un único operando que se
     escribe precediendo al operando. Un ejemplo es el factorial `!'.

_Infijo (infix)_
     Los operadores infijos son operadores binarios que necesitan dos
     operandos, los cuales se colocan uno a cada lado del operador.
     Ejemplos son el operador para la exponenciación, `^', y el
     operador de asignación, `:'.

_N-ario (n-ary)_
     Los operadores n-arios admiten un número arbitrario de operandos.
     Son ejemplos la multiplicación, `*', y la suma, `+'.

_Acotador (matchfix)_
     Los acotadores son operadores que se utilizan para establecer el
     comienzo y final de una lista de operandos. Los operadores `[' y
     `]' son ejemplos de acotadores, que se utilizan para definir una
     lista tal como `[a, b, ...]'.

_No-fijo (nofix)_
     Un operador no-fijo carece de operandos. Maxima no tiene
     operadores internos no-fijos, pero se pueden crear como cuando se
     escribe `nofix(quit)', lo que permite obviar el uso de paréntesis,
     y utilizar simplemente `quit' en lugar de `quit()', para cerrar
     una sesión de Maxima.

En la sección dedicada a los operadores definidos por el usuario se
describe cómo redefinir los operadores internos de Maxima y cómo crear
otros nuevos.

El mecanismo para definir un nuevo operador es sencillo.  Tan solo es
necesario declarar una función como operador; la función operador puede
estar definida o no.

Un ejemplo de operador definido por el usuario es el siguiente.  Nótese
que la llamada a función `"dd" (a)' equivale a `dd a', de igual manera
que  `"<-" (a, b)' también equivale a `a <- b'.  Nótese también que las
funciones `"dd"' y `"<-"' no están definidas en este ejemplo.

     (%i1) prefix ("dd");
     (%o1)                          dd
     (%i2) dd a;
     (%o2)                         dd a
     (%i3) "dd" (a);
     (%o3)                         dd a
     (%i4) infix ("<-");
     (%o4)                          <-
     (%i5) a <- dd b;
     (%o5)                      a <- dd b
     (%i6) "<-" (a, "dd" (b));
     (%o6)                      a <- dd b

La tabla anterior no incluye todos los operadores definidos en Maxima,
ya que también lo son `!' para el factorial, `for', `do' y `while' para
programar bucles, o `if', `then' y `else' para definir condicionales.

Las funciones `remove' y `kill' eliminan propiedades de operadores de
un átomo.  La llamada `remove ("<a>", op)' sólo elimina las propiedades
de operador de <a>.  La llamada `kill ("<a>")' elimina todas las
propiedades de <a>, incluidas las propiedades de operador.  Nótese que
el nombre del operador debe ir entre comillas.

     (%i1) infix ("##");
     (%o1)                          ##
     (%i2) "##" (a, b) := a^b;
                                          b
     (%o2)                     a ## b := a
     (%i3) 5 ## 3;
     (%o3)                          125
     (%i4) remove ("##", op);
     (%o4)                         done
     (%i5) 5 ## 3;
     Incorrect syntax: # is not a prefix operator
     5 ##
       ^
     (%i5) "##" (5, 3);
     (%o5)                          125
     (%i6) infix ("##");
     (%o6)                          ##
     (%i7) 5 ## 3;
     (%o7)                          125
     (%i8) kill ("##");
     (%o8)                         done
     (%i9) 5 ## 3;
     Incorrect syntax: # is not a prefix operator
     5 ##
       ^
     (%i9) "##" (5, 3);
     (%o9)                       ##(5, 3)


File: maxima.info,  Node: Operadores aritméticos,  Next: Operadores relacionales,  Prev: Introducción a los operadores,  Up: Operadores

6.2 Operadores aritméticos
==========================

 -- Operador: +
 -- Operador: -
 -- Operador: *
 -- Operador: /
 -- Operador: ^
     Los símbolos `+' `*' `/' y `^' representan la suma, resta,
     multiplicación, división y exponenciación, respectivamente.  Los
     nombres de estos operadores son `"+"' `"*"' `"/"' y `"^"', que
     pueden aparecer allá donde se requiera el nombre de una función u
     operador.

     Los símbolos `+' y `-' representan el positivo y negativo unario,
     siendo los nombres de estos operadores `"+"' y `"-"',
     respectivamente.

     En Maxima, la resta `a - b' se representa como la suma `a + (- b)'.
     Expresiones tales como `a + (- b)' se muestran como restas. Maxima
     reconoce `"-"' tan solo como el operador de negación unaria, no
     como el nombre del operador de resta binaria.

     La división `a / b' se representa en maxima como la multiplicación
     `a * b^(- 1)'. Expresiones tales como `a * b^(- 1)' se muestran
     como divisiones. Maxima reconoce `"/"' como el nombre del operador
     de división.

     La suma y la multiplicación son operadores conmutativos n-arios. La
     división y la exponenciación son operadores no conmutativos
     binarios.

     Maxima ordena los operandos de los operadores conmutativos para
     formar lo que se conoce como representación canónica. A efectos de
     almacenamiento interno, la ordenación viene determinada por
     `orderlessp'.  A efectos de presentación de las expresiones, la
     ordenación de la suma la determina `ordergreatp', y en el caso de
     la multiplicación, la ordenación coincide con la del
     almacenamiento interno.

     Los cálculos aritméticos se realizan con números literales
     (enteros, racionales, decimales ordinarios y decimales grandes).
     Excepto en el caso de la exponenciación, todas las operaciones
     aritméticas con números dan lugar a resultados en forma de
     números. La exponenciación da como resultado un número si alguno
     de los operandos es decimal ordinario o grande (bigfloat), o si el
     resultado es un entero o racional; en caso contrario, la
     exponenciación puede expresarse como una raíz cuadrada (`sqrt'),
     como otra potencia, o simplemente no sufre cambios.

     Se produce contagio de los decimales en coma flotante en los
     cálculos aritméticos: si algún operando es un número decimal
     grande (bigfloat), el resultado será también un número decimal
     grande; no habiendo decimales grandes, pero sí ordinarios, el
     resultado srá también un decimal ordinario; de no haber operandos
     decimales, el resultado será un número racional o entero.

     Los cálculos aritméticos son simplificaciones, no evaluaciones,
     por lo que se realizan en expresiones comentadas.

     Las operaciones aritméticas se aplican elemento a elemento en el
     caso de las listas cuando la variable global `listarith' vale
     `true'; pero en el caso de las matrices, siempre se aplican
     elemento a elemento.  Cuando un operando es una lista o matriz y
     otro operando lo es de otro tipo cualquiera, éste se combina con
     cada uno de los elementos de la lista o matriz.

     Ejemplos:

     La suma y la multiplicación son operadores conmutativos n-arios.
     Maxima ordena los operandos para formar lo que se conoce como
     representación canónica. Los nombres de estos operadores son `"+"'
     y `"-"'.

          (%i1) c + g + d + a + b + e + f;
          (%o1)               g + f + e + d + c + b + a
          (%i2) [op (%), args (%)];
          (%o2)              [+, [g, f, e, d, c, b, a]]
          (%i3) c * g * d * a * b * e * f;
          (%o3)                     a b c d e f g
          (%i4) [op (%), args (%)];
          (%o4)              [*, [a, b, c, d, e, f, g]]
          (%i5) apply ("+", [a, 8, x, 2, 9, x, x, a]);
          (%o5)                    3 x + 2 a + 19
          (%i6) apply ("*", [a, 8, x, 2, 9, x, x, a]);
                                           2  3
          (%o6)                       144 a  x

     La división y la exponenciación son operadores no conmutativos
     binarios.  Los nombres de estos operadores son `"/"' y `"^"'.

          (%i1) [a / b, a ^ b];
                                        a   b
          (%o1)                        [-, a ]
                                        b
          (%i2) [map (op, %), map (args, %)];
          (%o2)              [[/, ^], [[a, b], [a, b]]]
          (%i3) [apply ("/", [a, b]), apply ("^", [a, b])];
                                        a   b
          (%o3)                        [-, a ]
                                        b

     La resta y la división se representan internamente en términos de
     la suma y multiplicación, respectivamente.

          (%i1) [inpart (a - b, 0), inpart (a - b, 1), inpart (a - b, 2)];
          (%o1)                      [+, a, - b]
          (%i2) [inpart (a / b, 0), inpart (a / b, 1), inpart (a / b, 2)];
                                             1
          (%o2)                       [*, a, -]
                                             b

     Los cálculos se realizan con números literales.  Se produce el
     contagio de los números decimales.

          (%i1) 17 + b - (1/2)*29 + 11^(2/4);
                                                 5
          (%o1)                   b + sqrt(11) + -
                                                 2
          (%i2) [17 + 29, 17 + 29.0, 17 + 29b0];
          (%o2)                   [46, 46.0, 4.6b1]

     Los cálculos aritméticos son una simplificación, no una evaluación.

          (%i1) simp : false;
          (%o1)                         false
          (%i2) '(17 + 29*11/7 - 5^3);
                                        29 11    3
          (%o2)                    17 + ----- - 5
                                          7
          (%i3) simp : true;
          (%o3)                         true
          (%i4) '(17 + 29*11/7 - 5^3);
                                          437
          (%o4)                         - ---
                                           7

     Los cálculos aritméticos se realizan elemento a elemento en las
     listas (según sea el valor de `listarith') y matrices.

          (%i1) matrix ([a, x], [h, u]) - matrix ([1, 2], [3, 4]);
                                  [ a - 1  x - 2 ]
          (%o1)                   [              ]
                                  [ h - 3  u - 4 ]
          (%i2) 5 * matrix ([a, x], [h, u]);
                                    [ 5 a  5 x ]
          (%o2)                     [          ]
                                    [ 5 h  5 u ]
          (%i3) listarith : false;
          (%o3)                         false
          (%i4) [a, c, m, t] / [1, 7, 2, 9];
                                    [a, c, m, t]
          (%o4)                     ------------
                                    [1, 7, 2, 9]
          (%i5) [a, c, m, t] ^ x;
                                                x
          (%o5)                     [a, c, m, t]
          (%i6) listarith : true;
          (%o6)                         true
          (%i7) [a, c, m, t] / [1, 7, 2, 9];
                                        c  m  t
          (%o7)                     [a, -, -, -]
                                        7  2  9
          (%i8) [a, c, m, t] ^ x;
                                    x   x   x   x
          (%o8)                   [a , c , m , t ]


 -- Operador: **
     Operador de exponenciación.  Maxima identifica `**' con el
     operador `^' en la entrada de expresiones, pero se representa como
     `^' en las salidas no formateadas (`display2d=false'), o colocando
     un superíndice en la salida formateada (`display2d=true').

     La función `fortran' representa el operador de exponenciación con
     `**', tanto si se ha introducido como `**' o como `^'.

     Ejemplos:

          (%i1) is (a**b = a^b);
          (%o1)                         true
          (%i2) x**y + x^z;
                                        z    y
          (%o2)                        x  + x
          (%i3) string (x**y + x^z);
          (%o3)                        x^z+x^y
          (%i4) fortran (x**y + x^z);
                x**z+x**y
          (%o4)                         done


 -- Operator: ^^
     Operador de exponenciación no conmutativa.  Se trata del operador
     de exponenciación correspondiente a la multiplicación no
     conmutativa `.', del mismo modo que el operador de exponenciación
     ordinario `^' se corresponde con la multiplicación conmutativa `*'.

     La exponenciación no conmutativa se representa como `^^' en las
     salidas no formateadas (`display2d=false'), o colocando un
     superíndice entre ángulos (`< >') en la salida formateada
     (`display2d=true').

     Ejemplos:

          (%i1) a . a . b . b . b + a * a * a * b * b;
                                  3  2    <2>    <3>
          (%o1)                  a  b  + a    . b
          (%i2) string (a . a . b . b . b + a * a * a * b * b);
          (%o2)                  a^3*b^2+a^^2 . b^^3


 -- Operador: .
     El operador punto, para multiplicación de matrices
     (no-conmutativo).  Cuando `"."' se usa de esta forma, se dejarán
     espacios a ambos lados de éste, como en `A . B'. Así se evita que
     se confunda con el punto decimal de los números.

     Véanse: `dot', `dot0nscsimp', `dot0simp', `dot1simp', `dotassoc',
     `dotconstrules', `dotdistrib', `dotexptsimp', `dotident' y
     `dotscrules'.



File: maxima.info,  Node: Operadores relacionales,  Next: Operadores lógicos,  Prev: Operadores aritméticos,  Up: Operadores

6.3 Operadores relacionales
===========================

 -- Operator: <
 -- Operator: <=
 -- Operator: >=
 -- Operator: >
     Los símbolos `<', `<=', `>=' y `>' representan menor que, menor o
     igual que, mayor o igual que y mayor que, respectivamente.  Los
     nombres de estos operadores son `"<"' `"<="' `">="' y `">"', que
     pueden aparecer allá donde se requiera el nombre de una función u
     operador.

     Estos operadores relacionales son todos operadores binarios. Maxima
     no reconoce expresiones del estilo `a < b < c'.

     Las expresiones relacionales devuelven valores booleanos haciendo
     uso de las funciones `is' o `maybe', así como de las sentencias
     condicionales `if', `while' y `unless'.  Las expresiones
     relacionales no se evalúan de otra manera, aunque sus argumentos
     sí sean evaluados.

     Cuando una expresión relacional no pueda ser evaluada a `true' o
     `false', el comportamiento de `is' y de `if' estará controlado por
     la variable global `prederror'. Si `prederror' toma el valor
     `true', `is' y `if' emiten un mensaje de error. Si `prederror'
     toma el valor `false', `is' devuelve `unknown' y `if' devuelve una
     expresión condicional parcialmente evaluada.

     `maybe' se comporta siempre como si `prederror' fuese `false', al
     tiempo que `while' y `unless' se comportan siempre como si
     `prederror' fuese `true'.

     Los operadores relacionales no se distribuyen sobre listas ni
     sobre cualesquiera otros tipos de estructuras de datos.

     Véanse también `=', `#', `equal' y `notequal'.

     Ejemplos:

     Las expresiones relacionales se reducen a valores booleanos a
     través de ciertas funciones y sentencias condicionales.

          (%i1) [x, y, z] : [123, 456, 789];
          (%o1)                    [123, 456, 789]
          (%i2) is (x < y);
          (%o2)                         true
          (%i3) maybe (y > z);
          (%o3)                         false
          (%i4) if x >= z then 1 else 0;
          (%o4)                           0
          (%i5) block ([S], S : 0,
                       for i:1 while i <= 100 do S : S + i, return (S));
          (%o5)                         5050

     Las expresiones relacionales no se evalúan de otra manera, aunque
     sus argumentos sí sean evaluados.

          (%o1)                    [123, 456, 789]
          (%i2) [x < y, y <= z, z >= y, y > z];
          (%o2)    [123 < 456, 456 <= 789, 789 >= 456, 456 > 789]
          (%i3) map (is, %);
          (%o3)               [true, true, true, false]



File: maxima.info,  Node: Operadores lógicos,  Next: Operadores para ecuaciones,  Prev: Operadores relacionales,  Up: Operadores

6.4 Operadores lógicos
======================

 -- Operador: and
     Operador de conjunción lógica.  El operador `and' es un operador
     infijo `n'-ario; sus operandos son expresiones booleanas y su
     resultado es un valor lógico.

     El operador `and' impone la evaluación (igual que `is') de uno o
     más operandos, y puede forzar la evaluación de todos los operandos.

     Los operandos se evalúan en el orden en el que aparecen; sólo
     evalúa tantos operandos como sean necesarios para determinar el
     resultado.  Si algún operando vale `false', el resultado es
     `false' y ya no se evalúan más operandos.

     La variable global `prederror' controla el comportamiento de `and'
     cuando la evaluación de un operando no da como resultado `true' o
     `false'; `and' imprime un mensaje de error cuando `prederror' vale
     `true'.  Cuando los operandos devuelven un valor diferente a
     `true' o `false' al ser evaluados, el resultado es una expresión
     booleana.

     El operador `and' no es conmutativo: `a and b' puede no ser igual
     a `b and a' debido al tratamiento de operandos indeterminados.


 -- Operador: not
     Operador de negación lógica. El operador `not' es un operador
     prefijo; su operando es una expresión booleana y su resultado es
     un valor lógico.

     El operador `not' impone la evaluación (igual que `is') de su
     operando.

     La variable global `prederror' controla el comportamiento de `not'
     cuando la evaluación de su operando no da como resultado `true' o
     `false'; `not' imprime un mensaje de error cuando `prederror' vale
     `true'.  Cuando los operandos devuelven un valor diferente a
     `true' o `false' al ser evaluados, el resultado es una expresión
     booleana.


 -- Operador: or
     Operador de disyunción lógica. El operador `or' es un operador
     infijo `n'-ario; sus operandos son expresiones booleanas y su
     resultado es un valor lógico.

     El operador `or' impone la evaluación (igual que `is') de uno o
     más operandos, y puede forzar la evaluación de todos los operandos.

     Los operandos se evalúan en el orden en el que aparecen; `or' sólo
     evalúa tantos operandos como sean necesarios para determinar el
     resultado. Si un operando vale `true', el resultado es `true' y ya
     no se evalúan más operandos.

     La variable global `prederror' controla el comportamiento de `or'
     cuando la evaluación de un operando no da como resultado `true' o
     `false'; `or' imprime un mensaje de error cuando `prederror' vale
     `true'.  Cuando los operandos devuelven un valor diferente a
     `true' o `false' al ser evaluados, el resultado es una expresión
     booleana.

     El operador `or' no es conmutativo: `a or b' puede no ser igual a
     `b or a' debido al tratamiento de operandos indeterminados.



File: maxima.info,  Node: Operadores para ecuaciones,  Next: Operadores de asignación,  Prev: Operadores lógicos,  Up: Operadores

6.5 Operadores para ecuaciones
==============================

 -- Operador: #
     Representa la negación de la igualdad sintáctica `='.

     Nótese que debido a las reglas de evaluación de expresiones de
     tipo predicado (en concreto debido a que `not <expr>' obliga a la
     evaluación previa de <expr>), `not <a> = <b>' equivale a `is(<a> #
     <b>)', pero no a `<a> # <b>'.

     Ejemplos:

          (%i1) a = b;
          (%o1)                         a = b
          (%i2) is (a = b);
          (%o2)                         false
          (%i3) a # b;
          (%o3)                         a # b
          (%i4) not a = b;
          (%o4)                         true
          (%i5) is (a # b);
          (%o5)                         true
          (%i6) is (not a = b);
          (%o6)                         true


 -- Operador: =
     Operador de ecuación.

     La expresión `<a> = <b>' representa una ecuación sin evaluar, la
     cual puede verificarse o no. Las ecuaciones sin evaluar pueden
     aparecer como argumentos de `solve', `algsys' y de algunas otras
     funciones.

     La función `is' evalúa el operador `=' a un resultado booleano;
     `is(<a> = <b>)' asigna un valor de verdad a `<a> = <b>', siendo
     `true' si <a> y <b> son idénticos, lo cual acontece si ambos <a> y
     <b> son átomos idénticos, o si no siendo átomos, sus operadores y
     argumentos respectivos son idénticos; en caso contrario, `is(<a> =
     <b>)' devuelve el valor  `false'. Nunca se devuelve el valor
     `unknown'.  Cuando `is(<a> = <b>)' toma el valor `true', se dice
     que <a> y <b> son sintácticamente iguales, no expresiones
     equivalentes, para las cuales `is(equal(<a>, <b>))' devuelve
     `true'.  Las expresiones pueden ser equivalentes, pero no
     sintácticamente iguales.

     La negación de `=' se representa por `#'.  Como en el caso de `=',
     la expresión `<a> # <b>' no está evaluada; sin embargo, `is(<a> #
     <b>)' evalúa `<a> # <b>' a `true' o `false'.

     Además de `is', hay otros operadores que evalúan `=' y `#' a
     `true' o `false'; a saber, `if', `and', `or' y `not'.

     Nótese que debido a las reglas de evaluación de expresiones de
     tipo predicado (en concreto debido a que `not <expr>' obliga a la
     evaluación previa de <expr>), `not <a> = <b>' equivale a `is(<a> #
     <b>)', pero no a `<a> # <b>'.

     Las funciones `rhs' y `lhs' devuelven los miembros derecho e
     izquierdo, respectivamente, de una ecuación o inecuación.

     Véanse también `equal' y `notequal'.

     Ejemplos:

     La expresión `<a> = <b>' representa una ecuación sin evaluar, la
     cual puede verificarse o no.

          (%i1) eq_1 : a * x - 5 * y = 17;
          (%o1)                    a x - 5 y = 17
          (%i2) eq_2 : b * x + 3 * y = 29;
          (%o2)                    3 y + b x = 29
          (%i3) solve ([eq_1, eq_2], [x, y]);
                                  196         29 a - 17 b
          (%o3)          [[x = ---------, y = -----------]]
                               5 b + 3 a       5 b + 3 a
          (%i4) subst (%, [eq_1, eq_2]);
                   196 a     5 (29 a - 17 b)
          (%o4) [--------- - --------------- = 17,
                 5 b + 3 a      5 b + 3 a
                                            196 b     3 (29 a - 17 b)
                                          --------- + --------------- = 29]
                                          5 b + 3 a      5 b + 3 a
          (%i5) ratsimp (%);
          (%o5)                  [17 = 17, 29 = 29]

     `is(<a> = <b>)' evalúa `<a> = <b>' a `true' si <a> y <b> son
     sintácticamente iguales (es decir, idénticas).  Las expresiones
     pueden ser equivalentes, pero no sintácticamente iguales.

          (%i1) a : (x + 1) * (x - 1);
          (%o1)                    (x - 1) (x + 1)
          (%i2) b : x^2 - 1;
                                        2
          (%o2)                        x  - 1
          (%i3) [is (a = b), is (a # b)];
          (%o3)                     [false, true]
          (%i4) [is (equal (a, b)), is (notequal (a, b))];
          (%o4)                     [true, false]

     Algunos operadores evalúan `=' y `#' a `true' o `false'.

          (%i1) if expand ((x + y)^2) = x^2 + 2 * x * y + y^2
                  then FOO else BAR;
          (%o1)                          FOO
          (%i2) eq_3 : 2 * x = 3 * x;
          (%o2)                       2 x = 3 x
          (%i3) eq_4 : exp (2) = %e^2;
                                        2     2
          (%o3)                       %e  = %e
          (%i4) [eq_3 and eq_4, eq_3 or eq_4, not eq_3];
          (%o4)                  [false, true, true]

     Debido a que `not <expr>' obliga a la evaluación previa de <expr>,
     `not <a> = <b>' equivale a `is(<a> # <b>)'.

          (%i1) [2 * x # 3 * x, not (2 * x = 3 * x)];
          (%o1)                   [2 x # 3 x, true]
          (%i2) is (2 * x # 3 * x);
          (%o2)                         true



File: maxima.info,  Node: Operadores de asignación,  Next: Operadores definidos por el usuario,  Prev: Operadores para ecuaciones,  Up: Operadores

6.6 Operadores de asignación
============================

 -- Operador: :
     Operador de asignación.

     Cuando el miembro de la izquierda es una variable simple (no
     subindicada), `:' evalúa la expresión de la derecha y asigna ese
     valor a la variable del lado izquierdo.

     Cuando en el lado izquierdo hay un elemento subindicado
     correspondiente a una lista, matriz, array declarado de Maxima o
     array de Lisp, la expresión de la derecha se asigna a ese
     elemento. El subíndice debe hacer referencia a un elemento ya
     existente, ya que los objetos anteriores no pueden ampliarse
     nombrando elementos no existentes.

     Cuando en el lado izquierdo hay un elemento subindicado
     correspondiente a un array no declarado de Maxima, la expresión de
     la derecha se asigna a ese elemento en caso de que ya exista, o a
     un nuevo elemento, si éste todavía no existe.

     Cuando el miembro de la izquierda es una lista de átomos y/o
     variables subindicadas, el miembro derecho debe evaluar también a
     una lista, cuyos elementos serán asignados en paralelo a las
     variables de la lista de la izquierda.

     Véanse también `kill' y `remvalue', que deshacen las asociaciones
     hechas por el operador `:'.

     Ejemplos:

     Asignación a una variable simple.

          (%i1) a;
          (%o1)                           a
          (%i2) a : 123;
          (%o2)                          123
          (%i3) a;
          (%o3)                          123

     Asignación a un elemento de una lista.

          (%i1) b : [1, 2, 3];
          (%o1)                       [1, 2, 3]
          (%i2) b[3] : 456;
          (%o2)                          456
          (%i3) b;
          (%o3)                      [1, 2, 456]

     La asignación crea un array no declarado.

          (%i1) c[99] : 789;
          (%o1)                          789
          (%i2) c[99];
          (%o2)                          789
          (%i3) c;
          (%o3)                           c
          (%i4) arrayinfo (c);
          (%o4)                   [hashed, 1, [99]]
          (%i5) listarray (c);
          (%o5)                         [789]

     Asignación múltiple.

          (%i1) [a, b, c] : [45, 67, 89];
          (%o1)                     [45, 67, 89]
          (%i2) a;
          (%o2)                          45
          (%i3) b;
          (%o3)                          67
          (%i4) c;
          (%o4)                          89

     La asignación múltiple se hace en paralelo. Los valores de `a' y
     `b' se intercambian en este ejemplo.

          (%i1) [a, b] : [33, 55];
          (%o1)                       [33, 55]
          (%i2) [a, b] : [b, a];
          (%o2)                       [55, 33]
          (%i3) a;
          (%o3)                          55
          (%i4) b;
          (%o4)                          33

 -- Operador: ::
     Operador de asignación.

     El operador `::' es similar a `:', excepto que `::' evalúa ambos
     miembros, tanto el derecho como el izquierdo.

     Ejemplos:

          (%i1) x : 'foo;
          (%o1)                          foo
          (%i2) x :: 123;
          (%o2)                          123
          (%i3) foo;
          (%o3)                          123
          (%i4) x : '[a, b, c];
          (%o4)                       [a, b, c]
          (%i5) x :: [11, 22, 33];
          (%o5)                     [11, 22, 33]
          (%i6) a;
          (%o6)                          11
          (%i7) b;
          (%o7)                          22
          (%i8) c;
          (%o8)                          33

 -- Operador: ::=
     El operador de definición de macros `::=' define una función
     (llamada macro por razones históricas) que no evalúa sus
     argumentos, siendo la expresión que retorna (llamada
     "macroexpansión") evaluada dentro del contexto desde el cual se ha
     invocado la macro. En cualquier otro sentido, una función macro es
     igual que una función ordinaria.

     `macroexpand' devuelve la expresión que a su vez fue devuelta por
     una macro (sin evaluar la expresión); `macroexpand (foo (x))'
     seguida de `''%' es equivalente a `foo (x)' si `foo' es una
     función macro.

     `::=' coloca el nombre de la nueva función macro en la lista
     global `macros'. Por otro lado, las funciones `kill', `remove' y
     `remfunction' borran las definiciones de las funciones macro y
     eliminan sus nombres de la lista `macros'.

     Las funciones `fundef' y `dispfun' devuelven la definición de una
     función macro y le asignan una etiqueta, respectivamente.

     Las funciones macro normalmente contienen expresiones `buildq' y
     `splice' para construir una expresión, que luego será evaluada.

     Ejemplos:

     Una función macro no evalúa sus argumentos, por lo que el mensaje
     (1) muestra `y - z', no el valor de `y - z'.  La macroexpansión
     (es decir, la expresión no evaluada `'(print ("(2) x is equal to",
     x))') se evalúa en el contexto desde el cual se produjo la llamada
     a la macro, imprimiendo el mensaje (2).

          (%i1) x: %pi$

          (%i2) y: 1234$

          (%i3) z: 1729 * w$

          (%i4) printq1 (x) ::= block (print ("(1) x is equal to", x),
          '(print ("(2) x is equal to", x)))$

          (%i5) printq1 (y - z);
          (1) x is equal to y - z
          (2) x is equal to %pi
          (%o5)                                 %pi

     Una función ordinaria evalúa sus argumentos, por lo que el mensaje
     (1) muestra el valor de `y - z'.  El valor de retorno no se
     evalúa, por lo que el mensaje (2) no se imprime hasta la
     evaluación explícita `''%'.

          (%i1) x: %pi$

          (%i2) y: 1234$

          (%i3) z: 1729 * w$

          (%i4) printe1 (x) := block (print ("(1) x is equal to", x),
          '(print ("(2) x is equal to", x)))$

          (%i5) printe1 (y - z);
          (1) x is equal to 1234 - 1729 w
          (%o5)                     print((2) x is equal to, x)
          (%i6) ''%;
          (2) x is equal to %pi
          (%o6)                                 %pi

     `macroexpand' devuelve la macroexpansión; `macroexpand (foo (x))'
     seguida de `''%' es equivalente a `foo (x)' si `foo' es una
     función macro.

          (%i1) x: %pi$

          (%i2) y: 1234$

          (%i3) z: 1729 * w$

          (%i4) g (x) ::= buildq ([x], print ("x is equal to", x))$

          (%i5) macroexpand (g (y - z));
          (%o5)                     print(x is equal to, y - z)
          (%i6) ''%;
          x is equal to 1234 - 1729 w
          (%o6)                            1234 - 1729 w
          (%i7) g (y - z);
          x is equal to 1234 - 1729 w
          (%o7)                            1234 - 1729 w


 -- Operador: :=
     El operador de definición de funciones.  La expresión `<f>(<x_1>,
     ..., <x_n>) := <expr>' define una función de nombre <f> con
     argumentos <x_1>, ..., <x_n> y cuerpo <expr>.  El operador `:=' no
     evalúa el cuerpo de la función (a menos que se indique lo
     contrario mediante el operador comilla-comilla `''').  La función
     así definida puede ser una función ordinaria de Maxima (con
     argumentos encerrados entre paréntesis) o una función array (con
     argumentos encerrados entre corchetes).

     Cuando el último o único argumento <x_n> es una lista de un solo
     elemento, la función definida por `:=' acepta un número variable
     de argumentos. Los valores de los argumentos se asignan uno a uno
     a los argumentos formales <x_1>, ..., <x_(n - 1)>, y cualesquiera
     otros valores de argumentos, si existen, se asignan a <x_n> en
     forma de lista.

     Todas las definiciones de funciones aparecen en el mismo espacio de
     nombres; definiendo una función `f' dentro de otra función `g' no
     limita automáticamente el alcance de `f' a `g'.  No obstante,
     `local(f)' hace que la función `f' sea efectiva solamente dentro
     del bloque o empaquetado de expresiones en la que aparece `local'.

     Si un argumento formal <x_k> es un símbolo afectado por el
     operador comilla (expresión nominal), la función definida por `:='
     no evalúa el correspondiente valor de argumento.  En cualquier
     otro caso, los argumentos que se pasan son evaluados.

     Véanse también `define' y `::='.

     Ejemplos:

     `:=' no evalúa el cuerpo de la función (a menos que se indique lo
     contrario mediante el operador comilla-comilla `''').

          (%i1) expr : cos(y) - sin(x);
          (%o1)                    cos(y) - sin(x)
          (%i2) F1 (x, y) := expr;
          (%o2)                   F1(x, y) := expr
          (%i3) F1 (a, b);
          (%o3)                    cos(y) - sin(x)
          (%i4) F2 (x, y) := ''expr;
          (%o4)              F2(x, y) := cos(y) - sin(x)
          (%i5) F2 (a, b);
          (%o5)                    cos(b) - sin(a)

     La función así definida puede ser una función ordinaria de Maxima
     o una función array.

          (%i1) G1 (x, y) := x.y - y.x;
          (%o1)               G1(x, y) := x . y - y . x
          (%i2) G2 [x, y] := x.y - y.x;
          (%o2)                G2     := x . y - y . x
                                 x, y

     Cuando el último o único argumento <x_n> es una lista de un solo
     elemento, la función definida por `:=' acepta un número variable
     de argumentos.

          (%i1) H ([L]) := apply ("+", L);
          (%o1)                H([L]) := apply("+", L)
          (%i2) H (a, b, c);
          (%o2)                       c + b + a

     `local' define una función como local.

          (%i1) foo (x) := 1 - x;
          (%o1)                    foo(x) := 1 - x
          (%i2) foo (100);
          (%o2)                         - 99
          (%i3) block (local (foo), foo (x) := 2 * x, foo (100));
          (%o3)                          200
          (%i4) foo (100);
          (%o4)                         - 99


File: maxima.info,  Node: Operadores definidos por el usuario,  Prev: Operadores de asignación,  Up: Operadores

6.7 Operadores definidos por el usuario
=======================================

 -- Función: infix (<op>)
 -- Función: infix (<op>, <lbp>, <rbp>)
 -- Función: infix (<op>, <lbp>, <rbp>, <lpos>, <rpos>, <pos>)
     Declara <op> como operador infijo.  Un operador infijo es una
     función de dos argumentos, con el nombre de la función escrito
     entre sus argumentos.  Por ejemplo, el operador de sustracción `-'
     es un operador infijo.

     `infix (<op>)' declara <op> como operador infijo con fuerzas de
     ligadura por la izquierda y por la derecha iguales a 180, que es
     el valor por defecto, y partes izquierda y derecha iguales a `any'.

     `infix (<op>, <lbp>, <rbp>)' declara <op> como operador infijo con
     fuerzas de ligadura por la izquierda y por la derecha declaradas
     en los argumentos, siendo las partes izquierda y derecha iguales a
     `any'.

     `infix (<op>, <lbp>, <rbp>, <lpos>, <rpos>, <pos>)' declara <op>
     como operador infijo con fuerzas de ligadura por la izquierda y
     por la derecha, junto con los tipos de expresiones correspondientes
     a <lpos>, <rpos> y <pos>, que son el operando de la izquierda, el
     de la derecha y el operador del resultado; los tipos reconocidos
     son: `expr', `clause' y `any', que indican expresión algebraica,
     expresión booleana o cualquier otra, respectivamente. Maxima puede
     detectar algunos errores sintácticos comparando los tipos
     declarados con los de la expresión actual.

     La precedencia de <op> con respecto a otros operadores deriva de
     las fuerzas de ligadura de los operadores en cuestión.  Si las
     fuerzas de ligadura a izquierda y derecha de <op> son ambas
     mayores que las fuerzas de ligadura a izquierda y derecha de otro
     operador, entonces <op> tiene preferencia sobre el otro operador.
     Si las fuerzas de ligadura no son ambas mayores o menores, se
     aplican otras relaciones más complejas.

     La asociatividad de <op> depende de las fuerzas de ligadura.  Una
     mayor fuerza de ligadura a la izquierda (<lbp>) implica que <op>
     sea evaluado antes que otros operadores a su izquierda en la
     expresión, mientras que mayor fuerza de ligadura a la derecha
     (<rbp>) implica que <op> sea evaluado antes que otros operadores a
     su derecha en la expresión.  Así, si <lbp> es mayor, <op> es
     asociativo por la derecha, mientras que si <rbp> es mayor, <op> es
     asociativo por la izquierda.

     Véase también `Syntax'.

     Ejemplos:

     Si las fuerzas de ligadura a izquierda y derecha de <op> son ambas
     mayores que las fuerzas de ligadura a izquierda y derecha de otro
     operador, entonces <op> tiene preferencia sobre el otro operador.

          (%i1) :lisp (get '$+ 'lbp)
          100
          (%i1) :lisp (get '$+ 'rbp)
          100
          (%i1) infix ("##", 101, 101);
          (%o1)                          ##
          (%i2) "##"(a, b) := sconcat("(", a, ",", b, ")");
          (%o2)       (a ## b) := sconcat("(", a, ",", b, ")")
          (%i3) 1 + a ## b + 2;
          (%o3)                       (a,b) + 3
          (%i4) infix ("##", 99, 99);
          (%o4)                          ##
          (%i5) 1 + a ## b + 2;
          (%o5)                       (a+1,b+2)

     Mayor <lbp> hace a <op> asociativo por la derecha, mientras que
     mayor  <rbp> hace a <op> asociativo por la izquierda.

          (%i1) infix ("##", 100, 99);
          (%o1)                          ##
          (%i2) "##"(a, b) := sconcat("(", a, ",", b, ")")$
          (%i3) foo ## bar ## baz;
          (%o3)                    (foo,(bar,baz))
          (%i4) infix ("##", 100, 101);
          (%o4)                          ##
          (%i5) foo ## bar ## baz;
          (%o5)                    ((foo,bar),baz)

     Maxima puede detectar algunos errores sintácticos comparando los
     tipos declarados con los de la expresión actual.

          (%i1) infix ("##", 100, 99, expr, expr, expr);
          (%o1)                          ##
          (%i2) if x ## y then 1 else 0;
          Incorrect syntax: Found algebraic expression where logical expression expected
          if x ## y then
                       ^
          (%i2) infix ("##", 100, 99, expr, expr, clause);
          (%o2)                          ##
          (%i3) if x ## y then 1 else 0;
          (%o3)                if x ## y then 1 else 0

 -- Función: matchfix (<ldelimiter>, <rdelimiter>)
 -- Función: matchfix (<ldelimiter>, <rdelimiter>, <arg_pos>, <pos>)
     Declara un operador "matchfix" con delimitadores a la izquierda y
     derecha, <ldelimiter> y <rdelimiter>, respectivamente. Los
     delimitadores son cadenas alfanuméricas.

     Un operador "matchfix" es una función con un número arbitrario de
     argumentos, de manera que los argumentos se presentan entre los
     delimitadores de la izquierda y derecha. Los delimitadores pueden
     ser cualquier tipo de cadena, en tanto que el analizador
     sintáctico pueda distinguirlos de los operandos y de expresiones
     con operadores. En la práctica esto excluye delimitadores como
     `%', `,', `$' y `;',  necesitando aislar los delimitadores con
     espacios en blanco. El delimitador de la derecha puede ser igual o
     diferente del de la izquierda.

     Un delimitador de la izquierda sólo puede asociarse con un único
     delimitador de la derecha; dos operadores "matchfix" diferentes no
     pueden tener el mismo delimitador por la izquierda.

     Un operador ya existente puede declararse como operador "matchfix"
     sin necesidad de que cambie el resto de propiedades. En
     particular, los operadores de Maxima tales como la suma `+' pueden
     ser declarados como "matchfix".

     La llamada `matchfix (<ldelimiter>, <rdelimiter>, <arg_pos>,
     <pos>)' declara el argumento <arg_pos> y el resultado <pos>, así
     como los delimitadores  <ldelimiter> y <rdelimiter>.

     Los argumentos <arg_pos> y <pos> son tipos de funciones,
     reconociéndose como tales: `expr', `clause' y `any', los cuales
     hacen referencia a una expresión algebraica, booleana o de
     cualquier otro tipo, respectivamente.  Maxima puede detectar
     ciertos errores sintácticos comparando el tipo de expresión
     declarado con el de la expresión actual.

     La función que ejecutará una operación "matchfix" será una típica
     función definida por el usuario. La función de operador se define
     por el método habitual con  `:=' o `define'. Los argumentos pueden
     escribirse entre los delimitadores, o con el delimitador izquierdo
     como una cadena precedida de apóstrofo y seguidamente los
     argumentos entre paréntesis. La llamada `dispfun (<ldelimiter>)'
     muestra la definición de la función.

     El único operador "matchfix" de Maxima es el constructor de listas
     `[ ]'. Los paréntesis  `( )' y las comillas dobles  `" "'  actúan
     como operadores "matchfix", pero son tratados como operadores
     "matchfix" por el analizador sintáctico de Maxima.

     Ejemplos:

        * Los delimitadores pueden ser practicamente cualquier cadena.

          (%i1) matchfix ("@@", "~");
          (%o1)                          @@
          (%i2) @@ a, b, c ~;
          (%o2)                      @@a, b, c~
          (%i3) matchfix (">>", "<<");
          (%o3)                          >>
          (%i4) >> a, b, c <<;
          (%o4)                      >>a, b, c<<
          (%i5) matchfix ("foo", "oof");
          (%o5)                          foo
          (%i6) foo a, b, c oof;
          (%o6)                     fooa, b, coof
          (%i7) >> w + foo x, y oof + z << / @@ p, q ~;
                               >>z + foox, yoof + w<<
          (%o7)                ----------------------
                                      @@p, q~

        * Los operadores "matchfix" son funciones definidas por el
          usuario.

          (%i1) matchfix ("!-", "-!");
          (%o1)                         "!-"
          (%i2) !- x, y -! := x/y - y/x;
                                              x   y
          (%o2)                   !-x, y-! := - - -
                                              y   x
          (%i3) define (!-x, y-!, x/y - y/x);
                                              x   y
          (%o3)                   !-x, y-! := - - -
                                              y   x
          (%i4) define ("!-" (x, y), x/y - y/x);
                                              x   y
          (%o4)                   !-x, y-! := - - -
                                              y   x
          (%i5) dispfun ("!-");
                                              x   y
          (%t5)                   !-x, y-! := - - -
                                              y   x

          (%o5)                         done
          (%i6) !-3, 5-!;
                                          16
          (%o6)                         - --
                                          15
          (%i7) "!-" (3, 5);
                                          16
          (%o7)                         - --
                                          15


 -- Función: nary (<op>)
 -- Función: nary (<op>, <bp>, <arg_pos>, <pos>)
     Un operador n-ario denota una función con un número arbitrario de
     argumentos entre los que se intercal el símbolo del operador, como
     en `A+B+C'. La instrucción `nary("x")' declara `x' como operador
     n-ario. Las funciones se pueden declarar como n-arias; de modo que
     si se ejecuta `declare(j,nary)', el simplificador transforma
     `j(j(a,b),j(c,d))' en `j(a, b, c, d)'.


 -- Función: nofix (<op>)
 -- Función: nofix (<op>, <pos>)
     Los operadores no-fijos se utilizan para definir funciones sin
     argumentos.  La mera presencia de tal operador en una instrucción
     hará que se evalúe la función correspondiente. Por ejemplo, cuando
     se teclea `exit;' para salir de una interrupción de Maxima, `exit'
     se comporta como una función no-fija. La instrucción `nofix("x")'
     declara `x' como operador no-fijo.


 -- Función: postfix (<op>)
 -- Función: postfix (<op>, <lbp>, <lpos>, <pos>)
     Los operadores sufijos son funciones de un único argumento en las
     que éste precede al operador, como en `3!'. La instrucción
     `postfix("x")' declara `x' como operador sufijo.


 -- Función: prefix (<op>)
 -- Función: prefix (<op>, <rbp>, <rpos>, <pos>)
     Los operadores prefijos son funciones de un único argumento en las
     que éste se coloca a continuación del operador. La instrucción
     `prefix("x")' declara `x' como operador prefijo.


File: maxima.info,  Node: Evaluación,  Next: Expresiones,  Prev: Operadores,  Up: Top

7 Evaluación
************

* Menu:

* Introducción a la evaluación::
* Funciones y variables para la evaluación::


File: maxima.info,  Node: Introducción a la evaluación,  Next: Funciones y variables para la evaluación,  Prev: Evaluación,  Up: Evaluación

7.1 Introducción a la evaluación
================================

Las fases que se suceden desde que el usuario solicita un cálculo hasta
que obtiene el resultado son: la propia solicitud del cálculo, la
evaluación, la simplificación y la respuesta.

Toda expresión <expr> que se introduzca en Maxima será evaluada, de
manera que los símbolos que no tengan asociado ningún valor y los
números evalúan a sí mismos; en cambio, aquellos símbolos que tengan un
valor asociado serán sustituídos por tales valores.

Dos ejemplos. En el primero, los símbolos y los números se evalúan a sí
mismos; en el segundo ejemplo, al asignarle a la variable `a' el valor
`2', allá donde se escriba `a' será sustituido por dicho valor.

     (%i1) [a, b, 2, 1/2, 1.0];
                                       1
     (%o1)                   [a, b, 2, -, 1.0]
                                       2
     (%i2) a:2$

     (%i3) [a, sin(a), a^2];
     (%o3)                    [2, sin(2), 4]

Maxima distingue entre funciones en forma verbal y funciones en forma
nominal. Las funciones en forma verbal son evaluadas tomando en cuenta
los valores dados a sus argumentos; en cambio, las funciones nominales
no son evaluadas, aunque sus argumentos tengan valores asignados. Las
funciones son susceptibles de ser tratadas de ambos modos; ejemplos
típicos son la función de diferenciación `diff' y la de integración
`integrate'.

En el siguiente ejemplo se le asigna a la variable `a' cierto valor, a
continuación se invoca la función `diff' en su forma verbal con sus
argumentos tomando los valores `a*x^2' y `x'.  Seguidamente se invoca a
la misma función `diff' en su forma nominal, lo cual se consigue
mediante el operador de comilla simple (`''); en este caso la función
no es evaluada y devuelve una expresión simbólica en la que los
argumentos sí han sido evaluados, pues la variable `a' es sustituida
por el valor `1/2'.

     (%i1) a:1/2;
                                     1
     (%o1)                           -
                                     2
     (%i2) diff(a*x^2, x);
     (%o2)                           x
     (%i3) 'diff(a*x^2, x);
                                       2
                                  d   x
     (%o3)                        -- (--)
                                  dx  2

Sin embargo, no todas las funciones de Maxima sustituyen sus argumentos
por sus valores. La documentación para cada función informará si sus
argumentos son evaluados o no.

Por ejemplo, la función `properties' no evalúa sus argumentos, lo cual
resulta práctico para el usuario, ya que en caso contrario debería
utilizar el operador de comilla simple `'' a fin de poder mostrar las
propiedades del símbolo `a'. A continuación se muestra como en el
primer caso se devuelve una lista vacía, ya que no se le ha encontrado
ninguna propiedad al símbolo `a'; una vez se le ha asignado el valor
`2', la función `properties' nos dice que la variable guarda un valor y
esto es así porque no ha sustituido el símbolo `a' por su valor `2'. En
consecuencia, la función `properties' muestra las propiedades de `'a'.

     (%i1) properties(a);
     (%o1)                          []
     (%i2) a:2$

     (%i3) properties(a);
     (%o3)                        [value]

La evaluación de símbolos, funciones y expresiones se puede controlar
con los operadores de comilla simple (`'') y de doble comilla simple
(`'''). La evaluación se suprime con la comilla simple y se fuerza con
la doble comilla simple (que no comilla doble).

Con la función `ev' se evalúa una expresión dentro de un contexto
determinado controlado por el valor de ciertas variables `evflag' y
funciones de evaluación `evfun'.


File: maxima.info,  Node: Funciones y variables para la evaluación,  Prev: Introducción a la evaluación,  Up: Evaluación

7.2 Funciones y variables para la evaluación
============================================

 -- Operador: '
     El operador comilla simple `'' evita la evaluación.

     Aplicado a un símbolo, la comilla simple evita la evaluación del
     símbolo.

     Aplicado a la llamada de una función, la comilla simple evita la
     evaluación de la función llamada, aunque los argumentos de la
     función son evaluados (siempre y cuando la evaluación no se evite
     de otra manera).  El resultado es una forma de nombre de la
     función llamada.

     Aplicado a una expresión con paréntesis, la comilla simple evita
     la evaluación de todos los símbolos y llamadas a funciones que
     hayan en la expresión.  E.g., `'(f(x))' significa que no se evalua
     la expresión `f(x)'.  `'f(x)' (con la comilla simple aplicada a
     `f' en cambio de a `f(x)') significa el retorno de la forma de
     nombre de `f' aplicada a `[x]'.

     La comilla simple no evita la simplificación.

     Cuando el interruptor global `noundisp' es `true', los nombres se
     muestran con una comilla simple.  Este interruptor siempre tiene
     como valor `true' cuando se muestran definiciones de funciones.

     Ver también los operadores comilla-comilla `''' y `nouns'.

     Ejemplos:

     Aplicado a un símbolo, la comilla simple evita la evaluación del
     símbolo.

          (%i1) aa: 1024;
          (%o1)                         1024
          (%i2) aa^2;
          (%o2)                        1048576
          (%i3) 'aa^2;
                                           2
          (%o3)                          aa
          (%i4) ''%;
          (%o4)                        1048576

     Aplicado a la llamada de una función, la comilla simple evita la
     evaluación de la función llamada, aunque los argumentos de la
     función son evaluados (siempre y cuando la evaluación no se evite
     de otra manera).  El resultado es una forma de nombre de la
     función llamada.

          (%i1) x0: 5;
          (%o1)                           5
          (%i2) x1: 7;
          (%o2)                           7
          (%i3) integrate (x^2, x, x0, x1);
                                         218
          (%o3)                          ---
                                          3
          (%i4) 'integrate (x^2, x, x0, x1);
                                       7
                                      /
                                      [   2
          (%o4)                       I  x  dx
                                      ]
                                      /
                                       5
          (%i5) %, nouns;
                                         218
          (%o5)                          ---
                                          3

     Aplicado a una expresión con paréntesis, la comilla simple evita
     la evaluación de todos los símbolos y llamadas a funciones que
     haya dentro en la expresión.

          (%i1) aa: 1024;
          (%o1)                         1024
          (%i2) bb: 19;
          (%o2)                          19
          (%i3) sqrt(aa) + bb;
          (%o3)                          51
          (%i4) '(sqrt(aa) + bb);
          (%o4)                     bb + sqrt(aa)
          (%i5) ''%;
          (%o5)                          51

     La comilla simple no evita la simplificación.

          (%i1) sin (17 * %pi) + cos (17 * %pi);
          (%o1)                          - 1
          (%i2) '(sin (17 * %pi) + cos (17 * %pi));
          (%o2)                          - 1

     Internamente, Maxima considera que las operaciones con números
     decimales de coma flotante son simples simplificaciones.

          (%i1) sin(1.0);
          (%o1)                          .8414709848078965
          (%i2) '(sin(1.0));
          (%o2)                          .8414709848078965


 -- Operador: "
     El operador comilla-comilla `''' (dos comillas simples) modifica
     la evaluación en las expresiones de entrada.

     Aplicado a cualquier expresión general <expr>, las dos comillas
     simples hacen que el valor de <expr> sea sustituido por <expr> en
     la expresión de entrada.

     Aplicado al operador de una expresión, el operador comilla-comilla
     hace que el operador pase de ser un nombre a ser un verbo, a menos
     que ya sea un verbo.

     El operador comilla-comilla es aplicado por el analizador
     sintáctico de entrada; no se almacena como una parte de la
     expresión de entrada analizada.  Este operador se aplica siempre
     tan pronto como es detectado y no puede ser comentado con una
     comilla simple. De esta manera, el operador comilla-comilla
     provoca la evaluación de una expresión cuando ésta no estaba
     previsto que fuese evaluada, como en la definición de funciones,
     expresiones lambda y expresiones comentadas con una comilla simple
     `''.

     El operador comilla-comilla es reconocido tanto por `batch' como
     por `load'.

     Véanse también el operador comilla simple `'' y `nouns'.

     Ejemplos:

     Aplicado a cualquier expresión general <expr>, las dos comillas
     simples hacen que el valor de <expr> sea sustituido por <expr> en
     la expresión de entrada.

          (%i1) expand ((a + b)^3);
                               3        2      2      3
          (%o1)               b  + 3 a b  + 3 a  b + a
          (%i2) [_, ''_];
                                   3    3        2      2      3
          (%o2)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
          (%i3) [%i1, ''%i1];
                                   3    3        2      2      3
          (%o3)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
          (%i4) [aa : cc, bb : dd, cc : 17, dd : 29];
          (%o4)                   [cc, dd, 17, 29]
          (%i5) foo_1 (x) := aa - bb * x;
          (%o5)                 foo_1(x) := aa - bb x
          (%i6) foo_1 (10);
          (%o6)                      cc - 10 dd
          (%i7) ''%;
          (%o7)                         - 273
          (%i8) ''(foo_1 (10));
          (%o8)                         - 273
          (%i9) foo_2 (x) := ''aa - ''bb * x;
          (%o9)                 foo_2(x) := cc - dd x
          (%i10) foo_2 (10);
          (%o10)                        - 273
          (%i11) [x0 : x1, x1 : x2, x2 : x3];
          (%o11)                    [x1, x2, x3]
          (%i12) x0;
          (%o12)                         x1
          (%i13) ''x0;
          (%o13)                         x2
          (%i14) '' ''x0;
          (%o14)                         x3

     Aplicado al operador de una expresión, la doble comilla simple
     hace que el operador pase de ser nominal a verbal, a menos que ya
     sea un verbo.

          (%i1) declare (foo, noun);
          (%o1)                         done
          (%i2) foo (x) := x - 1729;
          (%o2)                 ''foo(x) := x - 1729
          (%i3) foo (100);
          (%o3)                       foo(100)
          (%i4) ''foo (100);
          (%o4)                        - 1629

     El operador comilla-comilla es aplicado por el analizador
     sintáctico de entrada; no se almacena como una parte de la
     expresión de entrada analizada.

          (%i1) [aa : bb, cc : dd, bb : 1234, dd : 5678];
          (%o1)                 [bb, dd, 1234, 5678]
          (%i2) aa + cc;
          (%o2)                        dd + bb
          (%i3) display (_, op (_), args (_));
                                     _ = cc + aa

                                   op(cc + aa) = +

                              args(cc + aa) = [cc, aa]

          (%o3)                         done
          (%i4) ''(aa + cc);
          (%o4)                         6912
          (%i5) display (_, op (_), args (_));
                                     _ = dd + bb

                                   op(dd + bb) = +

                              args(dd + bb) = [dd, bb]

          (%o5)                         done

     El operador comilla-comilla provoca la evaluación de una expresión
     cuando ésta no estaba previsto que fuese evaluada, como en la
     definición de funciones, expresiones lambda y expresiones
     comentadas con una comilla simple `''.

          (%i1) foo_1a (x) := ''(integrate (log (x), x));
          (%o1)               foo_1a(x) := x log(x) - x
          (%i2) foo_1b (x) := integrate (log (x), x);
          (%o2)           foo_1b(x) := integrate(log(x), x)
          (%i3) dispfun (foo_1a, foo_1b);
          (%t3)               foo_1a(x) := x log(x) - x

          (%t4)           foo_1b(x) := integrate(log(x), x)

          (%o4)                      [%t3, %t4]
          (%i5) integrate (log (x), x);
          (%o5)                     x log(x) - x
          (%i6) foo_2a (x) := ''%;
          (%o6)               foo_2a(x) := x log(x) - x
          (%i7) foo_2b (x) := %;
          (%o7)                    foo_2b(x) := %
          (%i8) dispfun (foo_2a, foo_2b);
          (%t8)               foo_2a(x) := x log(x) - x

          (%t9)                    foo_2b(x) := %

          (%o9)                      [%t7, %t8]
          (%i10) F : lambda ([u], diff (sin (u), u));
          (%o10)             lambda([u], diff(sin(u), u))
          (%i11) G : lambda ([u], ''(diff (sin (u), u)));
          (%o11)                  lambda([u], cos(u))
          (%i12) '(sum (a[k], k, 1, 3) + sum (b[k], k, 1, 3));
          (%o12)         sum(b , k, 1, 3) + sum(a , k, 1, 3)
                              k                  k
          (%i13) '(''(sum (a[k], k, 1, 3)) + ''(sum (b[k], k, 1, 3)));
          (%o13)             b  + a  + b  + a  + b  + a
                              3    3    2    2    1    1


 -- Función: ev (<expr>, <arg_1>, ..., <arg_n>)
     Evalua la expresión <expr> en el entorno especificado por los
     argumentos <arg_1>, ..., <arg_n>.  Los argumentos son
     interruptores (Variables Booleanas), variables de asignación,
     ecuaciones y funciones.  `ev' retorna el resultado (otra
     expresión) de la evaluación.

     La evaluación se realiza por etapas, como sigue:

       1. Primero se configura el entorno de acuerdo a los argumentos
          los cuales pueden ser algunos o todos de la siguiente lista:

             * `simp' causa que <expr> sea simplificada sin importar el
               valor de la variable interruptor `simp' la cual inhibe
               la simplificación cuando su valor es `false'.

             * `noeval' suprime la fase de evaluación de `ev' (Vea el
               paso (4) más adelante).  Esto es muy útil en conjunción
               con otras variables interruptor y causan en <expr> que
               sea resimplificada sin ser reevaluada.

             * `nouns' causa la evaluación de las formas nominales
               (típicamente funciones sin evaluar tales como
               `'integrate' or `'diff') en `expr'.

             * `expand' causa expansión.

             * `expand (<m>, <n>)' causa expansión, asignando los
               valores de `maxposex' y `maxnegex' a <m> y <n>,
               respectivamente.

             * `detout' hace que cualesquiera matrices inversas
               calculadas en <expr> conserven su determinante fuera de
               la inversa, en vez de que divida a cada elemento.

             * `diff' realiza todas las diferenciaciones indicadas en
               <expr>.

             * `derivlist (<x>, <y>, <z>, ...)' realiza sólo las
               diferenciaciones con respecto a las variables indicadas.

             * `risch' hace que las integrales presentes en <expr> se
               evalúen mediante el algoritmo de Risch. Véase también
               `risch'. Cuando se utiliza el símbolo especial `nouns',
               se aplica la rutina estándar de integración.

             * `float' provoca la conversión de los números racionales
               no-enteros a números decimales de coma flotante.

             * `numer' causa que algunas funciones matemáticas
               (incluyendo potenciación) con argumentos numéricos sean
               evaluados como punto flotante. Esto causa que las
               variables en <expr> las cuales hayan sido declaradas
               como variables numéricas sean reemplazadas por sus
               respectivos valores. Esto también configura la variable
               interruptor `float' a `true'.

             * `pred' provoca la evaluación de los predicados
               (expresiones las cuales se evaluan a `true' o `false').

             * `eval' provoca una post-evaluación extra de <expr>
               (véase el paso (5) más adelante), pudiendo aparecer
               `eval' varias veces; por cada aparición de `eval', la
               expresión es reevaluada.

             * `A', donde `A' es un átomo declarado como una variable
               de tipo interruptor, (Vea `evflag') causa que `A' tenga
               como valor `true' durante la evaluación de <expr>.

             * `V: expresion' (o alternativamente `V=expresion') causa
               que `V' tenga el valor de `expresion' durante la
               evaluación de <expr>. Notese que si `V' es una opción
               Maxima, entonces `expresion' se usa como su valor
               durante la evaluación de <expr>. Si más de un argumento
               de `ev' es de este tipo entonces el vínculo se hace en
               paralelo. Si `V' es una expresión no atómica entonces se
               hace una sustitución más que un vínculo.

             * `F' donde `F', un nombre de función, ha sido declarado
               para ser una función de evaluación (Vea `evfun') causa
               que `F' sea aplicada a <expr>.

             * Cualquier otro nombre de función (e.g., `sum') causa la
               evaluación de las ocurrencias de esos nombres en `expr'
               como si ellos fueran verbos.

             * En adición de que una función ocurra en <expr> (digamos
               `F(x)') puede ser definida localmente para el propósito
               de esta evaluación de <expr> pasando `F(x) := expresion'
               como un argumento a `ev'.

             * Si un átomo no mencionado anteriormente o una variable o
               expresión con subíndices fueran pasadas como un
               argumento, esta es evaluada y si el resultado es una
               ecuación o una asignación entonces el vínculo o
               sustitución se llevará a cabo. Si el resultado es una
               lista entonces los miembros de la lista tratados como si
               ellos fueran argumentos adicionales pasados a `ev'. Esto
               permite que una lista de argumentos sea pasada (e.g.,
               `[X=1, Y=A**2]') o una lista de nombres de ecuaciones
               (e.g., `[%t1, %t2]' donde `%t1' y `%t2' son ecuaciones)
               tal como lo que es retornado por `solve'.

          Los argumentos de `ev' pueden ser pasados en cualquier orden
          con excepción de la sustitución de ecuaciones las cuales son
          manipuladas en secuencia, de izquierda a derecha y las
          funciones de evaluación las cuales son compuestas, e.g., `ev
          (<expr>, ratsimp, realpart)' es manipulada como `realpart
          (ratsimp (<expr>))'.

          Los interruptores `simp', `numer' y `float' pueden también
          ser configurados localmente en una sentencia block, o
          globalmente en Maxima para que su efecto permanezca hasta que
          sean reconfiguradas.

          Si <expr> es una Expresión Racional Canónica (CRE, por sus
          siglas en inglés), entonces la expresión retornada por `ev'
          es también de tipo CRE, siempre que los interruptores `numer'
          y `float' no sean `true'.

       2. Durante el paso (1), se fabrica una lista de las variables
          que no contienen subíndices que aparecen en el lado izquierdo
          de las ecuaciones en los argumentos o en el valor de algunos
          argumentos si el valor es una ecuación. Las variables
          (variables que contienen subíndices las cuales no tienen
          asociado un arreglo de funciones como también las variables
          que no contienen subíndices) en la expresión <expr> son
          reemplazadas por sus valores globales, excepto por aquellos
          que aparezcan en esa lista.  Usualmente, <expr> es sólo una
          etiqueta o un `%' (como en `%i2' en el ejemplo de más abajo)
          así que este paso simplemente recupera la expresión a la que
          hace referencia la etiqueta y así `ev' puede trabajarla.

       3. Si algunas sustituciones son indicadas por los argumentos,
          ellas serán llevadas a cabo ahora.

       4. La expresión resultante es también reevaluada (a menos que
          uno de los argumentos fuese `noeval') y simplificada de
          acuerdo a los argumentos. Notese que cualquier llamada a una
          función en <expr> será llevada a cabo después de que las
          variables sean evaluadas en ella y que `ev(F(x))' pueda
          comportarse como `F(ev(x))'.

       5. Por cada aparición de `eval' en los argumentos, se repetirán
          los pasos (3) y (4).

     Ejemplos:

          (%i1) sin(x) + cos(y) + (w+1)^2 + 'diff (sin(w), w);
                                               d                    2
          (%o1)              cos(y) + sin(x) + -- (sin(w)) + (w + 1)
                                               dw
          (%i2) ev (%, numer, expand, diff, x=2, y=1);
                                         2
          (%o2)                cos(w) + w  + 2 w + 2.449599732693821

     Una sintaxis alternativa de alto nivel ha sido desarrollada para
     `ev' por medio de la cual se pueden escribir solamente sus
     argumentos, sin el comando `ev()'; se trata de una forma de
     escritura simplificada:

          <expr>, <arg_1>, ..., <arg_n>

     Esta sintaxis no está permitida dentro de otras expresiones, como
     funciones, bloques, etc.

     Nótese el proceso de vínculo en paralelo en el siguiente ejemplo:

          (%i3) programmode: false;
          (%o3)                                false
          (%i4) x+y, x: a+y, y: 2;
          (%o4)                              y + a + 2
          (%i5) 2*x - 3*y = 3$
          (%i6) -3*x + 2*y = -4$
          (%i7) solve ([%o5, %o6]);
          Solución

                                                    1
          (%t7)                               y = - -
                                                    5

                                                   6
          (%t8)                                x = -
                                                   5
          (%o8)                            [[%t7, %t8]]
          (%i8) %o6, %o8;
          (%o8)                              - 4 = - 4
          (%i9) x + 1/x > gamma (1/2);
                                             1
          (%o9)                          x + - > sqrt(%pi)
                                             x
          (%i10) %, numer, x=1/2;
          (%o10)                      2.5 > 1.772453850905516
          (%i11) %, pred;
          (%o11)                               true


 -- Símbolo especial: eval
     Como argumento en una llamada a `ev (<expr>)', `eval' fuerza una
     evaluación extra de <expr>.

     Véase también `ev'.

     Ejemplo:

          (%i1) [a:b,b:c,c:d,d:e];
          (%o1)                            [b, c, d, e]
          (%i2) a;
          (%o2)                                  b
          (%i3) ev(a);
          (%o3)                                  c
          (%i4) ev(a),eval;
          (%o4)                                  e
          (%i5) a,eval,eval;
          (%o5)                                  e


 -- Propiedad: evflag
     Cuando un símbolo <x> goza de la propiedad `evflag', las
     expresiones `ev(<expr>, <x>)' y `<expr>, <x>' (en modo
     interactivo) equivalen a `ev(<expr>, <x> = true)'.  Esto es, a <x>
     se le asigna `true' al tiempo que se evalúa <expr>.

     La expresión `declare(<x>, evflag)' dota a la variable <x> de la
     propiedad `evflag'.

     Los interruptores que tienen la propiedad `evflag' son:

        algebraic           cauchysum       demoivre
        dotscrules          %emode          %enumer
        exponentialize      exptisolate     factorflag
        float               halfangles      infeval
        isolate_wrt_times   keepfloat       letrat
        listarith           logabs          logarc
        logexpand           lognegint
        m1pbranch           numer_pbranch   programmode
        radexpand           ratalgdenom     ratfac
        ratmx               ratsimpexpons   simp
        simpproduct         simpsum         sumexpand
        trigexpand

     Ejemplos:

          (%i1) sin (1/2);
                                           1
          (%o1)                        sin(-)
                                           2
          (%i2) sin (1/2), float;
          (%o2)                   0.479425538604203
          (%i3) sin (1/2), float=true;
          (%o3)                   0.479425538604203
          (%i4) simp : false;
          (%o4)                         false
          (%i5) 1 + 1;
          (%o5)                         1 + 1
          (%i6) 1 + 1, simp;
          (%o6)                           2
          (%i7) simp : true;
          (%o7)                         true
          (%i8) sum (1/k^2, k, 1, inf);
                                      inf
                                      ====
                                      \     1
          (%o8)                        >    --
                                      /      2
                                      ====  k
                                      k = 1
          (%i9) sum (1/k^2, k, 1, inf), simpsum;
                                           2
                                        %pi
          (%o9)                         ----
                                         6
          (%i10) declare (aa, evflag);
          (%o10)                        done
          (%i11) if aa = true then YES else NO;
          (%o11)                         NO
          (%i12) if aa = true then YES else NO, aa;
          (%o12)                         YES


 -- Propiedad: evfun
     Cuando la función <F> goza de la propiedad `evfun', las
     expresiones `ev(<expr>, <F>)' y `<expr>, <F>' (en modo
     interactivo) equivalen a `<F>(ev(<expr>))'.

     Si se especifican dos o más funciones, <F>, <G>, etc., como
     poseedoras de la propiedad `evfun', éstas se aplican en el mismo
     orden en el que han sido especificadas como tales.

     La expresión `declare(<F>, evfun)' dota a la función  <F> de la
     propiedad `evfun'.

     Las funciones que tienen la propiedad `evfun' por defecto son:

        bfloat          factor       fullratsimp
        logcontract     polarform    radcan
        ratexpand       ratsimp      rectform
        rootscontract   trigexpand   trigreduce

     Ejemplos:

          (%i1) x^3 - 1;
                                        3
          (%o1)                        x  - 1
          (%i2) x^3 - 1, factor;
                                          2
          (%o2)                 (x - 1) (x  + x + 1)
          (%i3) factor (x^3 - 1);
                                          2
          (%o3)                 (x - 1) (x  + x + 1)
          (%i4) cos(4 * x) / sin(x)^4;
                                      cos(4 x)
          (%o4)                       --------
                                         4
                                      sin (x)
          (%i5) cos(4 * x) / sin(x)^4, trigexpand;
                           4           2       2         4
                        sin (x) - 6 cos (x) sin (x) + cos (x)
          (%o5)         -------------------------------------
                                          4
                                       sin (x)
          (%i6) cos(4 * x) / sin(x)^4, trigexpand, ratexpand;
                                     2         4
                                6 cos (x)   cos (x)
          (%o6)               - --------- + ------- + 1
                                    2          4
                                 sin (x)    sin (x)
          (%i7) ratexpand (trigexpand (cos(4 * x) / sin(x)^4));
                                     2         4
                                6 cos (x)   cos (x)
          (%o7)               - --------- + ------- + 1
                                    2          4
                                 sin (x)    sin (x)
          (%i8) declare ([F, G], evfun);
          (%o8)                         done
          (%i9) (aa : bb, bb : cc, cc : dd);
          (%o9)                          dd
          (%i10) aa;
          (%o10)                         bb
          (%i11) aa, F;
          (%o11)                        F(cc)
          (%i12) F (aa);
          (%o12)                        F(bb)
          (%i13) F (ev (aa));
          (%o13)                        F(cc)
          (%i14) aa, F, G;
          (%o14)                      G(F(cc))
          (%i15) G (F (ev (aa)));
          (%o15)                      G(F(cc))


 -- Variable opcional: infeval
     Habilita el modo de "evaluación infinita". `ev' repetidamente
     evalua una expresión hasta que se pare de hacer cambios. Para
     prevenir que una variable, digamos `X', sea evaluada sin parar en
     este modo, simplemente incluya `X='X' como argumento de `ev'.
     Esta claro que expresiones como `ev (X, X=X+1, infeval)' generarán
     un bucle infinito.

 -- Símbolo especial: noeval
     El símbolo `noeval' evita la fase de evaluación de `ev'.  Es útil
     conjuntamente con otras variables globales y para poder volver a
     simplificar expresiones sin tener que evaluarlas otra vez.


 -- Símbolo especial: nouns
     El símbolo `nouns' es una `evflag', lo que significa que cuando se
     utilice como una opción de la instrucción `ev', todas las formas
     nominales que aparezcan en una expresión las convierte en
     verbales, esto es, las evalúa.  Véanse también `noun', `nounify',
     `verb' y `verbify'.


 -- Símbolo especial: pred
     Cuando se utiliza como argumento en una llamada a `ev (<expr>)',
     `pred' provoca que los predicados (expresiones que se reducen a
     `true' o `false') se evalúen.

     Véase `ev'.

     Ejemplo:

          (%i1) 1<2;
          (%o1)                                1 < 2
          (%i2) 1<2,pred;
          (%o2)                                true


File: maxima.info,  Node: Expresiones,  Next: Simplificación,  Prev: Evaluación,  Up: Top

8 Expresiones
*************

* Menu:

* Introducción a las expresiones::
* Nombres y verbos::
* Identificadores::
* Desigualdades::
* Funciones y variables para expresiones::


File: maxima.info,  Node: Introducción a las expresiones,  Next: Nombres y verbos,  Prev: Expresiones,  Up: Expresiones

8.1 Introducción a las expresiones
==================================

Existe un cierto número de palabras reservadas que no deberían
utilizarse como nombres de variables. Su uso podría causar errores
sintácticos.

     integrate            next           from                 diff
     in                   at             limit                sum
     for                  and            elseif               then
     else                 do             or                   if
     unless               product        while                thru
     step

La mayoría de los objetos en Maxima son expresiones. Una secuencia de
expresiones puede constituir una expresión, separándolas por comas y
colocando paréntesis alrededor de ellas. Esto es similar a las
expresiones con coma en C.

     (%i1) x: 3$
     (%i2) (x: x+1, x: x^2);
     (%o2)                          16
     (%i3) (if (x > 17) then 2 else 4);
     (%o3)                           4
     (%i4) (if (x > 17) then x: 2 else y: 4, y+x);
     (%o4)                          20

Incluso los bucles en Maxima son expresiones, aunque el valor que
retornan (`done') no es muy útil.

     (%i1) y: (x: 1, for i from 1 thru 10 do (x: x*i))$
     (%i2) y;
     (%o2)                         done

pero quizás se quiera incluir un tercer término en la expresión con
coma para que devuelva el valor de interés.

     (%i3) y: (x: 1, for i from 1 thru 10 do (x: x*i), x)$
     (%i4) y;
     (%o4)                        3628800


File: maxima.info,  Node: Nombres y verbos,  Next: Identificadores,  Prev: Introducción a las expresiones,  Up: Expresiones

8.2 Nombres y verbos
====================

Maxima distingue entre operadores que son "nombres" y operadores que
son "verbos".  Un verbo es un operador que puede ser ejecutado.  Un
nombre es un operador que aparece como un símbolo en una expresión pero
sin ser ejecutado.  Por defecto, los nombres de funciones son verbos.
Un verbo puede transformarse en nombre utilizando el apóstrofo o
aplicando la función `nounify'.  Un nombre puede transformarse en verbo
aplicando la función `verbify'.  La variable `nouns' hace que `ev'
evalúe los nombres presentes en una expresión.

La forma verbal se distingue mediante la precedencia del carácter dólar
`$' al correspondiente símbolo de Lisp.  Por otro lado, la forma
nominal se distingue mediante la precedencia del carácter porcentaje
`%' al correspondiente símbolo de Lisp.  Algunos nombres gozan de
propiedades especiales para su representación, como `'integrate' o
`'derivative' (devuelto por `diff'), pero la mayoría no.  Por defecto,
las formas nominal y verbal de una función son idénticas cuando se
muestran en un terminal.  La variable global `noundisp' hace que Maxima
muestre los nombres precedidos del apóstrofo `''.

Véanse también `noun', `nouns', `nounify' y `verbify'.

Ejemplos:

     (%i1) foo (x) := x^2;
                                          2
     (%o1)                     foo(x) := x
     (%i2) foo (42);
     (%o2)                         1764
     (%i3) 'foo (42);
     (%o3)                        foo(42)
     (%i4) 'foo (42), nouns;
     (%o4)                         1764
     (%i5) declare (bar, noun);
     (%o5)                         done
     (%i6) bar (x) := x/17;
                                          x
     (%o6)                    ''bar(x) := --
                                          17
     (%i7) bar (52);
     (%o7)                        bar(52)
     (%i8) bar (52), nouns;
                                    52
     (%o8)                          --
                                    17
     (%i9) integrate (1/x, x, 1, 42);
     (%o9)                        log(42)
     (%i10) 'integrate (1/x, x, 1, 42);
                                  42
                                 /
                                 [   1
     (%o10)                      I   - dx
                                 ]   x
                                 /
                                  1
     (%i11) ev (%, nouns);
     (%o11)                       log(42)


File: maxima.info,  Node: Identificadores,  Next: Desigualdades,  Prev: Nombres y verbos,  Up: Expresiones

8.3 Identificadores
===================

En Maxima, los identificadores pueden contener caracteres alfabéticos,
números del 0 al 9 y cualquier otro carácter precedido de la barra
invertida `\'.

Un identificador puede comenzar con un carácter numérico si éste va
precedido de la barra invertida `\'.  Los caracteres numéricos que
ocupen la segunda posición o posterior no necesitan ir precedidos de la
barra invertida.

Los caracteres pueden declararse como alfabéticos con la función
`declare'.  Así declarados, no necesitan ir precedidos de la barra
invertida en un identificador.  En principio, los caracteres
alfabéticos son las letras de `A' a `Z' y `a' a `z', junto con  `%' y
`_'.

Maxima distingue minúsculas y mayúsculas. Los identificadores `foo',
`FOO' y `Foo' son distintos.  Véase *note Lisp y Maxima:: para más
información.

Un identificador en Maxima es un símbolo Lisp que comienza con el
símbolo dólar `$'.  Cualquier otro símbolo de Lisp va precedido de la
interrogación `?' cuando aparece en Maxima.  Véase *note Lisp y
Maxima:: para más información.

Ejemplos:

     (%i1) %an_ordinary_identifier42;
     (%o1)               %an_ordinary_identifier42
     (%i2) embedded\ spaces\ in\ an\ identifier;
     (%o2)           embedded spaces in an identifier
     (%i3) symbolp (%);
     (%o3)                         true
     (%i4) [foo+bar, foo\+bar];
     (%o4)                 [foo + bar, foo+bar]
     (%i5) [1729, \1729];
     (%o5)                     [1729, 1729]
     (%i6) [symbolp (foo\+bar), symbolp (\1729)];
     (%o6)                     [true, true]
     (%i7) [is (foo\+bar = foo+bar), is (\1729 = 1729)];
     (%o7)                    [false, false]
     (%i8) baz\~quux;
     (%o8)                       baz~quux
     (%i9) declare ("~", alphabetic);
     (%o9)                         done
     (%i10) baz~quux;
     (%o10)                      baz~quux
     (%i11) [is (foo = FOO), is (FOO = Foo), is (Foo = foo)];
     (%o11)                [false, false, false]
     (%i12) :lisp (defvar *my-lisp-variable* '$foo)
     *MY-LISP-VARIABLE*
     (%i12) ?\*my\-lisp\-variable\*;
     (%o12)                         foo


File: maxima.info,  Node: Desigualdades,  Next: Funciones y variables para expresiones,  Prev: Identificadores,  Up: Expresiones

8.4 Desigualdades
=================

Maxima dispone de los operadores de desigualdad `<', `<=', `>=', `>',
`#' y `notequal'.  Véase `if' para una descripción de las expresiones
condicionales.



Local Variables:
coding: iso-8859-1
End:
