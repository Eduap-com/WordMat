This is maxima.info, produced by makeinfo version 4.13 from
/home/vttoth/dev/maxima/doc/info/es//include-maxima.texi.

Este es el Manual de Maxima en versión Texinfo

Copyright 1994, 2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).  Un sistema de cálculo simbólico
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Funciones y variables para la programación,  Prev: Introducción a la programación,  Up: Programación

37.4 Funciones y variables para la programación
===============================================

 -- Función: backtrace ()
 -- Función: backtrace (<n>)
     Devuelve la pila de llamadas, esto es, la lista de funciones que
     han llamado a la función actualmente activa.

     La llamada a `backtrace()' devuelve la pila completa de llamadas.

     Ejemplos:

          (%i1) h(x) := g(x/7)$
          (%i2) g(x) := f(x-11)$
          (%i3) f(x) := e(x^2)$
          (%i4) e(x) := (backtrace(), 2*x + 13)$
          (%i5) h(10);
          #0: e(x=4489/49)
          #1: f(x=-67/7)
          #2: g(x=10/7)
          #3: h(x=10)
                                        9615
          (%o5)                         ----
                                         49

     La llamada `backtrace (<n>)' devuelve las <n> funciones más
     recientes, incluyendo a la función actualmente activa.

     Ejemplos:

          (%i1) h(x) := (backtrace(1), g(x/7))$
          (%i2) g(x) := (backtrace(1), f(x-11))$
          (%i3) f(x) := (backtrace(1), e(x^2))$
          (%i4) e(x) := (backtrace(1), 2*x + 13)$
          (%i5) h(10);
          #0: h(x=10)
          #0: g(x=10/7)
          #0: f(x=-67/7)
          #0: e(x=4489/49)
                                        9615
          (%o5)                         ----
                                         49


 -- Operador especial: do
     La sentencia `do' se utiliza para realizar iteraciones.  Debido a
     su generalidad la sentencia `do' se describirá en dos partes. En
     primer lugar se mostrará su forma más usual, análoga a la de otros
     lenguajes de programación (Fortran, Algol, PL/I, etc.); después se
     mencionarán otras formas de uso.

     Hay tres variantes de esta sentencia que se diferencian entre sí
     únicamente por las condiciones de fin de bucle. Son las siguientes:

        * `for <variable>: <valor_inicial> step <incremento>       thru
          <límite> do <cuerpo>'

        * `for <variable>: <valor_inicial> step <incremento>
          while <condición> do <cuerpo>'

        * `for <variable>: <valor_inicial> step <incremento>
          unless <condición> do <cuerpo>'

     El <valor_inicial>, el <incremento>, el <límite> y el <cuerpo>
     pueden ser cualquier tipo de expresión válida de Maxima. Si el
     incremento es igual a la unidad (1) entonces "`step 1'" puede
     omitirse.

     La ejecución de la sentencia `do' se realiza asignando el
     valor_inicial a la variable (llamada de aquí en adelante
     variable-control). A continuación: (1) si la variable-control ha
     excedido el límite de la especificación dada por un `thru', o si
     la condición impuesta por `unless' es verdadera (`true'), o si la
     condición dada por `while' es falsa (`false') entonces la
     iteración `do' termina. (2) El cuerpo se evalúa.  (3) El
     incremento es sumado a la variable-control. El proceso de (1) a
     (3) se repite hasta que la condición de fin de iteración se
     satisfaga. También es posible especificar varias condiciones de
     terminación del bucle, en cuyo caso `do' terminará cuando se
     satisfaga alguna de ellas.

     En general la condición `thru' se satisfará cuando la
     variable-control sea mayor que el límite si el incremento es no
     negativo, o cuando la variable-control sea menor que el límite
     cuando el incremento es negativo. El incremento y el límite pueden
     ser expresiones no numéricas, tanto en cuanto esta desigualdad
     pueda quedar determinada. Sin embargo, a menos que el incremento
     sea un número negativo en el momento de comenzar el cómputo de
     `do', Maxima supondrá que se evaluará a una cantidad positiva. En
     caso de no ser efectivamente positivo, la sentencia `do' puede dar
     un resultado inesperado.

     Nótese que el límite, el incremento y la condición de terminación
     se evalúan en cada iteración del bucle. Así, si alguna de
     expresiones necesitan de muchos cálculos y devuelven un resultado
     que no va a cambiar durante toda la ejecución del cuerpo, será más
     eficiente dar este valor a una variable antes de comenzar la
     sentencia `do' y utilizarla luego durante su ejecución.

     El valor que habitualmente devuelva la sentencia `do' será el
     átomo `done'. Sin embargo, la función `return' puede usarse dentro
     del cuerpo para salir de `do' de forma prematura retornando un
     valor determinado.  Nótese no obstante que un `return' dentro de
     un `do' que está dentro de un bloque (`block') provocará una
     salida de `do' pero no de `block'. Repárese también en que la
     función `go' no puede usarse para salir de `do' e ir a algún lugar
     de `block'.

     La variable-control es siempre local respecto de `do', por lo que
     se puede utilizar cualquier nombre de variable sin afectar el
     valor de cualquier otra variable externa a `do' y que tenga el
     mismo nombre. La variable-control no tendrá asignado ningún valor
     una vez se haya concluido el `do'.

          (%i1) for a:-3 thru 26 step 7 do display(a)$
                                       a = - 3

                                        a = 4

                                       a = 11

                                       a = 18

                                       a = 25

          (%i1) s: 0$
          (%i2) for i: 1 while i <= 10 do s: s+i;
          (%o2)                         done
          (%i3) s;
          (%o3)                          55

     Nótese que la condición `while i <= 10' es equivalente a `unless i
     > 10' y a `thru 10'.

          (%i1) series: 1$
          (%i2) term: exp (sin (x))$
          (%i3) for p: 1 unless p > 7 do
                    (term: diff (term, x)/p,
                     series: series + subst (x=0, term)*x^p)$
          (%i4) series;
                            7    6     5    4    2
                           x    x     x    x    x
          (%o4)            -- - --- - -- - -- + -- + x + 1
                           90   240   15   8    2

     lo que da ocho términos del desarrollo de Taylor de la función
     `e^sin(x)'.

          (%i1) poly: 0$
          (%i2) for i: 1 thru 5 do
                    for j: i step -1 thru 1 do
                        poly: poly + i*x^j$
          (%i3) poly;
                            5      4       3       2
          (%o3)          5 x  + 9 x  + 12 x  + 14 x  + 15 x
          (%i4) guess: -3.0$
          (%i5) for i: 1 thru 10 do
                    (guess: subst (guess, x, 0.5*(x + 10/x)),
                     if abs (guess^2 - 10) < 0.00005 then return (guess));
          (%o5)                  - 3.162280701754386

     Este ejemplo calcula la raíz cuadrada negativa de 10 haciendo 10
     iteraciones del método de Newton-Raphson. De no haberse alcanzado
     el criterio de convergencia el valor devuelto hubiese sido `done'.

     En lugar de añadir siempre una cantidad a la variable-control a
     veces se puede querer que cambie en cada iteración siguiendo algún
     otro criterio. En tal caso se puede hacer uso de `next
     <expresión>' en lugar de `step <incremento>'. Esto hará que a la
     variable-control se le asigne el resultado de evaluar la expresión
     en cada iteración del bucle.

          (%i6) for count: 2 next 3*count thru 20 do display (count)$
                                      count = 2

                                      count = 6

                                     count = 18

     En ocasiones puede interesar realizar una iteración en la que la
     variable-control no se utilice nunca. Se podrá entonces dar
     únicamente las condiciones de terminación del bucle omitiendo la
     inicialización y actualizando la información, tal como se hace en
     el siguiente ejemplo para calcular la raíz cuadrada de 5
     utilizando un valor inicial alejado de la solución.

          (%i1) x: 1000$
          (%i2) thru 20 do x: 0.5*(x + 5.0/x)$
          (%i3) x;
          (%o3)                   2.23606797749979
          (%i4) sqrt(5), numer;
          (%o4)                   2.23606797749979

     Si así se quiere, incluso es posible omitir las condiciones de
     terminación completamente y escribir únicamente `do <body>', lo
     que provocará entrar en un bucle infinito. En tal caso, debería
     usarse la función `return' a fin de terminar con la ejecución de
     `do'.

          (%i1) newton (f, x):= ([y, df, dfx], df: diff (f ('x), 'x),
                    do (y: ev(df), x: x - f(x)/y,
                        if abs (f (x)) < 5e-6 then return (x)))$
          (%i2) sqr (x) := x^2 - 5.0$
          (%i3) newton (sqr, 1000);
          (%o3)                   2.236068027062195

     (En este ejemplo, cuando se ejecuta `return' obliga a que sea `x'
     el valor devuelto por `do'. Al salirse del bloque, `x' es también
     el valor que devuelve `block' por ser `do' la última sentencia del
     bloque.)

     Hay todavía otra forma de `do' en Maxima. Su sintaxis es:

          for <variable> in <lista> <test_de_parada> do <cuerpo>

     Los elementos de <list> son cualesquiera expresiones que se irán
     asignando sucesivamente a la variable en cada repetición del
     cuerpo. El test de parada <end_tests> (que es opcional) puede
     usarse para terminar la ejecución de `do'; de otro modo las
     iteraciones se pararán cuando la lista se haya agotado o cuando se
     ejecute un `return' dentro del cuerpo.  (De hecho, la lista puede
     ser cualquier expresión no atómica, de la cual se irán extrayendo
     de forma sucesiva sus diferentes partes.)

          (%i1)  for f in [log, rho, atan] do ldisp(f(1))$
          (%t1)                                  0
          (%t2)                                rho(1)
                                               %pi
          (%t3)                                 ---
                                                4
          (%i4) ev(%t3,numer);
          (%o4)                             0.78539816


 -- Función: errcatch (<expr_1>, ..., <expr_n>)
     Evalúa las expresiones <expr_1>, ..., <expr_n> una a una y
     devuelve `[<expr_n>]' (una lista) en caso de que no ocurra ningún
     error. En caso de aparecer algún error durante el cálculo de
     alguno de los argumentos, `errcatch' evita que el error se
     propague y devuelve la lista vacía `[]' sin evaluar más argumentos.

     La función `errcatch' es útil en ficheros `batch' donde se
     sospeche que pueda aparecer algún error, el cual provocaría la
     terminación de la ejecución del `batch' de no ser previamente
     detectado.


 -- Función: error (<expr_1>, ..., <expr_n>)
 -- Variable del sistema: error
     Calcula y devuelve <expr_1>, ..., <expr_n>, enviando
     posteriormente una seãl de error a Maxima o al `errcatch' más
     cercano.

     A la variable `error' se le asigna una lista con la descripción
     del error. El primer elemento de `error' es una cadena de formato,
     la cual une todas las cadenas de los argumentos <expr_1>, ...,
     <expr_n>, siendo los demás elementos de la lista los valores de
     los argumentos que no son cadenas.

     La llamada a `errormsg()' formatea e imprime `error'. Se reimprime
     así el mensaje de error más reciente.


 -- Variable opcional: error_size
     Valor por defecto: 10

     La variable `error_size' modifica los mensajes de error de acuerdo
     con el tamaño de las expresiones que aparecen en él. Si el tamaño
     de una expresión (tal como lo determina la función Lisp
     `ERROR-SIZE') es mayor que `error_size', la expresión se reemplaza
     en el mensaje por un símbolo, asignándole a éste una expresión.
     Los símbolos se toman de la lista `error_syms'.

     En caso contrario, si la expresión es menor que `error_size', la
     expresión se muestra en el propio mensaje.

     Véanse también `error' y `error_syms'.

     Ejemplo:

     El tamaño de `U', tal como lo determina `ERROR-SIZE', es 24.

          (%i1) U: (C^D^E + B + A)/(cos(X-1) + 1)$

          (%i2) error_size: 20$

          (%i3) error ("Example expression is", U);

          Example expression is errexp1
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) errexp1;
                                      E
                                     D
                                    C   + B + A
          (%o4)                    --------------
                                   cos(X - 1) + 1
          (%i5) error_size: 30$

          (%i6) error ("Example expression is", U);

                                   E
                                  D
                                 C   + B + A
          Example expression is --------------
                                cos(X - 1) + 1
           -- an error.  Quitting.  To debug this try debugmode(true);


 -- Variable opcional: error_syms
     Valor por defecto: `[errexp1, errexp2, errexp3]'

     En los mensajes de error, las expresiones mayores que `error_size'
     son reemplazadas por símbolos a los cuales se les asignas estas
     expresiones.  Los símbolos se toman de la lista `error_syms'. La
     primera expresión que resulte ser demasiado larga se reemplaza por
     `error_syms[1]', la segunda por `error_syms[2]' y así
     sucesivamente.

     Si hay más expresiones largas que elementos en `error_syms', los
     símbolos se construyen automáticamente, siendo el <n>-ésimo
     símbolo equivalente a `concat ('errexp, <n>)'.

     Véanse también `error' y `error_size'.


 -- Función: errormsg ()
     Reimprime el mensaje de error más reciente. La variable `error'
     guarda el mensaje y `errormsg' lo formatea e imprime.


 -- Variable opcional: errormsg
     Valor por defecto: `true'

     Cuando `errormsg' vale `false' se suprimen los contenidos de los
     mensajes de error.

     La variable `errormsg' no se puede asignar a un valor local dentro
     de un bloque. El valor global de `errormsg' está siempre presente.

     Ejemplos:

          (%i1) errormsg;
          (%o1)                                true
          (%i2) sin(a,b);
          Wrong number of arguments to sin
           -- an error. To debug this try: debugmode(true);
          (%i3) errormsg:false;
          (%o3)                                false
          (%i4) sin(a,b);

           -- an error. To debug this try: debugmode(true);

     La variable `errormsg' no se puede asignar a un valor local dentro
     de un bloque.

          (%i1) f(bool):=block([errormsg:bool],
                               print ("value of errormsg is",errormsg))$
          (%i2) errormsg:true;
          (%o2)                                true
          (%i3) f(false);
          value of errormsg is true
          (%o3)                                true
          (%i4) errormsg:false;
          (%o4)                                false
          (%i5) f(true);
          value of errormsg is false
          (%o5)                                false

 -- Operador especial: for
     Utilizado en las iteraciones. Véase `do' para una descripción de
     las técnicas de iteración en Maxima.


 -- Función: go (<etiqueta>)
     Se utiliza dentro de un bloque (`block') para transferir el
     control a la sentencia del bloque que esté etiquetada con el
     argumento de `go'. Una sentencia queda etiquetada cuando está
     precedida por un argumento de tipo átomo como cualquier otra
     sentencia de `block'.  Por ejemplo:

          block ([x], x:1, tururu, x+1, ..., go(tururu), ...)

     El argumento de `go' debe ser el nombre de una etiqueta que
     aparezca en el mismo bloque (`block'). No se puede utilizar `go'
     para transferir el control a un bloque que no sea aquel que
     contenga la sentencia `go'.


 -- Operador especial: if
     Evaluación condicionada. Se reconocen varias formas de expresiones
     `if'.

     La expresión `if <cond_1> then <expr_1> else <expr_0>' devuelve
     <expr_1> si <cond_1> vale `true', en caso contrario la respuesta
     es `expr_0'.

     La expresión `if <cond_1> then <expr_1> elseif <cond_2> then
     <expr_2> elseif ... else <expr_0>' devuelve <expr_k> si <cond_k>
     vale `true' y todas las condiciones anteriores toman el valor
     `false'.  Si ninguna de las condiciones vale `true', la respuesta
     es `expr_0'.

     La falta de un `else' final se interpreta como un `else false';
     esto es, la expresión `if <cond_1> then <expr_1>' equivale a `if
     <cond_1> then <expr_1> else false', y `if <cond_1> then <expr_1>
     elseif ... elseif <cond_n> then <expr_n>' equivale a su vez a `if
     <cond_1> then <expr_1> elseif ... elseif <cond_n> then <expr_n>
     else false'.

     Las alternativas <expr_0>, ..., <expr_n> pueden ser expresiones
     válidas de Maxima, incluidas expresiones `if' anidadas.  Las
     alternativas ni se simplifican ni se evalúan, a menos que su
     condición asociada valga `true'.

     Las condiciones <cond_1>, ..., <cond_n> deben ser expresiones
     capaces de dar como resultado `true' o `false' al ser evaluadas.
     Si en un momento dado una condición no da como resultado un valor
     de verdad (`true' o `false'), el comportamiento de `if' se controla
     con la variable global `prederror'. Si `prederror' vale `true', se
     considera un error que la condición evaluada no dé como resultado
     un valor de verdad; en caso contrario, las condiciones que no den
     como resultado un valor de verdad se aceptan, dándose el resultado
     como una expresión condicional.

     Las condiciones pueden contener operadores lógicos y relacionales,
     así como otros elementos, tal como se indica a continuación:

          Operación               Símbolo     Tipo

          menor que               <           operador relacional infijo
          menor o igual que       <=          operador relacional infijo
          igualdad (sintáctica)   =           operador relacional infijo
          negación de =           #           operador relacional infijo
          igualdad (por valor)    equal       operador relacional infijo
          negación de equal       notequal    operador relacional infijo
          mayor o igual que       >=          operador relacional infijo
          mayor que               >           operador relacional infijo
          y                       and         operador lógico infijo
          o                       or          operador lógico infijo
          no                      not         operador lógico prefijo


 -- Función: map (<f>, <expr_1>, ..., <expr_n>)
     Devuelve una expresión cuyo operador principal es el mismo que
     aparece en las expresiones <expr_1>, ..., <expr_n> pero cuyas
     subpartes son los resultados de aplicar <f> a cada una de las
     subpartes de las expresiones;  <f> puede ser tanto el nombre de
     una función de n argumentos como una expresión `lambda' de n
     argumentos.

     Uno de los usos que tiene `map' es la de aplicar (o mapear) una
     función (por ejemplo, `partfrac') sobre cada término de una
     expresión extensa en la que normalmente no se podría utilizar la
     función debido a insuficiencias en el espacio de almacenamiento
     durante el curso de un cálculo.

          (%i1) map(f,x+a*y+b*z);
          (%o1)                        f(b z) + f(a y) + f(x)
          (%i2) map(lambda([u],partfrac(u,x)),x+1/(x^3+4*x^2+5*x+2));
                                     1       1        1
          (%o2)                     ----- - ----- + -------- + x
                                   x + 2   x + 1          2
                                                   (x + 1)
          (%i3) map(ratsimp, x/(x^2+x)+(y^2+y)/y);
                                                1
          (%o3)                            y + ----- + 1
                                              x + 1
          (%i4) map("=",[a,b],[-0.5,3]);
          (%o4)                          [a = - 0.5, b = 3]

     Véase también `maperror' .

 -- Función: mapatom (<expr>)
     Devuelve `true' si y sólo <expr> es tratado por las rutinas de
     mapeo como un átomo.

 -- Variable opcional: maperror
     Valor por defecto: `true'

     Cuando `maperror' toma el valor `false', hace que todas las
     funciones de mapeo, como por ejemplo

          map (f, <expr_1>, <expr_2>, ...)

     (1) paren cuando hayan terminado de procesar la <expr_i> más corta,
     a menos que todas ellas sean del mismo tamaño y (2) apliquen  `f'
     a `[expr_1, expr_2, ...]' si es el caso que las `expr_i' no son
     todas del mismo tipo de objeto.

     Cuando `maperror' toma el valor `true' entonces se emite un
     mensaje de error cuando se presenta cualquiera de los dos casos
     anteriores.


 -- Variable opcional: mapprint
     Valor por defecto: `true'

     Si `mapprint' vale `true', se producirán ciertos mensajes por
     parte de las funciones `map', `mapl' y `fullmap' en determinadas
     situaciones, como cuando `map' hace uso de `apply'.

     Si `mapprint' vale `false', no se emitirán tales mensajes.

 -- Función: maplist (<f>, <expr_1>, ..., <expr_n>)
     Devuelve una lista con las aplicaciones de <f> a las partes de las
     expresiones <expr_1>, ..., <expr_n>; <f> es el nombre de una
     función ou una expresión lambda.

     La función `maplist' difiere de `map (<f>, <expr_1>, ...,
     <expr_n>)', la cual devuelve una expresión con el mismo operador
     principal que tenga <expr_i>, excepto en simplificaciones y en el
     caso en el que `map' hace un `apply'.


 -- Variable opcional: prederror
     Valor por defecto: `false'

     Cuando `prederror' toma el valor `true', se emite un mensaje de
     error siempre que el predicado de una sentencia  `if' o de una
     función `is' no se pueda evaluar ni a verdadero (`true') ni  a
     falso (`false').

     Si toma el valor `false', se devuelve bajo las mismas
     circunstancias anteriores el valor `unknown'. El modo `prederror:
     false' no está soportado en el código traducido; sin embargo,
     `maybe' está soportado en código traducido.

     Véanse también `is' y `maybe'.


 -- Función: return (valor)
     Puede utilizarse para salir de un bloque, devolviendo su argumento.
     Véase `block' para más información.


 -- Función: scanmap (<f>, <expr>)
 -- Función: scanmap (<f>, <expr>, bottomup)
     Aplica recursivamente <f> sobre <expr>, de arriba hacia abajo.
     Esto es más útil cuando se busca una factorización completa, por
     ejemplo:

          (%i1) exp:(a^2+2*a+1)*y + x^2$
          (%i2) scanmap(factor,exp);
                                              2      2
          (%o2)                         (a + 1)  y + x

     Nótese que cómo `scanmap' aplica la función dada `factor' a las
     subexpresiones que forman a <expr>; si se presenta otra forma de
     <expr> a `scanmap' entonces el resultado puede ser diferente. Así,
     `%o2' no se restaura cuando `scanmap' se aplica a la forma
     expandida de exp:

          (%i3) scanmap(factor,expand(exp));
                                     2                  2
          (%o3)                      a  y + 2 a y + y + x

     Aquí hay otro ejemplo de la forma en que `scanmap' aplica
     recursivamente una función dada a todas las subexpresiones,
     incluyendo exponentes:

          (%i4) expr : u*v^(a*x+b) + c$
          (%i5) scanmap('f, expr);
                              f(f(f(a) f(x)) + f(b))
          (%o5) f(f(f(u) f(f(v)                      )) + f(c))

     `scanmap (<f>, <expr>, bottomup)' aplica <f> a <expr> de abajo
     hacia arriba. Por ejemplo, para `f' no definida,

          scanmap(f,a*x+b) ->
             f(a*x+b) -> f(f(a*x)+f(b)) -> f(f(f(a)*f(x))+f(b))
          scanmap(f,a*x+b,bottomup) -> f(a)*f(x)+f(b)
              -> f(f(a)*f(x))+f(b) ->
               f(f(f(a)*f(x))+f(b))

     En este caso se obtiene la misma respuesta por cualquiera de los
     dos métodos.


 -- Función: throw (<expr>)
     Evalúa <expr> y devuelve el valor del `catch' más reciente. La
     función `throw' se utiliza junto con `catch' como un mecanismo de
     retorno no local.


 -- Operador especial: while
 -- Operador especial: unless
     Véase `do'.


 -- Función: outermap (<f>, <a_1>, ..., <a_n>)
     Aplica la función <f> a cada uno de los elementos del producto
     vectorial <a_1> por <a_2> ... por <a_n>.

     El argumento <f> debe ser el nombre de una función de n argumentos,
     o una expresión lambda de n argumentos.  Cada uno de los
     argumentos <a_k> puede ser una lista, una lista anidada, una
     matriz o cualquier otro tipo de expresión.

     El valor devuelto por `outermap' es una estructura anidada. Si <x>
     es la respuesta dada por `outermap', entonces tiene la misma
     estructura que la primera lista, lista anidada o matriz,
     `<x>[i_1]...[i_m]' tiene la misma estructura que la segunda lista,
     lista anidada o matriz, `<x>[i_1]...[i_m][j_1]...[j_n]' tiene la
     misma estructura que la tercera lista, lista anidada o matriz, y
     así sucesivamente, siendo <m>, <n>, ... los números índice
     necesarios para acceder a los elementos de cada argumento: uno
     para las listas, dos para las matrices y uno o más para las listas
     anidadas.  Aquellos argumentos que no sean listas ni matrices no
     tienen efecto alguno sobre la estructura del valor retornado.

     Nótese que el efecto producido por `outermap' es diferente del que
     se obtiene al aplicar <f> a cada uno de los elementos del producto
     devuelto por `cartesian_product'. La función `outermap' mantiene
     la estructura de los argumentos en la respuesta, miemtras que
     `cartesian_product' no lo hace.

     La función `outermap' evalúa sus argumentos.

     Véanse también `map', `maplist' y `apply'.

     Ejemplos:

     Ejemplos elementales de uso de `outermap'.  Con el fin de mostrar
     con mayor claridad las combinaciones del argumento, se mantiene
     sin definir `F'.

          (%i1) outermap (F, [a, b, c], [1, 2, 3]);
          (%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)],
                                               [F(c, 1), F(c, 2), F(c, 3)]]
          (%i2) outermap (F, matrix ([a, b], [c, d]), matrix ([1, 2], [3, 4]));
                   [ [ F(a, 1)  F(a, 2) ]  [ F(b, 1)  F(b, 2) ] ]
                   [ [                  ]  [                  ] ]
                   [ [ F(a, 3)  F(a, 4) ]  [ F(b, 3)  F(b, 4) ] ]
          (%o2)    [                                            ]
                   [ [ F(c, 1)  F(c, 2) ]  [ F(d, 1)  F(d, 2) ] ]
                   [ [                  ]  [                  ] ]
                   [ [ F(c, 3)  F(c, 4) ]  [ F(d, 3)  F(d, 4) ] ]
          (%i3) outermap (F, [a, b], x, matrix ([1, 2], [3, 4]));
                 [ F(a, x, 1)  F(a, x, 2) ]  [ F(b, x, 1)  F(b, x, 2) ]
          (%o3) [[                        ], [                        ]]
                 [ F(a, x, 3)  F(a, x, 4) ]  [ F(b, x, 3)  F(b, x, 4) ]
          (%i4) outermap (F, [a, b], matrix ([1, 2]), matrix ([x], [y]));
                 [ [ F(a, 1, x) ]  [ F(a, 2, x) ] ]
          (%o4) [[ [            ]  [            ] ],
                 [ [ F(a, 1, y) ]  [ F(a, 2, y) ] ]
                                        [ [ F(b, 1, x) ]  [ F(b, 2, x) ] ]
                                        [ [            ]  [            ] ]]
                                        [ [ F(b, 1, y) ]  [ F(b, 2, y) ] ]
          (%i5) outermap ("+", [a, b, c], [1, 2, 3]);
          (%o5) [[a + 1, a + 2, a + 3], [b + 1, b + 2, b + 3],
                                                     [c + 1, c + 2, c + 3]]

     El siguiente ejemplo permite hacer un análisis más profundo del
     valor retornado por `outermap'.  Los tres primeros argumentos son
     una matriz, una lista y otra matriz, en este orden. El valor
     devuelto es una matriz, cuyos elementos son listas y cada elemento
     de cada una de estas listas es a su vez una matriz.

          (%i1) arg_1 :  matrix ([a, b], [c, d]);
                                      [ a  b ]
          (%o1)                       [      ]
                                      [ c  d ]
          (%i2) arg_2 : [11, 22];
          (%o2)                       [11, 22]
          (%i3) arg_3 : matrix ([xx, yy]);
          (%o3)                      [ xx  yy ]
          (%i4) xx_0 : outermap(lambda([x, y, z], x / y + z), arg_1,
                                                             arg_2, arg_3);
                         [  [      a        a  ]  [      a        a  ]  ]
                         [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                         [  [      11       11 ]  [      22       22 ]  ]
          (%o4)  Col 1 = [                                              ]
                         [  [      c        c  ]  [      c        c  ]  ]
                         [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                         [  [      11       11 ]  [      22       22 ]  ]
                           [  [      b        b  ]  [      b        b  ]  ]
                           [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                           [  [      11       11 ]  [      22       22 ]  ]
                   Col 2 = [                                              ]
                           [  [      d        d  ]  [      d        d  ]  ]
                           [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                           [  [      11       11 ]  [      22       22 ]  ]
          (%i5) xx_1 : xx_0 [1][1];
                     [      a        a  ]  [      a        a  ]
          (%o5)     [[ xx + --  yy + -- ], [ xx + --  yy + -- ]]
                     [      11       11 ]  [      22       22 ]
          (%i6) xx_2 : xx_0 [1][1] [1];
                                [      a        a  ]
          (%o6)                 [ xx + --  yy + -- ]
                                [      11       11 ]
          (%i7) xx_3 : xx_0 [1][1] [1] [1][1];
                                            a
          (%o7)                        xx + --
                                            11
          (%i8) [op (arg_1), op (arg_2), op (arg_3)];
          (%o8)                  [matrix, [, matrix]
          (%i9) [op (xx_0), op (xx_1), op (xx_2)];
          (%o9)                  [matrix, [, matrix]

     La función `outermap' mantiene la estructura de los argumentos en
     su respuesta, mientras que `cartesian_product' no lo hace.

          (%i1) outermap (F, [a, b, c], [1, 2, 3]);
          (%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)],
                                               [F(c, 1), F(c, 2), F(c, 3)]]
          (%i2) setify (flatten (%));
          (%o2) {F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3),
                                                 F(c, 1), F(c, 2), F(c, 3)}
          (%i3) map (lambda ([L], apply (F, L)), cartesian_product ({a, b, c}, {1, 2, 3}));
          (%o3) {F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3),
                                                 F(c, 1), F(c, 2), F(c, 3)}
          (%i4) is (equal (%, %th (2)));
          (%o4)                         true



File: maxima.info,  Node: Depurado,  Next: augmented_lagrangian,  Prev: Programación,  Up: Top

38 Depurado
***********

* Menu:

* Depuración del código fuente::
* Claves de depuración::
* Funciones y variables para depurado::


File: maxima.info,  Node: Depuración del código fuente,  Next: Claves de depuración,  Up: Depurado

38.1 Depuración del código fuente
=================================

Maxima es capaz de dar asistencia en la depuración del código fuente.
Un usuario puede establecer un punto de referencia dentro del código de
una función a partir del cual se siga la ejecución línea a línea. La
compliación puede ser posteriormente examinada, conjuntamente con los
valores que se han ido asignando a las variables.

La instrucción `:help', o `:h', muestra la lista de comandos para la
depuración. (En general, los comandos pueden abreviarse; en algunos
casos la lista de alternativas podrá ser listada.) Dentro del
depurador, el usuario podrá examinar también cualquier función propia
de Maxima, definirla y manipular variables y expresiones.

El punto de referencia se establecerá con la instrucción `:br'. Ya
dentro del depurador, el usuario podrá avanzar una línea de cada vez
utilizando la instrucción `:n' (de "next", en inglés). La orden `:bt'
(de "backtrace") muestra la lista de la pila. Finalmente, con el
comando `:r' ("resume") se abandona el depurador continuando con la
ejecución. El uso de estas instrucciones se muestra en el siguiente
ejemplo.

     (%i1) load ("/tmp/foobar.mac");

     (%o1)                           /tmp/foobar.mac

     (%i2) :br foo
     Turning on debugging debugmode(true)
     Bkpt 0 for foo (in /tmp/foobar.mac line 1)

     (%i2) bar (2,3);
     Bkpt 0:(foobar.mac 1)
     /tmp/foobar.mac:1::

     (dbm:1) :bt                  <-- pulsando :bt se retrocede
     #0: foo(y=5)(foobar.mac line 1)
     #1: bar(x=2,y=3)(foobar.mac line 9)

     (dbm:1) :n                   <-- pulsando :n se avanza una línea
     (foobar.mac 2)
     /tmp/foobar.mac:2::

     (dbm:1) :n                   <-- pulsando :n se avanza otra línea
     (foobar.mac 3)
     /tmp/foobar.mac:3::

     (dbm:1) u;                   <-- se pide el valor de u
     28

     (dbm:1) u: 33;               <-- se cambia el valor de u a 33
     33

     (dbm:1) :r                   <-- pulsando :r se termina la depuración

     (%o2)                                1094

El fichero `/tmp/foobar.mac' contiene lo siguiente:

     foo(y) := block ([u:y^2],
       u: u+3,
       u: u^2,
       u);

     bar(x,y) := (
       x: x+2,
       y: y+2,
       x: foo(y),
       x+y);

USO DEL DEPURADOR EN EMACS

Si el usuario está corriendo el código bajo GNU emacs en un entorno de
texto (dbl shell), o está ejecutando el  entorno gráfico `xmaxima',
entonces cuando una función pare en el punto de referencia, podrá
observar su posición actual en el archivo fuente, el cual será mostrado
en la otra mitad de la ventana, bien resaltada en rojo, o con una
pequeña flecha apuntando a la línea correcta. El usuario puede avanzar
líneas simples tecleando M-n (Alt-n).

Bajo Emacs se debe ejecutar el programa en una ventana de texto `dbl',
la cual requiere el archivo `dbl.el' que está en el directorio elisp.
El usuario debe instalar los archivos elisp o agregar el directorio
elisp de Maxima a la ruta de búsqueda: por ejemplo, se puede añadir lo
siguiente al archivo `.emacs' o al `site-init.el'

     (setq load-path (cons "/usr/share/maxima/5.9.1/emacs" load-path))
     (autoload 'dbl "dbl")

entonces en emacs

     M-x dbl

debería abrir una ventana del sistema en la cual se pueden ejecutar
programas, por ejemplo Maxima, gcl, gdb, etc.  En esta ventana también
se puede ejecutar el depurador, mostrando el código fuente en la otra
ventana.

El usuario puede colocar un punto de referencia en una línea
determinada sin más que teclear `C-x space'. Con esto se le hace saber
al depurador en qué función está el cursor y en qué línea del mismo. Si
el cursor está en la línea 2 de `foo', entonces insertará en la otra
ventana la instrucción "`:br foo 2'", a fin de detener `foo' justo en
la segunda línea. Para tener esto operativo, el usuario debe tener
activo maxima-mode.el (modo-maxima.el) en la ventana en la que está
`foobar.mac'. Hay otros comandos disponibles en la ventana, como
evaluar la función dentro de Maxima tecleando `Alt-Control-x'.


File: maxima.info,  Node: Claves de depuración,  Next: Funciones y variables para depurado,  Prev: Depuración del código fuente,  Up: Depurado

38.2 Claves de depuración
=========================

Las claves de depuración son palabras que no son interpretadas como
expresiones de Maxima. Una clave de depuración puede introducirse
dentro de Maxima o del depurador. Las claves de depuración comienzan
con dos puntos, ':'. Por ejemplo, para evaluar una expresión Lisp, se
puede teclear `:lisp' seguido de la expresión a ser evaluada.

     (%i1) :lisp (+ 2 3)
     5

El número de argumentos depende del comando en particular. Además,
tampoco es necesario teclear el nombre completo de la instrucción, tan
solo lo justo para diferenciarla de las otras instrucciones. Así, `:br'
sería suficiente para `:break'.

Las claves de depuración se listan a continuación.

`:break F n'
     Establece un punto de referencia en la función `F' en la línea `n'
     contando a partir del comienzo de la función. Si `F' es una
     cadena, entonces se entiende que se trata de un fichero, siendo
     entonces `n' el número de línea a partir del comienzo del fichero.
     El valor `n' es opcional; en caso de no ser suministrado, se
     entenderá que vale cero (primera línea de la función o fichero).

`:bt'
     Retrocede en la pila.

`:continue'
     Continua el cómputo de la función.

`:delete'
     Borra los punto de referencia especificados, o todos si no se
     especifica ninguno.

`:disable'
     Deshabilita los puntos de referencia especificados, o todos si no
     se especifica ninguno.

`:enable'
     Habilita los puntos de referencia especificados, o todos si no se
     especifica ninguno.

`:frame n'
     Imprime el elemento `n' de la pila, o el actualmente activo si no
     se especifica ninguno.

`:help'
     Imprime la ayuda sobre un comando del depurador, o de todos los
     comandos si no se especifica ninguno.

`:info'
     Imprime información sobre un elemento.

`:lisp expresión'
     Evalúa la `expresión' Lisp.

`:lisp-quiet expresión'
     Evalúa la `expresión' Lisp sin devolver el resultado.

`:next'
     Como `:step', excepto que `:next' se salta las llamadas a
     funciones.

`:quit'
     Sale del nivel actual del depurador sin completar el cómputo.

`:resume'
     Continúa con el cómputo.

`:step'
     Sigue con el cómputo de la función o fichero hasta que alcance una
     nueva línea fuente.

`:top'
     Retorna a Maxima desde cualquier nivel del depurador sin completar
     el cómputo.


File: maxima.info,  Node: Funciones y variables para depurado,  Prev: Claves de depuración,  Up: Depurado

38.3 Funciones y variables para depurado
========================================

 -- Variable opcional: debugmode
     Valor por defecto: `false'

     Cuando en Maxima ocurre un error, Maxima inicializará el depurador
     si `debugmode' tiene el valor `true'.  El usuario puede ingresar
     comandos para examinar la pila de llamadas, los puntos de
     interrupción; en pocas palabras ir a través del código de Maxima.
     Vea `debugging' para una lista de los comandos del depurador.

     Habilitando `debugmode' no se capturarán los errores tipo Lisp.


 -- Variable opcional: refcheck
     Valor por defecto: `false'

     Cuando `refcheck' vale `true', Maxima imprime un mensaje cada vez
     que una variable es utilizada por vez primera en un cálculo.


 -- Variable opcional: setcheck
     Valor por defecto: `false'

     Cuando el valor de `setcheck' es una lista de variables (se admite
     que tengan subíndices) Maxima devuelve un mensaje indicando si los
     valores que han sido asignados a las variables lo han sido con el
     operador ordinario `:', o con el operador de asignación `::' o
     como resultado de haberse realizado una llamada de función, pero
     en ningún caso cuando la asignación haya sido hecha mediante los
     operadores `:=' o `::='. El mensaje contiene el nombre de la
     variable y su valor.

     La variable `setcheck' admite también los valores `all' o `true'
     con lo que el informe incluirá todas las variables.

     Cada nueva asignación de `setcheck' establece una nueva lista de
     variables a ser monitorizada, de forma que cualquier otra variable
     previamente asignada a `setcheck' es olvidada.

     Los nombres asignados a `setcheck' deben estar precedidos del
     apóstrofo `'' a fin de evitar que las variables sean evaluadas
     antes de ser almacenadas en `setcheck'. Por ejemplo, si `x', `y' y
     `z' ya guardan algún valor entoces se hará

          setcheck: ['x, 'y, 'z]$

     para colocarlas en la lista de variables a monitorizar.

     No se generará ninguna salida cuando una variable de la lista
     `setcheck' sea asignada a ella misma, como en `X: 'X'.


 -- Variable opcional: setcheckbreak
     Valor por defecto: `false'

     Si `setcheckbreak' es igual `true', Maxima se detendrá siempre que
     a una variable de la lista `setcheck' se le asigne un nuevo valor.
     La detención tendrá lugar justo antes de hacerse la asignación. En
     ese momento `setval' guarda el valor que se le va a dar a la
     variable. Entonces el usuario podrá darle un valor diferente
     pasándoselo a la variable `setval'.

     Véanse también `setcheck' y `setval'.


 -- Variable del sistema: setval
     Guarda el valor que va a ser asignado a una variable cuando
     `setcheckbreak' realiza una detención. Entonces se podrá asignarle
     otro valor pasándoselo previamente a `setval'.

     Véanse también `setcheck' y `setcheckbreak'.


 -- Función: timer (<f_1>, ..., <f_n>)
 -- Función: timer (all)
 -- Función: timer ()
     Dadas las funciones <f_1>, ..., <f_n>, `timer' coloca cada una de
     ellas en la lista de funciones para las cuales se generarán
     estadísticas relativas al tiempo de cómputo. Así, `timer(f)$
     timer(g)$' coloca a `f' y luego a `g' en dicha lista de forma
     acumulativa.

     La sentencia `timer(all)' coloca todas las funciones de usuario
     (las referenciadas por la variable global `functions') en la lista
     de funciones cuyos tiempos de ejecución se quieren monitorizar.

     Si no se le pasan argumentos a `timer' se obtendrá la lista de
     funciones cuyos tiempos de ejecución se quieren monitorizar.

     Maxima almacena la duración del cómputo de cada función de la
     lista, de forma que `timer_info' devolverá las estadísticas
     correspondientes, incluyendo el tiempo medio de cada llamada a la
     función, el número de llamadas realizadas y el tiempo total
     transcurrido. La instrucción `untimer' borra las funciones de la
     lista.

     La función `timer' no evalúa sus argumentos, de forma que `f(x) :=
     x^2$ g:f$ timer(g)$' no coloca a `f' en la lista.

     Si `trace(f)' está activada, entonces `timer(f)' está desactivada;
     `trace' y `timer' no pueden estar operativas al mismo tiempo.

     Véase también `timer_devalue'.


 -- Función: untimer (<f_1>, ..., <f_n>)
 -- Función: untimer ()
     Dadas las funciones <f_1>, ..., <f_n>, `untimer' las elimina de la
     lista de funciones cuyos tiempos de ejecución se quiere
     monitorizar.

     Si no se le suministran argumentos, `untimer' borra completamente
     la lista.

     Tras la ejecución de `untimer (f)', `timer_info (f)' aún devuelve
     las estadísticas de tiempo previamente registradas, pero
     `timer_info()' (sin argumentos) no devuelve información sobre
     aquellas funciones que ya no están en la lista. La ejecución de
     `timer (f)' inicializa todas las estadísticas a cero y coloca `f'
     nuevamente en la lista.


 -- Variable opcional: timer_devalue
     Valor por defecto: `false'

     Si `timer_devalue' es igual a `true', Maxima le resta a cada
     función cuyos tiempos de ejecución se quiere monitorizar el tiempo
     gastado en llamadas a otras funciones presentes también en la
     lista de monitorización. En caso contrario, los tiempos que se
     obtienen para cada función incluyen también los consumidos en
     otras funciones. Nótese que el tiempo consumido en llamadas a
     otras funciones que no están en la lista de monitorización no se
     resta del tiempo total.

     Véanse también `timer' y `timer_info'.


 -- Función: timer_info (<f_1>, ..., <f_n>)
 -- Función: timer_info ()
     Dadas las funciones <f_1>, ..., <f_n>, `timer_info' devuelve una
     matriz con información relativa a los tiempos de ejecución de cada
     una de estas funciones. Sin argumentos, `timer_info' devuelve la
     información asociada a todas las funciones cuyos tiempos de
     ejecución se quiere monitorizar.

     La matriz devuelta por `timer_info' incluye los nombres de las
     funciones, tiempo de ejecución en cada llamada, número de veces
     que ha sido llamada, tiempo total de ejecución y tiempo consumido
     en la recolección de basura, `gctime' (del inglés, "garbage
     collection time") en la versión original de Macsyma, aunque ahora
     toma el valor constante cero.

     Los datos con los que `timer_info' construye su respuesta pueden
     obtenerse también con la función `get':

          get(f, 'calls);  get(f, 'runtime);  get(f, 'gctime);

     Véase también `timer'.


 -- Función: trace (<f_1>, ..., <f_n>)
 -- Función: trace (all)
 -- Función: trace ()
     Dadas las funciones <f_1>, ..., <f_n>, `trace' imprime información
     sobre depuración cada vez que estas funciones son llamadas;
     `trace(f)$ trace(g)$' coloca de forma acumulativa a `f' y luego a
     `g' en la lista de funciones a ser rastradas.

     La sentencia `trace(all)' coloca todas las funciones de usuario
     (las referenciadas por la variable global `functions') en la lista
     de funciones a ser rastreadas.

     Si no se suministran argumentos, `trace' devuelve una lista con
     todas las funciones a ser rastreadas.

     La función `untrace' desactiva el rastreo. Véase también
     `trace_options'.

     La función `trace' no evalúa sus argumentos, de forma que `f(x) :=
     x^2$ g:f$ trace(g)$' no coloca a `f' en la lista de rastreo.

     Cuando una función se redefine es eliminada de la lista de
     rastreo. Así, tras  `timer(f)$ f(x) := x^2$', la función `f'
     dejará de estar en dicha lista.

     Si `timer (f)' está activado, entonces `trace (f)' está
     desactivado, ya que `trace' y `timer' no pueden estar ambos
     activos para la misma función.


 -- Función: trace_options (<f>, <option_1>, ..., <option_n>)
 -- Función: trace_options (<f>)
     Establece las opciones de rastreo para la función <f>. Cualquier
     otra opción previamente especificada queda reemplazada por las
     nuevas. La ejecución de `trace_options (<f>, ...)' no tiene ningún
     efecto, a menos que se haya invocado previamente a `trace (<f>)'
     (es indiferente que esta invocación sea anterior o posterior a
     `trace_options').

     `trace_options (<f>)' inicializa todas las opciones a sus valores
     por defecto.

     Las claves de opciones son:

        * `noprint': No se imprime mensaje alguno ni a la entrada ni a
          la salida de la función.

        * `break': Coloca un punto de referencia antes de que la
          función comience a ejecutarse y otro después de que termine
          su ejecución. Véase `break'.

        * `lisp_print': Muestra los argumentos y valores retornados
          como objetos de Lisp.

        * `info': Imprime `-> true' tanto a la entrada como a la salida
          de la función.

        * `errorcatch': Detecta errores, otorgando la posibilidad de
          marcar un error, reintentar la llamada a la función o
          especificar un valor de retorno.

     Las opciones de rastreo se especifican de dos formas. La única
     presencia de la clave de opción ya activa la opción. (Nótese que
     la opción <foo> no se activa mediante `<foo>: true' u otra forma
     similar; se tendrá en cuenta también que las claves no necesitan
     ir precedidas del apóstrofo.) Especificando la clave de opción
     junto con una función de predicado se hace que la opción quede
     condicionada al predicado.

     La lista de argumentos para las funciones de predicado es siempre
     `[level, direction, function, item]' donde `level' es el nivel de
     recursión para la función,  `direction' puede ser tanto `enter'
     como `exit', `function' es el nombre de la función  y `item' es la
     lista de argumentos (a la entrada) o el valor de retorno (a la
     salida).

     A continuación un ejemplo de opciones de rastreo no condicionales:

          (%i1) ff(n) := if equal(n, 0) then 1 else n * ff(n - 1)$

          (%i2) trace (ff)$

          (%i3) trace_options (ff, lisp_print, break)$

          (%i4) ff(3);

     Para la misma función, con la opción `break' condicionada a un
     predicado:

          (%i5) trace_options (ff, break(pp))$

          (%i6) pp (level, direction, function, item) := block (print (item),
              return (function = 'ff and level = 3 and direction = exit))$

          (%i7) ff(6);


 -- Función: untrace (<f_1>, ..., <f_n>)
 -- Función: untrace ()
     Dadas las funciones <f_1>, ..., <f_n>, `untrace' desactiva el
     rastreo previamente activado por la función `trace'. Si no se
     aportan argumentos, `untrace' desactiva el rastreo de todas las
     funciones.

     La llamada a `untrace' devuelve una lista con las funciones para
     las que el rastreo se ha desactivado.



File: maxima.info,  Node: augmented_lagrangian,  Next: Bernstein,  Prev: Depurado,  Up: Top

39 augmented_lagrangian
***********************

* Menu:

* Funciones y variables para augmented_lagrangian::


File: maxima.info,  Node: Funciones y variables para augmented_lagrangian,  Prev: augmented_lagrangian,  Up: augmented_lagrangian

39.1 Funciones y variables para augmented_lagrangian
====================================================

 -- Función: augmented_lagrangian_method (<FOM>, <xx>, <C>, <yy>)
 -- Función: augmented_lagrangian_method (<FOM>, <xx>, <C>, <yy>,
          optional_args)
 -- Función: augmented_lagrangian_method ([<FOM>, <grad>], <xx>, <C>,
          <yy>)
 -- Función: augmented_lagrangian_method ([<FOM>, <grad>], <xx>, <C>,
          <yy>, optional_args)
     Devuelve una aproximación del valor mínimo de la expresión <FOM>
     respecto de las variables <xx>, manteniendo las restricciones <C>
     igual a cero. La lista <yy> contiene las soluciones iniciales para
     <xx>.  El algoritmo que se utiliza es el método del lagrangiano
     aumentado (ver referencias [1] y [2]).

     Si <grad> está presente en la llamada a la función, se interpreta
     como el gradiente de <FOM> respecto de <xx>, representado como una
     lista de tantas expresiones como variables tenga <xx>. Si el
     argumento <grad> no está, se calculará de forma automática.

     Tanto <FOM> como cada uno de los elementos de <grad>, si se da
     como argumento, deben ser expresiones ordinarias; no admitiéndose
     ni nombres de funciones ni expresiones lambda.

     El argumento `optional_args' hace referencia a otros argumentos
     adicionales, los cuales se especifican de la forma `<symbol> =
     <value>'.  Los argumentos opcionales reconocidos son:

    `niter'
          Número de iteraciones del algoritmo.

    `lbfgs_tolerance'
          Tolerancia que se pasa a LBFGS.

    `iprint'
          Parámetro IPRINT (lista de dos enteros que controlan la
          frecuencia de mensajes) que se pasa a LBFGS.

    `%lambda'
          Valor inicial de `%lambda' que será utilizado para calcular el
          lagrangiano aumentado.

     Esta función minimiza el lagrangiano aumentado haciendo uso del
     algoritmo LBFGS, que es un método de los llamados quasi-Newton.

     Antes de hacer uso de esta función ejecútense
     `load("augmented_lagrangian")'.

     Véase también `lbfgs'.

     Referencias:

     [1]
     `http://www-fp.mcs.anl.gov/otc/Guide/OptWeb/continuous/constrained/nonlinearcon/auglag.html'

     [2] `http://www.cs.ubc.ca/spider/ascher/542/chap10.pdf'

     Ejemplos:

          (%i1) load (lbfgs);
          (%o1)     /maxima/share/lbfgs/lbfgs.mac
          (%i2) load (augmented_lagrangian);
          (%o2)
             /maxima/share/contrib/augmented_lagrangian.mac
          (%i3) FOM: x^2 + 2*y^2;
                                         2    2
          (%o3)                       2 y  + x
          (%i4) xx: [x, y];
          (%o4)                        [x, y]
          (%i5) C: [x + y - 1];
          (%o5)                      [y + x - 1]
          (%i6) yy: [1, 1];
          (%o6)                        [1, 1]
          (%i7) augmented_lagrangian_method(FOM, xx, C, yy, iprint=[-1,0]);
          (%o7) [[x = 0.66665984108002, y = 0.33334027245545],
                                           %lambda = [- 1.333337940892525]]

     Mismo ejemplo que en el caso anterior, pero ahora el gradiente se
     suministra como argumento.

          (%i1) load (lbfgs)$
          (%i2) load (augmented_lagrangian)$
          (%i3) FOM: x^2 + 2*y^2;
                                         2    2
          (%o3)                       2 y  + x
          (%i4) FOM: x^2 + 2*y^2;
                                         2    2
          (%o4)                       2 y  + x
          (%i5) xx: [x, y];
          (%o5)                        [x, y]
          (%i6) grad : [2*x, 4*y];
          (%o6)                      [2 x, 4 y]
          (%i7) C: [x + y - 1];
          (%o7)                      [y + x - 1]
          (%i8) yy: [1, 1];
          (%o8)                        [1, 1]
          (%i9) augmented_lagrangian_method ([FOM, grad], xx, C, yy,
                                             iprint = [-1, 0]);
          (%o9) [[x = 0.666659841080025, y = .3333402724554462],
                                           %lambda = [- 1.333337940892543]]


File: maxima.info,  Node: Bernstein,  Next: bode,  Prev: augmented_lagrangian,  Up: Top

40 Bernstein
************

* Menu:

* Funciones y variables para Bernstein::


File: maxima.info,  Node: Funciones y variables para Bernstein,  Prev: Bernstein,  Up: Bernstein

40.1 Funciones y variables para Bernstein
=========================================

 -- Función: bernstein_poly (<k>, <n>, <x>)
     Si `k' no es un entero negativo, los polinomios de Bernstein se
     definen como `bernstein_poly(k,n,x) = binomial(n,k) x^k
     (1-x)^(n-k)'; en cambio, si `k' es un entero negativo, el
     polinomio de Bernstein `bernstein_poly(k,n,x)' se anula. Cuando o
     bien `k' o `n' no son enteros, la variable opcional
     `bernstein_explicit' controla la expansión de los polinomios de
     Bernstein a su forma explícita.

     Ejemplo:

          (%i1) load(bernstein)$

          (%i2) bernstein_poly(k,n,x);
          (%o2)                bernstein_poly(k, n, x)
          (%i3) bernstein_poly(k,n,x), bernstein_explicit : true;
                                                 n - k  k
          (%o3)            binomial(n, k) (1 - x)      x

     Los polinomios de Bernstein tienen definidas su derivada e
     integral:

          (%i4) diff(bernstein_poly(k,n,x),x);
          (%o4) (bernstein_poly(k - 1, n - 1, x)
                                           - bernstein_poly(k, n - 1, x)) n
          (%i5) integrate(bernstein_poly(k,n,x),x);
          (%o5)
                                                                      k + 1
           hypergeometric([k + 1, k - n], [k + 2], x) binomial(n, k) x
           ----------------------------------------------------------------
                                        k + 1

     Cuando los argumentos contienen números decimales en coma
     flotante, los polinomios de Bernstein también devuelven resultados
     decimales.

          (%i6) bernstein_poly(5,9, 1/2 + %i);
                                  39375 %i   39375
          (%o6)                   -------- + -----
                                    128       256
          (%i7) bernstein_poly(5,9, 0.5b0 + %i);
          (%o7)           3.076171875b2 %i + 1.5380859375b2

     Para hacer uso de `bernstein_poly', ejecútese primero
     `load("bernstein")'.


 -- Variable opcional: bernstein_explicit
     Valor por defecto: `false'

     Cuando o bien `k' o `n' no son enteros, la variable opcional
     `bernstein_explicit' controla la expansión de los polinomios de
     Bernstein a su forma explícita.

     Ejemplo:

          (%i1) bernstein_poly(k,n,x);
          (%o1)                       bernstein_poly(k, n, x)
          (%i2) bernstein_poly(k,n,x), bernstein_explicit : true;
                                                        n - k  k
          (%o2)                   binomial(n, k) (1 - x)      x

     Cuando tanto `k' como `n' son enteros, `bernstein(k,n,x)' se
     expande siempre a su forma explícita.


 -- Función: multibernstein_poly (<[k1,k2,...,kp]>,<[n1,n2,...,
          np]>,<[x1,x2,..., xp]>)
     La sentencia `multibernstein_poly (<[k1,k2,...,kp]>,<[n1,n2,...,
     np]>,<[x1,x2,..., xp]>)' es el producto de polinomios de Bernstein
     `bernstein_poly(k1,n1,x1) bernstein_poly(k2,n2,x2) ...
     bernstein_poly(kp,np,xp)'.

     Para hacer uso de `multibernstein_poly', ejecútese primero
     `load("bernstein")'.


 -- Función: bernstein_approx (<f>,<[x1,x1,...,xn]>,n)
     Devuelve el polinomio de Bernstein uniforme de `n'-ésimo orden que
     aproxima la función `(x1,x2,..xn) |--> f'.

     Ejemplos:

          (%i1) bernstein_approx(f(x),[x], 2);
                                  2       1                          2
          (%o1)             f(1) x  + 2 f(-) (1 - x) x + f(0) (1 - x)
                                          2
          (%i2) bernstein_approx(f(x,y),[x,y], 2);
                         2  2       1                2                  2  2
          (%o2) f(1, 1) x  y  + 2 f(-, 1) (1 - x) x y  + f(0, 1) (1 - x)  y
                                    2
                    1   2                 1  1
           + 2 f(1, -) x  (1 - y) y + 4 f(-, -) (1 - x) x (1 - y) y
                    2                     2  2
                    1         2                      2        2
           + 2 f(0, -) (1 - x)  (1 - y) y + f(1, 0) x  (1 - y)
                    2
                 1                      2                  2        2
           + 2 f(-, 0) (1 - x) x (1 - y)  + f(0, 0) (1 - x)  (1 - y)
                 2

     Para hacer uso de `bernstein_approx', ejecútese primero
     `load("bernstein")'.


 -- Función: bernstein_expand (<e>, <[x1,x1,...,xn]>)
     Expresa el polinomio `e' como una combinación lineal de polinomios
     de Bernstein multivariantes.

          (%i1) bernstein_expand(x*y+1,[x,y]);
          (%o1)           2 x y + (1 - x) y + x (1 - y) + (1 - x) (1 - y)
          (%i2) expand(%);
          (%o2)                               x y + 1

     Maxima devuelve un error si el primer argumento no es un polinomio.

     Para hacer uso de `bernstein_expand', ejecútese primero
     `load("bernstein")'.



File: maxima.info,  Node: bode,  Next: cobyla,  Prev: Bernstein,  Up: Top

41 bode
*******

* Menu:

* Funciones y variables para bode::


File: maxima.info,  Node: Funciones y variables para bode,  Prev: bode,  Up: bode

41.1 Funciones y variables para bode
====================================

 -- Función: bode_gain (<H>, <range>, ...<plot_opts>...)
     Función para dibujar el gráfico de ganancia de Bode.

     Ejemplos (1 a 7 de
          `http://www.swarthmore.edu/NatSci/echeeve1/Ref/Bode/BodeHow.html',
     8 de Ron Crummett):
          (%i1) load("bode")$

          (%i2) H1 (s) := 100 * (1 + s) / ((s + 10) * (s + 100))$

          (%i3) bode_gain (H1 (s), [w, 1/1000, 1000])$

          (%i4) H2 (s) := 1 / (1 + s/omega0)$

          (%i5) bode_gain (H2 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i6) H3 (s) := 1 / (1 + s/omega0)^2$

          (%i7) bode_gain (H3 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i8) H4 (s) := 1 + s/omega0$

          (%i9) bode_gain (H4 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i10) H5 (s) := 1/s$

          (%i11) bode_gain (H5 (s), [w, 1/1000, 1000])$

          (%i12) H6 (s) := 1/((s/omega0)^2 + 2 * zeta * (s/omega0) + 1)$

          (%i13) bode_gain (H6 (s), [w, 1/1000, 1000]),
                            omega0 = 10, zeta = 1/10$

          (%i14) H7 (s) := (s/omega0)^2 + 2 * zeta * (s/omega0) + 1$

          (%i15) bode_gain (H7 (s), [w, 1/1000, 1000]),
                            omega0 = 10, zeta = 1/10$

          (%i16) H8 (s) := 0.5 / (0.0001 * s^3 + 0.002 * s^2 + 0.01 * s)$

          (%i17) bode_gain (H8 (s), [w, 1/1000, 1000])$

     Antes de hacer uso de esta función ejecútese  `load("bode")'.
     Véase también `bode_phase'.

 -- Función: bode_phase (<H>, <range>, ...<plot_opts>...)
     Función para dibujar el gráfico de fase de Bode.

     Ejemplos (1 a 7 de
          `http://www.swarthmore.edu/NatSci/echeeve1/Ref/Bode/BodeHow.html',
     8 de Ron Crummett):
          (%i1) load("bode")$

          (%i2) H1 (s) := 100 * (1 + s) / ((s + 10) * (s + 100))$

          (%i3) bode_phase (H1 (s), [w, 1/1000, 1000])$

          (%i4) H2 (s) := 1 / (1 + s/omega0)$

          (%i5) bode_phase (H2 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i6) H3 (s) := 1 / (1 + s/omega0)^2$

          (%i7) bode_phase (H3 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i8) H4 (s) := 1 + s/omega0$

          (%i9) bode_phase (H4 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i10) H5 (s) := 1/s$

          (%i11) bode_phase (H5 (s), [w, 1/1000, 1000])$

          (%i12) H6 (s) := 1/((s/omega0)^2 + 2 * zeta * (s/omega0) + 1)$

          (%i13) bode_phase (H6 (s), [w, 1/1000, 1000]),
                             omega0 = 10, zeta = 1/10$

          (%i14) H7 (s) := (s/omega0)^2 + 2 * zeta * (s/omega0) + 1$

          (%i15) bode_phase (H7 (s), [w, 1/1000, 1000]),
                             omega0 = 10, zeta = 1/10$

          (%i16) H8 (s) := 0.5 / (0.0001 * s^3 + 0.002 * s^2 + 0.01 * s)$

          (%i17) bode_phase (H8 (s), [w, 1/1000, 1000])$

          (%i18) block ([bode_phase_unwrap : false],
                        bode_phase (H8 (s), [w, 1/1000, 1000]));

          (%i19) block ([bode_phase_unwrap : true],
                        bode_phase (H8 (s), [w, 1/1000, 1000]));

     Antes de hacer uso de esta función ejecútese  `load("bode")'.
     Véase también `bode_gain'.


File: maxima.info,  Node: cobyla,  Next: contrib_ode,  Prev: bode,  Up: Top

42 cobyla
*********

* Menu:

* Introducción a cobyla::
* Funciones y variables para cobyla::
* Ejemplos para cobyla::


File: maxima.info,  Node: Introducción a cobyla,  Next: Funciones y variables para cobyla,  Prev: cobyla,  Up: cobyla

42.1 Introducción a cobyla
==========================

`fmin_cobyla' es una traducción a Common Lisp hecha con el programa
`f2cl' de la rutina Fortran COBYLA, (Powell, [1][2][3]), para
optimización con restricciones.

COBYLA minimiza una función objetivo F(X) sujeta a M restricciones con
desigualdades de la forma g(X) >= 0 sobre X, siendo X un vector de
variables de N componentes.

Las restricciones en forma de igualdades se pueden implementar por pares
de desigualdades de la forma g(X)>=0 y -g(X)>= 0. El interfaz Maxima
para COBYLA admite restricciones de igualdad, transformándolas luego
internamente a pares de desigualdades.

El algoritmo hace uso de aproximaciones lineales, tanto de la función
objetivo como de las funciones de restricción; tales aproximaciones se
hacen mediante interpolación lineal de N+1 puntos en el espacio de
variables. Los puntos de interpolación se consideran vértices de un
simplejo o símplex. El parámetro RHO controla el tamaño del simplejo y
se reduce automáticamente de RHOBEG a RHOEND. Para cada RHO la
subrutina intenta alcanzar un buen vector de variables para el tamaño
actual, reduciéndose entonces RHO hasta alcanzar el valor de RHOEND.
Por eso, tanto a RHOBEG como a RHOEND se les deben asignar valores
razonables, lo que requiere cierto trabajo empírico previo.  La rutina
trata cada restricción individualmente cuando se calcula un en las
variables. El nombre de la rutina se deriva de la frase Constrained
Optimization BY Linear Approximations.

Referecias:

[1] Código Fortran procede de
`http://plato.asu.edu/sub/nlores.html#general'

[2] M. J. D. Powell, "A direct search optimization method that models
the objective and constraint functions by linear interpolation," en
Advances in Optimization and Numerical Analysis, eds. S. Gomez and
J.-P. Hennart (Kluwer Academic: Dordrecht, 1994), p. 51-67.

[3] M. J. D. Powell, "Direct search algorithms for optimization
calculations," Acta Numerica 7, 287-336 (1998).  Also available as
University of Cambridge, Department of Applied Mathematics and
Theoretical Physics,  Numerical Analysis Group, Report NA1998/04 from
`http://www.damtp.cam.ac.uk/user/na/reports.html'


File: maxima.info,  Node: Funciones y variables para cobyla,  Next: Ejemplos para cobyla,  Prev: Introducción a cobyla,  Up: cobyla

42.2 Funciones y variables para cobyla
======================================

 -- Función: fmin_cobyla (<F>, <X>, <Y>)
 -- Función: fmin_cobyla (<F>, <X>, <Y>, optional_args)
     Devuelve una aproximación del valor mínimo de la expresión <F>
     respecto de las variables <X>, sujeta a un conjunto opcional de
     restricciones. <Y> es una lista que contiene una solución semilla
     inicial en <X>.

     <F> debe ser una expresión ordinaria, no valen nombres de funciones
     ni expresiones lambda.

     `optional_args' hace referencia a argumentos adicionales, que se
     especifican de la forma `<symbol> = <value>'. Los argumentos
     opcionales que se reconocen son:

    `constraints'
          Lista de restricciones en forma de desigualdades e igualdades
          que debe satisfacer <X>. Las desigualdades deben ser de la
          forma `g(<X>) >= h(<X>)' o `g(<X>) <= h(<X>)'.  Las
          restricciones de igualdad deben ser de la forma `g(<X>) =
          h(<X>)'.

    `rhobeg'
          Valor inicial de la variable interna RHO, que controla el
          tamaño del simplejo. Su valor por defecto es 1.0.

    `rhoend'
          El valor final deseado para el parámetro RHO. Es
          aproximadamente la precisión de las variables. Su valor por
          defecto es 1d-6.

    `iprint'
          Nivel de información de salida. Su valor por defecto es 0.
             * 0 - Sin información de salida

             * 1 - Sumario al final de los cálculos

             * 2 - Se van mostrando los nuevos valores de RHO y SIGMA,
               incluyendo  el vector de variables.

             * 3 - Como en 2, pero la información se muestra cuando se
               calcula F(X).

    `maxfun'
          Número máximo de evaluaciones de la función. Su valor por
          defecto es 1000.

     El resultado devuelto es un vector:
       1. Los valores de las variables con las que se alcanza el valor
          mínimo.  Es una lista de elementos de la forma `<var> =
          <value>' para cada una de las variables listadas en <X>.

       2. El valor mínimo de la función objetivo.

       3. El número de evaluaciones de la función.

       4. Código de retorno con los siguientes significados:
            1.  0 - No ha habido errores.

            2.  1 - Alcanzado el máximo número permitido de
               evaluaciones de la función.

            3.  2 - Errores de redondeo han impedido el avance del
               proceso.

     El código `load(fmin_cobyla)' carga en memoria esta función..


 -- Función: bf_fmin_cobyla (<F>, <X>, <Y>)
 -- Función: bf_fmin_cobyla (<F>, <X>, <Y>, optional_args)
     Esta función es idéntica a `fmin_cobyla', excepto por el hecho de
     que utiliza aritmética de precisión arbitraria (bigfloat) y que el
     valor por defecto de <rhoend> es `10^(fpprec/2)'.

     Véase `fmin_cobyla'.

     El código `load(fmin_cobyla)' carga en memoria esta función..



File: maxima.info,  Node: Ejemplos para cobyla,  Prev: Funciones y variables para cobyla,  Up: cobyla

42.3 Ejemplos para cobyla
=========================

Minimizar x1*x2 bajo la condición 1-x1^2-x2^2 >= 0.  La solución
teórica es x1 = 1/sqrt(2), x2 = -1/sqrt(2).

     (%i1) load(fmin_cobyla)$

     (%i2) fmin_cobyla(x1*x2, [x1, x2], [1,1], constraints = [x1^2+x2^2<=1], iprint=1);

        Normal return from subroutine COBYLA

        NFVALS =   66   F =-5.000000E-01    MAXCV = 1.999845E-12
        X = 7.071058E-01  -7.071077E-01
     (%o2) [[x1 = 0.70710584934848, x2 = - 0.7071077130248], - 0.49999999999926,
            [[-1.999955756559757e-12],[]], 66]

Hay más ejemplos en el directorio `share/cobyla/ex'.


File: maxima.info,  Node: contrib_ode,  Next: descriptive,  Prev: cobyla,  Up: Top

43 contrib_ode
**************

* Menu:

* Introducción a contrib_ode::
* Funciones y variables para contrib_ode::
* Posibles mejoras a contrib_ode::
* Pruebas realizadas con contrib_ode::
* Referencias para contrib_ode::


File: maxima.info,  Node: Introducción a contrib_ode,  Next: Funciones y variables para contrib_ode,  Prev: contrib_ode,  Up: contrib_ode

43.1 Introducción a contrib_ode
===============================

La función `ode2' de Maxima resuelve ecuaciones diferenciales
ordinarias (EDO) simples de primer y segundo orden. La función
`contrib_ode' extiende las posibilidades de `ode2' con métodos
adicionales para ODEs lineales y no lineales de primer orden y
homogéneas lineales de segundo orden.  El código se encuentra en estado
de desarrollo y la syntaxis puede cambiar en futuras versiones. Una vez
el código se haya estabilizado podrá pasar a integrarse dentro de
Maxima.

El paquete debe cargarse con la instrucción `load('contrib_ode)' antes
de utilizarlo.

La sintaxis de `contrib_ode' es similar a la de `ode2'.  Necesita tres
argumentos: una EDO (sólo se necesita el miembro izquierdo si el
derecho es igual cero), la variable dependiente y la independiente. Si
encuentra la solución, devolverá una lista de resultados.

La forma de los resultados devueltos es diferente de la utilizada por
`ode2'.  Puesto que las ecuaciones no lineales pueden tener múltiples
soluciones, `contrib_ode' devuelve una lista de soluciones.  Las
soluciones pueden tener diferentes formatos:
   * una función explícita para la variable dependiente,

   * una función implícita para la variable dependiente,

   * una solución paramétrica en términos de la variable `%t' o

   * una transformación en otra EDO de variable `%u'.


`%c' hace referencia a la constante de integración en las ecuaciones de
primer orden.  `%k1' y `%k2' son las constantes para las ecuaciones de
segundo orden.  Si por cualquier razón contrib_ode no pudiese encontrar
una solución, devolverá `false', quizás después de mostrar un mensaje
de error.

Ejemplos:

En ocasiones es necesario devolver una lista de soluciones, pues
algunas EDOs pueden tener múltiples soluciones:

     (%i1) load('contrib_ode)$

     (%i2) eqn:x*'diff(y,x)^2-(1+x*y)*'diff(y,x)+y=0;

                         dy 2             dy
     (%o2)            x (--)  - (x y + 1) -- + y = 0
                         dx               dx
     (%i3) contrib_ode(eqn,y,x);

                                                  x
     (%o3)             [y = log(x) + %c, y = %c %e ]
     (%i4) method;

     (%o4)                        factor

Las EDOs no lineales pueden tener soluciones singulares sin constantes
de integración, como en la segunda solución del ejemplo siguiente:

     (%i1) load('contrib_ode)$

     (%i2) eqn:'diff(y,x)^2+x*'diff(y,x)-y=0;

                            dy 2     dy
     (%o2)                 (--)  + x -- - y = 0
                            dx       dx
     (%i3) contrib_ode(eqn,y,x);

                                                2
                                      2        x
     (%o3)              [y = %c x + %c , y = - --]
                                               4
     (%i4) method;

     (%o4)                       clairault

La siguiente ODE tiene dos soluciones paramétricas en términos de la
variable `%t'. En este caso, las soluciones paramétricas se pueden
manipular para dar soluciones explícitas.

     (%i1) load('contrib_ode)$

     (%i2) eqn:'diff(y,x)=(x+y)^2;

                               dy          2
     (%o2)                     -- = (y + x)
                               dx
     (%i3) contrib_ode(eqn,y,x);

     (%o3) [[x = %c - atan(sqrt(%t)), y = - x - sqrt(%t)],
                          [x = atan(sqrt(%t)) + %c, y = sqrt(%t) - x]]
     (%i4) method;

     (%o4)                       lagrange

En el siguiente ejemplo (Kamke 1.112) se obtiene una solución implícita.

     (%i1) load('contrib_ode)$

     (%i2) assume(x>0,y>0);

     (%o2)                    [x > 0, y > 0]
     (%i3) eqn:x*'diff(y,x)-x*sqrt(y^2+x^2)-y;

                          dy           2    2
     (%o3)              x -- - x sqrt(y  + x ) - y
                          dx
     (%i4) contrib_ode(eqn,y,x);

                                       y
     (%o4)                  [x - asinh(-) = %c]
                                       x
     (%i5) method;

     (%o5)                          lie

La siguiente ecuación de Riccati se transforma en una EDO lineal de
segundo orden de variable `%u'. Maxima es incapaz de resolver la nueva
EDO, por lo que la devuelve si resolver:

     (%i1) load('contrib_ode)$

     (%i2) eqn:x^2*'diff(y,x)=a+b*x^n+c*x^2*y^2;

                         2 dy      2  2      n
     (%o2)              x  -- = c x  y  + b x  + a
                           dx
     (%i3) contrib_ode(eqn,y,x);

                    d%u
                    ---                            2
                    dx        2     n - 2   a     d %u
     (%o3)  [[y = - ----, %u c  (b x      + --) + ---- c = 0]]
                    %u c                     2      2
                                            x     dx
     (%i4) method;

     (%o4)                        riccati

Para EDOs de primer orden, `contrib_ode' llama a `ode2'.  Entonces
trata de aplicar los siguientes métodos: factorización, Clairault,
Lagrange, Riccati, Abel y Lie. El método de Lie no se intenta aplicar a
las ecuaciones de Abel si el propio método de Abel no obtiene solución,
pero sí se utiliza si el método de Riccati devuelve una EDO de segundo
orden sin resolver.

Para EDOs de segundo orden, `contrib_ode' llama a `ode2' y luego a
`odelin'.

Se mostrarán mensajes de depurado si se ejecuta la sentencia
`put('contrib_ode,true,'verbose)'.


File: maxima.info,  Node: Funciones y variables para contrib_ode,  Next: Posibles mejoras a contrib_ode,  Prev: Introducción a contrib_ode,  Up: contrib_ode

43.2 Funciones y variables para contrib_ode
===========================================

 -- Función: contrib_ode (<eqn>, <y>, <x>)
     Devuelve la lista de soluciones de la ecuación diferencia
     ordinaria (EDO) <eqn> de variable independiente <x> y variable
     dependiente <y>.


 -- Función: odelin (<eqn>, <y>, <x>)
     La función `odelin' resulve EDOs homogéneas lineales de primer y
     segundo orden con variable independiente <x> y variable
     dependiente <y>. Devuelve un conjunto fundamental de soluciones de
     la EDO.

     Para EDOs de segundo orden, `odelin' utiliza un método
     desarrollado por Bronstein y Lafaille, que busca las soluciones en
     términos de funciones especiales dadas.

          (%i1) load('contrib_ode);

          (%i2) odelin(x*(x+1)*'diff(y,x,2)+(x+5)*'diff(y,x,1)+(-4)*y,y,x);
          ...trying factor method
          ...solving 7 equations in 4 variables
          ...trying the Bessel solver
          ...solving 1 equations in 2 variables
          ...trying the F01 solver
          ...solving 1 equations in 3 variables
          ...trying the spherodial wave solver
          ...solving 1 equations in 4 variables
          ...trying the square root Bessel solver
          ...solving 1 equations in 2 variables
          ...trying the 2F1 solver
          ...solving 9 equations in 5 variables
                 gauss_a(- 6, - 2, - 3, - x)  gauss_b(- 6, - 2, - 3, - x)
          (%o2) {---------------------------, ---------------------------}
                              4                            4
                             x                            x


 -- Función: ode_check (<eqn>, <soln>)
     Devuelve el valor de la ecuación diferencia ordinaria (EDO) <eqn>
     después de sustituir una posible solución <soln>. El valor es cero
     si <soln> es una solución de <eqn>.

          (%i1) load('contrib_ode)$

          (%i2) eqn:'diff(y,x,2)+(a*x+b)*y;

                                   2
                                  d y
          (%o2)                   --- + (a x + b) y
                                    2
                                  dx
          (%i3) ans:[y = bessel_y(1/3,2*(a*x+b)^(3/2)/(3*a))*%k2*sqrt(a*x+b)
                   +bessel_j(1/3,2*(a*x+b)^(3/2)/(3*a))*%k1*sqrt(a*x+b)];

                                            3/2
                              1  2 (a x + b)
          (%o3) [y = bessel_y(-, --------------) %k2 sqrt(a x + b)
                              3       3 a
                                                    3/2
                                      1  2 (a x + b)
                           + bessel_j(-, --------------) %k1 sqrt(a x + b)]
                                      3       3 a
          (%i4) ode_check(eqn,ans[1]);

          (%o4)                           0


 -- Variable opcional: `method'
     A la variable `method' se le asigna el método aplicado.


 -- Variable: `%c'
     `%c' es la constante de integración para EDOs de primer orden.


 -- Variable: `%k1'
     `%k1' es la primera constante de integración para EDOs de segundo
     orden.


 -- Variable: `%k2'
     `%k2' es la segunda constante de integración para EDOs de segundo
     orden.


 -- Función: gauss_a (<a>, <b>, <c>, <x>)
     `gauss_a(a,b,c,x)' y `gauss_b(a,b,c,x)' son funciones geométricas
     2F1 . Representan dos soluciones independientes cualesquiera de la
     ecuación diferencial hipergeométrica `x(1-x) diff(y,x,2) +
     [c-(a+b+1)x] diff(y,x) - aby = 0' (A&S 15.5.1).

     El único uso que se hace de estas funciones es en las soluciones de
     EDOs que devuelven `odelin' y `contrib_ode'. La definición y
     utilización de estas funciones puede cambiar en futuras
     distribuciones de Maxima.

     Véanse también `gauss_b', `dgauss_a' y `gauss_b'.


 -- Función: gauss_b (<a>, <b>, <c>, <x>)
     Véase  también `gauss_a'.

 -- Función: dgauss_a (<a>, <b>, <c>, <x>)
     The derivative with respect to x of `gauss_a(a,b,c,x)'.

 -- Función: dgauss_b (<a>, <b>, <c>, <x>)
     Derivada de `gauss_b(<a>,<b>,<c>,<x>)' respecto de <x>.

 -- Función: kummer_m (<a>, <b>, <x>)
     Función M de Kummer, tal como la definen Abramowitz y Stegun,
     Handbook of Mathematical Functions, Sección 13.1.2.

     El único uso que se hace de esta función es en las soluciones de
     EDOs que devuelven `odelin' y `contrib_ode'. La definición y
     utilización de estas funciones puede cambiar en futuras
     distribuciones de Maxima.

     Véanse también `kummer_u', `dkummer_m' y `dkummer_u'.

 -- Función: kummer_u (<a>, <b>, <x>)
     Función U de Kummer, tal como la definen Abramowitz y Stegun,
     Handbook of Mathematical Functions, Sección 13.1.3.

     Véase  también `kummer_m'.

 -- Función: dkummer_m (<a>, <b>, <x>)
     Derivada de `kummer_m(<a>,<b>,<x>)' respecto de <x>.

 -- Función: dkummer_u (<a>, <b>, <x>)
     Derivada de `kummer_u(<a>,<b>,<x>)' respecto de <x>.


File: maxima.info,  Node: Posibles mejoras a contrib_ode,  Next: Pruebas realizadas con contrib_ode,  Prev: Funciones y variables para contrib_ode,  Up: contrib_ode

43.3 Posibles mejoras a contrib_ode
===================================

Este paquete aún se encuentra en fase de desarrollo. Aspectos
pendientes:

   * Extender el método FACTOR `ode1_factor' para que trabaje con
     raíces múltiples.

   * Extender el método FACTOR `ode1_factor' para que intente resolver
     factores de orden superior. En este momento sólo intenta resolver
     factores lineales.

   * Modificar la rutina LAGRANGE `ode1_lagrange' para que prefiera
     raíces reales a las complejas.

   * Añadir más métodos para las ecuaciones de RIccati.

   * Mejorar la identificación de las ecuaciones de Abel de segunda
     especie.  El procedimiento actual no es muy bueno.

   * Trabajar la rutina del grupo simétrico de Lie `ode1_lie'.  Existen
     algunos problemas: algunas partes no están implementadas, algunos
     ejemplos no terminan de ejecutarse, otros producen errors, otros
     devuelven respuestas muy complejas.

   * Hacer más pruebas.



File: maxima.info,  Node: Pruebas realizadas con contrib_ode,  Next: Referencias para contrib_ode,  Prev: Posibles mejoras a contrib_ode,  Up: contrib_ode

43.4 Pruebas realizadas con contrib_ode
=======================================

Los procedimientos fueron probados con cerca de mil ecuaciones tomadas
de Murphy, Kamke, Zwillinger y otros. Éstas se encuentran en el
directorio de pruebas.

   * La rutina de Clairault `ode1_clairault' encuentra todas las
     soluciones conocidas, incluídas las singulares, de las ecuaciones
     de Clairault en Murphy y Kamke.

   * Las otras rutinas a veces devuelven una sola solución cuando
     existen más.

   * Algunas de las soluciones devueltas por `ode1_lie' son demasiado
     complejas e imposibles de interpretar.

   * A veces se producen detenciones imprevistas del procedimiento.



File: maxima.info,  Node: Referencias para contrib_ode,  Prev: Pruebas realizadas con contrib_ode,  Up: contrib_ode

43.5 Referencias para contrib_ode
=================================

  1. E. Kamke, Differentialgleichungen Losungsmethoden und Losungen,
     Vol 1,     Geest & Portig, Leipzig, 1961

  2. G. M. Murphy, Ordinary Differential Equations and Their Solutions,
        Van Nostrand, New York, 1960

  3. D. Zwillinger, Handbook of Differential Equations, 3rd edition,
     Academic Press, 1998

  4. F. Schwarz, Symmetry Analysis of Abel's Equation, Studies in
     Applied Mathematics, 100:269-294 (1998)

  5. F. Schwarz, Algorithmic Solution of Abel's Equation,     Computing
     61, 39-49 (1998)

  6. E. S. Cheb-Terrab, A. D. Roche, Symmetries and First Order     ODE
     Patterns, Computer Physics Communications 113 (1998), p 239.
     (`http://lie.uwaterloo.ca/papers/ode_vii.pdf')

  7. E. S. Cheb-Terrab, T. Kolokolnikov,  First Order ODEs,
     Symmetries and Linear Transformations, European Journal of
     Applied Mathematics, Vol. 14, No. 2, pp. 231-246 (2003).
     (`http://arxiv.org/abs/math-ph/0007023',
     `http://lie.uwaterloo.ca/papers/ode_iv.pdf')

  8. G. W. Bluman, S. C. Anco, Symmetry and Integration Methods for
     Differential Equations, Springer, (2002)

  9. M Bronstein, S Lafaille, Solutions of linear ordinary differential
     equations in terms of special functions, Proceedings of ISSAC
     2002, Lille, ACM Press, 23-28.
     (`http://www-sop.inria.fr/cafe/Manuel.Bronstein/publications/issac2002.pdf')


File: maxima.info,  Node: descriptive,  Next: diag,  Prev: contrib_ode,  Up: Top

44 descriptive
**************

* Menu:

* Introducción a descriptive::
* Funciones y variables para el tratamiento de datos::
* Funciones y variables de parámetros descriptivos::
* Funciones y variables para gráficos estadísticos::


File: maxima.info,  Node: Introducción a descriptive,  Next: Funciones y variables para el tratamiento de datos,  Prev: descriptive,  Up: descriptive

44.1 Introducción a descriptive
===============================

El paquete `descriptive' contiene funciones para realizar cl'culos y
gráficos estadísticos descriptivos.  Junto con el código fuente se
distribuyen tres conjuntos de datos: `pidigits.data', `wind.data' y
`biomed.data'.

Cualquier manual de estadística se puede utilizar como referencia al
paquete `descriptive'.

Para comentarios, fallos y sugerencias, por favor contactar con <'mario
AT edu DOT xunta DOT es'>.

Aquí un sencillo ejemplo sobre cómo operan las funciones de
`descriptive', dependiendo de la naturaleza de sus argumentos, listas o
matrices,

     (%i1) load (descriptive)$
     (%i2) /* muestra univariate */   mean ([a, b, c]);
                                 c + b + a
     (%o2)                       ---------
                                     3
     (%i3) matrix ([a, b], [c, d], [e, f]);
                                 [ a  b ]
                                 [      ]
     (%o3)                       [ c  d ]
                                 [      ]
                                 [ e  f ]
     (%i4) /* muestra multivariante */ mean (%);
                           e + c + a  f + d + b
     (%o4)                [---------, ---------]
                               3          3

Nótese que en las muestras multivariantes la media se calcula para cada
columna.

En caso de varias muestras de diferente tamaño, la función `map' de
Maxima puede utilizarse para obtener los resultados deseados para cada
muestra,

     (%i1) load (descriptive)$
     (%i2) map (mean, [[a, b, c], [d, e]]);
                             c + b + a  e + d
     (%o2)                  [---------, -----]
                                 3        2

En este caso, dos muestras de tamaños 3 y 2 han sido almacenadas en una
lista.

Muestras univariantes deben guardarse en listas como en

     (%i1) s1 : [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5];
     (%o1)           [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]

y muestras multivariantes en matrices como las del siguiente ejemplo

     (%i1) s2 : matrix ([13.17, 9.29], [14.71, 16.88], [18.50, 16.88],
                  [10.58, 6.63], [13.33, 13.25], [13.21,  8.12]);
                             [ 13.17  9.29  ]
                             [              ]
                             [ 14.71  16.88 ]
                             [              ]
                             [ 18.5   16.88 ]
     (%o1)                   [              ]
                             [ 10.58  6.63  ]
                             [              ]
                             [ 13.33  13.25 ]
                             [              ]
                             [ 13.21  8.12  ]

En este caso, el número de columnas es igual al de la dimensión de la
variable aleatoria y el número de filas coincide con el tamaño muestral.

Los datos pueden suministrarse manualmente, pero las muestras grandes
se suelen almacenar en ficheros de texto. Por ejemplo, el fichero
`pidigits.data' contiene los 100 primeros dígitos del número `%pi':
           3
           1
           4
           1
           5
           9
           2
           6
           5
           3 ...

A fin de leer estos dígitos desde Maxima,

     (%i1) s1 : read_list (file_search ("pidigits.data"))$
     (%i2) length (s1);
     (%o2)                          100

Por otro lado, el archivo `wind.data' contiene los promedios diarios de
la velocidad del viento en cinco estaciones meteorológicas en Irlanda
(esta muestra es parte de un conjunto de datos correspondientes a 12
estaciones meteorológicas. El fichero original se puede descargar
libremente del 'StatLib Data Repository' y se analiza en  Haslett, J.,
Raftery, A. E. (1989) <Space-time Modelling with Long-memory
Dependence: Assessing Ireland's Wind Power Resource, with Discussion>.
Applied Statistics 38, 1-50). Así se leen los datos:

     (%i1) s2 : read_matrix (file_search ("wind.data"))$
     (%i2) length (s2);
     (%o2)                          100
     (%i3) s2 [%]; /* last record */
     (%o3)            [3.58, 6.0, 4.58, 7.62, 11.25]

Algunas muestras contienen datos no numéricos. Como ejemplo, el archivo
`biomed.data' (el cual es parte de otro mayor descargado también del
'StatLib Data Repository') contiene cuatro mediciones sanguíneas
tomadas a dos grupos de pacientes, `A' y `B', de diferentes edades,

     (%i1) s3 : read_matrix (file_search ("biomed.data"))$
     (%i2) length (s3);
     (%o2)                          100
     (%i3) s3 [1]; /* first record */
     (%o3)            [A, 30, 167.0, 89.0, 25.6, 364]

El primer individuo pertenece al grupo `A', tiene 30 años de edad y sus
medidas sanguíneas fueron 167.0, 89.0, 25.6 y 364.

Debe tenerse cuidado cuando se trabaje con datos categóricos. En el
siguiente ejemplo, se asigna al símbolo `a' cierto valor en algún
momento previo y luego se toma una muestra con el valor categórico `a',

     (%i1) a : 1$
     (%i2) matrix ([a, 3], [b, 5]);
                                 [ 1  3 ]
     (%o2)                       [      ]
                                 [ b  5 ]


File: maxima.info,  Node: Funciones y variables para el tratamiento de datos,  Next: Funciones y variables de parámetros descriptivos,  Prev: Introducción a descriptive,  Up: descriptive

44.2 Funciones y variables para el tratamiento de datos
=======================================================

 -- Función: build_sample (<list>)
 -- Función: build_sample (<matrix>)
     Construye una muestra a partir de una tabla de frecuencias
     absolutas.  La tabla de entrada puede ser una una matriz o una
     lista de listas, todas ellas de igual tamaño. El número de
     columnas o la longitud de las listas debe ser mayor que la unidad.
     El último elemento de cada fila o lista se interpreta como la
     frecuencia absoluta.  El resultado se devuelve siempre en formato
     de matriz.

     Ejemplos:

     Tabla de frecuencias univariante.

          (%i1) load (descriptive)$
          (%i2) sam1: build_sample([[6,1], [j,2], [2,1]]);
                                 [ 6 ]
                                 [   ]
                                 [ j ]
          (%o2)                  [   ]
                                 [ j ]
                                 [   ]
                                 [ 2 ]
          (%i3) mean(sam1);
                                2 j + 8
          (%o3)                [-------]
                                   4
          (%i4) barsplot(sam1) $

     Tabla de frecuencias multivariante.

          (%i1) load (descriptive)$
          (%i2) sam2: build_sample([[6,3,1], [5,6,2], [u,2,1],[6,8,2]]) ;
                                     [ 6  3 ]
                                     [      ]
                                     [ 5  6 ]
                                     [      ]
                                     [ 5  6 ]
          (%o2)                      [      ]
                                     [ u  2 ]
                                     [      ]
                                     [ 6  8 ]
                                     [      ]
                                     [ 6  8 ]
          (%i3) cov(sam2);
                 [   2                 2                            ]
                 [  u  + 158   (u + 28)     2 u + 174   11 (u + 28) ]
                 [  -------- - ---------    --------- - ----------- ]
          (%o3)  [     6          36            6           12      ]
                 [                                                  ]
                 [ 2 u + 174   11 (u + 28)            21            ]
                 [ --------- - -----------            --            ]
                 [     6           12                 4             ]
          (%i4) barsplot(sam2, grouping=stacked) $

 -- Función: continuous_freq (<list>)
 -- Función: continuous_freq (<list>, <m>)
     El argumento de `continuous_freq' debe ser una lista de números.
     Divide el rango en intervalos y cuenta cuántos valores hay en
     ellos.  El segundo argumento es opcional y puede ser el número de
     clases deseado, 10 por defecto, o una lista que contenga los
     límites de las clases y el número de éstas, o una lista que
     contenga únicamente los límites. Si los valores muestrales son
     todos iguales, esta función devuelve solamente una clase de
     amplitud 2.

     Ejemplos:

     El argumento opcional indica el número de clases deseadas.  La
     primera lista de la respuesta contiene los límites de los
     intervalos y la segunda los totales correspondientes: hay 16
     dígitos en el intervalo `[0, 1.8]', 24 en `(1.8, 3.6]' y así
     sucesivamente.

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) continuous_freq (s1, 5);
          (%o3) [[0, 1.8, 3.6, 5.4, 7.2, 9.0], [16, 24, 18, 17, 25]]

     El argumento opcional indica que queremos 7 clases con límites -2
     y 12:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) continuous_freq (s1, [-2,12,7]);
          (%o3) [[- 2, 0, 2, 4, 6, 8, 10, 12], [8, 20, 22, 17, 20, 13, 0]]

     El argumento opcional indica que queremos el número por defecto de
     clases y límites -2 y 12:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) continuous_freq (s1, [-2,12]);
                          3  4  11  18     32  39  46  53
          (%o3)  [[- 2, - -, -, --, --, 5, --, --, --, --, 12],
                          5  5  5   5      5   5   5   5
                         [0, 8, 20, 12, 18, 9, 8, 25, 0, 0]]


 -- Función: discrete_freq (<list>)
     Calcula las frecuencias absolutas en muestras discretas, tanto
     numéricas como categóricas. Su único argumento debe ser una lista.

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) discrete_freq (s1);
          (%o3) [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
                                       [8, 8, 12, 12, 10, 8, 9, 8, 12, 13]]

     La primera lista son los valores de la muestra y la segunda sus
     frecuencias absolutas. Las instrucciones `? col' y `? transpose'
     pueden ayudar a comprender la última entrada.

 -- Función: standardize (<list>)
 -- Función: standardize (<matrix>)
     Resta a cada elemento de la lista la media muestral y luego divide
     el resultado por la desviación típica. Si la entrada es una
     matriz, `standardize' resta a cada fila la media multivariante y
     luego divide cada componente por la desviación típica
     correspondiente.


 -- Función: subsample (<data_matrix>, <predicate_function>)
 -- Función: subsample (<data_matrix>, <predicate_function>, <col_num>,
          <col_num>, ...)
     Esta es una variante de la función `submatrix' de Maxima.  El
     primer argumento es una matriz de datos, el segundo es una función
     de predicado y el resto de argumentos opcionales son los números
     de las columnas a tomar en consideración.

     Estos son los registros multivariantes en los que la velocidad del
     viento en la primera estación meteorológica fue menor de 18 nudos.
     Véase cómo en la expresión lambda la <i>-ésima componente se la
     referencia como `v[i]'.
          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) subsample (s2, lambda([v], v[1] > 18));
                        [ 19.38  15.37  15.12  23.09  25.25 ]
                        [                                   ]
                        [ 18.29  18.66  19.08  26.08  27.63 ]
          (%o3)         [                                   ]
                        [ 20.25  21.46  19.95  27.71  23.38 ]
                        [                                   ]
                        [ 18.79  18.96  14.46  26.38  21.84 ]

     En el siguiente ejemplo, se solicitan únicamente la primera,
     segunda y quinta componentes de aquellos registros con velocidades
     del viento mayores o iguales que 16 nudos en la estación número 1
     y menores que 25 nudos en la estación número 4. La muestra sólo
     contiene los datos referidos a las estaciones 1, 2 y 5. En este
     caso, la función de predicado se define por medio de una función
     de Maxima ordinaria.
          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) g(x):= x[1] >= 16 and x[4] < 25$
          (%i4) subsample (s2, g, 1, 2, 5);
                               [ 19.38  15.37  25.25 ]
                               [                     ]
                               [ 17.33  14.67  19.58 ]
          (%o4)                [                     ]
                               [ 16.92  13.21  21.21 ]
                               [                     ]
                               [ 17.25  18.46  23.87 ]

     He aquí un ejemplo con las variables categóricas de `biomed.data'.
     Se piden los registros correspondientes a aquellos pacientes del
     grupo `B' mayores de 38 anños,
          (%i1) load (descriptive)$
          (%i2) s3 : read_matrix (file_search ("biomed.data"))$
          (%i3) h(u):= u[1] = B and u[2] > 38 $
          (%i4) subsample (s3, h);
                          [ B  39  28.0  102.3  17.1  146 ]
                          [                               ]
                          [ B  39  21.0  92.4   10.3  197 ]
                          [                               ]
                          [ B  39  23.0  111.5  10.0  133 ]
                          [                               ]
                          [ B  39  26.0  92.6   12.3  196 ]
          (%o4)           [                               ]
                          [ B  39  25.0  98.7   10.0  174 ]
                          [                               ]
                          [ B  39  21.0  93.2   5.9   181 ]
                          [                               ]
                          [ B  39  18.0  95.0   11.3  66  ]
                          [                               ]
                          [ B  39  39.0  88.5   7.6   168 ]

     Es probable que el análisis estadístico requiera únicamente de las
     medidas sanguíneas.
          (%i1) load (descriptive)$
          (%i2) s3 : read_matrix (file_search ("biomed.data"))$
          (%i3) subsample (s3, lambda([v], v[1] = B and v[2] > 38),
                     3, 4, 5, 6);
                             [ 28.0  102.3  17.1  146 ]
                             [                        ]
                             [ 21.0  92.4   10.3  197 ]
                             [                        ]
                             [ 23.0  111.5  10.0  133 ]
                             [                        ]
                             [ 26.0  92.6   12.3  196 ]
          (%o3)              [                        ]
                             [ 25.0  98.7   10.0  174 ]
                             [                        ]
                             [ 21.0  93.2   5.9   181 ]
                             [                        ]
                             [ 18.0  95.0   11.3  66  ]
                             [                        ]
                             [ 39.0  88.5   7.6   168 ]

     Esta es la media multivariante de `s3'.
          (%i1) load (descriptive)$
          (%i2) s3 : read_matrix (file_search ("biomed.data"))$
          (%i3) mean (s3);
                 65 B + 35 A  317          6 NA + 8145.0
          (%o3) [-----------, ---, 87.178, -------------, 18.123,
                     100      10                100
                                                              3 NA + 19587
                                                              ------------]
                                                                  100

     Aquí la primera componente carece de significado, ya que tanto `A'
     como `B' son categóricas, la segunda componente es la edad media
     de los individuos en forma racional, al tiempo que los valores
     cuarto y quinto muestran cierto comportamiento extraño; lo cual se
     debe a que el símbolo `NA' se utiliza para indicar datos no
     disponibles, por lo que ambas medias no tienen sentido. Una
     posible solución puede ser extraer de la matriz aquellas filas con
     símbolos `NA', lo que acarrearía cierta pérdida de información.
          (%i1) load (descriptive)$
          (%i2) s3 : read_matrix (file_search ("biomed.data"))$
          (%i3) g(v):= v[4] # NA and v[6] # NA $
          (%i4) mean (subsample (s3, g, 3, 4, 5, 6));
          (%o4) [79.4923076923077, 86.2032967032967, 16.93186813186813,
                                                                      2514
                                                                      ----]
                                                                       13

 -- Función: transform_sample (<matriz>, <varlist>, <exprlist>)
     Transforma la <matriz> de datos, en la que a cada columna se le
     asigna un nombre de acuerdo con la lista <varlist>, según las
     expresiones de <exprlist>.

     Ejemplos:

     El segundo argumento asigna nombres a las tres columnas, con ellos
     la lista de expresiones define la transformación de la muestra.

          (%i1) load (descriptive)$
          (%i2) data: matrix([3,2,7],[3,7,2],[8,2,4],[5,2,4]) $
          (%i3) transform_sample(data, [a,b,c], [c, a*b, log(a)]);
                                         [ 7  6   log(3) ]
                                         [               ]
                                         [ 2  21  log(3) ]
          (%o3)                          [               ]
                                         [ 4  16  log(8) ]
                                         [               ]
                                         [ 4  10  log(5) ]

     Añade una columna constante y elimina la tercera variable.

          (%i1) load (descriptive)$
          (%i2) data: matrix([3,2,7],[3,7,2],[8,2,4],[5,2,4]) $
          (%i3) transform_sample(data, [a,b,c], [makelist(1,k,length(data)),a,b]);
                                            [ 1  3  2 ]
                                            [         ]
                                            [ 1  3  7 ]
          (%o3)                             [         ]
                                            [ 1  8  2 ]
                                            [         ]
                                            [ 1  5  2 ]


File: maxima.info,  Node: Funciones y variables de parámetros descriptivos,  Next: Funciones y variables para gráficos estadísticos,  Prev: Funciones y variables para el tratamiento de datos,  Up: descriptive

44.3 Funciones y variables de parámetros descriptivos
=====================================================

 -- Función: mean (<list>)
 -- Función: mean (<matrix>)
     Es la media muestral, definida como
                                 n
                               ====
                       _   1   \
                       x = -    >    x
                           n   /      i
                               ====
                               i = 1

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) mean (s1);
                                         471
          (%o3)                          ---
                                         100
          (%i4) %, numer;
          (%o4)                         4.71
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) mean (s2);
          (%o6)     [9.9485, 10.1607, 10.8685, 15.7166, 14.8441]


 -- Función: var (<list>)
 -- Función: var (<matrix>)
     Es la varianza muestral, definida como
                               n
                             ====
                     2   1   \          _ 2
                    s  = -    >    (x - x)
                         n   /       i
                             ====
                             i = 1

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) var (s1), numer;
          (%o3)                   8.425899999999999

     Véase también `var1'.

 -- Función: var1 (<list>)
 -- Función: var1 (<matrix>)
     Es la cuasivarianza muestral, definida como
                               n
                             ====
                         1   \          _ 2
                        ---   >    (x - x)
                        n-1  /       i
                             ====
                             i = 1

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) var1 (s1), numer;
          (%o3)                    8.5110101010101
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) var1 (s2);
          (%o5) [17.39586540404041, 15.13912778787879, 15.63204924242424,
                                      32.50152569696971, 24.66977392929294]

     Véase también `var'.

 -- Función: std (<list>)
 -- Función: std (<matrix>)
     Es la desviación típica muestral, raíz cuadrada de `var'.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) std (s1), numer;
          (%o3)                   2.902740084816414
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) std (s2);
          (%o5) [4.149928523480858, 3.871399812729241, 3.933920277534866,
                                      5.672434260526957, 4.941970881136392]

     Véanse también `var' y `std1'.

 -- Función: std1 (<list>)
 -- Función: std1 (<matrix>)
     Es la cuasidesviación típica muestral, raíz cuadrada de `var1'.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) std1 (s1), numer;
          (%o3)                   2.917363553109228
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) std1 (s2);
          (%o5) [4.17083509672109, 3.89090320978032, 3.953738641137555,
                                      5.701010936401517, 4.966867617451963]

     Véanse también `var1' y `std'.

 -- Función: noncentral_moment (<list>, <k>)
 -- Función: noncentral_moment (<matrix>, <k>)
     Es el momento no central de orden k, definido como
                                 n
                               ====
                           1   \      k
                           -    >    x
                           n   /      i
                               ====
                               i = 1

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) noncentral_moment (s1, 1), numer; /* the mean */
          (%o3)                         4.71
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%o5) [319793.8724761506, 320532.1923892463, 391249.5621381556,
                                      2502278.205988911, 1691881.797742255]
          (%i6) noncentral_moment (s2, 5);

     Véase también `central_moment'.

 -- Función: central_moment (<list>, <k>)
 -- Función: central_moment (<matrix>, <k>)
     Es el momento central de orden k, definido como
                              n
                            ====
                        1   \          _ k
                        -    >    (x - x)
                        n   /       i
                            ====
                            i = 1

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) central_moment (s1, 2), numer; /* the variance */
          (%o3)                   8.425899999999999
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%o5) [11.29584771375004, 16.97988248298583, 5.626661952750102,
                                       37.5986572057918, 25.85981904394192]
          (%i6) central_moment (s2, 3);

     Véanse también `central_moment' y `mean'.

 -- Función: cv (<list>)
 -- Función: cv (<matrix>)
     Es el coeficiente de variación, o cociente entre la desviación
     típica muestral (`std') y la media (`mean'),

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) cv (s1), numer;
          (%o3)                   .6193977819764815
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) cv (s2);
          (%o5) [.4192426091090204, .3829365309260502, 0.363779605385983,
                                      .3627381836021478, .3346021393989506]

     Véanse también `std' y `mean'.

 -- Función: smin (<list>)
 -- Función: smin (<matrix>)
     Es el valor mínimo de la muestra <list>.  Cuando el argumento es
     una matriz, `smin' devuelve una lista con los valores mínimos de
     las columnas, las cuales están asociadas a variables estadísticas.

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) smin (s1);
          (%o3)                           0
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) smin (s2);
          (%o5)             [0.58, 0.5, 2.67, 5.25, 5.17]

     Véase también `smax'.

 -- Función: smax (<list>)
 -- Función: smax (<matrix>)
     Es el valor máximo de la muestra <list>.  Cuando el argumento es
     una matriz, `smax' devuelve una lista con los valores máximos de
     las columnas, las cuales están asociadas a variables estadísticas.

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) smax (s1);
          (%o3)                           9
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) smax (s2);
          (%o5)          [20.25, 21.46, 20.04, 29.63, 27.63]

     Véase también `smin'.

 -- Función: range (<list>)
 -- Función: range (<matrix>)
     Es la diferencia entre los valores extremos.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) range (s1);
          (%o3)                           9
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) range (s2);
          (%o5)          [19.67, 20.96, 17.37, 24.38, 22.46]


 -- Función: quantile (<list>, <p>)
 -- Función: quantile (<matrix>, <p>)
     Es el <p>-cuantil, siendo <p> un número del intervalo [0, 1], de
     la muestra <list>.  Aunque existen varias definiciones para el
     cuantil muestral (Hyndman, R. J., Fan, Y. (1996) <Sample quantiles
     in statistical packages>. American Statistician, 50, 361-365), la
     programada en el paquete  `descriptive' es la basada en la
     interpolación lineal.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) /* 1st and 3rd quartiles */
                   [quantile (s1, 1/4), quantile (s1, 3/4)], numer;
          (%o3)                      [2.0, 7.25]
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) quantile (s2, 1/4);
          (%o5)    [7.2575, 7.477500000000001, 7.82, 11.28, 11.48]


 -- Función: median (<list>)
 -- Función: median (<matrix>)
     Una vez ordenada una muestra, si el tamaño muestral es impar la
     mediana es el valor central, en caso contrario será la media de
     los dos valores centrales.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) median (s1);
                                          9
          (%o3)                           -
                                          2
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) median (s2);
          (%o5)         [10.06, 9.855, 10.73, 15.48, 14.105]

     La mediana es el cuantil 1/2.

     Véase también `quantile'.

 -- Función: qrange (<list>)
 -- Función: qrange (<matrix>)
     El rango intercuartílico es la diferencia entre el tercer y primer
     cuartil, `quantile(<list>,3/4) - quantile(<list>,1/4)',

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) qrange (s1);
                                         21
          (%o3)                          --
                                         4
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) qrange (s2);
          (%o5) [5.385, 5.572499999999998, 6.0225, 8.729999999999999,
                                                         6.650000000000002]

     Véase también `quantile'.

 -- Función: mean_deviation (<list>)
 -- Función: mean_deviation (<matrix>)
     Es la desviación media, definida como
                               n
                             ====
                         1   \          _
                         -    >    |x - x|
                         n   /       i
                             ====
                             i = 1

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) mean_deviation (s1);
                                         51
          (%o3)                          --
                                         20
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) mean_deviation (s2);
          (%o5) [3.287959999999999, 3.075342, 3.23907, 4.715664000000001,
                                                         4.028546000000002]

     Véase también `mean'.

 -- Función: median_deviation (<list>)
 -- Función: median_deviation (<matrix>)
     Es la desviación mediana, definida como
                           n
                         ====
                     1   \
                     -    >    |x - med|
                     n   /       i
                         ====
                         i = 1

     siendo `med' la mediana de <list>.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) median_deviation (s1);
                                          5
          (%o3)                           -
                                          2
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) median_deviation (s2);
          (%o5)           [2.75, 2.755, 3.08, 4.315, 3.31]

     Véase también `mean'.

 -- Función: harmonic_mean (<list>)
 -- Función: harmonic_mean (<matrix>)
     Es la media armónica, definida como
                            n
                         --------
                          n
                         ====
                         \     1
                          >    --
                         /     x
                         ====   i
                         i = 1

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) y : [5, 7, 2, 5, 9, 5, 6, 4, 9, 2, 4, 2, 5]$
          (%i3) harmonic_mean (y), numer;
          (%o3)                   3.901858027632205
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) harmonic_mean (s2);
          (%o5) [6.948015590052786, 7.391967752360356, 9.055658197151745,
                                      13.44199028193692, 13.01439145898509]

     Véanse también `mean' y `geometric_mean'.

 -- Función: geometric_mean (<list>)
 -- Función: geometric_mean (<matrix>)
     Es la media geométrica, definida como
                           /  n      \ 1/n
                           | /===\   |
                           |  ! !    |
                           |  ! !  x |
                           |  ! !   i|
                           | i = 1   |
                           \         /

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) y : [5, 7, 2, 5, 9, 5, 6, 4, 9, 2, 4, 2, 5]$
          (%i3) geometric_mean (y), numer;
          (%o3)                   4.454845412337012
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) geometric_mean (s2);
          (%o5) [8.82476274347979, 9.22652604739361, 10.0442675714889,
                                      14.61274126349021, 13.96184163444275]

     Véanse también `mean' y `harmonic_mean'.

 -- Función: kurtosis (<list>)
 -- Función: kurtosis (<matrix>)
     Es el coeficiente de curtosis, definido como
                              n
                            ====
                      1     \          _ 4
                     ----    >    (x - x)  - 3
                        4   /       i
                     n s    ====
                            i = 1

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) kurtosis (s1), numer;
          (%o3)                  - 1.273247946514421
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) kurtosis (s2);
          (%o5) [- .2715445622195385, 0.119998784429451,
             - .4275233490482866, - .6405361979019522, - .4952382132352935]

     Véanse también `mean', `var' y `skewness'.

 -- Función: skewness (<list>)
 -- Función: skewness (<matrix>)
     Es el coeficiente de asimetría, definido como
                              n
                            ====
                      1     \          _ 3
                     ----    >    (x - x)
                        3   /       i
                     n s    ====
                            i = 1

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) skewness (s1), numer;
          (%o3)                  .009196180476450306
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) skewness (s2);
          (%o5) [.1580509020000979, .2926379232061854, .09242174416107717,
                                      .2059984348148687, .2142520248890832]

     Véanse también `mean', `var' y `kurtosis'.

 -- Función: pearson_skewness (<list>)
 -- Función: pearson_skewness (<matrix>)
     Es el coeficiente de asimetría de Pearson, definido como
                          _
                       3 (x - med)
                       -----------
                            s

     siendo <med> la mediana de <list>.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) pearson_skewness (s1), numer;
          (%o3)                   .2159484029093895
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) pearson_skewness (s2);
          (%o5) [- .08019976629211892, .2357036272952649,
                   .1050904062491204, .1245042340592368, .4464181795804519]

     Véanse también `mean', `var' y `median'.

 -- Función: quartile_skewness (<list>)
 -- Función: quartile_skewness (<matrix>)
     Es el coeficiente de asimetría cuartílico, definido como
                         c    - 2 c    + c
                          3/4      1/2    1/4
                         --------------------
                             c    - c
                              3/4    1/4

     siendo c_p el <p>-cuantil de la muestra <list>.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) quartile_skewness (s1), numer;
          (%o3)                  .04761904761904762
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) quartile_skewness (s2);
          (%o5) [- 0.0408542246982353, .1467025572005382,
                 0.0336239103362392, .03780068728522298, 0.210526315789474]

     Véase también `quantile'.

 -- Función: cov (<matrix>)
     Es la matriz de covarianzas de una muestra multivariante, definida
     como
                        n
                       ====
                    1  \           _        _
                S = -   >    (X  - X) (X  - X)'
                    n  /       j        j
                       ====
                       j = 1

     siendo X_j la j-ésima fila de la matriz muestral.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) fpprintprec : 7$  /* change precision for pretty output */
                [ 17.22191  13.61811  14.37217  19.39624  15.42162 ]
                [                                                  ]
                [ 13.61811  14.98774  13.30448  15.15834  14.9711  ]
                [                                                  ]
          (%o4) [ 14.37217  13.30448  15.47573  17.32544  16.18171 ]
                [                                                  ]
                [ 19.39624  15.15834  17.32544  32.17651  20.44685 ]
                [                                                  ]
                [ 15.42162  14.9711   16.18171  20.44685  24.42308 ]
          (%i5) cov (s2);

     Véase también `cov1'.

 -- Función: cov1 (<matrix>)
     Es la matriz de cuasivarianzas de una muestra multivariante,
     definida como
                        n
                       ====
                   1   \           _        _
             S  = ---   >    (X  - X) (X  - X)'
              1   n-1  /       j        j
                       ====
                       j = 1

     siendo X_j la j-ésima fila de la matriz muestral.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) fpprintprec : 7$ /* change precision for pretty output */
                [ 17.39587  13.75567  14.51734  19.59216  15.5774  ]
                [                                                  ]
                [ 13.75567  15.13913  13.43887  15.31145  15.12232 ]
                [                                                  ]
          (%o4) [ 14.51734  13.43887  15.63205  17.50044  16.34516 ]
                [                                                  ]
                [ 19.59216  15.31145  17.50044  32.50153  20.65338 ]
                [                                                  ]
                [ 15.5774   15.12232  16.34516  20.65338  24.66977 ]
          (%i5) cov1 (s2);

     Véase también `cov'.

 -- Función: global_variances (<matrix>)
 -- Función: global_variances (<matrix>, <options> ...)
     La función `global_variances' devuelve una lista de medidas
     globales de variabilidad:

        * <varianza total>: `trace(S_1)',

        * <varianza media>: `trace(S_1)/p',

        * <varianza generalizada>: `determinant(S_1)',

        * <desviación típica generalizada>: `sqrt(determinant(S_1))',

        * <varianza efectiva> `determinant(S_1)^(1/p)', (definida en:
          Peña, D. (2002) <Análisis de datos multivariantes>;
          McGraw-Hill, Madrid.)

        * <desviación típica efectiva>: `determinant(S_1)^(1/(2*p))'.
     donde <p> es la dimensión de la variable aleatoria multivariante y
     S_1 la matriz de covarianzas devuelta por la función `cov1'.

     Opción:

        * `'data', por defecto `'true', indica si la matriz de entrada
          contiene los datos muestrales, en cuyo caso la matriz de
          covarianzas `cov1' debe ser calculada; en caso contrario, se
          le debe pasar ésta a la función como matriz simétrica en
          lugar de los datos.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) global_variances (s2);
          (%o3) [105.338342060606, 21.06766841212119, 12874.34690469686,
                   113.4651792608502, 6.636590811800794, 2.576158149609762]

     Cálculo de `global_variances' a partir de la matriz de covarianzas.

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) s : cov1 (s2)$
          (%i4) global_variances (s, data=false);
          (%o4) [105.338342060606, 21.06766841212119, 12874.34690469686,
                   113.4651792608502, 6.636590811800794, 2.576158149609762]

     Véanse también `cov' y `cov1'.

 -- Función: cor (<matrix>)
 -- Función: cor (<matrix>, <options> ...)
     Es la matriz de correlaciones de la muestra multivariante.

     Opción:

        * `'data', por defecto `'true', indica si la matriz de entrada
          contiene los datos muestrales, en cuyo caso la matriz de
          covarianzas `cov1' debe ser calculada; en caso contrario, se
          le debe pasar ésta a la función como matriz simétrica en
          lugar de los datos.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) fpprintprec:7$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) cor (s2);
                [   1.0     .8476339  .8803515  .8239624  .7519506 ]
                [                                                  ]
                [ .8476339    1.0     .8735834  .6902622  0.782502 ]
                [                                                  ]
          (%o4) [ .8803515  .8735834    1.0     .7764065  .8323358 ]
                [                                                  ]
                [ .8239624  .6902622  .7764065    1.0     .7293848 ]
                [                                                  ]
                [ .7519506  0.782502  .8323358  .7293848    1.0    ]

     Cálculo de la matriz de correlaciones a partir de la matriz de
     covarianzas.

          (%i1) load (descriptive)$
          (%i2) fpprintprec : 7 $
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) s : cov1 (s2)$
          (%i5) cor (s, data=false); /* this is faster */
                [   1.0     .8476339  .8803515  .8239624  .7519506 ]
                [                                                  ]
                [ .8476339    1.0     .8735834  .6902622  0.782502 ]
                [                                                  ]
          (%o5) [ .8803515  .8735834    1.0     .7764065  .8323358 ]
                [                                                  ]
                [ .8239624  .6902622  .7764065    1.0     .7293848 ]
                [                                                  ]
                [ .7519506  0.782502  .8323358  .7293848    1.0    ]

     Véanse también `cov' y `cov1'.

 -- Función: list_correlations (<matrix>)
 -- Función: list_correlations (<matrix>, <options> ...)
     La función `list_correlations' devuelve una lista con medidas de
     correlación:

        * <matriz de precisión>: es la inversa de la matriz de
          covarianzas S_1,
                      -1     ij
                     S   = (s  )
                      1         i,j = 1,2,...,p

        * <multiple correlation vector>:  (R_1^2, R_2^2, ..., R_p^2),
          with
                      2          1
                     R  = 1 - -------
                      i        ii
                              s   s
                                   ii
          es un indicador de la bondad de ajuste del modelo de
          regresión lineal multivariante de X_i cuando el resto de
          variables se utilizan como regresores.

        * <matriz de correlaciones parciales>: en la que el elemento
          (i, j) es
                                        ij
                                       s
                     r        = - ------------
                      ij.rest     / ii  jj\ 1/2
                                  |s   s  |
                                  \       /

     Opción:

        * `'data', por defecto `'true', indica si la matriz de entrada
          contiene los datos muestrales, en cuyo caso la matriz de
          covarianzas `cov1' debe ser calculada; en caso contrario, se
          le debe pasar ésta a la función como matriz simétrica en
          lugar de los datos.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) z : list_correlations (s2)$
          (%i4) fpprintprec : 5$ /* for pretty output */
                [  .38486   - .13856   - .15626   - .10239    .031179  ]
                [                                                      ]
                [ - .13856   .34107    - .15233    .038447   - .052842 ]
                [                                                      ]
          (%o5) [ - .15626  - .15233    .47296    - .024816  - .10054  ]
                [                                                      ]
                [ - .10239   .038447   - .024816   .10937    - .034033 ]
                [                                                      ]
                [ .031179   - .052842  - .10054   - .034033   .14834   ]
          (%o6)       [.85063, .80634, .86474, .71867, .72675]
                 [  - 1.0     .38244   .36627   .49908   - .13049 ]
                 [                                                ]
                 [  .38244    - 1.0    .37927  - .19907   .23492  ]
                 [                                                ]
          (%o7)  [  .36627    .37927   - 1.0    .10911    .37956  ]
                 [                                                ]
                 [  .49908   - .19907  .10911   - 1.0     .26719  ]
                 [                                                ]
                 [ - .13049   .23492   .37956   .26719    - 1.0   ]

     Véanse también `cov' y `cov1'.

 -- Función: principal_components (<matrix>)
 -- Función: principal_components (<matrix>, <options> ...)
     Calcula las componentes principales de una muestra multivariante.
     Las componentes principales se utilizan en el análisis estadístico
     multivariante para reducir la dimensionalidad de la muestra.

     Opción:

        * `'data', por defecto `'true', indica si la matriz de entrada
          contiene los datos muestrales, en cuyo caso la matriz de
          covarianzas `cov1' debe ser calculada; en caso contrario, se
          le debe pasar ésta a la función como matriz simétrica en
          lugar de los datos.

     La salida de la función `principal_components' es una lista con
     los siguientes resultados:

        * varianzas de las componentes principales,

        * porcentajes de variación total explicada por cada componente
          principal,

        * matriz de rotación.

     Ejemplos:

     En este ejemplo, la primera componente explica el 83.13 por ciento
     de la varianza total.

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) fpprintprec:4 $
          (%i4) res: principal_components(s2);
          0 errors, 0 warnings
          (%o4) [[87.57, 8.753, 5.515, 1.889, 1.613],
          [83.13, 8.31, 5.235, 1.793, 1.531],
          [ .4149  .03379   - .4757  - 0.581   - .5126 ]
          [                                            ]
          [ 0.369  - .3657  - .4298   .7237    - .1469 ]
          [                                            ]
          [ .3959  - .2178  - .2181  - .2749    .8201  ]]
          [                                            ]
          [ .5548   .7744    .1857    .2319    .06498  ]
          [                                            ]
          [ .4765  - .4669   0.712   - .09605  - .1969 ]
          (%i5) /* porcentajes acumulados  */
              block([ap: copy(res[2])],
                for k:2 thru length(ap) do ap[k]: ap[k]+ap[k-1],
                ap);
          (%o5)                 [83.13, 91.44, 96.68, 98.47, 100.0]
          (%i6) /* dimension de la muestra */
                p: length(first(res));
          (%o6)                                  5
          (%i7) /* dibuja porcentajes para seleccionar el numero de
                   componentes principales para el analisis ulterior */
               draw2d(
                  fill_density = 0.2,
                  apply(bars, makelist([k, res[2][k], 1/2], k, p)),
                  points_joined = true,
                  point_type    = filled_circle,
                  point_size    = 3,
                  points(makelist([k, res[2][k]], k, p)),
                  xlabel = "Variances",
                  ylabel = "Percentages",
                  xtics  = setify(makelist([concat("PC",k),k], k, p))) $

     En caso de que la matriz de covarianzas sea conocida, se le puede
     pasar a la función, pero debe utilizarse la opción `data=false'.

          (%i1) load (descriptive)$
          (%i2) S: matrix([1,-2,0],[-2,5,0],[0,0,2]);
                                          [  1   - 2  0 ]
                                          [             ]
          (%o2)                           [ - 2   5   0 ]
                                          [             ]
                                          [  0    0   2 ]
          (%i3) fpprintprec:4 $
          (%i4) /* el argumento es una matriz de covarianzas */
                res: principal_components(S, data=false);
          0 errors, 0 warnings
                                                            [ - .3827  0.0  .9239 ]
                                                            [                     ]
          (%o4) [[5.828, 2.0, .1716], [72.86, 25.0, 2.145], [  .9239   0.0  .3827 ]]
                                                            [                     ]
                                                            [   0.0    1.0   0.0  ]
          (%i5) /* transformacion para obtener las componentes principales a
                   partir de los registros originales */
                matrix([a1,b2,c3],[a2,b2,c2]).last(res);
                       [ .9239 b2 - .3827 a1  1.0 c3  .3827 b2 + .9239 a1 ]
          (%o5)        [                                                  ]
                       [ .9239 b2 - .3827 a2  1.0 c2  .3827 b2 + .9239 a2 ]



File: maxima.info,  Node: Funciones y variables para gráficos estadísticos,  Prev: Funciones y variables de parámetros descriptivos,  Up: descriptive

44.4 Funciones y variables para gráficos estadísticos
=====================================================

 -- Función: barsplot (<data1>, <data2>, ..., <option_1>, <option_2>,
          ...)
 -- Función: barsplot_description (...)
     Dibuja diagramas de barras para variables estadísticas discretas,
     tanto para una como para más muestras.

     <data> puede ser una lista de resultados provenientes de una
     muestra o una matriz de <m> filas y <n> columnas, representando <n>
     muestras de tamaño <m> cada una.

     Las opciones disponibles son:

          <box_width> (valor por defecto, `3/4'): ancho relativo de los
          rectángulos. Este valor debe pertenecer al rango `[0,1]'.

        * <grouping> (valor por defecto, `clustered'): indica cómo se
          agrupan las diferentes muestras. Son valores válidos:
          `clustered' y `stacked'.

        * <groups_gap> (valor por defecto, `1'): un número positivo que
          representa la separación entre dos grupos consecutivos de
          barras.

        * <bars_colors> (valor por defecto, `[]'): una lista de colores
          para múltiples muestras. Cuando el número de muestras sea
          mayor que el de colores especificados, los colores
          adicionales necesarios se seleccionan aleatoriamente. Véase
          `color' para más información.

        * <frequency> (valor por defecto, `absolute'): indica la escala
          de las ordenadas.  Valores admitidos son:  `absolute',
          `relative' y and `percent'.

        * <ordering> (valor por defecto, `orderlessp'): los valores
          admitidos para esta opción son: `orderlessp' y `ordergreatp',
          indicando cómo se deben ordenar los resultados muestrales
          sobre el eje-<x>.

        * <sample_keys> (valor por defecto, `[]'): es una lista de
          cadenas de texto a usar como leyendas. Cuando la lista tenga
          una longitud diferente de cero o del número de muestras, se
          devolverá un mensaje de error.

        * <start_at> (valor por defecto, `0'): indica a qué altura
          comienza a dibujarse el gráfico de barra sobre el eje de
          abscisas.

        * Todas las opciones globales de `draw', excepto `xtics', que
          se asigna internamente por `barsplot'. Si es necesario que el
          usuario le dé su propio valor a esta opción, o quiere
          construir una escena más compleja, debe hacer uso de
          `barsplot_description'. Véase el ejemplo más abajo.

        * Las siguientes opciones locales de `draw': `key', `color',
          `fill_color', `fill_density' y `line_width'. Véase también
          `bars'.


     La función `barsplot_description' crea un objeto gráfico útil para
     formar escenas complejas, junto con otros objetos gráficos.  Se
     dispone también de la función `wxbarsplot' para crear histogramas
     incorporados en los interfaces wxMaxima y iMaxima.

     Ejemplos:

     Muestra univariante en formato matricial. Frecuencias absolutas.

          (%i1) load (descriptive)$
          (%i2) m : read_matrix (file_search ("biomed.data"))$
          (%i3) barsplot(
                  col(m,2),
                  title        = "Ages",
                  xlabel       = "years",
                  box_width    = 1/2,
                  fill_density = 3/4)$

     Dos muestras de diferente tamaño, con frecuencias relativas y
     colores definidos por el usuario.

          (%i1) load (descriptive)$
          (%i2) l1:makelist(random(10),k,1,50)$
          (%i3) l2:makelist(random(10),k,1,100)$
          (%i4) barsplot(
                  l1,l2,
                  box_width    = 1,
                  fill_density = 1,
                  bars_colors  = [black, grey],
                  frequency = relative,
                  sample_keys = ["A", "B"])$

     Cuatro muestras no numéricas de igual tamaño.

          (%i1) load (descriptive)$
          (%i2) barsplot(
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  title  = "Asking for something to four groups",
                  ylabel = "# of individuals",
                  groups_gap   = 3,
                  fill_density = 0.5,
                  ordering     = ordergreatp)$

     Barras apiladas verticalmente.

          (%i1) load (descriptive)$
          (%i2) barsplot(
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  title  = "Asking for something to four groups",
                  ylabel = "# of individuals",
                  grouping     = stacked,
                  fill_density = 0.5,
                  ordering     = ordergreatp)$

     `barsplot' en un contexto multiplot.

          (%i1) load (descriptive)$
          (%i2) l1:makelist(random(10),k,1,50)$
          (%i3) l2:makelist(random(10),k,1,100)$
          (%i4) bp1 :
                  barsplot_description(
                   l1,
                   box_width = 1,
                   fill_density = 0.5,
                   bars_colors = [blue],
                   frequency = relative)$
          (%i5) bp2 :
                  barsplot_description(
                   l2,
                   box_width = 1,
                   fill_density = 0.5,
                   bars_colors = [red],
                   frequency = relative)$
          (%i6) draw(gr2d(bp1), gr2d(bp2))$

     Para las opciones relacionadas con los diagramas de barras, véase
     `bars' del paquete `draw'.

     Véanse también las funciones `histogram' y `piechart'.

 -- Función: boxplot (<data>)
 -- Función: boxplot (<data>, <option_1>, <option_2>, ...)
 -- Función: boxplot_description (...)
     Dibuja diagramas de cajas (box-and-whishker). El argumento <data>
     puede ser una lista, lo cual no es de gran interés, puesto que
     estos gráficos se utilizan principalmente para comparar distintas
     muestras, o una matriz, de manera que sea posible comparar dos o
     más componentes de una muestra multivariante. También se permite
     que <data> sea una lista de muestras con posibles tamaños
     diferentes; de hecho, esta es la única función del paquete
     `descriptive' que admite esta estructura de datos.

     Opciones disponibles:

        * <box_width> (valor por defecto, `3/4'): ancho relativo de las
          cajas.  This  value must be in the range `[0,1]'.

        * <box_orientation> (valor por defecto, `vertical'): valores
          posibles: `vertical' y `horizontal'.

        * Todas las opciones globales de `draw', excepto
          `points_joined', `point_size', `point_type', `xtics',
          `ytics', `xrange' y `yrange', que se asignan internamente por
          `boxplot'. Si es necesario que el usuario le dé sus propios
          valores a estas opciones, o quiere construir una escena más
          compleja, debe hacer uso de `boxplot_description'.

        * Las siguientes opciones locales de `draw': `key', `color', y
          `line_width'.


     La función `boxplot_description' crea un objeto gráfico útil para
     formar escenas complejas, junto con otros objetos gráficos.  Se
     dispone también de la función `wxboxplot' para crear histogramas
     incorporados en los interfaces wxMaxima y iMaxima.

     Ejemplos:

     Diagrama de cajas de una muestra multivariante.

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix(file_search("wind.data"))$
          (%i3) boxplot(s2,
                  box_width  = 0.2,
                  title      = "Windspeed in knots",
                  xlabel     = "Stations",
                  color      = red,
                  line_width = 2)$

     Diagrama de cajas de tres muestras de tamaños diferentes.

          (%i1) load (descriptive)$
          (%i2) A :
                 [[6, 4, 6, 2, 4, 8, 6, 4, 6, 4, 3, 2],
                  [8, 10, 7, 9, 12, 8, 10],
                  [16, 13, 17, 12, 11, 18, 13, 18, 14, 12]]$
          (%i3) boxplot (A, box_orientation = horizontal)$


 -- Función: histogram (<list>)
 -- Función: histogram (<list>, <option_1>, <option_2>, ...)
 -- Función: histogram (<one_column_matrix>)
 -- Función: histogram (<one_column_matrix>, <option_1>, <option_2>,
          ...)
 -- Función: histogram (<one_row_matrix>)
 -- Función: histogram (<one_row_matrix>, <option_1>, <option_2>, ...)
 -- Función: histogram_description (...)
     Dibuja un histograma a partir de una muestra continua. Los datos
     muestrales deben darse en forma de lista de números o como una
     matriz unidimensional.

     Opciones dispponibles:

        * <nclasses> (valor por defecto, `10'): número de clases del
          histograma, o una lista indicando los límites de las clases y
          su número, o solamente los límites.

        * <frequency> (valor por defecto, `absolute'): indica la escala
          de las ordenadas.  Valores admitidos son:  `absolute',
          `relative', `percent' y `density'.  Con `density', el
          histograma adquiere un área total igual a uno.

        * <htics> (valor por defecto, `auto'): formato para las marcas
          sobre el eje de las abscisas. Valores admitidos son: `auto',
          `endpoints', `intervals' o una lista de etiquetas.

        * Todas las opciones globales de `draw', excepto `xrange',
          `yrange' y `xtics', que son asignadas internamente por
          `histogram'.  Si es necesario que el usuario le dé sus
          propios valores a estas opciones, debe hacer uso de
          `histogram_description'. Véase el ejemplo más abajo.

        * Las siguientes opciones locales de `draw': `key', `color',
          `fill_color', `fill_density' y `line_width'. Véase también
          `bars'.


     La función `histogram_description' crea un objeto gráfico útil
     para formar escenas complejas, junto con otros objetos gráficos.
     Se dispone también de la función `wxhistogram' para crear
     histogramas incorporados en los interfaces wxMaxima y iMaxima.

     Ejemplos:

     Un histograma con seis clases:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) histogram (
                     s1,
                     nclasses     = 8,
                     title        = "pi digits",
                     xlabel       = "digits",
                     ylabel       = "Absolute frequency",
                     fill_color   = grey,
                     fill_density = 0.6)$

     Ajustando los límites del histograma a -2 y 12, con 3 clases.
     También se establece un formato predefinido a las marcas del eje
     de abscisas:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) histogram (
                     s1,
                     nclasses     = [-2,12,3],
                     htics        = ["A", "B", "C"],
                     terminal     = png,
                     fill_color   = "#23afa0",
                     fill_density = 0.6)$

     Se hace uso de `histogram_description' para ajustar la opción
     `xrange' y añadir una curva explícita a la escena:

          (%i1) load (descriptive)$
          (%i2) ( load("distrib"),
                  m: 14, s: 2,
                  s2: random_normal(m, s, 1000) ) $
          (%i3) draw2d(
                  grid   = true,
                  xrange = [5, 25],
                  histogram_description(
                    s2,
                    nclasses     = 9,
                    frequency    = density,
                    fill_density = 0.5),
                  explicit(pdf_normal(x,m,s), x, m - 3*s, m + 3* s))$


 -- Función: piechart (<list>)
 -- Función: piechart (<list>, <option_1>, <option_2>, ...)
 -- Función: piechart (<one_column_matrix>)
 -- Función: piechart (<one_column_matrix>, <option_1>, <option_2>, ...)
 -- Función: piechart (<one_row_matrix>)
 -- Función: piechart (<one_row_matrix>, <option_1>, <option_2>, ...)
 -- Función: piechart_description (...)
     Similar a `barsplot', pero dibuja sectores en lugar de rectángulos.

     Opciones disponibles:

        * <sector_colors> (valor por defecto, `[]'): una lista de
          colores para los sectores. Cuando el número de sectores sea
          mayor que el de colores especificados, los colores
          adicionales necesarios se seleccionan aleatoriamente. Véase
          `color' para más información.

        * <pie_center> (valor por defecto, `[0,0]'): centro del diagrama

        * <pie_radius> (valor por defecto, `1'): radio del diagrama.

        * Todas las opciones globales de `draw', excepto `key', que se
          asigna internamente por `piechart'. Si es necesario que el
          usuario le dé su propio valor a esta opción, o quiere
          construir una escena más compleja, debe hacer uso de
          `piechart_description'.

        * Las siguientes opciones locales de `draw': `key', `color',
          `fill_density' y `line_width'. Véase también `bars'.


     La función `piechart_description' crea un objeto gráfico útil para
     formar escenas complejas, junto con otros objetos gráficos.  Se
     dispone también de la función `wxpiechart' para crear histogramas
     incorporados en los interfaces wxMaxima y iMaxima.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) piechart(
                  s1,
                  xrange  = [-1.1, 1.3],
                  yrange  = [-1.1, 1.1],
                  title   = "Digit frequencies in pi")$

     Véase también la función `barsplot'.

 -- Función: scatterplot (<list>)
 -- Función: scatterplot (<list>, <option_1>, <option_2>, ...)
 -- Función: scatterplot (<matrix>)
 -- Función: scatterplot (<matrix>, <option_1>, <option_2>, ...)
 -- Función: scatterplot_description (...)
     Dibuja diagramas de dispersión, tanto de muestras univariantes
     (<list>) como multivariantes (<matrix>).

     Las opciones disponibles son las mismas que admite `histogram'.

     La función `scatterplot_description' crea un objeto gráfico útil
     para formar escenas complejas, junto con otros objetos gráficos.
     Se dispone también de la función `wxscatterplot' para crear
     histogramas incorporados en los interfaces wxMaxima y iMaxima.

     Ejemplos:

     Diagrama de dispersión univariante a partir de una muestra normal
     simulada.

          (%i1) load (descriptive)$
          (%i2) load (distrib)$
          (%i3) scatterplot(
                  random_normal(0,1,200),
                  xaxis      = true,
                  point_size = 2,
                  dimensions = [600,150])$

     Diagrama de dispersión bidimensional.

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) scatterplot(
                 submatrix(s2, 1,2,3),
                 title      = "Data from stations #4 and #5",
                 point_type = diamant,
                 point_size = 2,
                 color      = blue)$

     Diagrama de dispersión tridimensional.

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) scatterplot(submatrix (s2, 1,2), nclasses=4)$

     Diagrama de dispersión de cinco dimensiones, con histogramas de
     cinco classes.

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) scatterplot(
                  s2,
                  nclasses     = 5,
                  frequency    = relative,
                  fill_color   = blue,
                  fill_density = 0.3,
                  xtics        = 5)$

     Para dibujar puntos aislados o unidos por segmentos, tanto en dos
     como en tres dimensiones, véase `points'.  Véase también
     `histogram'.

 -- Función: starplot (<data1>, <data2>, ..., <option_1>, <option_2>,
          ...)
 -- Función: starplot_description (...)
     Dibuja diagramas de estrellas para variables estadísticas
     discretas, tanto para una como para más muestras.

     <data> puede ser una lista de resultados provenientes de una
     muestra o una matriz de <m> filas y <n> columnas, representando <n>
     muestras de tamaño <m> cada una.

     Las opciones disponibles son:

        * <stars_colors> (valor por defecto, `[]'): una lista de
          colores para muestras múltiples. Cuando haya más muestras que
          colores especificados, los colores que faltan se eligen
          aleatoriamente. Véase `color' para más información.

        * <frequency> (valor por defecto, `absolute'): indica la escala
          de los radios.  Valores admitidos son:  `absolute' y
          `relative'.

        * <ordering> (valor por defecto, `orderlessp'): los valores
          admitidos para esta opción son: `orderlessp' y `ordergreatp',
          indicando cómo se deben ordenar los resultados muestrales
          sobre el eje-<x>.

        * <sample_keys> (valor por defecto, `[]'): es una lista de
          cadenas de texto a usar como leyendas. Cuando la lista tenga
          una longitud diferente de cero o del número de muestras, se
          devolverá un mensaje de error.

        * <star_center> (valor por defecto, `[0,0]'): centro del
          diagrama.

        * <star_radius> (valor por defecto, `1'): radio del diagrama.

        * Todas las opciones globales de `draw', excepto
          `points_joined', `point_type', and `key', que se asignan
          internamente por `starplot'. Si es necesario que el usuario
          les dé sus propios valores a estas opciones, o quiere
          construir una escena más compleja, debe hacer uso de
          `starplot_description'.

        * La siguiente opción local de `draw': `line_width'.


     La función `starplot_description' crea un objeto gráfico útil para
     formar escenas complejas, junto con otros objetos gráficos.  Se
     dispone también de la función `wxstarplot' para crear histogramas
     incorporados en los interfaces wxMaxima y iMaxima.

     Ejemplo:

     Gráfico basado en frecuencias absolutas. La localización y el
     radios lo define el usuario.

          (%i1) load (descriptive)$
          (%i2) l1: makelist(random(10),k,1,50)$
          (%i3) l2: makelist(random(10),k,1,200)$
          (%i4) starplot(
                  l1, l2,
                  stars_colors = [blue,red],
                  sample_keys = ["1st sample", "2nd sample"],
                  star_center = [1,2],
                  star_radius = 4,
                  proportional_axes = xy,
                  line_width = 2 ) $


 -- Función: stemplot (<m>)
 -- Función: stemplot (<m>, <option>)
     Dibuja diagrama de tallos y hojas.

     La única opción disponible es:

        * <leaf_unit> (valor por defecto, `1'): indica la unidad de las
          hojas; debe ser una potencia de 10.


     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) load(distrib)$
          (%i3) stemplot(
                  random_normal(15, 6, 100),
                  leaf_unit = 0.1);
          -5|4
           0|37
           1|7
           3|6
           4|4
           5|4
           6|57
           7|0149
           8|3
           9|1334588
          10|07888
          11|01144467789
          12|12566889
          13|24778
          14|047
          15|223458
          16|4
          17|11557
          18|000247
          19|4467799
          20|00
          21|1
          22|2335
          23|01457
          24|12356
          25|455
          27|79
          key: 6|3 =  6.3
          (%o3)                  done



File: maxima.info,  Node: diag,  Next: distrib,  Prev: descriptive,  Up: Top

45 diag
*******

* Menu:

* Funciones y variables para diag::


File: maxima.info,  Node: Funciones y variables para diag,  Prev: diag,  Up: diag

45.1 Funciones y variables para diag
====================================

 -- Función: diag (<lm>)
     Genera una matriz cuadrada con las matrices de <lm> en la
     diagonal, siendo <lm> una lista de matrices o de escalares.

     Ejemplo:
          (%i1) load("diag")$

          (%i2) a1:matrix([1,2,3],[0,4,5],[0,0,6])$

          (%i3) a2:matrix([1,1],[1,0])$

          (%i4) diag([a1,x,a2]);
                             [ 1  2  3  0  0  0 ]
                             [                  ]
                             [ 0  4  5  0  0  0 ]
                             [                  ]
                             [ 0  0  6  0  0  0 ]
          (%o4)              [                  ]
                             [ 0  0  0  x  0  0 ]
                             [                  ]
                             [ 0  0  0  0  1  1 ]
                             [                  ]
                             [ 0  0  0  0  1  0 ]

     Antes de hacer uso de esta función ejecútese  `load("diag")'.

 -- Función: JF (<lambda>,<n>)
     Devuelve la célula de Jordan de orden  <n> con valor propio
     <lambda>.

     Ejemplo:
          (%i1) load("diag")$

          (%i2) JF(2,5);
                              [ 2  1  0  0  0 ]
                              [               ]
                              [ 0  2  1  0  0 ]
                              [               ]
          (%o2)               [ 0  0  2  1  0 ]
                              [               ]
                              [ 0  0  0  2  1 ]
                              [               ]
                              [ 0  0  0  0  2 ]
          (%i3) JF(3,2);
                                   [ 3  1 ]
          (%o3)                    [      ]
                                   [ 0  3 ]

     Antes de hacer uso de esta función ejecútese  `load("diag")'.

 -- Función: jordan (<mat>)
     Devuelve la forma de Jordan de la matriz <mat>, pero en formato de
     lista de Maxima. Para obtener la matriz correspondiente, llámese a
     la función `dispJordan' utilizando como argumento la salida de
     `jordan'.

     Ejemplo:
          (%i1) load("diag")$

          (%i3) a:matrix([2,0,0,0,0,0,0,0],
                         [1,2,0,0,0,0,0,0],
                         [-4,1,2,0,0,0,0,0],
                         [2,0,0,2,0,0,0,0],
                         [-7,2,0,0,2,0,0,0],
                         [9,0,-2,0,1,2,0,0],
                         [-34,7,1,-2,-1,1,2,0],
                         [145,-17,-16,3,9,-2,0,3])$

          (%i34) jordan(a);
          (%o4)             [[2, 3, 3, 1], [3, 1]]
          (%i5) dispJordan(%);
                          [ 2  1  0  0  0  0  0  0 ]
                          [                        ]
                          [ 0  2  1  0  0  0  0  0 ]
                          [                        ]
                          [ 0  0  2  0  0  0  0  0 ]
                          [                        ]
                          [ 0  0  0  2  1  0  0  0 ]
          (%o5)           [                        ]
                          [ 0  0  0  0  2  1  0  0 ]
                          [                        ]
                          [ 0  0  0  0  0  2  0  0 ]
                          [                        ]
                          [ 0  0  0  0  0  0  2  0 ]
                          [                        ]
                          [ 0  0  0  0  0  0  0  3 ]

     Antes de hacer uso de esta función ejecútese  `load("diag")'.
     Véanse también `dispJordan' y `minimalPoly'.

 -- Función: dispJordan (<l>)
     Devuelve la matriz de Jordan asociada a la codificación dada por
     la lista <l>, que habitualmente será la salida de la función
     `jordan'.

     Ejemplo:
          (%i1) load("diag")$

          (%i2) b1:matrix([0,0,1,1,1],
                          [0,0,0,1,1],
                          [0,0,0,0,1],
                          [0,0,0,0,0],
                          [0,0,0,0,0])$

          (%i3) jordan(b1);
          (%o3)                  [[0, 3, 2]]
          (%i4) dispJordan(%);
                              [ 0  1  0  0  0 ]
                              [               ]
                              [ 0  0  1  0  0 ]
                              [               ]
          (%o4)               [ 0  0  0  0  0 ]
                              [               ]
                              [ 0  0  0  0  1 ]
                              [               ]
                              [ 0  0  0  0  0 ]

     Antes de hacer uso de esta función ejecútese  `load("diag")'.
     Véanse también `jordan' y `minimalPoly'.

 -- Función: minimalPoly (<l>)
     Devuelve el polinomio mínimo asociado a la codificación dada por
     la lista <l>, que habitualmente será la salida de la función
     `jordan'.

     Ejemplo:
          (%i1) load("diag")$

          (%i2) a:matrix([2,1,2,0],
                         [-2,2,1,2],
                         [-2,-1,-1,1],
                         [3,1,2,-1])$

          (%i3) jordan(a);
          (%o3)               [[- 1, 1], [1, 3]]
          (%i4) minimalPoly(%);
                                      3
          (%o4)                (x - 1)  (x + 1)

     Antes de hacer uso de esta función ejecútese  `load("diag")'.
     Véanse también `jordan' y `dispJordan'.

 -- Función: ModeMatrix (<A>,<l>)
     Devuelve la matriz <M> tal que (M^^-1).A.M=J, donde <J> es la
     forma de Jordan de <A>. La lista <l> es la forma codificada de la
     forma de Jordan tal como la devuelve la función `jordan'.

     Ejemplo:
          (%i1) load("diag")$

          (%i2) a:matrix([2,1,2,0],
                    [-2,2,1,2],
                    [-2,-1,-1,1],
                    [3,1,2,-1])$

          (%i3) jordan(a);
          (%o3)               [[- 1, 1], [1, 3]]
          (%i4) M: ModeMatrix(a,%);
                            [  1    - 1   1   1 ]
                            [                   ]
                            [   1               ]
                            [ - -   - 1   0   0 ]
                            [   9               ]
                            [                   ]
          (%o4)             [   13              ]
                            [ - --   1   - 1  0 ]
                            [   9               ]
                            [                   ]
                            [  17               ]
                            [  --   - 1   1   1 ]
                            [  9                ]
          (%i5) is(  (M^^-1).a.M = dispJordan(%o3)  );
          (%o5)                      true
     Nótese que `dispJordan(%o3)' es la forma de Jordan de la matriz
     `a'.

     Antes de hacer uso de esta función ejecútese  `load("diag")'.
     Véanse también `jordan' y `dispJordan'.

 -- Función: mat_function (<f>,<mat>)
     Devuelve  f(mat), siendo <f> una función analítica y <mat> una
     matriz. Este cálculo se basa en la fórmula integral de Cauchy, que
     establece que si `f(x)' es analítica y
          mat=diag([JF(m1,n1),...,JF(mk,nk)]),

     entonces

          f(mat)=ModeMatrix*diag([f(JF(m1,n1)),...,f(JF(mk,nk))])
                    * ModeMatrix^^(-1)

     Nótese que hay otros métodos alternativos para realizar este
     cálculo.

     Se presentan algunos ejemplos.

     Ejemplo 1:
          (%i1) load("diag")$

          (%i2) b2:matrix([0,1,0], [0,0,1], [-1,-3,-3])$

          (%i3) mat_function(exp,t*b2);
                         2   - t
                        t  %e          - t     - t
          (%o3) matrix([-------- + t %e    + %e   ,
                           2
                  - t     - t                           - t
           2    %e      %e        - t           - t   %e
          t  (- ----- - ----- + %e   ) + t (2 %e    - -----)
                  t       2                             t
                         t
                                   - t          - t     - t
                 - t       - t   %e        2  %e      %e
           + 2 %e   , t (%e    - -----) + t  (----- - -----)
                                   t            2       t
                         2   - t            - t     - t
               - t      t  %e        2    %e      %e        - t
           + %e   ], [- --------, - t  (- ----- - ----- + %e   ),
                           2                t       2
                                                   t
                  - t     - t      2   - t
             2  %e      %e        t  %e          - t
          - t  (----- - -----)], [-------- - t %e   ,
                  2       t          2
                  - t     - t                           - t
           2    %e      %e        - t           - t   %e
          t  (- ----- - ----- + %e   ) - t (2 %e    - -----),
                  t       2                             t
                         t
                - t     - t                 - t
           2  %e      %e            - t   %e
          t  (----- - -----) - t (%e    - -----)])
                2       t                   t
          (%i4) ratsimp(%);
                         [   2              - t ]
                         [ (t  + 2 t + 2) %e    ]
                         [ -------------------- ]
                         [          2           ]
                         [                      ]
                         [         2   - t      ]
          (%o4)  Col 1 = [        t  %e         ]
                         [      - --------      ]
                         [           2          ]
                         [                      ]
                         [     2          - t   ]
                         [   (t  - 2 t) %e      ]
                         [   ----------------   ]
                         [          2           ]
                   [      2        - t    ]
                   [    (t  + t) %e       ]
                   [                      ]
           Col 2 = [     2            - t ]
                   [ - (t  - t - 1) %e    ]
                   [                      ]
                   [     2          - t   ]
                   [   (t  - 3 t) %e      ]
                   [        2   - t       ]
                   [       t  %e          ]
                   [       --------       ]
                   [          2           ]
                   [                      ]
                   [      2          - t  ]
           Col 3 = [    (t  - 2 t) %e     ]
                   [  - ----------------  ]
                   [           2          ]
                   [                      ]
                   [   2              - t ]
                   [ (t  - 4 t + 2) %e    ]
                   [ -------------------- ]
                   [          2           ]

     Ejemplo 2:
          (%i5) b1:matrix([0,0,1,1,1],
                          [0,0,0,1,1],
                          [0,0,0,0,1],
                          [0,0,0,0,0],
                          [0,0,0,0,0])$

          (%i6) mat_function(exp,t*b1);
                            [              2     ]
                            [             t      ]
                            [ 1  0  t  t  -- + t ]
                            [             2      ]
                            [                    ]
          (%o6)             [ 0  1  0  t    t    ]
                            [                    ]
                            [ 0  0  1  0    t    ]
                            [                    ]
                            [ 0  0  0  1    0    ]
                            [                    ]
                            [ 0  0  0  0    1    ]
          (%i7) minimalPoly(jordan(b1));
                                       3
          (%o7)                       x
          (%i8) ident(5)+t*b1+1/2*(t^2)*b1^^2;
                            [              2     ]
                            [             t      ]
                            [ 1  0  t  t  -- + t ]
                            [             2      ]
                            [                    ]
          (%o8)             [ 0  1  0  t    t    ]
                            [                    ]
                            [ 0  0  1  0    t    ]
                            [                    ]
                            [ 0  0  0  1    0    ]
                            [                    ]
                            [ 0  0  0  0    1    ]
          (%i9) mat_function(exp,%i*t*b1);
                       [                           2 ]
                       [                          t  ]
                       [ 1  0  %i t  %i t  %i t - -- ]
                       [                          2  ]
                       [                             ]
          (%o9)        [ 0  1   0    %i t    %i t    ]
                       [                             ]
                       [ 0  0   1     0      %i t    ]
                       [                             ]
                       [ 0  0   0     1        0     ]
                       [                             ]
                       [ 0  0   0     0        1     ]
          (%i10) mat_function(cos,t*b1)+%i*mat_function(sin,t*b1);
                        [                           2 ]
                        [                          t  ]
                        [ 1  0  %i t  %i t  %i t - -- ]
                        [                          2  ]
                        [                             ]
          (%o10)        [ 0  1   0    %i t    %i t    ]
                        [                             ]
                        [ 0  0   1     0      %i t    ]
                        [                             ]
                        [ 0  0   0     1        0     ]
                        [                             ]
                        [ 0  0   0     0        1     ]

     Ejemplo 3:
          (%i11) a1:matrix([2,1,0,0,0,0],
                           [-1,4,0,0,0,0],
                           [-1,1,2,1,0,0],
                           [-1,1,-1,4,0,0],
                           [-1,1,-1,1,3,0],
                           [-1,1,-1,1,1,2])$

          (%i12) fpow(x):=block([k],declare(k,integer),x^k)$

          (%i13) mat_function(fpow,a1);
                          [  k      k - 1 ]         [      k - 1    ]
                          [ 3  - k 3      ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [  k      k - 1 ]
                          [  - k 3        ]         [ 3  + k 3      ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
          (%o13)  Col 1 = [               ] Col 2 = [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                   [       0       ]         [       0       ]
                   [               ]         [               ]
                   [       0       ]         [       0       ]
                   [               ]         [               ]
                   [  k      k - 1 ]         [      k - 1    ]
                   [ 3  - k 3      ]         [   k 3         ]
                   [               ]         [               ]
           Col 3 = [       k - 1   ] Col 4 = [  k      k - 1 ]
                   [  - k 3        ]         [ 3  + k 3      ]
                   [               ]         [               ]
                   [       k - 1   ]         [      k - 1    ]
                   [  - k 3        ]         [   k 3         ]
                   [               ]         [               ]
                   [       k - 1   ]         [      k - 1    ]
                   [  - k 3        ]         [   k 3         ]
                   [    0    ]
                   [         ]         [ 0  ]
                   [    0    ]         [    ]
                   [         ]         [ 0  ]
                   [    0    ]         [    ]
                   [         ]         [ 0  ]
           Col 5 = [    0    ] Col 6 = [    ]
                   [         ]         [ 0  ]
                   [    k    ]         [    ]
                   [   3     ]         [ 0  ]
                   [         ]         [    ]
                   [  k    k ]         [  k ]
                   [ 3  - 2  ]         [ 2  ]

     Antes de hacer uso de esta función ejecútese  `load("diag")'.


File: maxima.info,  Node: distrib,  Next: draw,  Prev: diag,  Up: Top

46 distrib
**********

* Menu:

* Introducción a distrib::
* Funciones y variables para distribuciones continuas::
* Funciones y variables para distribuciones discretas::


File: maxima.info,  Node: Introducción a distrib,  Next: Funciones y variables para distribuciones continuas,  Prev: distrib,  Up: distrib

46.1 Introducción a distrib
===========================

El paquete `distrib' contiene un conjunto de funciones para la
realización de cálculos probabilísticos con modelos univariantes, tanto
discretos como continuos.

A continuación un breve recordatorio de las deficiones básicas sobre
distribuciones de probabilidad.

Sea f(x) la <función de densidad> de una variable aleatoria X
absolutamente continua. La <función de distribución> se define como
                            x
                           /
                           [
                    F(x) = I     f(u) du
                           ]
                           /
                            minf
que es igual a la probabilidad <Pr(X <= x)>.

La <media> es un parámetro de localización y se define como
                          inf
                         /
                         [
                E[X]  =  I   x f(x) dx
                         ]
                         /
                          minf

La  <varianza> es una medida de dispersión,
                      inf
                     /
                     [                    2
              V[X] = I     f(x) (x - E[X])  dx
                     ]
                     /
                      minf
que es un número real positivo. La raíz cuadrada de la varianza es la
<desviación típica>, D[X]=sqrt(V[X]), siendo otra medida de dispersión.

El <coeficiente de asimetría> es una medida de forma,
                      inf
                     /
                 1   [                    3
       SK[X] = ----- I     f(x) (x - E[X])  dx
                   3 ]
               D[X]  /
                      minf

Y el <coeficiente de curtosis> mide el apuntamiento de la densidad,
                      inf
                     /
                 1   [                    4
       KU[X] = ----- I     f(x) (x - E[X])  dx - 3
                   4 ]
               D[X]  /
                      minf
Si X es normal, KU[X]=0. De hecho, tanto la asimetría como la curtosis
son parámetros de forma para medir la no normalidad de una distribución.

Si la variable aleatoria X es discreta, su función de densidad, o de
<probabiliad>,  f(x) toma valores positivos dentro de un conjunto
numerable de valores x_i, y cero en cualquier otro lugar. En este caso,
la función de distribución es
                            ====
                            \
                     F(x) =  >    f(x )
                            /        i
                            ====
                           x <= x
                            i

La media, varianza, desviación típica y los coeficientes de asimetría y
curtosis adquieren las formas
                            ====
                            \
                     E[X] =  >  x  f(x ) ,
                            /    i    i
                            ====
                             x
                              i

                     ====
                     \                     2
             V[X] =   >    f(x ) (x - E[X])  ,
                     /        i    i
                     ====
                      x
                       i

                    D[X] = sqrt(V[X]),

                          ====
                   1      \                     3
       SK[X] =  -------    >    f(x ) (x - E[X])
                D[X]^3    /        i    i
                          ====
                           x
                            i
y
                          ====
                   1      \                     4
       KU[X] =  -------    >    f(x ) (x - E[X])   - 3 ,
                D[X]^4    /        i    i
                          ====
                           x
                            i
respectivamente.

Por favor, consúltese cualquier manual introductorio de probabilidad y
estadística para más información sobre toda esta parafernalia
matemática.

Se sigue cierta convención a la hora de nombrar las funciones del
paquete `distrib'. Cada nombre tiene dos partes, el primero hace
referencia a la función o parámetro que se quiere calcular,
     Funciones:
        Función de densidad        (pdf_*)
        Función de distribución    (cdf_*)
        Cuantil                    (quantile_*)
        Media                      (mean_*)
        Varianza                   (var_*)
        Desviación típica          (std_*)
        Coeficiente de asimetría   (skewness_*)
        Coeficiente de curtosis    (kurtosis_*)
        Valor aleatorio            (random_*)

La segunda parte hace referencia explícita al modelo probabilístico,
     Distribuciones continuas:
        Normal              (*normal)
        Student             (*student_t)
        Chi^2               (*chi2)
        Chi^2 no central    (*noncentral_chi2)
        F                   (*f)
        Exponencial         (*exp)
        Lognormal           (*lognormal)
        Gamma               (*gamma)
        Beta                (*beta)
        Continua uniforme   (*continuous_uniform)
        Logística           (*logistic)
        Pareto              (*pareto)
        Weibull             (*weibull)
        Rayleigh            (*rayleigh)
        Laplace             (*laplace)
        Cauchy              (*cauchy)
        Gumbel              (*gumbel)

     Distribuciones discretas:
        Binomial             (*binomial)
        Poisson              (*poisson)
        Bernoulli            (*bernoulli)
        Geométrica           (*geometric)
        Uniforme discreta    (*discrete_uniform)
        Hipergeométrica      (*hypergeometric)
        Binomial negativa    (*negative_binomial)
        Finita discreta      (*general_finite_discrete)

Por ejemplo, `pdf_student_t(x,n)' es la función de densidad de la
distribución de Student con <n> grados de libertad, `std_pareto(a,b)'
es la desviación típica de la distribución de Pareto de parámetros <a>
y <b>, y `kurtosis_poisson(m)' es el coeficiente de curtosis de la
distribución de Poisson de media <m>.

Para poder hacer uso del paquete `distrib' es necesario cargarlo
primero tecleando
     (%i1) load(distrib)$

Para comentarios, errores o sugerencias, por favor contáctese conmigo
en <'mario ARROBA edu PUNTO xunta PUNTO es'>.


File: maxima.info,  Node: Funciones y variables para distribuciones continuas,  Next: Funciones y variables para distribuciones discretas,  Prev: Introducción a distrib,  Up: distrib

46.2 Funciones y variables para distribuciones continuas
========================================================

 -- Función: pdf_normal (<x>,<m>,<s>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de la variable aleatoria Normal(m,s), con s>0. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_normal (<x>,<m>,<s>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de la variable aleatoria Normal(m,s), con s>0. Esta
     función se define en términos de la función de error,  `erf', de
     Maxima.

          (%i1) load (distrib)$
          (%i2) assume(s>0)$ cdf_normal(x,m,s);
                                       x - m
                                 erf(---------)
                                     sqrt(2) s    1
          (%o3)                  -------------- + -
                                       2          2

     Véase también `erf'.

 -- Función: quantile_normal (<q>,<m>,<s>)
     Devuelve el <q>-cuantil de una variable aleatoria Normal(m,s), con
     s>0; en otras palabras, es la inversa de  `cdf_normal'. El
     argumento <q> debe ser un número de [0,1]. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

          (%i1) load (distrib)$
          (%i2) quantile_normal(95/100,0,1);
                                                9
          (%o2)             sqrt(2) inverse_erf(--)
                                                10
          (%i3) float(%);
          (%o3)               1.644853626951472


 -- Función: mean_normal (<m>,<s>)
     Devuelve la media de  una variable aleatoria Normal(m,s), con s>0,
     es decir <m>. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_normal (<m>,<s>)
     Devuelve la varianza de  una variable aleatoria Normal(m,s), con
     s>0, es decir <s^2>.

 -- Función: std_normal (<m>,<s>)
     Devuelve la desviación típica de  una variable aleatoria
     Normal(m,s), con s>0, es decir <s>. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: skewness_normal (<m>,<s>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Normal(m,s), con s>0, que es siempre igual a 0. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: kurtosis_normal (<m>,<s>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     Normal(m,s), con s>0, que es siempre igual a 0. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: random_normal (<m>,<s>)
 -- Función: random_normal (<m>,<s>,<n>)
     Devuelve un valor aleatorio  Normal(m,s), con s>0. Llamando a
     `random_normal' con un tercer argumento <n>, se simula una muestra
     aleatoria de tamaño <n>.

     El algoritmo de simulación es el de Box-Mueller, tal como está
     descrito en Knuth, D.E. (1981) <Seminumerical Algorithms. The Art
     of Computer Programming.> Addison-Wesley.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_student_t (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Student t(n), con n>0. Para hacer uso
     de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_student_t (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Student t(n), con n>0.

          (%i1) load (distrib)$
          (%i2) cdf_student_t(1/2, 7/3);
                                                   7  1  28
                       beta_incomplete_regularized(-, -, --)
                                                   6  2  31
          (%o2)    1 - -------------------------------------
                                         2
          (%i3) float(%);
          (%o3)                .6698450596140415

 -- Función: quantile_student_t (<q>,<n>)
     Devuelve el <q>-cuantil de una variable aleatoria de Student t(n),
     con n>0; en otras palabras, se trata de la inversa de
     `cdf_student_t'. El argumento <q> debe ser un número de [0,1].
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_student_t (<n>)
     Devuelve la media de una variable aleatoria de Student t(n), con
     n>0, que vale siempre 0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: var_student_t (<n>)
     Devuelve la varianza de una variable aleatoria de Student t(n),
     con n>2.

          (%i1) load (distrib)$
          (%i2) assume(n>2)$  var_student_t(n);
                                          n
          (%o3)                         -----
                                        n - 2

 -- Función: std_student_t (<n>)
     Devuelve la desviación típica de una variable aleatoria de Student
     t(n), con n>2. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: skewness_student_t (<n>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Student t(n), con n>3, que vale siempre 0. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: kurtosis_student_t (<n>)
     Devuelve el coeficiente de curtosis una variable aleatoria de
     Student t(n), con n>4. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_student_t (<n>)
 -- Función: random_student_t (<n>,<m>)
     Devuelve un valor aleatorio t(n), con n>0. Llamando a
     `random_student_t' con un segundo argumento <m>, se obtiene una
     muestra aleatoria simulada de tamaño <m>.

     El algoritmo utilizado está basado en el hecho de que si <Z> es
     una variable aleatoria normal N(0,1) y S^2 es una chi cuadrada de
     <n> grados de libertad, Chi^2(n), entonces
                                     Z
                           X = -------------
                               /   2  \ 1/2
                               |  S   |
                               | ---  |
                               \  n   /

     es una variable aleatoria de Student de <n> grados de libertad,
     t(n).

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_noncentral_student_t (<x>,<n>,<ncp>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria no central de Student nc_t(n,ncp), con
     n>0 grados de libertad y parámetro de no centralidad ncp. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

     En ocasiones es necesario hacer algún trabajo extra para obtener
     el resultado final.

          (%i1) load (distrib)$
          (%i2) expand(pdf_noncentral_student_t(3,5,0.1));
                 .01370030107589574 sqrt(5)
          (%o2)  --------------------------
                 sqrt(2) sqrt(14) sqrt(%pi)
             1.654562884111515E-4 sqrt(5)
           + ----------------------------
                      sqrt(%pi)
             .02434921505438663 sqrt(5)
           + --------------------------
                        %pi
          (%i3) float(%);
          (%o3)          .02080593159405669

 -- Función: cdf_noncentral_student_t (<x>,<n>,<ncp>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria no central de Student
     nc_t(n,ncp), con n>0 grados de libertad y parámetro de no
     centralidad ncp. Esta función no tiene expresión compacta y se
     calcula numéricamente si la variable global `numer' vale `true' o
     si alguno de sus argumentos es un número decimal, en otro caso
     devuelve una expresión nominal.  Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

          (%i1) load (distrib)$
          (%i2) cdf_noncentral_student_t(-2,5,-5);
          (%o2) cdf_noncentral_student_t(- 2, 5, - 5)
          (%i3) cdf_noncentral_student_t(-2.0,5,-5);
          (%o3)          .9952030093319743


 -- Función: quantile_noncentral_student_t (<q>,<n>,<ncp>)
     Devuelve el <q>-cuantil de una variable aleatoria no central de
     Student nc_t(n,ncp), con n>0 grados de libertad y parámetro de no
     centralidad ncp; en otras palabras, se trata de la inversa de
     `cdf_noncentral_student_t'. El argumento <q> debe ser un número de
     [0,1]. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: mean_noncentral_student_t (<n>,<ncp>)
     Devuelve la media de una variable aleatoria no central de Student
     nc_t(n,ncp), con n>1 grados de libertad y parámetro de no
     centralidad ncp. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

          (%i1) load (distrib)$
          (%i2) (assume(df>1), mean_noncentral_student_t(df,k));
                             df - 1
                       gamma(------) sqrt(df) k
                               2
          (%o2)        ------------------------
                                        df
                          sqrt(2) gamma(--)
                                        2


 -- Función: var_noncentral_student_t (<n>,<ncp>)
     Devuelve la varianza de una variable aleatoria no central de
     Student nc_t(n,ncp), con n>2 grados de libertad y parámetro de no
     centralidad ncp. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_noncentral_student_t (<n>,<ncp>)
     Devuelve la desviación típica de una variable aleatoria no central
     de Student nc_t(n,ncp), con n>2 grados de libertad y parámetro de
     no centralidad ncp. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_noncentral_student_t (<n>,<ncp>)
     Devuelve el coeficiente de asimetría de una variable aleatoria no
     central de Student nc_t(n,ncp), con n>3 grados de libertad y
     parámetro de no centralidad ncp. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: kurtosis_noncentral_student_t (<n>,<ncp>)
     Devuelve el coeficiente de curtosis de una variable aleatoria no
     central de Student nc_t(n,ncp), con n>4 grados de libertad y
     parámetro de no centralidad ncp. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: random_noncentral_student_t (<n>,<ncp>)
 -- Función: random_noncentral_student_t (<n>,<ncp>,<m>)
     Devuelve un valor aleatorio nc_t(n,ncp), con n>0. Llamando a
     `random_noncentral_student_t' con un tercer argumento <m>, se
     obtiene una muestra aleatoria simulada de tamaño <m>.

     El algoritmo utilizado está basado en el hecho de que si <X> es
     una variable aleatoria normal N(ncp,1) y S^2 es una chi cuadrada
     de <n> grados de libertad, Chi^2(n), entonces
                                     X
                           U = -------------
                               /   2  \ 1/2
                               |  S   |
                               | ---  |
                               \  n   /

     es una variable aleatoria no central de Student de <n> grados de
     libertad y parámetro de no centralidad ncp, nc_t(n,ncp).

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_chi2 (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria chi-cuadrado Chi^2(n), con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2), por lo
     que cuando Maxima no tiene suficiente información para obtener el
     resultado, devuelve una forma nominal basada en la función de
     densidad de la gamma.

          (%i1) load (distrib)$
          (%i2) pdf_chi2(x,n);
                                              n
          (%o2)                  pdf_gamma(x, -, 2)
                                              2
          (%i3) assume(x>0, n>0)$  pdf_chi2(x,n);
                                   n/2 - 1   - x/2
                                  x        %e
          (%o4)                   ----------------
                                    n/2       n
                                   2    gamma(-)
                                              2

 -- Función: cdf_chi2 (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria chi-cuadrado Chi^2(n), con
     n>0.

          (%i1) load (distrib)$
          (%i2) cdf_chi2(3,4);
                                                         3
          (%o2)      1 - gamma_incomplete_regularized(2, -)
                                                         2
          (%i3) float(%);
          (%o3)               .4421745996289256

 -- Función: quantile_chi2 (<q>,<n>)
     Devuelve el <q>-cuantil de una variable aleatoria Chi^2(n), con
     n>0; en otras palabras, se trata de la inversa de  `cdf_chi2'. El
     argumento <q> debe ser un número de [0,1].

     Esta función no tiene expresión compacta y se calcula
     numéricamente si la variable global `numer' vale `true', en otro
     caso devuelve una expresión nominal basada en la función cuantil
     de la gamma, puesto que la variable aleatoria Chi^2(n) equivale a
     una Gamma(n/2,2).

          (%i1) load (distrib)$
          (%i2) quantile_chi2(0.99,9);
          (%o2)                   21.66599433346194
          (%i3) quantile_chi2(0.99,n);
                                                  n
          (%o3)              quantile_gamma(0.99, -, 2)
                                                  2

 -- Función: mean_chi2 (<n>)
     Devuelve la media de  una variable aleatoria  Chi^2(n), con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2), por lo
     que cuando Maxima no tiene suficiente información para obtener el
     resultado, devuelve una forma nominal basada en la media de la
     gamma.

          (%i1) load (distrib)$
          (%i2) mean_chi2(n);
                                             n
          (%o2)                   mean_gamma(-, 2)
                                             2
          (%i3) assume(n>0)$ mean_chi2(n);
          (%o4)                           n

 -- Función: var_chi2 (<n>)
     Devuelve la varianza de  una variable aleatoria  Chi^2(n), con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2), por lo
     que cuando Maxima no tiene suficiente información para obtener el
     resultado, devuelve una forma nominal basada en la varianza de la
     gamma.

          (%i1) load (distrib)$
          (%i2) var_chi2(n);
                                             n
          (%o2)                    var_gamma(-, 2)
                                             2
          (%i3) assume(n>0)$ var_chi2(n);
          (%o4)                          2 n

 -- Función: std_chi2 (<n>)
     Devuelve la desviación típica de  una variable aleatoria
     Chi^2(n), con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2), por lo
     que cuando Maxima no tiene suficiente información para obtener el
     resultado, devuelve una forma nominal basada en la desviación
     típica de la gamma.

          (%i1) load (distrib)$
          (%i2) std_chi2(n);
                                             n
          (%o2)                    std_gamma(-, 2)
                                             2
          (%i3) assume(n>0)$ std_chi2(n);
          (%o4)                    sqrt(2) sqrt(n)

 -- Función: skewness_chi2 (<n>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Chi^2(n), con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2), por lo
     que cuando Maxima no tiene suficiente información para obtener el
     resultado, devuelve una forma nominal basada en el coeficiente de
     asimetría de la gamma.

          (%i1) load (distrib)$
          (%i2) skewness_chi2(n);
                                               n
          (%o2)                 skewness_gamma(-, 2)
                                               2
          (%i3) assume(n>0)$ skewness_chi2(n);
                                      2 sqrt(2)
          (%o4)                       ---------
                                       sqrt(n)

 -- Función: kurtosis_chi2 (<n>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Chi^2(n), con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2), por lo
     que cuando Maxima no tiene suficiente información para obtener el
     resultado, devuelve una forma nominal basada en el coeficiente de
     curtosis de la gamma.

          (%i1) load (distrib)$
          (%i2) kurtosis_chi2(n);
                                               n
          (%o2)                 kurtosis_gamma(-, 2)
                                               2
          (%i3) assume(n>0)$ kurtosis_chi2(n);
                                         12
          (%o4)                          --
                                         n

 -- Función: random_chi2 (<n>)
 -- Función: random_chi2 (<n>,<m>)
     Devuelve un valor aleatorio  Chi^2(n), con n>0. Llamando a
     `random_chi2' con un segundo argumento <m>, se simulará una
     muestra aleatoria de tamaño <m>.

     La simulación está basada en el algoritmo de Ahrens-Cheng. Véase
     `random_gamma' para más detalles.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_noncentral_chi2 (<x>,<n>,<ncp>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria chi-cuadrado no centrada
     nc_Chi^2(n,ncp), con n>0 y parámetro de no centralidad ncp>=0.
     Para hacer uso de esta función ejecútese primero `load(distrib)'.


 -- Función: cdf_noncentral_chi2 (<x>,<n>,<ncp>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria chi-cuadrado no centrada
     nc_Chi^2(n,ncp), con n>0 y parámetro de no centralidad ncp>=0.


 -- Función: quantile_noncentral_chi2 (<q>,<n>,<ncp>)
     Devuelve el <q>-cuantil de una variable aleatoria chi-cuadrado no
     centrada nc_Chi^2(n,ncp), con n>0 y parámetro de no centralidad
     ncp>=0; en otras palabras, se trata de la inversa de
     `cdf_noncentral_chi2'. El argumento <q> debe ser un número de
     [0,1].

     Esta función no tiene expresión compacta y se calcula
     numéricamente si la variable global `numer' vale `true', en otro
     caso devuelve una expresión nominal.


 -- Función: mean_noncentral_chi2 (<n>,<ncp>)
     Devuelve la media de  una variable aleatoria chi-cuadrado no
     centrada nc_Chi^2(n,ncp), con n>0 y parámetro de no centralidad
     ncp>=0.


 -- Función: var_noncentral_chi2 (<n>,<ncp>)
     Devuelve la varianza de  una variable aleatoria chi-cuadrado no
     centrada  nc_Chi^2(n,ncp), con n>0 y parámetro de no centralidad
     ncp>=0.


 -- Función: std_noncentral_chi2 (<n>,<ncp>)
     Devuelve la desviación típica de  una variable aleatoria
     chi-cuadrado no centrada  nc_Chi^2(n,ncp), con n>0 y parámetro de
     no centralidad ncp>=0.


 -- Función: skewness_noncentral_chi2 (<n>,<ncp>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     chi-cuadrado no centrada  nc_Chi^2(n,ncp), con n>0 y parámetro de
     no centralidad ncp>=0.


 -- Función: kurtosis_noncentral_chi2 (<n>,<ncp>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     chi-cuadrado no centrada nc_Chi^2(n,ncp), con n>0 y parámetro de
     no centralidad ncp>=0.


 -- Función: random_noncentral_chi2 (<n>,<ncp>)
 -- Función: random_noncentral_chi2 (<n>,<ncp>,<m>)
     Devuelve un valor aleatorio  nc_Chi^2(n,ncp), con n>0 y parámetro
     de no centralidad ncp>=0. Llamando a `random_noncentral_chi2' con
     un tercer argumento <m>, se simulará una muestra aleatoria de
     tamaño <m>.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.


 -- Función: pdf_f (<x>,<m>,<n>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria  F(m,n), con m,n>0. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_f (<x>,<m>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria  F(m,n), con m,n>0.

          (%i1) load (distrib)$
          (%i2) cdf_f(2,3,9/4);
                                                   9  3  3
          (%o2)    1 - beta_incomplete_regularized(-, -, --)
                                                   8  2  11
          (%i3) float(%);
          (%o3)                 0.66756728179008

 -- Función: quantile_f (<q>,<m>,<n>)
     Devuelve el <q>-cuantil de una variable aleatoria  F(m,n), con
     m,n>0; en otras palabras, se trata de la inversa de  `cdf_f'. El
     argumento <q> debe ser un número de [0,1].

     Esta función no tiene expresión compacta, por lo que es evaluada
     numéricamente si la variable global `numer' vale `true', en caso
     contrario devuelve una forma nominal.

          (%i1) load (distrib)$
          (%i2) quantile_f(2/5,sqrt(3),5);
                                         2
          (%o2)               quantile_f(-, sqrt(3), 5)
                                         5
          (%i3) %,numer;
          (%o3)                   0.518947838573693

 -- Función: mean_f (<m>,<n>)
     Devuelve la media de  una variable aleatoria  F(m,n), con m>0,
     n>2. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_f (<m>,<n>)
     Devuelve la varianza de  una variable aleatoria  F(m,n), con m>0,
     n>4. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_f (<m>,<n>)
     Devuelve la desviación típica de  una variable aleatoria  F(m,n),
     con m>0, n>4. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: skewness_f (<m>,<n>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     F(m,n), con m>0, n>6. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: kurtosis_f (<m>,<n>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     F(m,n), con m>0, n>8. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_f (<m>,<n>)
 -- Función: random_f (<m>,<n>,<k>)
     Devuelve un valor aleatorio  F(m,n), con m,n>0. Llamando a
     `random_f' con un tercer argumento <k>, se simulará una muestra
     aleatoria de tamaño <k>.

     El algoritmo de simulación está basado en el hecho de que si <X>
     es una variable aleatoria Chi^2(m) y Y es una Chi^2(n), entonces
                                  n X
                              F = ---
                                  m Y

     es una variable aleatoria F con <m> y <n> grados de libertad,
     F(m,n).

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_exp (<x>,<m>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria Exponencial(m), con m>0.

     La variable aleatoria Exponencial(m) equivale a una
     Weibull(1,1/m), por lo que si Maxima no tiene suficiente
     información para calcular el resultado, devolverá una forma
     nominal basada en la densidad de Weibull.

          (%i1) load (distrib)$
          (%i2) pdf_exp(x,m);
                                                  1
          (%o2)                 pdf_weibull(x, 1, -)
                                                  m
          (%i3) assume(x>0,m>0)$  pdf_exp(x,m);
                                          - m x
          (%o4)                       m %e

 -- Función: cdf_exp (<x>,<m>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Exponencial(m), con m>0.

     La variable aleatoria Exponencial(m) equivale a una
     Weibull(1,1/m), por lo que si Maxima no tiene suficiente
     información para calcular el resultado, devolverá una forma
     nominal basada en la distribución de Weibull.

          (%i1) load (distrib)$
          (%i2) cdf_exp(x,m);
                                                  1
          (%o2)                 cdf_weibull(x, 1, -)
                                                  m
          (%i3) assume(x>0,m>0)$  cdf_exp(x,m);
                                           - m x
          (%o4)                      1 - %e

 -- Función: quantile_exp (<q>,<m>)
     Devuelve el <q>-cuantil de una variable aleatoria Exponencial(m),
     con m>0; en otras palabras, se trata de la inversa de  `cdf_exp'.
     El argumento <q> debe ser un número de [0,1].

     La variable aleatoria Exponencial(m) equivale a una
     Weibull(1,1/m), por lo que si Maxima no tiene suficiente
     información para calcular el resultado, devolverá una forma
     nominal basada en el cuantil de la Weibull.

          (%i1) load (distrib)$
          (%i2) quantile_exp(0.56,5);
          (%o2)                   .1641961104139661
          (%i3) quantile_exp(0.56,m);
                                                      1
          (%o3)             quantile_weibull(0.56, 1, -)
                                                      m

 -- Función: mean_exp (<m>)
     Devuelve la media de  una variable aleatoria Exponencial(m), con
     m>0.

     La variable aleatoria Exponencial(m) equivale a una
     Weibull(1,1/m), por lo que si Maxima no tiene suficiente
     información para calcular el resultado, devolverá una forma
     nominal basada en la media de la Weibull.

          (%i1) load (distrib)$
          (%i2) mean_exp(m);
                                                 1
          (%o2)                  mean_weibull(1, -)
                                                 m
          (%i3) assume(m>0)$  mean_exp(m);
                                          1
          (%o4)                           -
                                          m

 -- Función: var_exp (<m>)
     Devuelve la varianza de  una variable aleatoria Exponencial(m),
     con m>0.

     La variable aleatoria Exponencial(m) equivale a una
     Weibull(1,1/m), por lo que si Maxima no tiene suficiente
     información para calcular el resultado, devolverá una forma
     nominal basada en la varianza de la Weibull.

          (%i1) load (distrib)$
          (%i2) var_exp(m);
                                                 1
          (%o2)                   var_weibull(1, -)
                                                 m
          (%i3) assume(m>0)$  var_exp(m);
                                         1
          (%o4)                          --
                                          2
                                         m

 -- Función: std_exp (<m>)
     Devuelve la desviación típica de  una variable aleatoria
     Exponencial(m), con m>0.

     La variable aleatoria Exponencial(m) equivale a una
     Weibull(1,1/m), por lo que si Maxima no tiene suficiente
     información para calcular el resultado, devolverá una forma
     nominal basada en la desviación típica de la Weibull.

          (%i1) load (distrib)$
          (%i2) std_exp(m);
                                                 1
          (%o2)                   std_weibull(1, -)
                                                 m
          (%i3) assume(m>0)$  std_exp(m);
                                          1
          (%o4)                           -
                                          m

 -- Función: skewness_exp (<m>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Exponencial(m), con m>0.

     La variable aleatoria Exponencial(m) equivale a una
     Weibull(1,1/m), por lo que si Maxima no tiene suficiente
     información para calcular el resultado, devolverá una forma
     nominal basada en el coeficiente de asimetría de la Weibull.

          (%i1) load (distrib)$
          (%i2) skewness_exp(m);
                                                   1
          (%o2)                skewness_weibull(1, -)
                                                   m
          (%i3) assume(m>0)$  skewness_exp(m);
          (%o4)                           2

 -- Función: kurtosis_exp (<m>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Exponencial(m), con m>0.

     La variable aleatoria Exponencial(m) equivale a una
     Weibull(1,1/m), por lo que si Maxima no tiene suficiente
     información para calcular el resultado, devolverá una forma
     nominal basada en el coeficiente de curtosis de la Weibull.

          (%i1) load (distrib)$
          (%i2) kurtosis_exp(m);
                                                   1
          (%o2)                kurtosis_weibull(1, -)
                                                   m
          (%i3) assume(m>0)$  kurtosis_exp(m);
          (%o4)                           6

 -- Función: random_exp (<m>)
 -- Función: random_exp (<m>,<k>)
     Devuelve un valor aleatorio  Exponencial(m), con m>0. Llamando a
     `random_exp2' con un segundo argumento <k>, se simulará una
     muestra aleatoria de tamaño <k>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_lognormal (<x>,<m>,<s>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria Lognormal(m,s), con s>0. Para hacer uso
     de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_lognormal (<x>,<m>,<s>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Lognormal(m,s), con s>0.
     Esta función se define en términos de la función de error, `erf',
     de Maxima.

          (%i1) load (distrib)$
          (%i2) assume(x>0, s>0)$  cdf_lognormal(x,m,s);
                                     log(x) - m
                                 erf(----------)
                                     sqrt(2) s     1
          (%o3)                  --------------- + -
                                        2          2

     Véase también `erf'.

 -- Función: quantile_lognormal (<q>,<m>,<s>)
     Devuelve el <q>-cuantil de una variable aleatoria Lognormal(m,s),
     con s>0; en otras palabras, se trata de la inversa de
     `cdf_lognormal'. El argumento <q> debe ser un número de [0,1].
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_lognormal (<m>,<s>)
     Devuelve la media de  una variable aleatoria Lognormal(m,s), con
     s>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_lognormal (<m>,<s>)
     Devuelve la varianza de  una variable aleatoria Lognormal(m,s),
     con s>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_lognormal (<m>,<s>)
     Devuelve la desviación típica de  una variable aleatoria
     Lognormal(m,s), con s>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_lognormal (<m>,<s>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Lognormal(m,s), con s>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: kurtosis_lognormal (<m>,<s>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Lognormal(m,s), con s>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_lognormal (<m>,<s>)
 -- Función: random_lognormal (<m>,<s>,<n>)
     Devuelve un valor aleatorio  Lognormal(m,s), con s>0. Llamando a
     `random_lognormal' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño <n>.

     Las variables lognormales se simulan mediante variables normales.
     Véase `random_normal' para más detalles.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_gamma (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria Gamma(a,b), con a,b>0. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_gamma (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Gamma(a,b), con a,b>0.

          (%i1) load (distrib)$
          (%i2) cdf_gamma(3,5,21);
                                                        1
          (%o2)     1 - gamma_incomplete_regularized(5, -)
                                                        7
          (%i3) float(%);
          (%o3)              4.402663157376807E-7

 -- Función: quantile_gamma (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria Gamma(a,b), con
     a,b>0; en otras palabras, se trata de la inversa de  `cdf_gamma'.
     El argumento <q> debe ser un número de [0,1]. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_gamma (<a>,<b>)
     Devuelve la media de  una variable aleatoria Gamma(a,b), con
     a,b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_gamma (<a>,<b>)
     Devuelve la varianza de  una variable aleatoria Gamma(a,b), con
     a,b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_gamma (<a>,<b>)
     Devuelve la desviación típica de  una variable aleatoria
     Gamma(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_gamma (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Gamma(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: kurtosis_gamma (<a>,<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Gamma(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_gamma (<a>,<b>)
 -- Función: random_gamma (<a>,<b>,<n>)
     Devuelve un valor aleatorio  Gamma(a,b), con a,b>0. Llamando a
     `random_gamma' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño <n>.

     El algoritmo de simulación es una combinación de dos
     procedimientos, según sea el valor del parámetro <a>:

     Para a>=1, Cheng, R.C.H. y Feast, G.M. (1979). <Some simple gamma
     variate generators>. Appl. Stat., 28, 3, 290-295.

     Para 0<a<1, Ahrens, J.H. y Dieter, U. (1974). <Computer methods
     for sampling from gamma, beta, poisson and binomial
     distributions>. Computing, 12, 223-246.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_beta (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria Beta(a,b), con a,b>0. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_beta (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Beta(a,b), con a,b>0.

          (%i1) load (distrib)$
          (%i2) cdf_beta(1/3,15,2);
                                       11
          (%o2)                     --------
                                    14348907
          (%i3) float(%);
          (%o3)              7.666089131388195E-7

 -- Función: quantile_beta (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria Beta(a,b), con
     a,b>0; en otras palabras, se trata de la inversa de  `cdf_beta'.
     El argumento <q> debe ser un número de [0,1]. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_beta (<a>,<b>)
     Devuelve la media de  una variable aleatoria Beta(a,b), con a,b>0.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: var_beta (<a>,<b>)
     Devuelve la varianza de  una variable aleatoria Beta(a,b), con
     a,b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_beta (<a>,<b>)
     Devuelve la desviación típica de  una variable aleatoria
     Beta(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_beta (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Beta(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: kurtosis_beta (<a>,<b>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     Beta(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_beta (<a>,<b>)
 -- Función: random_beta (<a>,<b>,<n>)
     Devuelve un valor aleatorio Beta(a,b), con a,b>0. Llamando a
     `random_beta' con un tercer argumento <n>, se simulará una muestra
     aleatoria de tamaño  <n>.

     El algoritmo de simulación es el decrito en Cheng, R.C.H. (1978).
     <Generating Beta Variates with Nonintegral Shape Parameters>.
     Communications of the ACM, 21:317-322.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_continuous_uniform (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria  Uniforme Continua(a,b), con a<b. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_continuous_uniform (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria  Uniforme Continua(a,b),
     con a<b. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: quantile_continuous_uniform (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria  Uniforme
     Continua(a,b), con a<b; en otras palabras, se trata de la inversa
     de  `cdf_continuous_uniform'. El argumento <q> debe ser un número
     de [0,1]. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: mean_continuous_uniform (<a>,<b>)
     Devuelve la media de  una variable aleatoria  Uniforme
     Continua(a,b), con a<b. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: var_continuous_uniform (<a>,<b>)
     Devuelve la varianza de  una variable aleatoria  Uniforme
     Continua(a,b), con a<b. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: std_continuous_uniform (<a>,<b>)
     Devuelve la desviación típica de  una variable aleatoria  Uniforme
     Continua(a,b), con a<b. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_continuous_uniform (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Uniforme Continua(a,b), con a<b. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: kurtosis_continuous_uniform (<a>,<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Uniforme Continua(a,b), con a<b. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: random_continuous_uniform (<a>,<b>)
 -- Función: random_continuous_uniform (<a>,<b>,<n>)
     Devuelve un valor aleatorio  Uniforme Continuo(a,b), con a<b.
     Llamando a `random_continuous_uniform' con un tercer argumento
     <n>, se simulará una muestra aleatoria de tamaño  <n>.

     Esta función es una aplicación directa de la función  `random' de
     Maxima.

     Véase también `random'. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: pdf_logistic (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria Logística(a,b), con b>0. Para hacer uso
     de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_logistic (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Logística(a,b), con b>0.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_logistic (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria Logística(a,b),
     con b>0; en otras palabras, se trata de la inversa de
     `cdf_logistic'. El argumento <q> debe ser un número de [0,1]. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_logistic (<a>,<b>)
     Devuelve la media de  una variable aleatoria Logística(a,b), con
     b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_logistic (<a>,<b>)
     Devuelve la varianza de  una variable aleatoria Logística(a,b),
     con b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_logistic (<a>,<b>)
     Devuelve la desviación típica de  una variable aleatoria
     Logística(a,b), con b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_logistic (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Logística(a,b), con b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: kurtosis_logistic (<a>,<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Logística(a,b), con b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_logistic (<a>,<b>)
 -- Función: random_logistic (<a>,<b>,<n>)
     Devuelve un valor aleatorio  Logístico(a,b), con b>0. Llamando a
     `random_logistic' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_pareto (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Pareto(a,b), con a,b>0. Para hacer
     uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_pareto (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Pareto(a,b), con a,b>0.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_pareto (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Pareto(a,b),
     con a,b>0; en otras palabras, se trata de la inversa de
     `cdf_pareto'. El argumento <q> debe ser un número de [0,1]. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_pareto (<a>,<b>)
     Devuelve la media de  una variable aleatoria de Pareto(a,b), con
     a>1,b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_pareto (<a>,<b>)
     Devuelve la varianza de  una variable aleatoria de Pareto(a,b),
     con a>2,b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_pareto (<a>,<b>)
     Devuelve la desviación típica de  una variable aleatoria de
     Pareto(a,b), con a>2,b>0. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: skewness_pareto (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Pareto(a,b), con a>3,b>0. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: kurtosis_pareto (<a>,<b>)
     Devuelve el coeficiente de curtosis de una variable aleatoria de
     Pareto(a,b), con a>4,b>0. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: random_pareto (<a>,<b>)
 -- Función: random_pareto (<a>,<b>,<n>)
     Devuelve un valor aleatorio  Pareto(a,b), con a>0,b>0. Llamando a
     `random_pareto' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_weibull (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Weibull(a,b), con a,b>0. Para hacer
     uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_weibull (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Weibull(a,b), con a,b>0.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_weibull (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Weibull(a,b),
     con a,b>0; en otras palabras, se trata de la inversa de
     `cdf_weibull'. El argumento <q> debe ser un número de [0,1]. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_weibull (<a>,<b>)
     Devuelve la media de  una variable aleatoria de Weibull(a,b), con
     a,b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_weibull (<a>,<b>)
     Devuelve la varianza de  una variable aleatoria de Weibull(a,b),
     con a,b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_weibull (<a>,<b>)
     Devuelve la desviación típica de  una variable aleatoria de
     Weibull(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_weibull (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Weibull(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: kurtosis_weibull (<a>,<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria de
     Weibull(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_weibull (<a>,<b>)
 -- Función: random_weibull (<a>,<b>,<n>)
     Devuelve un valor aleatorio  Weibull(a,b), con a,b>0. Llamando a
     `random_weibull' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_rayleigh (<x>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Rayleigh(b), con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la densidad de
     la Weibull.

          (%i1) load (distrib)$
          (%i2) pdf_rayleigh(x,b);
                                                  1
          (%o2)                 pdf_weibull(x, 2, -)
                                                  b
          (%i3) assume(x>0,b>0)$ pdf_rayleigh(x,b);
                                              2  2
                                     2     - b  x
          (%o4)                   2 b  x %e

 -- Función: cdf_rayleigh (<x>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Rayleigh(b), con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la
     distribución de la Weibull.

          (%i1) load (distrib)$
          (%i2) cdf_rayleigh(x,b);
                                                  1
          (%o2)                 cdf_weibull(x, 2, -)
                                                  b
          (%i3) assume(x>0,b>0)$ cdf_rayleigh(x,b);
                                             2  2
                                          - b  x
          (%o4)                     1 - %e

 -- Función: quantile_rayleigh (<q>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Rayleigh(b),
     con b>0; en otras palabras, se trata de la inversa de
     `cdf_rayleigh'. El argumento <q> debe ser un número de [0,1].

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en los cuantiles
     de la Weibull.

          (%i1) load (distrib)$
          (%i2) quantile_rayleigh(0.99,b);
                                                      1
          (%o2)             quantile_weibull(0.99, 2, -)
                                                      b
          (%i3) assume(x>0,b>0)$ quantile_rayleigh(0.99,b);
                                  2.145966026289347
          (%o4)                   -----------------
                                          b

 -- Función: mean_rayleigh (<b>)
     Devuelve la media de  una variable aleatoria de Rayleigh(b), con
     b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la media de la
     Weibull.

          (%i1) load (distrib)$
          (%i2) mean_rayleigh(b);
                                                 1
          (%o2)                  mean_weibull(2, -)
                                                 b
          (%i3) assume(b>0)$ mean_rayleigh(b);
                                      sqrt(%pi)
          (%o4)                       ---------
                                         2 b

 -- Función: var_rayleigh (<b>)
     Devuelve la varianza de  una variable aleatoria de Rayleigh(b),
     con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la varianza de
     la Weibull.

          (%i1) load (distrib)$
          (%i2) var_rayleigh(b);
                                                 1
          (%o2)                   var_weibull(2, -)
                                                 b
          (%i3) assume(b>0)$ var_rayleigh(b);
                                           %pi
                                       1 - ---
                                            4
          (%o4)                        -------
                                          2
                                         b

 -- Función: std_rayleigh (<b>)
     Devuelve la desviación típica de  una variable aleatoria de
     Rayleigh(b), con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la desviación
     típica de la Weibull.

          (%i1) load (distrib)$
          (%i2) std_rayleigh(b);
                                                 1
          (%o2)                   std_weibull(2, -)
                                                 b
          (%i3) assume(b>0)$ std_rayleigh(b);
                                             %pi
                                    sqrt(1 - ---)
                                              4
          (%o4)                     -------------
                                          b

 -- Función: skewness_rayleigh (<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Rayleigh(b), con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en el coeficiente
     de asimetría de la Weibull.

          (%i1) load (distrib)$
          (%i2) skewness_rayleigh(b);
                                                   1
          (%o2)                skewness_weibull(2, -)
                                                   b
          (%i3) assume(b>0)$ skewness_rayleigh(b);
                                   3/2
                                %pi      3 sqrt(%pi)
                                ------ - -----------
                                  4           4
          (%o4)                 --------------------
                                         %pi 3/2
                                    (1 - ---)
                                          4

 -- Función: kurtosis_rayleigh (<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria de
     Rayleigh(b), con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en el coeficiente
     de curtosis de la Weibull.

          (%i1) load (distrib)$
          (%i2) kurtosis_rayleigh(b);
                                                   1
          (%o2)                kurtosis_weibull(2, -)
                                                   b
          (%i3) assume(b>0)$ kurtosis_rayleigh(b);
                                            2
                                       3 %pi
                                   2 - ------
                                         16
          (%o4)                    ---------- - 3
                                        %pi 2
                                   (1 - ---)
                                         4

 -- Función: random_rayleigh (<b>)
 -- Función: random_rayleigh (<b>,<n>)
     Devuelve un valor aleatorio  Rayleigh(b), con b>0. Llamando a
     `random_rayleigh' con un segundo argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_laplace (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Laplace(a,b), con b>0. Para hacer uso
     de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_laplace (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Laplace(a,b), con b>0.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_laplace (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Laplace(a,b),
     con b>0; en otras palabras, se trata de la inversa de
     `cdf_laplace'. El argumento <q> debe ser un número de [0,1]. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_laplace (<a>,<b>)
     Devuelve la media de  una variable aleatoria de Laplace(a,b), con
     b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_laplace (<a>,<b>)
     Devuelve la varianza de  una variable aleatoria de Laplace(a,b),
     con b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_laplace (<a>,<b>)
     Devuelve la desviación típica de  una variable aleatoria de
     Laplace(a,b), con b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_laplace (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Laplace(a,b), con b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: kurtosis_laplace (<a>,<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria de
     Laplace(a,b), con b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_laplace (<a>,<b>)
 -- Función: random_laplace (<a>,<b>,<n>)
     Devuelve un valor aleatorio  Laplace(a,b), con b>0. Llamando a
     `random_laplace' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_cauchy (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Cauchy(a,b), con b>0. Para hacer uso
     de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_cauchy (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Cauchy(a,b), con b>0.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_cauchy (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Cauchy(a,b),
     con b>0; en otras palabras, se trata de la inversa de
     `cdf_cauchy'. El argumento <q> debe ser un número de [0,1]. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: random_cauchy (<a>,<b>)
 -- Función: random_cauchy (<a>,<b>,<n>)
     Devuelve un valor aleatorio  Cauchy(a,b), con b>0. Llamando a
     `random_cauchy' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_gumbel (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Gumbel(a,b), con b>0. Para hacer uso
     de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_gumbel (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Gumbel(a,b), con b>0.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_gumbel (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Gumbel(a,b),
     con b>0; en otras palabras, se trata de la inversa de
     `cdf_gumbel'. El argumento <q> debe ser un número de [0,1]. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_gumbel (<a>,<b>)
     Devuelve la media de  una variable aleatoria de Gumbel(a,b), con
     b>0.

          (%i1) load (distrib)$
          (%i2) assume(b>0)$  mean_gumbel(a,b);
          (%o3)                     %gamma b + a
     donde el símbolo `%gamma' representa la constante de
     Euler-Mascheroni. Véase también `%gamma'.

 -- Función: var_gumbel (<a>,<b>)
     Devuelve la varianza de  una variable aleatoria de Gumbel(a,b),
     con b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_gumbel (<a>,<b>)
     Devuelve la desviación típica de  una variable aleatoria de
     Gumbel(a,b), con b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_gumbel (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Gumbel(a,b), con b>0.

          (%i1) load (distrib)$
          (%i2) assume(b>0)$ skewness_gumbel(a,b);
                                 12 sqrt(6) zeta(3)
          (%o3)                  ------------------
                                           3
                                        %pi
          (%i4) numer:true$ skewness_gumbel(a,b);
          (%o5)                   1.139547099404649
     donde `zeta' representa la función zeta de Riemann.

 -- Función: kurtosis_gumbel (<a>,<b>)
     Devuelve el coeficiente de curtosis de una variable aleatoria de
     Gumbel(a,b), con b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_gumbel (<a>,<b>)
 -- Función: random_gumbel (<a>,<b>,<n>)
     Devuelve un valor aleatorio  Gumbel(a,b), con b>0. Llamando a
     `random_gumbel' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.


File: maxima.info,  Node: Funciones y variables para distribuciones discretas,  Prev: Funciones y variables para distribuciones continuas,  Up: distrib

46.3 Funciones y variables para distribuciones discretas
========================================================

 -- Función: pdf_general_finite_discrete (<x>,<v>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria general discreta finita, con vector de
     probabilidades v, tal que `Pr(X=i) = v_i'. El vector v puede ser
     una lista de expresiones no negativas, cuyas componentes se
     normalizarán para obtener un vector de probabilidades. Para hacer
     uso de esta función, ejecútese primero `load(distrib)'.

          (%i1) load (distrib)$
          (%i2) pdf_general_finite_discrete(2, [1/7, 4/7, 2/7]);
                                          4
          (%o2)                           -
                                          7
          (%i3) pdf_general_finite_discrete(2, [1, 4, 2]);
                                          4
          (%o3)                           -
                                          7

 -- Función: cdf_general_finite_discrete (<x>,<v>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria general discreta finita,
     con vector de probabilidades v.

     Véase `pdf_general_finite_discrete' para más detalles.

          (%i1) load (distrib)$
          (%i2) cdf_general_finite_discrete(2, [1/7, 4/7, 2/7]);
                                          5
          (%o2)                           -
                                          7
          (%i3) cdf_general_finite_discrete(2, [1, 4, 2]);
                                          5
          (%o3)                           -
                                          7
          (%i4) cdf_general_finite_discrete(2+1/2, [1, 4, 2]);
                                          5
          (%o4)                           -
                                          7

 -- Función: quantile_general_finite_discrete (<q>,<v>)
     Devuelve el <q>-cuantil de una variable aleatoria general discreta
     finita, con vector de probabilidades v.

     Véase `pdf_general_finite_discrete' para más detalles.

 -- Función: mean_general_finite_discrete (<v>)
     Devuelve la media de una variable aleatoria general discreta
     finita, con vector de probabilidades v.

     Véase `pdf_general_finite_discrete' para más detalles.

 -- Función: var_general_finite_discrete (<v>)
     Devuelve la varianza de una variable aleatoria general discreta
     finita, con vector de probabilidades v.

     Véase `pdf_general_finite_discrete' para más detalles.

 -- Función: std_general_finite_discrete (<v>)
     Devuelve la desviación típica de una variable aleatoria general
     discreta finita, con vector de probabilidades v.

     Véase `pdf_general_finite_discrete' para más detalles.

 -- Función: skewness_general_finite_discrete (<v>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     general discreta finita, con vector de probabilidades v.

     Véase `pdf_general_finite_discrete' para más detalles.

 -- Función: kurtosis_general_finite_discrete (<v>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     general discreta finita, con vector de probabilidades v.

     Véase `pdf_general_finite_discrete' para más detalles.

 -- Función: random_general_finite_discrete (<v>)
 -- Función: random_general_finite_discrete (<v>,<m>)
     Devuelve un valor aleatorio de una variable aleatoria general
     discreta finita, con vector de probabilidades v. Llamando a
     `random_general_finite_discrete' con un segundo argumento <n>, se
     simulará una muestra aleatoria de tamaño <n>.

     Véase `pdf_general_finite_discrete' para más detalles.

          (%i1) load (distrib)$
          (%i2) random_general_finite_discrete([1,3,1,5]);
          (%o2)                          4
          (%i3) random_general_finite_discrete([1,3,1,5], 10);
          (%o3)           [4, 2, 2, 3, 2, 4, 4, 1, 2, 2]

 -- Función: pdf_binomial (<x>,<n>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria Binomial(n,p), con 0<p<1 y
     n entero positivo. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: cdf_binomial (<x>,<n>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Binomial(n,p), con 0<p<1 y
     n entero positivo.

          (%i1) load (distrib)$
          (%i2) cdf_binomial(5,7,1/6);
                                      7775
          (%o2)                       ----
                                      7776
          (%i3) float(%);
          (%o3)               .9998713991769548

 -- Función: quantile_binomial (<q>,<n>,<p>)
     Devuelve el <q>-cuantil de una variable aleatoria Binomial(n,p),
     con 0<p<1 y n entero positivo; en otras palabras, se trata de la
     inversa de  `cdf_binomial'. El argumento <q> debe ser un número de
     [0,1]. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: mean_binomial (<n>,<p>)
     Devuelve la media de  una variable aleatoria Binomial(n,p), con
     0<p<1 y n entero positivo. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: var_binomial (<n>,<p>)
     Devuelve la varianza de  una variable aleatoria Binomial(n,p), con
     0<p<1 y n entero positivo. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: std_binomial (<n>,<p>)
     Devuelve la desviación típica de  una variable aleatoria
     Binomial(n,p), con 0<p<1 y n entero positivo. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: skewness_binomial (<n>,<p>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Binomial(n,p), con 0<p<1 y n entero positivo. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: kurtosis_binomial (<n>,<p>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     binomial  Binomial(n,p), con 0<p<1 y n entero positivo. Para hacer
     uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: random_binomial (<n>,<p>)
 -- Función: random_binomial (<n>,<p>,<m>)
     Devuelve un valor aleatorio  Binomial(n,p), con 0<p<1 y n entero
     positivo. Llamando a  `random_binomial' con un tercer argumento
     <m>, se simulará una muestra aleatoria de tamaño  <m>.

     El algoritmo de simulación es el descrito en Kachitvichyanukul, V.
     y Schmeiser, B.W. (1988) <Binomial Random Variate Generation>.
     Communications of the ACM, 31, Feb., 216.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_poisson (<x>,<m>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria de Poisson(m), con m>0.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_poisson (<x>,<m>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Poisson(m), con m>0.

          (%i1) load (distrib)$
          (%i2) cdf_poisson(3,5);
          (%o2)       gamma_incomplete_regularized(4, 5)
          (%i3) float(%);
          (%o3)               .2650259152973623

 -- Función: quantile_poisson (<q>,<m>)
     Devuelve el <q>-cuantil de una variable aleatoria de Poisson(m),
     con m>0; en otras palabras, se trata de la inversa de
     `cdf_poisson'. El argumento <q> debe ser un número de [0,1]. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_poisson (<m>)
     Devuelve la media de una variable aleatoria de Poisson(m), con
     m>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_poisson (<m>)
     Devuelve la varianza de  una variable aleatoria de Poisson(m), con
     m>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_poisson (<m>)
     Devuelve la desviación típica de  una variable aleatoria de
     Poisson(m), con m>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_poisson (<m>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Poisson(m), con m>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: kurtosis_poisson (<m>)
     Devuelve el coeficiente de curtosis de una variable aleatoria de
     Poisson(m), con m>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_poisson (<m>)
 -- Función: random_poisson (<m>,<n>)
     Devuelve un valor aleatorio  Poisson(m), con m>0. Llamando a
     `random_poisson' con un segundo argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     El algoritmo de simulación es el descrito en Ahrens, J.H. and
     Dieter, U. (1982) <Computer Generation of Poisson Deviates From
     Modified Normal Distributions>. ACM Trans. Math. Software, 8, 2,
     June,163-179.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_bernoulli (<x>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria de Bernoulli(p), con 0<p<1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la función de
     probabilidad de la binomial.

          (%i1) load (distrib)$
          (%i2) pdf_bernoulli(1,p);
          (%o2)                 pdf_binomial(1, 1, p)
          (%i3) assume(0<p,p<1)$ pdf_bernoulli(1,p);
          (%o4)                           p

 -- Función: cdf_bernoulli (<x>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Bernoulli(p), con 0<p<1.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_bernoulli (<q>,<p>)
     Devuelve el <q>-cuantil de una variable aleatoria de Bernoulli(p),
     con 0<p<1; en otras palabras, se trata de la inversa de
     `cdf_bernoulli'. El argumento <q> debe ser un número de [0,1].
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_bernoulli (<p>)
     Devuelve la media de  una variable aleatoria de Bernoulli(p), con
     0<p<1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la media de la
     binomial.

          (%i1) load (distrib)$
          (%i2) mean_bernoulli(p);
          (%o2)                  mean_binomial(1, p)
          (%i3) assume(0<p,p<1)$ mean_bernoulli(p);
          (%o4)                           p

 -- Función: var_bernoulli (<p>)
     Devuelve la varianza de  una variable aleatoria de Bernoulli(p),
     con 0<p<1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la varianza de
     la binomial.

          (%i1) load (distrib)$
          (%i2) var_bernoulli(p);
          (%o2)                  var_binomial(1, p)
          (%i3) assume(0<p,p<1)$ var_bernoulli(p);
          (%o4)                       (1 - p) p

 -- Función: std_bernoulli (<p>)
     Devuelve la desviación típica de  una variable aleatoria de
     Bernoulli(p), con 0<p<1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la desviación
     típica de la binomial.

          (%i1) load (distrib)$
          (%i2) std_bernoulli(p);
          (%o2)                  std_binomial(1, p)
          (%i3) assume(0<p,p<1)$ std_bernoulli(p);
          (%o4)                  sqrt(1 - p) sqrt(p)

 -- Función: skewness_bernoulli (<p>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Bernoulli(p), con 0<p<1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en el coeficiente
     de asimetría de la binomial.

          (%i1) load (distrib)$
          (%i2) skewness_bernoulli(p);
          (%o2)                skewness_binomial(1, p)
          (%i3) assume(0<p,p<1)$ skewness_bernoulli(p);
                                       1 - 2 p
          (%o4)                  -------------------
                                 sqrt(1 - p) sqrt(p)

 -- Función: kurtosis_bernoulli (<p>)
     Devuelve el coeficiente de curtosis una variable aleatoria de
     Bernoulli(p), con 0<p<1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en el coeficiente
     de curtosis de la binomial.

          (%i1) load (distrib)$
          (%i2) kurtosis_bernoulli(p);
          (%o2)                kurtosis_binomial(1, p)
          (%i3) assume(0<p,p<1)$ kurtosis_bernoulli(p);
                                   1 - 6 (1 - p) p
          (%o4)                    ---------------
                                      (1 - p) p

 -- Función: random_bernoulli (<p>)
 -- Función: random_bernoulli (<p>,<n>)
     Devuelve un valor aleatorio  Bernoulli(p), con 0<p<1. Llamando a
     `random_bernoulli' con un segundo argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     Es aplicación directa de la función `random' de Maxima.

     Véase también `random'. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: pdf_geometric (<x>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria Geométrica(p), con 0<p<1.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_geometric (<x>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Geométrica(p), con 0<p<1.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_geometric (<q>,<p>)
     Devuelve el <q>-cuantil de una variable aleatoria Geométrica(p),
     con 0<p<1; en otras palabras, se trata de la inversa de
     `cdf_geometric'. El argumento <q> debe ser un número de [0,1].
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_geometric (<p>)
     Devuelve la media de  una variable aleatoria Geométrica(p), con
     0<p<1. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_geometric (<p>)
     Devuelve la varianza de  una variable aleatoria Geométrica(p), con
     0<p<1. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_geometric (<p>)
     Devuelve la desviación típica de  una variable aleatoria
     Geométrica(p), con 0<p<1. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: skewness_geometric (<p>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Geométrica(p), con 0<p<1. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: kurtosis_geometric (<p>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     Geométrica(p), con 0<p<1. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: random_geometric (<p>)
 -- Función: random_geometric (<p>,<n>)
     Devuelve un valor aleatorio Geométrico(p), con 0<p<1. Llamando a
     `random_geometric' con un segundo argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     El algoritmo está basado en la simulación de ensayos de Bernoulli.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_discrete_uniform (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria Uniforme Discreta(n), con n
     entero positivo. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: cdf_discrete_uniform (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Uniforme Discreta(n), con n
     entero positivo. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: quantile_discrete_uniform (<q>,<n>)
     Devuelve el <q>-cuantil de una variable aleatoria Uniforme
     Discreta(n), con n entero positivo; en otras palabras, se trata de
     la inversa de  `cdf_discrete_uniform'. El argumento <q> debe ser
     un número de [0,1]. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: mean_discrete_uniform (<n>)
     Devuelve la media de  una variable aleatoria Uniforme Discreta(n),
     con n entero positivo. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: var_discrete_uniform (<n>)
     Devuelve la varianza de  una variable aleatoria Uniforme
     Discreta(n), con n entero positivo. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: std_discrete_uniform (<n>)
     Devuelve la desviación típica de  una variable aleatoria Uniforme
     Discreta(n), con n entero positivo. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: skewness_discrete_uniform (<n>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Uniforme Discreta(n), con n entero positivo. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: kurtosis_discrete_uniform (<n>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     Uniforme Discreta(n), con n entero positivo. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: random_discrete_uniform (<n>)
 -- Función: random_discrete_uniform (<n>,<m>)
     Devuelve un valor aleatorio  Uniforme Discreto(n), con n entero
     positivo. Llamando a  `random_discrete_uniform' con un segundo
     argumento <m>, se simulará una muestra aleatoria de tamaño  <m>.

     Se trata de una aplicación directa de la función `random' de
     Maxima.

     Véase también `random'. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: pdf_hypergeometric (<x>,<n1>,<n2>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria Hipergeométrica(n1,n2,n),
     con <n1>, <n2> y <n> enteros positivos y n<=n1+n2. Siendo <n1> el
     número de objetos de la clase A, <n2> el número de objetos de la
     clase B y <n> el tamaño de una muestra sin reemplazamiento, esta
     función devuelve la probabilidad del suceso "extraer exactamente
     <x> objetos de la clase A".

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_hypergeometric (<x>,<n1>,<n2>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución of una variable aleatoria Hipergeométrica(n1,n2,n),
     con <n1>, <n2> y <n> enteros positivos y n<=n1+n2. Véase
     `pdf_hypergeometric' para una descripción más completa.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_hypergeometric (<q>,<n1>,<n2>,<n>)
     Devuelve el <q>-cuantil de una variable aleatoria
     Hipergeométrica(n1,n2,n), con <n1>, <n2> y <n> enteros positivos y
     n<=n1+n2; en otras palabras, se trata de la inversa de
     `cdf_hypergeometric'. El argumento <q> debe ser un número de
     [0,1]. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: mean_hypergeometric (<n1>,<n2>,<n>)
     Devuelve la media de  una variable aleatoria uniforme discreta
     Hyp(n1,n2,n), con <n1>, <n2> y <n> enteros positivos y n<=n1+n2.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: var_hypergeometric (<n1>,<n2>,<n>)
     Devuelve la varianza de  una variable aleatoria
     Hipergeométrica(n1,n2,n), con <n1>, <n2> y <n> enteros positivos y
     n<=n1+n2. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_hypergeometric (<n1>,<n2>,<n>)
     Devuelve la desviación típica de  una variable aleatoria
     Hipergeométrica(n1,n2,n), con <n1>, <n2> y <n> enteros positivos y
     n<=n1+n2. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: skewness_hypergeometric (<n1>,<n2>,<n>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Hipergeométrica(n1,n2,n), con <n1>, <n2> y <n> enteros positivos y
     n<=n1+n2. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: random_hypergeometric (<n1>,<n2>,<n>)
 -- Función: random_hypergeometric (<n1>,<n2>,<n>,<m>)
     Devuelve un valor aleatorio Hipergeométrico(n1,n2,n), con <n1>,
     <n2> y <n> enteros positivos y n<=n1+n2. Llamando a
     `random_hypergeometric' con un cuarto argumento <m>, se simulará
     una muestra aleatoria de tamaño  <m>.

     Algoritmo descrito en Kachitvichyanukul, V., Schmeiser, B.W.
     (1985) <Computer generation of hypergeometric random variates.>
     Journal of Statistical Computation and Simulation 22, 127-145.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_negative_binomial (<x>,<n>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria Binomial Negativa(n,p), con
     0<p<1 y n positivo. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: cdf_negative_binomial (<x>,<n>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Binomial Negativa(n,p), con
     0<p<1 y n positivo.

          (%i1) load (distrib)$
          (%i2) cdf_negative_binomial(3,4,1/8);
                                      3271
          (%o2)                      ------
                                     524288
          (%i3) float(%);
          (%o3)              .006238937377929687

 -- Función: quantile_negative_binomial (<q>,<n>,<p>)
     Devuelve el <q>-cuantil de una variable aleatoria Binomial
     Negativa(n,p), con 0<p<1 y n positivo; en otras palabras, se trata
     de la inversa de  `cdf_negative_binomial'. El argumento <q> debe
     ser un número de [0,1]. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: mean_negative_binomial (<n>,<p>)
     Devuelve la media de  una variable aleatoria Binomial
     Negativa(n,p), con 0<p<1 and n positivo. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: var_negative_binomial (<n>,<p>)
     Devuelve la varianza de  una variable aleatoria Binomial
     Negativa(n,p), con 0<p<1 and n positivo. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: std_negative_binomial (<n>,<p>)
     Devuelve la desviación típica de  una variable aleatoria Binomial
     Negativa(n,p), con 0<p<1 and n positivo. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: skewness_negative_binomial (<n>,<p>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Binomial Negativa(n,p), con 0<p<1 and n positivo. Para hacer uso
     de esta función, ejecútese primero `load(distrib)'.

 -- Función: kurtosis_negative_binomial (<n>,<p>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     binomial negativa  NB(n,p), con 0<p<1 and n positivo. Para hacer
     uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: random_negative_binomial (<n>,<p>)
 -- Función: random_negative_binomial (<n>,<p>,<m>)
     Devuelve un valor aleatorio Binomial Negativo(n,p), con 0<p<1 y n
     positivo. Llamando a  `random_negative_binomial' con un tercer
     argumento <m>, se simulará una muestra aleatoria de tamaño  <m>.

     Algoritmo descrito en Devroye, L. (1986) <Non-Uniform Random
     Variate Generation>. Springer Verlag, p. 480.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.


File: maxima.info,  Node: draw,  Next: drawdf,  Prev: distrib,  Up: Top

47 draw
*******

* Menu:

* Introducción a draw::
* Funciones y variables para draw::
* Funciones y variables para picture::
* Funciones y variables para worldmap::


File: maxima.info,  Node: Introducción a draw,  Next: Funciones y variables para draw,  Prev: draw,  Up: draw

47.1 Introducción a draw
========================

`draw' es un interfaz para comunicar Maxima con Gnuplot.

Tres son las funciones principales a utilizar a nivel de Maxima:
`draw2d', `draw3d' y `draw'.

Sígase este enlace para ver ejemplos más elaborados de este paquete:

`http://riotorto.users.sourceforge.net/gnuplot'

Se necesita tener instalado Gnuplot 4.2 o superior para ejecutar este
paquete.



Local Variables:
coding: iso-8859-1
End:
