<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.0.3, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Rules and Patterns (Maxima 5.47.0 Manual)</title>

<meta name="description" content="Rules and Patterns (Maxima 5.47.0 Manual)">
<meta name="keywords" content="Rules and Patterns (Maxima 5.47.0 Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="maxima_toc.html" rel="start" title="Top">
<link href="Function-and-Variable-Index.html" rel="index" title="Function and Variable Index">
<link href="maxima_toc.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="maxima_toc.html" rel="up" title="Top">
<link href="maxima_34.html#Sets" rel="next" title="Sets">
<link href="maxima_32.html#Miscellaneous-Options" rel="prev" title="Miscellaneous Options">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
ul.mark-bullet {list-style-type: disc}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 1em; padding-bottom: 1em;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%; display: block; margin-left: auto; margin-right: auto}

-->
</style>


</head>

<body lang="en">
<div class="chapter-level-extent" id="Rules-and-Patterns">
<div class="nav-panel">
<p>
Next: <a href="maxima_34.html#Sets" accesskey="n" rel="next">Sets</a>, Previous: <a href="maxima_32.html#Miscellaneous-Options" accesskey="p" rel="prev">Miscellaneous Options</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<h2 class="chapter" id="Rules-and-Patterns-1">34 Rules and Patterns</h2>

<a class="anchor" id="Item_003a-Rules_002fnode_002fIntroduction-to-Rules-and-Patterns"></a><ul class="mini-toc">
<li><a href="#Introduction-to-Rules-and-Patterns" accesskey="1">Introduction to Rules and Patterns</a></li>
<li><a href="#Functions-and-Variables-for-Rules-and-Patterns" accesskey="2">Functions and Variables for Rules and Patterns</a></li>
</ul>
<hr>
<div class="section-level-extent" id="Introduction-to-Rules-and-Patterns">
<div class="nav-panel">
<p>
Next: <a href="#Functions-and-Variables-for-Rules-and-Patterns" accesskey="n" rel="next">Functions and Variables for Rules and Patterns</a>, Previous: <a href="#Rules-and-Patterns" accesskey="p" rel="prev">Rules and Patterns</a>, Up: <a href="#Rules-and-Patterns" accesskey="u" rel="up">Rules and Patterns</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Introduction-to-Rules-and-Patterns-1">34.1 Introduction to Rules and Patterns</h3>

<p>This section describes user-defined pattern matching and simplification rules.
There are two groups of functions which implement somewhat different pattern
matching schemes.  In one group are <code class="code">tellsimp</code>, <code class="code">tellsimpafter</code>,
<code class="code">defmatch</code>, <code class="code">defrule</code>, <code class="code">apply1</code>, <code class="code">applyb1</code>, and
<code class="code">apply2</code>.  In the other group are <code class="code">let</code> and <code class="code">letsimp</code>.
Both schemes define patterns in terms of pattern variables declared by
<code class="code">matchdeclare</code>.
</p>
<p>Pattern-matching rules defined by <code class="code">tellsimp</code> and <code class="code">tellsimpafter</code> are
applied automatically by the Maxima simplifier.  Rules defined by
<code class="code">defmatch</code>, <code class="code">defrule</code>, and <code class="code">let</code> are applied by an explicit
function call.
</p>
<p>There are additional mechanisms for rules applied to polynomials by
<code class="code">tellrat</code>, and for commutative and noncommutative algebra in <code class="code">affine</code>
package.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Simplification">Simplification</a>
&middot;
<a class="ref" href="Documentation-Categories.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
&middot;
</div>


<a class="anchor" id="Item_003a-Rules_002fnode_002fFunctions-and-Variables-for-Rules-and-Patterns"></a><hr>
</div>
<div class="section-level-extent" id="Functions-and-Variables-for-Rules-and-Patterns">
<div class="nav-panel">
<p>
Previous: <a href="#Introduction-to-Rules-and-Patterns" accesskey="p" rel="prev">Introduction to Rules and Patterns</a>, Up: <a href="#Rules-and-Patterns" accesskey="u" rel="up">Rules and Patterns</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Functions-and-Variables-for-Rules-and-Patterns-1">34.2 Functions and Variables for Rules and Patterns</h3>


<a class="anchor" id="apply1"></a><a class="anchor" id="Item_003a-Rules_002fdeffn_002fapply1"></a><dl class="first-deffn">
<dt class="deffn" id="index-apply1"><span class="category-def">Function: </span><span><strong class="def-name">apply1</strong> <var class="def-var-arguments">(<var class="var">expr</var>, <var class="var">rule_1</var>, &hellip;, <var class="var">rule_n</var>)</var><a class="copiable-link" href='#index-apply1'> &para;</a></span></dt>
<dd>
<p>Repeatedly applies <var class="var">rule_1</var> to
<var class="var">expr</var> until it fails, then repeatedly applies the same rule to all
subexpressions of <var class="var">expr</var>, left to right, until <var class="var">rule_1</var> has failed
on all subexpressions.  Call the result of transforming <var class="var">expr</var> in this
manner <var class="var">expr_2</var>.  Then <var class="var">rule_2</var> is applied in the same fashion
starting at the top of <var class="var">expr_2</var>.  When <var class="var">rule_n</var> fails on the final
subexpression, the result is returned.
</p>
<p><code class="code">maxapplydepth</code> is the depth of the deepest subexpressions processed by
<code class="code">apply1</code> and <code class="code">apply2</code>.
</p>
<p>See also <code class="code"><a class="ref" href="#applyb1">applyb1</a></code>, <code class="code"><a class="ref" href="#apply2">apply2</a></code> and <code class="code"><a class="ref" href="#let">let</a></code>.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
&middot;
</div>
</dd></dl>


<a class="anchor" id="apply2"></a><a class="anchor" id="Item_003a-Rules_002fdeffn_002fapply2"></a><dl class="first-deffn">
<dt class="deffn" id="index-apply2"><span class="category-def">Function: </span><span><strong class="def-name">apply2</strong> <var class="def-var-arguments">(<var class="var">expr</var>, <var class="var">rule_1</var>, &hellip;, <var class="var">rule_n</var>)</var><a class="copiable-link" href='#index-apply2'> &para;</a></span></dt>
<dd>
<p>If <var class="var">rule_1</var> fails on a given subexpression, then <var class="var">rule_2</var> is
repeatedly applied, etc.  Only if all rules fail on a given
subexpression is the whole set of rules repeatedly applied to the next
subexpression.  If one of the rules succeeds, then the same
subexpression is reprocessed, starting with the first rule.
</p>
<p><code class="code">maxapplydepth</code> is the depth of the deepest subexpressions processed by
<code class="code">apply1</code> and <code class="code">apply2</code>.
</p>
<p>See also <code class="code"><a class="ref" href="#apply1">apply1</a></code> and <code class="code"><a class="ref" href="#let">let</a></code>.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
&middot;
</div>
</dd></dl>


<a class="anchor" id="applyb1"></a><a class="anchor" id="Item_003a-Rules_002fdeffn_002fapplyb1"></a><dl class="first-deffn">
<dt class="deffn" id="index-applyb1"><span class="category-def">Function: </span><span><strong class="def-name">applyb1</strong> <var class="def-var-arguments">(<var class="var">expr</var>, <var class="var">rule_1</var>, &hellip;, <var class="var">rule_n</var>)</var><a class="copiable-link" href='#index-applyb1'> &para;</a></span></dt>
<dd>
<p>Repeatedly applies <var class="var">rule_1</var> to the deepest subexpression of <var class="var">expr</var>
until it fails, then repeatedly applies the same rule one level higher (i.e.,
larger subexpressions), until <var class="var">rule_1</var> has failed on the top-level
expression.  Then <var class="var">rule_2</var> is applied in the same fashion to the result of
<var class="var">rule_1</var>.  After <var class="var">rule_n</var> has been applied to the top-level expression,
the result is returned.
</p>
<p><code class="code">applyb1</code> is similar to <code class="code">apply1</code> but works from
the bottom up instead of from the top down.
</p>
<p><code class="code">maxapplyheight</code> is the maximum height which <code class="code">applyb1</code> reaches
before giving up.
</p>
<p>See also <code class="code"><a class="ref" href="#apply1">apply1</a></code>, <code class="code"><a class="ref" href="#apply2">apply2</a></code> and <code class="code"><a class="ref" href="#let">let</a></code>.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="current_005flet_005frule_005fpackage"></a><a class="anchor" id="Item_003a-Rules_002fdefvr_002fcurrent_005flet_005frule_005fpackage"></a><dl class="first-defvr">
<dt class="defvr" id="index-current_005flet_005frule_005fpackage"><span class="category-def">Option variable: </span><span><strong class="def-name">current_let_rule_package</strong><a class="copiable-link" href='#index-current_005flet_005frule_005fpackage'> &para;</a></span></dt>
<dd><p>Default value: <code class="code">default_let_rule_package</code>
</p>
<p><code class="code">current_let_rule_package</code> is the name of the rule package that is used by
functions in the <code class="code">let</code> package (<code class="code">letsimp</code>, etc.) if no other rule package is specified.
This variable may be assigned the name of any rule package defined
via the <code class="code">let</code> command.
</p>
<p>If a call such as <code class="code">letsimp (expr, rule_pkg_name)</code> is made,
the rule package <code class="code">rule_pkg_name</code> is used for that function call only,
and the value of <code class="code">current_let_rule_package</code> is not changed.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="default_005flet_005frule_005fpackage"></a><a class="anchor" id="Item_003a-Rules_002fdefvr_002fdefault_005flet_005frule_005fpackage"></a><dl class="first-defvr">
<dt class="defvr" id="index-default_005flet_005frule_005fpackage"><span class="category-def">Option variable: </span><span><strong class="def-name">default_let_rule_package</strong><a class="copiable-link" href='#index-default_005flet_005frule_005fpackage'> &para;</a></span></dt>
<dd><p>Default value: <code class="code">default_let_rule_package</code>
</p>
<p><code class="code">default_let_rule_package</code> is the name of the rule package used when one
is not explicitly set by the user with <code class="code">let</code> or by changing the value of
<code class="code">current_let_rule_package</code>.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="defmatch"></a><a class="anchor" id="Item_003a-Rules_002fdeffn_002fdefmatch"></a><dl class="first-deffn">
<dt class="deffn" id="index-defmatch"><span class="category-def">Function: </span><span><strong class="def-name">defmatch</strong> <var class="def-var-arguments"><br>&nbsp;&nbsp;&nbsp;&nbsp;<code class="t">defmatch</code> (<var class="var">progname</var>, <var class="var">pattern</var>, <var class="var">x_1</var>, &hellip;, <var class="var">x_n</var>) <br>&nbsp;&nbsp;&nbsp;&nbsp;<code class="t">defmatch</code> (<var class="var">progname</var>, <var class="var">pattern</var>)</var><a class="copiable-link" href='#index-defmatch'> &para;</a></span></dt>
<dd>
<p>Defines a function <code class="code"><var class="var">progname</var>(<var class="var">expr</var>, <var class="var">x_1</var>, ..., <var class="var">x_n</var>)</code>
which tests <var class="var">expr</var> to see if it matches <var class="var">pattern</var>.
</p>
<p><var class="var">pattern</var> is an expression containing the pattern arguments <var class="var">x_1</var>,
&hellip;, <var class="var">x_n</var> (if any) and some pattern variables (if any).  The pattern
arguments are given explicitly as arguments to <code class="code">defmatch</code> while the pattern
variables are declared by the <code class="code">matchdeclare</code> function.  Any variable not
declared as a pattern variable in <code class="code">matchdeclare</code> or as a pattern argument
in <code class="code">defmatch</code> matches only itself.
</p>
<p>The first argument to the created function <var class="var">progname</var> is an expression to be
matched against the pattern and the other arguments are the actual arguments
which correspond to the dummy variables <var class="var">x_1</var>, &hellip;, <var class="var">x_n</var> in the
pattern.
</p>
<p>If the match is successful, <var class="var">progname</var> returns a list of equations whose
left sides are the pattern arguments and pattern variables, and whose right
sides are the subexpressions which the pattern arguments and variables matched.
The pattern variables, but not the pattern arguments, are assigned the
subexpressions they match.  If the match fails, <var class="var">progname</var> returns
<code class="code">false</code>.
</p>
<p>A literal pattern (that is, a pattern which contains neither pattern arguments
nor pattern variables) returns <code class="code">true</code> if the match succeeds.
</p>
<p>See also <code class="code"><a class="ref" href="#matchdeclare">matchdeclare</a></code>, <code class="code"><a class="ref" href="#defrule">defrule</a></code>, <code class="code"><a class="ref" href="#tellsimp">tellsimp</a></code> and
<code class="code"><a class="ref" href="#tellsimpafter">tellsimpafter</a></code>.
</p>
<p>Examples:
</p>
<p>Define a function <code class="code">linearp(expr, x)</code> which
tests <code class="code">expr</code> to see if it is of the form <code class="code">a*x + b</code>
such that <code class="code">a</code> and <code class="code">b</code> do not contain <code class="code">x</code> and <code class="code">a</code> is nonzero.
This match function matches expressions which are linear in any variable,
because the pattern argument <code class="code">x</code> is given to <code class="code">defmatch</code>.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), b,
                    freeof(x));
(%o1)                         done
</pre></div><div class="group"><pre class="example-preformatted">(%i2) defmatch (linearp, a*x + b, x);
(%o2)                        linearp
</pre></div><div class="group"><pre class="example-preformatted">(%i3) linearp (3*z + (y + 1)*z + y^2, z);
                         2
(%o3)              [b = y , a = y + 4, x = z]
</pre></div><div class="group"><pre class="example-preformatted">(%i4) a;
(%o4)                         y + 4
</pre></div><div class="group"><pre class="example-preformatted">(%i5) b;
                                2
(%o5)                          y
</pre></div><div class="group"><pre class="example-preformatted">(%i6) x;
(%o6)                           x
</pre></div></div>

<p>Define a function <code class="code">linearp(expr)</code> which tests <code class="code">expr</code>
to see if it is of the form <code class="code">a*x + b</code>
such that <code class="code">a</code> and <code class="code">b</code> do not contain <code class="code">x</code> and <code class="code">a</code> is nonzero.
This match function only matches expressions linear in <code class="code">x</code>,
not any other variable, because no pattern argument is given to <code class="code">defmatch</code>.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), b,
                    freeof(x));
(%o1)                         done
</pre></div><div class="group"><pre class="example-preformatted">(%i2) defmatch (linearp, a*x + b);
(%o2)                        linearp
</pre></div><div class="group"><pre class="example-preformatted">(%i3) linearp (3*z + (y + 1)*z + y^2);
(%o3)                         false
</pre></div><div class="group"><pre class="example-preformatted">(%i4) linearp (3*x + (y + 1)*x + y^2);
                             2
(%o4)                  [b = y , a = y + 4]
</pre></div></div>

<p>Define a function <code class="code">checklimits(expr)</code> which tests <code class="code">expr</code>
to see if it is a definite integral.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) matchdeclare ([a, f], true);
(%o1)                         done
</pre></div><div class="group"><pre class="example-preformatted">(%i2) constinterval (l, h) := constantp (h - l);
(%o2)        constinterval(l, h) := constantp(h - l)
</pre></div><div class="group"><pre class="example-preformatted">(%i3) matchdeclare (b, constinterval (a));
(%o3)                         done
</pre></div><div class="group"><pre class="example-preformatted">(%i4) matchdeclare (x, atom);
(%o4)                         done
</pre></div><div class="group"><pre class="example-preformatted">(%i5) simp : false;
(%o5)                         false
</pre></div><div class="group"><pre class="example-preformatted">(%i6) defmatch (checklimits, 'integrate (f, x, a, b));
(%o6)                      checklimits
</pre></div><div class="group"><pre class="example-preformatted">(%i7) simp : true;
(%o7)                         true
</pre></div><div class="group"><pre class="example-preformatted">(%i8) 'integrate (sin(t), t, %pi + x, 2*%pi + x);
                       x + 2 %pi
                      /
                      [
(%o8)                 I          sin(t) dt
                      ]
                      /
                       x + %pi
</pre></div><div class="group"><pre class="example-preformatted">(%i9) checklimits (%);
(%o9)    [b = x + 2 %pi, a = x + %pi, x = t, f = sin(t)]
</pre></div></div>

<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
&middot;
</div>
</dd></dl>


<a class="anchor" id="defrule"></a><a class="anchor" id="Item_003a-Rules_002fdeffn_002fdefrule"></a><dl class="first-deffn">
<dt class="deffn" id="index-defrule"><span class="category-def">Function: </span><span><strong class="def-name">defrule</strong> <var class="def-var-arguments">(<var class="var">rulename</var>, <var class="var">pattern</var>, <var class="var">replacement</var>)</var><a class="copiable-link" href='#index-defrule'> &para;</a></span></dt>
<dd>
<p>Defines and names a replacement rule for the given pattern.  If the rule named
<var class="var">rulename</var> is applied to an expression (by <code class="code">apply1</code>, <code class="code">applyb1</code>, or
<code class="code">apply2</code>), every subexpression matching the pattern will be replaced by the
replacement.  All variables in the replacement which have been
assigned values by the pattern match are assigned those values in the
replacement which is then simplified.
</p>
<p>The rules themselves can be
treated as functions which transform an expression by one
operation of the pattern match and replacement.
If the match fails, the rule function returns <code class="code">false</code>.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
&middot;
</div>
</dd></dl>


<a class="anchor" id="disprule"></a><a class="anchor" id="Item_003a-Rules_002fdeffn_002fdisprule"></a><dl class="first-deffn">
<dt class="deffn" id="index-disprule"><span class="category-def">Function: </span><span><strong class="def-name">disprule</strong> <var class="def-var-arguments"><br>&nbsp;&nbsp;&nbsp;&nbsp;<code class="t">disprule</code> (<var class="var">rulename_1</var>, &hellip;, <var class="var">rulename_2</var>) <br>&nbsp;&nbsp;&nbsp;&nbsp;<code class="t">disprule</code> (all)</var><a class="copiable-link" href='#index-disprule'> &para;</a></span></dt>
<dd>
<p>Display rules with the names <var class="var">rulename_1</var>, &hellip;, <var class="var">rulename_n</var>,
as returned by <code class="code">defrule</code>, <code class="code">tellsimp</code>, or <code class="code">tellsimpafter</code>,
or a pattern defined by <code class="code">defmatch</code>.
Each rule is displayed with an intermediate expression label (<code class="code">%t</code>).
</p>
<p><code class="code">disprule (all)</code> displays all rules.
</p>
<p><code class="code">disprule</code> quotes its arguments.
<code class="code">disprule</code> returns the list of intermediate expression labels corresponding
to the displayed rules.
</p>
<p>See also <code class="code"><a class="ref" href="#letrules">letrules</a></code>,  which displays rules defined by <code class="code"><a class="ref" href="#let">let</a></code>.
</p>
<p>Examples:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) tellsimpafter (foo (x, y), bar (x) + baz (y));
(%o1)                   [foorule1, false]
</pre></div><div class="group"><pre class="example-preformatted">(%i2) tellsimpafter (x + y, special_add (x, y));
(%o2)                   [+rule1, simplus]
</pre></div><div class="group"><pre class="example-preformatted">(%i3) defmatch (quux, mumble (x));
(%o3)                         quux
</pre></div><div class="group"><pre class="example-preformatted">(%i4) disprule (foorule1, ?\+rule1, quux);
(%t4)        foorule1 : foo(x, y) -&gt; baz(y) + bar(x)

(%t5)          +rule1 : y + x -&gt; special_add(x, y)

(%t6)                quux : mumble(x) -&gt; []

(%o6)                    [%t4, %t5, %t6]
</pre></div><div class="group"><pre class="example-preformatted">(%i7) ev(%);
(%o7) [foorule1 : foo(x, y) -&gt; baz(y) + bar(x), 
     +rule1 : y + x -&gt; special_add(x, y), quux : mumble(x) -&gt; []]
</pre></div></div>

<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
&middot;
<a class="ref" href="Documentation-Categories.html#Category_003a-Display-functions">Display functions</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="let"></a><a class="anchor" id="Item_003a-Rules_002fdeffn_002flet"></a><dl class="first-deffn">
<dt class="deffn" id="index-let"><span class="category-def">Function: </span><span><strong class="def-name">let</strong> <var class="def-var-arguments"><br>&nbsp;&nbsp;&nbsp;&nbsp;<code class="t">let</code> (<var class="var">prod</var>, <var class="var">repl</var>, <var class="var">predname</var>, <var class="var">arg_1</var>, &hellip;, <var class="var">arg_n</var>) <br>&nbsp;&nbsp;&nbsp;&nbsp;<code class="t">let</code> ([<var class="var">prod</var>, <var class="var">repl</var>, <var class="var">predname</var>, <var class="var">arg_1</var>, &hellip;, <var class="var">arg_n</var>], <var class="var">package_name</var>)</var><a class="copiable-link" href='#index-let'> &para;</a></span></dt>
<dd>
<p>Defines a substitution rule for <code class="code">letsimp</code> such that <var class="var">prod</var> is replaced
by <var class="var">repl</var>.  <var class="var">prod</var> is a product of positive or negative powers of the
following terms:
</p>
<ul class="itemize mark-bullet">
<li>Atoms which <code class="code">letsimp</code> will search for literally unless previous to calling
<code class="code">letsimp</code> the <code class="code">matchdeclare</code> function is used to associate a
predicate with the atom.  In this case <code class="code">letsimp</code> will match the atom to
any term of a product satisfying the predicate.
</li><li>Kernels such as <code class="code">sin(x)</code>, <code class="code">n!</code>, <code class="code">f(x,y)</code>, etc.  As with atoms
above <code class="code">letsimp</code> will look for a literal match unless <code class="code">matchdeclare</code>
is used to associate a predicate with the argument of the kernel.
</li></ul>

<p>A term to a positive power will only match a term having at least that
power.  A term to a negative power
on the other hand will only match a term with a power at least as
negative.  In the case of negative powers in <var class="var">prod</var> the switch
<code class="code">letrat</code> must be set to <code class="code">true</code>.
See also <code class="code"><a class="ref" href="#letrat">letrat</a></code>.
</p>
<p>If a predicate is included in the <code class="code">let</code> function followed by a list of
arguments, a tentative match (i.e. one that would be accepted if the predicate
were omitted) is accepted only if <code class="code">predname (arg_1', ..., arg_n')</code>
evaluates to <code class="code">true</code> where <var class="var">arg_i&rsquo;</var> is the value matched to <var class="var">arg_i</var>.
The <var class="var">arg_i</var> may be the name of any atom or the argument of any kernel
appearing in <var class="var">prod</var>.
<var class="var">repl</var> may be any rational expression.  If any of the atoms or arguments from <var class="var">prod</var> appear in <var class="var">repl</var> the
appropriate substitutions are made.  </p>
<p>The global flag <code class="code">letrat</code> controls the simplification of quotients by
<code class="code">letsimp</code>.  When <code class="code">letrat</code> is <code class="code">false</code>, <code class="code">letsimp</code> simplifies
the numerator and denominator of <var class="var">expr</var> separately, and does not simplify
the quotient.  Substitutions such as <code class="code">n!/n</code> goes to <code class="code">(n-1)!</code> then
fail.  When <code class="code">letrat</code> is <code class="code">true</code>, then the numerator, denominator, and
the quotient are simplified in that order.
</p>
<p>These substitution functions allow you to work with several rule packages at
once.  Each rule package can contain any number of <code class="code">let</code> rules and is
referenced by a user-defined name.  The command <code class="code">let ([<var class="var">prod</var>,
<var class="var">repl</var>, <var class="var">predname</var>, <var class="var">arg_1</var>, ..., <var class="var">arg_n</var>], <var class="var">package_name</var>)</code>
adds the rule <var class="var">predname</var> to the rule package <var class="var">package_name</var>.  The
command <code class="code">letsimp (<var class="var">expr</var>, <var class="var">package_name</var>)</code> applies the rules in 
<var class="var">package_name</var>.  <code class="code">letsimp (<var class="var">expr</var>, <var class="var">package_name1</var>,
<var class="var">package_name2</var>, ...)</code> is equivalent to <code class="code">letsimp (<var class="var">expr</var>,
<var class="var">package_name1</var>)</code> followed by <code class="code">letsimp (%, <var class="var">package_name2</var>)</code>,
&hellip;
</p>
<p><code class="code">current_let_rule_package</code> is the name of the rule package that is
presently being used.  This variable may be assigned the name of any rule
package defined via the <code class="code">let</code> command.  Whenever any of the functions
comprising the <code class="code">let</code> package are called with no package name, the package
named by <code class="code">current_let_rule_package</code> is used.  If a call such as
<code class="code">letsimp (<var class="var">expr</var>, <var class="var">rule_pkg_name</var>)</code> is made, the rule package
<var class="var">rule_pkg_name</var> is used for that <code class="code">letsimp</code> command only, and
<code class="code">current_let_rule_package</code> is not changed.  If not otherwise specified,
<code class="code">current_let_rule_package</code> defaults to <code class="code">default_let_rule_package</code>.
</p>
<div class="example">
<pre class="example-preformatted">(%i1) matchdeclare ([a, a1, a2], true)$
(%i2) oneless (x, y) := is (x = y-1)$
(%i3) let (a1*a2!, a1!, oneless, a2, a1);
(%o3)         a1 a2! --&gt; a1! where oneless(a2, a1)
(%i4) letrat: true$
(%i5) let (a1!/a1, (a1-1)!);
                        a1!
(%o5)                   --- --&gt; (a1 - 1)!
                        a1
(%i6) letsimp (n*m!*(n-1)!/m);
(%o6)                      (m - 1)! n!
(%i7) let (sin(a)^2, 1 - cos(a)^2);
                        2               2
(%o7)                sin (a) --&gt; 1 - cos (a)
(%i8) letsimp (sin(x)^4);
                        4           2
(%o8)                cos (x) - 2 cos (x) + 1
</pre></div>

<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="letrat"></a><a class="anchor" id="Item_003a-Rules_002fdefvr_002fletrat"></a><dl class="first-defvr">
<dt class="defvr" id="index-letrat"><span class="category-def">Option variable: </span><span><strong class="def-name">letrat</strong><a class="copiable-link" href='#index-letrat'> &para;</a></span></dt>
<dd><p>Default value: <code class="code">false</code>
</p>
<p>When <code class="code">letrat</code> is <code class="code">false</code>, <code class="code">letsimp</code> simplifies the
numerator and denominator of a ratio separately,
and does not simplify the quotient.
</p>
<p>When <code class="code">letrat</code> is <code class="code">true</code>,
the numerator, denominator, and their quotient are simplified in that order.
</p>
<div class="example">
<pre class="example-preformatted">(%i1) matchdeclare (n, true)$
(%i2) let (n!/n, (n-1)!);
                         n!
(%o2)                    -- --&gt; (n - 1)!
                         n
(%i3) letrat: false$
(%i4) letsimp (a!/a);
                               a!
(%o4)                          --
                               a
(%i5) letrat: true$
(%i6) letsimp (a!/a);
(%o6)                       (a - 1)!
</pre></div>

<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
&middot;
</div>
</dd></dl>


<a class="anchor" id="letrules"></a><a class="anchor" id="Item_003a-Rules_002fdeffn_002fletrules"></a><dl class="first-deffn">
<dt class="deffn" id="index-letrules"><span class="category-def">Function: </span><span><strong class="def-name">letrules</strong> <var class="def-var-arguments"><br>&nbsp;&nbsp;&nbsp;&nbsp;<code class="t">letrules</code> () <br>&nbsp;&nbsp;&nbsp;&nbsp;<code class="t">letrules</code> (<var class="var">package_name</var>)</var><a class="copiable-link" href='#index-letrules'> &para;</a></span></dt>
<dd>
<p>Displays the rules in a rule package.
<code class="code">letrules ()</code> displays the rules in the current rule package.
<code class="code">letrules (<var class="var">package_name</var>)</code> displays the rules in <var class="var">package_name</var>.
</p>
<p>The current rule package is named by <code class="code">current_let_rule_package</code>.
If not otherwise specified, <code class="code">current_let_rule_package</code>
defaults to <code class="code">default_let_rule_package</code>.
</p>
<p>See also <code class="code"><a class="ref" href="#disprule">disprule</a></code>, which displays rules defined by <code class="code"><a class="ref" href="#tellsimp">tellsimp</a></code> and
<code class="code"><a class="ref" href="#tellsimpafter">tellsimpafter</a></code>.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="letsimp"></a><a class="anchor" id="Item_003a-Rules_002fdeffn_002fletsimp"></a><dl class="first-deffn">
<dt class="deffn" id="index-letsimp"><span class="category-def">Function: </span><span><strong class="def-name">letsimp</strong> <var class="def-var-arguments"><br>&nbsp;&nbsp;&nbsp;&nbsp;<code class="t">letsimp</code> (<var class="var">expr</var>) <br>&nbsp;&nbsp;&nbsp;&nbsp;<code class="t">letsimp</code> (<var class="var">expr</var>, <var class="var">package_name</var>) <br>&nbsp;&nbsp;&nbsp;&nbsp;<code class="t">letsimp</code> (<var class="var">expr</var>, <var class="var">package_name_1</var>, &hellip;, <var class="var">package_name_n</var>)</var><a class="copiable-link" href='#index-letsimp'> &para;</a></span></dt>
<dd>
<p>Repeatedly applies the substitution rules defined by <code class="code">let</code>
until no further change is made to <var class="var">expr</var>.
</p>
<p><code class="code">letsimp (<var class="var">expr</var>)</code> uses the rules from <code class="code">current_let_rule_package</code>.
</p>
<p><code class="code">letsimp (<var class="var">expr</var>, <var class="var">package_name</var>)</code> uses the rules from
<var class="var">package_name</var> without changing <code class="code">current_let_rule_package</code>.
</p>
<p><code class="code">letsimp (<var class="var">expr</var>, <var class="var">package_name_1</var>, ..., <var class="var">package_name_n</var>)</code>
is equivalent to <code class="code">letsimp (<var class="var">expr</var>, <var class="var">package_name_1</var>)</code>,
followed by <code class="code">letsimp (%, <var class="var">package_name_2</var>)</code>, and so on.
</p>
<p>See also <code class="code"><a class="ref" href="#let">let</a></code>.
For other ways to do substitutions see also <code class="code"><a class="ref" href="maxima_5.html#subst">subst</a></code>,
<code class="code"><a class="ref" href="maxima_5.html#psubst">psubst</a></code>, <code class="code"><a class="ref" href="maxima_17.html#at">at</a></code> and <code class="code"><a class="ref" href="maxima_13.html#ratsubst">ratsubst</a></code>.
</p>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) e0: e(k) = -(9*y(k))/(5*z)-u(k-1)/(5*z)+(4*y(k))/(5*z^2)
                 +(3*u(k-1))/(5*z^2)+y(k)-(2*u(k-1))/5;
                9 y(k)    u(k - 1)   4 y(k)   3 u(k - 1)
(%o1) e(k) = (- ------) - -------- + ------ + ---------- + y(k)
                 5 z        5 z          2          2
                                      5 z        5 z
                                                       2 u(k - 1)
                                                     - ----------
                                                           5
</pre></div><pre class="example-preformatted">(%i2) matchdeclare(h,any)$
</pre><div class="group"><pre class="example-preformatted">(%i3) let(u(h)/z,u(h-1));
                        u(h)
(%o3)                   ---- --&gt; u(h - 1)
                         z
</pre></div><div class="group"><pre class="example-preformatted">(%i4) let(y(h)/z, y(h-1));
                        y(h)
(%o4)                   ---- --&gt; y(h - 1)
                         z
</pre></div><div class="group"><pre class="example-preformatted">(%i5) e1:letsimp(e0);
                2 u(k - 1)           3 u(k - 3)   4 y(k - 2)
(%o5) e(k) = (- ----------) + y(k) + ---------- + ----------
                    5                    5            5
                                       u(k - 2)       9 y(k - 1)
                                  + (- --------) + (- ----------)
                                          5               5
</pre></div></div>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="let_005frule_005fpackages"></a><a class="anchor" id="Item_003a-Rules_002fdefvr_002flet_005frule_005fpackages"></a><dl class="first-defvr">
<dt class="defvr" id="index-let_005frule_005fpackages"><span class="category-def">Option variable: </span><span><strong class="def-name">let_rule_packages</strong><a class="copiable-link" href='#index-let_005frule_005fpackages'> &para;</a></span></dt>
<dd><p>Default value: <code class="code">[default_let_rule_package]</code>
</p>
<p><code class="code">let_rule_packages</code> is a list of all user-defined let rule packages
plus the default package <code class="code">default_let_rule_package</code>.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="matchdeclare"></a><a class="anchor" id="Item_003a-Rules_002fdeffn_002fmatchdeclare"></a><dl class="first-deffn">
<dt class="deffn" id="index-matchdeclare"><span class="category-def">Function: </span><span><strong class="def-name">matchdeclare</strong> <var class="def-var-arguments">(<var class="var">a_1</var>, <var class="var">pred_1</var>, &hellip;, <var class="var">a_n</var>, <var class="var">pred_n</var>)</var><a class="copiable-link" href='#index-matchdeclare'> &para;</a></span></dt>
<dd>
<p>Associates a predicate <var class="var">pred_k</var> 
with a variable or list of variables <var class="var">a_k</var>
so that <var class="var">a_k</var> matches expressions
for which the predicate returns anything other than <code class="code">false</code>.
</p>
<p>A predicate is the name of a function,
or a lambda expression,
or a function call or lambda call missing the last argument,
or <code class="code">true</code> or <code class="code">all</code>.
Any expression matches <code class="code">true</code> or <code class="code">all</code>.
If the predicate is specified as a function call or lambda call,
the expression to be tested is appended to the list of arguments;
the arguments are evaluated at the time the match is evaluated.
Otherwise, the predicate is specified as a function name or lambda expression,
and the expression to be tested is the sole argument.
A predicate function need not be defined when <code class="code">matchdeclare</code> is called;
the predicate is not evaluated until a match is attempted.
</p>
<p>A predicate may return a Boolean expression as well as <code class="code">true</code> or
<code class="code">false</code>.  Boolean expressions are evaluated by <code class="code">is</code> within the
constructed rule function, so it is not necessary to call <code class="code">is</code> within the
predicate.
</p>
<p>If an expression satisfies a match predicate, the match variable is assigned the
expression, except for match variables which are operands of addition <code class="code">+</code>
or multiplication <code class="code">*</code>.  Only addition and multiplication are handled
specially; other n-ary operators (both built-in and user-defined) are treated
like ordinary functions.
</p>
<p>In the case of addition and multiplication, the match variable may be assigned a
single expression which satisfies the match predicate, or a sum or product
(respectively) of such expressions.  Such multiple-term matching is greedy:
predicates are evaluated in the order in which their associated variables
appear in the match pattern, and a term which satisfies more than one predicate
is taken by the first predicate which it satisfies.  Each predicate is tested
against all operands of the sum or product before the next predicate is
evaluated.  In addition, if 0 or 1 (respectively) satisfies a match predicate,
and there are no other terms which satisfy the predicate, 0 or 1 is assigned to
the match variable associated with the predicate.
</p>
<p>The algorithm for processing addition and multiplication patterns makes some
match results (for example, a pattern in which a &quot;match anything&quot; variable
appears) dependent on the ordering of terms in the match pattern and in the
expression to be matched.  However, if all match predicates are mutually
exclusive, the match result is insensitive to ordering, as one match predicate
cannot accept terms matched by another.
</p>
<p>Calling <code class="code">matchdeclare</code> with a variable <var class="var">a</var> as an argument changes the
<code class="code">matchdeclare</code> property for <var class="var">a</var>, if one was already declared; only the
most recent <code class="code">matchdeclare</code> is in effect when a rule is defined.  Later
changes to the <code class="code">matchdeclare</code> property (via <code class="code">matchdeclare</code> or
<code class="code">remove</code>) do not affect existing rules.
</p>
<p><code class="code">propvars (matchdeclare)</code> returns the list of all variables for which there
is a <code class="code">matchdeclare</code> property.  <code class="code">printprops (<var class="var">a</var>, matchdeclare)</code>
returns the predicate for variable <code class="code">a</code>.
<code class="code">printprops (all, matchdeclare)</code> returns the list of predicates for all
<code class="code">matchdeclare</code> variables.  <code class="code">remove (<var class="var">a</var>, matchdeclare)</code> removes
the <code class="code">matchdeclare</code> property from <var class="var">a</var>.
</p>
<p>The functions <code class="code">defmatch</code>, <code class="code">defrule</code>, <code class="code">tellsimp</code>,
<code class="code">tellsimpafter</code>, and <code class="code">let</code> construct rules which test expressions
against patterns.
</p>
<p><code class="code">matchdeclare</code> quotes its arguments.
<code class="code">matchdeclare</code> always returns <code class="code">done</code>.
</p>
<p>Examples:
</p>
<p>A predicate is the name of a function,
or a lambda expression,
or a function call or lambda call missing the last argument,
or <code class="code">true</code> or <code class="code">all</code>.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) matchdeclare (aa, integerp);
(%o1)                         done
</pre></div><div class="group"><pre class="example-preformatted">(%i2) matchdeclare (bb, lambda ([x], x &gt; 0));
(%o2)                         done
</pre></div><div class="group"><pre class="example-preformatted">(%i3) matchdeclare (cc, freeof (%e, %pi, %i));
(%o3)                         done
</pre></div><div class="group"><pre class="example-preformatted">(%i4) matchdeclare (dd, lambda ([x, y], gcd (x, y) = 1) (1728));
(%o4)                         done
</pre></div><div class="group"><pre class="example-preformatted">(%i5) matchdeclare (ee, true);
(%o5)                         done
</pre></div><div class="group"><pre class="example-preformatted">(%i6) matchdeclare (ff, all);
(%o6)                         done
</pre></div></div>

<p>If an expression satisfies a match predicate,
the match variable is assigned the expression.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) matchdeclare (aa, integerp, bb, atom);
(%o1)                         done
</pre></div><div class="group"><pre class="example-preformatted">(%i2) defrule (r1, bb^aa, [&quot;integer&quot; = aa, &quot;atom&quot; = bb]);
                    aa
(%o2)        r1 : bb   -&gt; [integer = aa, atom = bb]
</pre></div><div class="group"><pre class="example-preformatted">(%i3) r1 (%pi^8);
(%o3)               [integer = 8, atom = %pi]
</pre></div></div>

<p>In the case of addition and multiplication, the match variable may be assigned
a single expression which satisfies the match predicate, or a sum or product
(respectively) of such expressions.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));
(%o1)                         done
</pre></div><div class="group"><pre class="example-preformatted">(%i2) defrule (r1, aa + bb, [&quot;all atoms&quot; = aa, &quot;all nonatoms&quot; =
               bb]);
(%o2)  r1 : bb + aa -&gt; [all atoms = aa, all nonatoms = bb]
</pre></div><div class="group"><pre class="example-preformatted">(%i3) r1 (8 + a*b + sin(x));
(%o3)     [all atoms = 8, all nonatoms = sin(x) + a b]
</pre></div><div class="group"><pre class="example-preformatted">(%i4) defrule (r2, aa * bb, [&quot;all atoms&quot; = aa, &quot;all nonatoms&quot; =
               bb]);
(%o4)   r2 : aa bb -&gt; [all atoms = aa, all nonatoms = bb]
</pre></div><div class="group"><pre class="example-preformatted">(%i5) r2 (8 * (a + b) * sin(x));
(%o5)    [all atoms = 8, all nonatoms = (b + a) sin(x)]
</pre></div></div>

<p>When matching arguments of <code class="code">+</code> and <code class="code">*</code>,
if all match predicates are mutually exclusive,
the match result is insensitive to ordering,
as one match predicate cannot accept terms matched by another.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));
(%o1)                         done
</pre></div><div class="group"><pre class="example-preformatted">(%i2) defrule (r1, aa + bb, [&quot;all atoms&quot; = aa, &quot;all nonatoms&quot; =
               bb]);
(%o2)  r1 : bb + aa -&gt; [all atoms = aa, all nonatoms = bb]
</pre></div><div class="group"><pre class="example-preformatted">(%i3) r1 (8 + a*b + %pi + sin(x) - c + 2^n);
                                                     n
(%o3) [all atoms = %pi + 8, all nonatoms = sin(x) + 2  - c + a b]
</pre></div><div class="group"><pre class="example-preformatted">(%i4) defrule (r2, aa * bb, [&quot;all atoms&quot; = aa, &quot;all nonatoms&quot; =
               bb]);
(%o4)   r2 : aa bb -&gt; [all atoms = aa, all nonatoms = bb]
</pre></div><div class="group"><pre class="example-preformatted">(%i5) r2 (8 * (a + b) * %pi * sin(x) / c * 2^n);
                                                n + 3
                                       (b + a) 2      sin(x)
(%o5) [all atoms = %pi, all nonatoms = ---------------------]
                                                 c
</pre></div></div>

<p>The functions <code class="code">propvars</code> and <code class="code">printprops</code> return information about
match variables.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) matchdeclare ([aa, bb, cc], atom, [dd, ee], integerp);
(%o1)                         done
</pre></div><div class="group"><pre class="example-preformatted">(%i2) matchdeclare (ff, floatnump, gg, lambda ([x], x &gt; 100));
(%o2)                         done
</pre></div><div class="group"><pre class="example-preformatted">(%i3) propvars (matchdeclare);
(%o3)             [aa, bb, cc, dd, ee, ff, gg]
</pre></div><div class="group"><pre class="example-preformatted">(%i4) printprops (ee, matchdeclare);
(%o4)                    [integerp(ee)]
</pre></div><div class="group"><pre class="example-preformatted">(%i5) printprops (gg, matchdeclare);
(%o5)              [lambda([x], x &gt; 100, gg)]
</pre></div><div class="group"><pre class="example-preformatted">(%i6) printprops (all, matchdeclare);
(%o6) [lambda([x], x &gt; 100, gg), floatnump(ff), integerp(ee), 
                      integerp(dd), atom(cc), atom(bb), atom(aa)]
</pre></div></div>

<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
&middot;
<a class="ref" href="Documentation-Categories.html#Category_003a-Declarations-and-inferences">Declarations and inferences</a>
&middot;
</div>
</dd></dl>


<a class="anchor" id="maxapplydepth"></a><a class="anchor" id="Item_003a-Rules_002fdefvr_002fmaxapplydepth"></a><dl class="first-defvr">
<dt class="defvr" id="index-maxapplydepth"><span class="category-def">Option variable: </span><span><strong class="def-name">maxapplydepth</strong><a class="copiable-link" href='#index-maxapplydepth'> &para;</a></span></dt>
<dd><p>Default value: 10000
</p>
<p><code class="code">maxapplydepth</code> is the maximum depth to which <code class="code">apply1</code>
and <code class="code">apply2</code> will delve.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Function-application">Function application</a>
&middot;
</div>
</dd></dl>


<a class="anchor" id="maxapplyheight"></a><a class="anchor" id="Item_003a-Rules_002fdefvr_002fmaxapplyheight"></a><dl class="first-defvr">
<dt class="defvr" id="index-maxapplyheight"><span class="category-def">Option variable: </span><span><strong class="def-name">maxapplyheight</strong><a class="copiable-link" href='#index-maxapplyheight'> &para;</a></span></dt>
<dd><p>Default value: 10000
</p>
<p><code class="code">maxapplyheight</code> is the maximum height to which <code class="code">applyb1</code>
will reach before giving up.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Function-application">Function application</a>
&middot;
</div>
</dd></dl>


<a class="anchor" id="remlet"></a><a class="anchor" id="Item_003a-Rules_002fdeffn_002fremlet"></a><dl class="first-deffn">
<dt class="deffn" id="index-remlet"><span class="category-def">Function: </span><span><strong class="def-name">remlet</strong> <var class="def-var-arguments"><br>&nbsp;&nbsp;&nbsp;&nbsp;<code class="t">remlet</code> (<var class="var">prod</var>, <var class="var">name</var>) <br>&nbsp;&nbsp;&nbsp;&nbsp;<code class="t">remlet</code> () <br>&nbsp;&nbsp;&nbsp;&nbsp;<code class="t">remlet</code> (all) <br>&nbsp;&nbsp;&nbsp;&nbsp;<code class="t">remlet</code> (all, <var class="var">name</var>)</var><a class="copiable-link" href='#index-remlet'> &para;</a></span></dt>
<dd>
<p>Deletes the substitution rule, <code class="code">prod --&gt; repl</code>, most
recently defined by the <code class="code">let</code> function.  If name is supplied the rule is
deleted from the rule package name.
</p>
<p><code class="code">remlet()</code> and <code class="code">remlet(all)</code> delete all substitution rules from the
current rule package.  If the name of a rule package is supplied, e.g.
<code class="code">remlet (all, <var class="var">name</var>)</code>, the rule package <var class="var">name</var> is also deleted.
</p>
<p>If a substitution is to be changed using the same
product, <code class="code">remlet</code> need not be called, just redefine the substitution
using the same product (literally) with the <code class="code">let</code> function and the new
replacement and/or predicate name.  Should <code class="code">remlet (<var class="var">prod</var>)</code> now be
called the original substitution rule is revived.
</p>
<p>See also <code class="code"><a class="ref" href="#remrule">remrule</a></code>, which removes a rule defined by <code class="code"><a class="ref" href="#tellsimp">tellsimp</a></code> or
<code class="code"><a class="ref" href="#tellsimpafter">tellsimpafter</a></code>.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="remrule"></a><a class="anchor" id="Item_003a-Rules_002fdeffn_002fremrule"></a><dl class="first-deffn">
<dt class="deffn" id="index-remrule"><span class="category-def">Function: </span><span><strong class="def-name">remrule</strong> <var class="def-var-arguments"><br>&nbsp;&nbsp;&nbsp;&nbsp;<code class="t">remrule</code> (<var class="var">op</var>, <var class="var">rulename</var>) <br>&nbsp;&nbsp;&nbsp;&nbsp;<code class="t">remrule</code> (<var class="var">op</var>, all)</var><a class="copiable-link" href='#index-remrule'> &para;</a></span></dt>
<dd>
<p>Removes rules defined by <code class="code">tellsimp</code> or <code class="code">tellsimpafter</code>.
</p>
<p><code class="code">remrule (<var class="var">op</var>, <var class="var">rulename</var>)</code>
removes the rule with the name <var class="var">rulename</var> from the operator <var class="var">op</var>.
When <var class="var">op</var> is a built-in or user-defined operator
(as defined by <code class="code">infix</code>, <code class="code">prefix</code>, etc.),
<var class="var">op</var> and <var class="var">rulename</var> must be enclosed in double quote marks.
</p>
<p><code class="code">remrule (<var class="var">op</var>, all)</code> removes all rules for the operator <var class="var">op</var>.
</p>
<p>See also <code class="code"><a class="ref" href="#remlet">remlet</a></code>, which removes a rule defined by <code class="code"><a class="ref" href="#let">let</a></code>.
</p>
<p>Examples:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) tellsimp (foo (aa, bb), bb - aa);
(%o1)                   [foorule1, false]
</pre></div><div class="group"><pre class="example-preformatted">(%i2) tellsimpafter (aa + bb, special_add (aa, bb));
(%o2)                   [+rule1, simplus]
</pre></div><div class="group"><pre class="example-preformatted">(%i3) infix (&quot;@@&quot;);
(%o3)                          @@
</pre></div><div class="group"><pre class="example-preformatted">(%i4) tellsimp (aa @@ bb, bb/aa);
(%o4)                   [@@rule1, false]
</pre></div><div class="group"><pre class="example-preformatted">(%i5) tellsimpafter (quux (%pi, %e), %pi - %e);
(%o5)                  [quuxrule1, false]
</pre></div><div class="group"><pre class="example-preformatted">(%i6) tellsimpafter (quux (%e, %pi), %pi + %e);
(%o6)             [quuxrule2, quuxrule1, false]
</pre></div><div class="group"><pre class="example-preformatted">(%i7) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
       quux (%e, %pi)];
                                     bb
(%o7) [bb - aa, special_add(aa, bb), --, %pi - %e, %pi + %e]
                                     aa
</pre></div><div class="group"><pre class="example-preformatted">(%i8) remrule (foo, foorule1);
(%o8)                          foo
</pre></div><div class="group"><pre class="example-preformatted">(%i9) remrule (&quot;+&quot;, ?\+rule1);
(%o9)                           +
</pre></div><div class="group"><pre class="example-preformatted">(%i10) remrule (&quot;@@&quot;, ?\@\@rule1);
(%o10)                         @@
</pre></div><div class="group"><pre class="example-preformatted">(%i11) remrule (quux, all);
(%o11)                        quux
</pre></div><div class="group"><pre class="example-preformatted">(%i12) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
        quux (%e, %pi)];
(%o12) [foo(aa, bb), bb + aa, aa @@ bb, quux(%pi, %e), 
                                                   quux(%e, %pi)]
</pre></div></div>

<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
&middot;
</div>
</dd></dl>


<a class="anchor" id="tellsimp"></a><a class="anchor" id="Item_003a-Rules_002fdeffn_002ftellsimp"></a><dl class="first-deffn">
<dt class="deffn" id="index-tellsimp"><span class="category-def">Function: </span><span><strong class="def-name">tellsimp</strong> <var class="def-var-arguments">(<var class="var">pattern</var>, <var class="var">replacement</var>)</var><a class="copiable-link" href='#index-tellsimp'> &para;</a></span></dt>
<dd>
<p>is similar to <code class="code">tellsimpafter</code> but places
new information before old so that it is applied before the built-in
simplification rules.
</p>
<p><code class="code">tellsimp</code> is used when it is important to modify
the expression before the simplifier works on it, for instance if the
simplifier &quot;knows&quot; something about the expression, but what it returns
is not to your liking.
If the simplifier &quot;knows&quot; something about the
main operator of the expression, but is simply not doing enough for
you, you probably want to use <code class="code">tellsimpafter</code>.
</p>
<p>The pattern may not be a
sum, product, single variable, or number.
</p>
<p>The system variable <code class="code">rules</code> is the list of rules defined by
<code class="code">defrule</code>, <code class="code">defmatch</code>, <code class="code">tellsimp</code>, and <code class="code">tellsimpafter</code>.
</p>
<p>Examples:
</p>
<div class="example">
<pre class="example-preformatted">(%i1) matchdeclare (x, freeof (%i));
(%o1)                         done
(%i2) %iargs: false$
(%i3) tellsimp (sin(%i*x), %i*sinh(x));
(%o3)                 [sinrule1, simp-%sin]
(%i4) trigexpand (sin (%i*y + x));
(%o4)         sin(x) cos(%i y) + %i cos(x) sinh(y)
(%i5) %iargs:true$
(%i6) errcatch(0^0);
 0
0  has been generated
(%o6)                          []
(%i7) ev (tellsimp (0^0, 1), simp: false);
(%o7)                  [^rule1, simpexpt]
(%i8) 0^0;
(%o8)                           1
(%i9) remrule (&quot;^&quot;, %th(2)[1]);
(%o9)                           ^
(%i10) tellsimp (sin(x)^2, 1 - cos(x)^2);
(%o10)                 [^rule2, simpexpt]
(%i11) (1 + sin(x))^2;
                                      2
(%o11)                    (sin(x) + 1)
(%i12) expand (%);
                                   2
(%o12)               2 sin(x) - cos (x) + 2
(%i13) sin(x)^2;
                                  2
(%o13)                     1 - cos (x)
(%i14) kill (rules);
(%o14)                        done
(%i15) matchdeclare (a, true);
(%o15)                        done
(%i16) tellsimp (sin(a)^2, 1 - cos(a)^2);
(%o16)                 [^rule3, simpexpt]
(%i17) sin(y)^2;
                                  2
(%o17)                     1 - cos (y)
</pre></div>

<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="tellsimpafter"></a><a class="anchor" id="Item_003a-Rules_002fdeffn_002ftellsimpafter"></a><dl class="first-deffn">
<dt class="deffn" id="index-tellsimpafter"><span class="category-def">Function: </span><span><strong class="def-name">tellsimpafter</strong> <var class="def-var-arguments">(<var class="var">pattern</var>, <var class="var">replacement</var>)</var><a class="copiable-link" href='#index-tellsimpafter'> &para;</a></span></dt>
<dd>
<p>Defines a simplification rule which the Maxima simplifier applies after built-in
simplification rules.  <var class="var">pattern</var> is an expression, comprising pattern
variables (declared by <code class="code">matchdeclare</code>) and other atoms and operators,
considered literals for the purpose of pattern matching.  <var class="var">replacement</var> is
substituted for an actual expression which matches <var class="var">pattern</var>; pattern
variables in <var class="var">replacement</var> are assigned the values matched in the actual
expression.
</p>
<p><var class="var">pattern</var> may be any nonatomic expression in which the main operator is not
a pattern variable; the simplification rule is associated with the main
operator.  The names of functions (with one exception, described below), lists,
and arrays may appear in <var class="var">pattern</var> as the main operator only as literals
(not pattern variables); this rules out expressions such as <code class="code">aa(x)</code> and
<code class="code">bb[y]</code> as patterns, if <code class="code">aa</code> and <code class="code">bb</code> are pattern variables.
Names of functions, lists, and arrays which are pattern variables may appear as
operators other than the main operator in <var class="var">pattern</var>.
</p>
<p>There is one exception to the above rule concerning names of functions.
The name of a subscripted function in an expression such as <code class="code">aa[x](y)</code>
may be a pattern variable, because the main operator is not <code class="code">aa</code> but rather
the Lisp atom <code class="code">mqapply</code>.  This is a consequence of the representation of
expressions involving subscripted functions.
</p>

<p>Simplification rules are applied after evaluation 
(if not suppressed through quotation or the flag <code class="code">noeval</code>).
Rules established by <code class="code">tellsimpafter</code> are applied in the order they were
defined, and after any built-in rules.
Rules are applied bottom-up, that is,
applied first to subexpressions before application to the whole expression.
It may be necessary to repeatedly simplify a result (for example, via the
quote-quote operator <code class="code">'<!-- /@w -->'</code> or the flag <code class="code">infeval</code>)
to ensure that all rules are applied.
</p>
<p>Pattern variables are treated as local variables in simplification rules.
Once a rule is defined, the value of a pattern variable
does not affect the rule, and is not affected by the rule.
An assignment to a pattern variable which results from a successful rule match
does not affect the current assignment (or lack of it) of the pattern variable.
However, as with all atoms in Maxima, the properties of pattern variables (as
declared by <code class="code">put</code> and related functions) are global.
</p>
<p>The rule constructed by <code class="code">tellsimpafter</code> is named after the main operator of
<var class="var">pattern</var>.  Rules for built-in operators, and user-defined operators defined
by <code class="code">infix</code>, <code class="code">prefix</code>, <code class="code">postfix</code>, <code class="code">matchfix</code>, and
<code class="code">nofix</code>, have names which are Lisp identifiers.
Rules for other functions have names which are Maxima identifiers.
</p>
<p>The treatment of noun and verb forms is slightly confused.  If a rule is defined for a noun (or verb) form
and a rule for the corresponding verb (or noun) form already exists, 
the newly-defined rule applies to both forms (noun and verb).
If a rule for the corresponding verb (or noun) form does not exist,
the newly-defined rule applies only to the noun (or verb) form.
</p>
<p>The rule constructed by <code class="code">tellsimpafter</code> is an ordinary Lisp function.
If the name of the rule is <code class="code">$foorule1</code>,
the construct <code class="code">:lisp (trace $foorule1)</code> traces the function,
and <code class="code">:lisp (symbol-function '$foorule1)</code> displays its definition.
</p>
<p><code class="code">tellsimpafter</code> quotes its arguments.
<code class="code">tellsimpafter</code> returns the list of rules for the main operator of
<var class="var">pattern</var>, including the newly established rule.
</p>
<p>See also <code class="code"><a class="ref" href="#matchdeclare">matchdeclare</a></code>, <code class="code"><a class="ref" href="#defmatch">defmatch</a></code>, <code class="code"><a class="ref" href="#defrule">defrule</a></code>, <code class="code"><a class="ref" href="#tellsimp">tellsimp</a></code>,
<code class="code"><a class="ref" href="#let">let</a></code>, <code class="code"><a class="ref" href="maxima_3.html#kill">kill</a></code>, <code class="code"><a class="ref" href="#remrule">remrule</a></code> and <code class="code"><a class="ref" href="#clear_005frules">clear_rules</a></code>.
</p>
<p>Examples:
</p>
<p><var class="var">pattern</var> may be any nonatomic expression in which the 
main operator is not a pattern variable.
</p>
<div class="example">
<pre class="example-preformatted">(%i1) matchdeclare (aa, atom, [ll, mm], listp, xx, true)$
</pre><div class="group"><pre class="example-preformatted">(%i2) tellsimpafter (sin (ll), map (sin, ll));
(%o2)                 [sinrule1, simp-%sin]
</pre></div><div class="group"><pre class="example-preformatted">(%i3) sin ([1/6, 1/4, 1/3, 1/2, 1]*%pi);
                    1     1     sqrt(3)
(%o3)              [-, -------, -------, 1, 0]
                    2  sqrt(2)     2
</pre></div><div class="group"><pre class="example-preformatted">(%i4) tellsimpafter (ll^mm, map (&quot;^&quot;, ll, mm));
(%o4)                  [^rule1, simpexpt]
</pre></div><div class="group"><pre class="example-preformatted">(%i5) [a, b, c]^[1, 2, 3];
                                2   3
(%o5)                      [a, b , c ]
</pre></div><div class="group"><pre class="example-preformatted">(%i6) tellsimpafter (foo (aa (xx)), aa (foo (xx)));
(%o6)                   [foorule1, false]
</pre></div><div class="group"><pre class="example-preformatted">(%i7) foo (bar (u - v));
(%o7)                    bar(foo(u - v))
</pre></div></div>

<p>Rules are applied in the order they were defined.
If two rules can match an expression,
the rule which was defined first is applied.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) matchdeclare (aa, integerp);
(%o1)                         done
</pre></div><div class="group"><pre class="example-preformatted">(%i2) tellsimpafter (foo (aa), bar_1 (aa));
(%o2)                   [foorule1, false]
</pre></div><div class="group"><pre class="example-preformatted">(%i3) tellsimpafter (foo (aa), bar_2 (aa));
(%o3)              [foorule2, foorule1, false]
</pre></div><div class="group"><pre class="example-preformatted">(%i4) foo (42);
(%o4)                       bar_1(42)
</pre></div></div>

<p>Pattern variables are treated as local variables in simplification rules.
(Compare to <code class="code">defmatch</code>, which treats pattern variables as global
variables.)
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) matchdeclare (aa, integerp, bb, atom);
(%o1)                         done
</pre></div><div class="group"><pre class="example-preformatted">(%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
(%o2)                   [foorule1, false]
</pre></div><div class="group"><pre class="example-preformatted">(%i3) bb: 12345;
(%o3)                         12345
</pre></div><div class="group"><pre class="example-preformatted">(%i4) foo (42, %e);
(%o4)                 bar(aa = 42, bb = %e)
</pre></div><div class="group"><pre class="example-preformatted">(%i5) bb;
(%o5)                         12345
</pre></div></div>

<p>As with all atoms, properties of pattern variables are global even though values
are local.  In this example, an assignment property is declared via
<code class="code">define_variable</code>.  This is a property of the atom <code class="code">bb</code> throughout
Maxima.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) matchdeclare (aa, integerp, bb, atom);
(%o1)                         done
</pre></div><div class="group"><pre class="example-preformatted">(%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
(%o2)                   [foorule1, false]
</pre></div><div class="group"><pre class="example-preformatted">(%i3) foo (42, %e);
(%o3)                 bar(aa = 42, bb = %e)
</pre></div><div class="group"><pre class="example-preformatted">(%i4) define_variable (bb, true, boolean);
(%o4)                         true
</pre></div><div class="group"><pre class="example-preformatted">(%i5) foo (42, %e);
translator: bb was declared with mode boolean, but it has value: 
                                                               %e
 -- an error. To debug this try: debugmode(true);
</pre></div></div>

<p>Rules are named after main operators.
Names of rules for built-in and user-defined operators are Lisp identifiers,
while names for other functions are Maxima identifiers.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) tellsimpafter (foo (%pi + %e), 3*%pi);
(%o1)                   [foorule1, false]
</pre></div><div class="group"><pre class="example-preformatted">(%i2) tellsimpafter (foo (%pi * %e), 17*%e);
(%o2)              [foorule2, foorule1, false]
</pre></div><div class="group"><pre class="example-preformatted">(%i3) tellsimpafter (foo (%i ^ %e), -42*%i);
(%o3)         [foorule3, foorule2, foorule1, false]
</pre></div><div class="group"><pre class="example-preformatted">(%i4) tellsimpafter (foo (9) + foo (13), quux (22));
(%o4)                   [+rule1, simplus]
</pre></div><div class="group"><pre class="example-preformatted">(%i5) tellsimpafter (foo (9) * foo (13), blurf (22));
(%o5)                  [*rule1, simptimes]
</pre></div><div class="group"><pre class="example-preformatted">(%i6) tellsimpafter (foo (9) ^ foo (13), mumble (22));
(%o6)                  [^rule1, simpexpt]
</pre></div><div class="group"><pre class="example-preformatted">(%i7) rules;
(%o7) [foorule1, foorule2, foorule3, +rule1, *rule1, ^rule1]
</pre></div><div class="group"><pre class="example-preformatted">(%i8) foorule_name: first (%o1);
(%o8)                       foorule1
</pre></div><div class="group"><pre class="example-preformatted">(%i9) plusrule_name: first (%o4);
(%o9)                        +rule1
</pre></div><div class="group"><pre class="example-preformatted">(%i10) remrule (foo, foorule1);
(%o10)                         foo
</pre></div><div class="group"><pre class="example-preformatted">(%i11) remrule (&quot;^&quot;, ?\^rule1);
(%o11)                          ^
</pre></div><div class="group"><pre class="example-preformatted">(%i12) rules;
(%o12)        [foorule2, foorule3, +rule1, *rule1]
</pre></div></div>

<p>A worked example: anticommutative multiplication.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) gt (i, j) := integerp(j) and i &lt; j;
(%o1)          gt(i, j) := integerp(j) and (i &lt; j)
</pre></div><div class="group"><pre class="example-preformatted">(%i2) matchdeclare (i, integerp, j, gt(i));
(%o2)                         done
</pre></div><div class="group"><pre class="example-preformatted">(%i3) tellsimpafter (s[i]^^2, 1);
(%o3)                 [^^rule1, simpncexpt]
</pre></div><div class="group"><pre class="example-preformatted">(%i4) tellsimpafter (s[i] . s[j], -s[j] . s[i]);
(%o4)                   [.rule1, simpnct]
</pre></div><div class="group"><pre class="example-preformatted">(%i5) s[1] . (s[1] + s[2]);
(%o5)                    s  . (s  + s )
                          1     2    1
</pre></div><div class="group"><pre class="example-preformatted">(%i6) expand (%);
(%o6)                      1 - s  . s
                                2    1
</pre></div><div class="group"><pre class="example-preformatted">(%i7) factor (expand (sum (s[i], i, 0, 9)^^5));
(%o7) 100 (s  + s  + s  + s  + s  + s  + s  + s  + s  + s )
            9    8    7    6    5    4    3    2    1    0
</pre></div></div>

<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="clear_005frules"></a><a class="anchor" id="Item_003a-Rules_002fdeffn_002fclear_005frules"></a><dl class="first-deffn">
<dt class="deffn" id="index-clear_005frules"><span class="category-def">Function: </span><span><strong class="def-name">clear_rules</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href='#index-clear_005frules'> &para;</a></span></dt>
<dd>
<p>Executes <code class="code">kill (rules)</code> and then resets the next rule number to 1
for addition <code class="code">+</code>, multiplication <code class="code">*</code>, and exponentiation <code class="code">^</code>.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Rules-and-patterns">Rules and patterns</a>
&middot;
</div>
</dd></dl>


</div>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="maxima_34.html#Sets" accesskey="n" rel="next">Sets</a>, Previous: <a href="maxima_32.html#Miscellaneous-Options" accesskey="p" rel="prev">Miscellaneous Options</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
