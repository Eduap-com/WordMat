<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.0.3, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>to_poly_solve-pkg (Maxima 5.47.0 Manual)</title>

<meta name="description" content="to_poly_solve-pkg (Maxima 5.47.0 Manual)">
<meta name="keywords" content="to_poly_solve-pkg (Maxima 5.47.0 Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="maxima_toc.html" rel="start" title="Top">
<link href="Function-and-Variable-Index.html" rel="index" title="Function and Variable Index">
<link href="maxima_toc.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="maxima_toc.html" rel="up" title="Top">
<link href="maxima_92.html#unit_002dpkg" rel="next" title="unit-pkg">
<link href="maxima_90.html#stringproc_002dpkg" rel="prev" title="stringproc-pkg">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
ul.mark-bullet {list-style-type: disc}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 1em; padding-bottom: 1em;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%; display: block; margin-left: auto; margin-right: auto}

-->
</style>

<script type='text/javascript'>
MathJax = {
  options: {
    skipHtmlTags: {'[-]': ['pre']},
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
};
</script><script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>
</head>

<body lang="en" class="tex2jax_ignore">
<div class="chapter-level-extent" id="to_005fpoly_005fsolve_002dpkg">
<div class="nav-panel">
<p>
Next: <a href="maxima_92.html#unit_002dpkg" accesskey="n" rel="next">unit</a>, Previous: <a href="maxima_90.html#stringproc_002dpkg" accesskey="p" rel="prev">stringproc</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<h2 class="chapter" id="to_005fpoly_005fsolve">92 to_poly_solve</h2>

<a class="anchor" id="Item_003a-to_005fpoly_005fsolve_002fnode_002fFunctions-and-Variables-for-to_005fpoly_005fsolve"></a><ul class="mini-toc">
<li><a href="#Functions-and-Variables-for-to_005fpoly_005fsolve" accesskey="1">Functions and Variables for to_poly_solve</a></li>
</ul>
<hr>
<div class="section-level-extent" id="Functions-and-Variables-for-to_005fpoly_005fsolve">
<div class="nav-panel">
<p>
Previous: <a href="#to_005fpoly_005fsolve_002dpkg" accesskey="p" rel="prev">to_poly_solve</a>, Up: <a href="#to_005fpoly_005fsolve_002dpkg" accesskey="u" rel="up">to_poly_solve</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Functions-and-Variables-for-to_005fpoly_005fsolve-1">92.1 Functions and Variables for to_poly_solve</h3>

<p>The packages <code class="code">to_poly</code> and <code class="code">to_poly_solve</code> are experimental;
the specifications of the functions in these packages might change or
the some of the functions in these packages might be merged into other
Maxima functions.
</p>
<p>Barton Willis (Professor of Mathematics, University of Nebraska at
Kearney) wrote the <code class="code">to_poly</code> and <code class="code">to_poly_solve</code> packages and the
English language user documentation for these packages.
</p>
<a class="anchor" id="Item_003a-to_005fpoly_005fsolve_002fdeffn_002f_0025and"></a><dl class="first-deffn">
<dt class="deffn" id="index-_0025and"><span class="category-def">Operator: </span><span><strong class="def-name">%and</strong><a class="copiable-link" href='#index-_0025and'> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-Logical-conjunction-1"></a>

<p>The operator <code class="code">%and</code> is a simplifying nonshort-circuited logical
conjunction.  Maxima simplifies an <code class="code">%and</code> expression to either true,
false, or a logically equivalent, but simplified, expression.  The
operator <code class="code">%and</code> is associative, commutative, and idempotent.  Thus
when <code class="code">%and</code> returns a noun form, the arguments of <code class="code">%and</code> form
a non-redundant sorted list; for example
</p>
<div class="example">
<pre class="example-preformatted">(%i1) a %and (a %and b);
(%o1)                       a %and b
</pre></div>

<p>If one argument to a conjunction is the <i class="i">explicit</i> the negation of another
argument, <code class="code">%and</code> returns false:
</p>
<div class="example">
<pre class="example-preformatted">(%i2) a %and (not a);
(%o2)                         false
</pre></div>

<p>If any member of the conjunction is false, the conjunction simplifies
to false even if other members are manifestly non-boolean; for example
</p>
<div class="example">
<pre class="example-preformatted">(%i3) 42 %and false;
(%o3)                         false
</pre></div>

<p>Any argument of an <code class="code">%and</code> expression that is an inequation (that
is, an inequality or equation), is simplified using the Fourier
elimination package.  The Fourier elimination simplifier has a
pre-processor that converts some, but not all, nonlinear inequations
into linear inequations; for example the Fourier elimination code
simplifies <code class="code">abs(x) + 1 &gt; 0</code> to true, so
</p>
<div class="example">
<pre class="example-preformatted">(%i4) (x &lt; 1) %and (abs(x) + 1 &gt; 0);
(%o4)                         x &lt; 1
</pre></div>

<p><b class="b">Notes</b>  
</p><ul class="itemize mark-bullet">
<li>The option variable <code class="code">prederror</code> does <i class="i">not</i> alter the
simplification <code class="code">%and</code> expressions.

</li><li>To avoid operator precedence errors, compound expressions
involving the operators <code class="code">%and, %or</code>, and <code class="code">not</code> should be
fully parenthesized.

</li><li>The Maxima operators <code class="code">and</code> and <code class="code">or</code> are both
short-circuited.  Thus <code class="code">and</code> isn&rsquo;t associative or commutative.

</li></ul>

<p><b class="b">Limitations</b> The conjunction <code class="code">%and</code> simplifies inequations
<i class="i">locally, not globally</i>.  This means that conjunctions such as
</p>
<div class="example">
<pre class="example-preformatted">(%i5) (x &lt; 1) %and (x &gt; 1);
(%o5)                 (x &gt; 1) %and (x &lt; 1)
</pre></div>

<p>do <i class="i">not</i> simplify to false.  Also, the Fourier elimination code <i class="i">ignores</i>
the fact database;
</p>
<div class="example">
<pre class="example-preformatted">(%i6) assume(x &gt; 5);
(%o6)                        [x &gt; 5]
(%i7) (x &gt; 1) %and (x &gt; 2);
(%o7)                 (x &gt; 1) %and (x &gt; 2)
</pre></div>

<p>Finally, nonlinear inequations that aren&rsquo;t easily converted into an
equivalent linear inequation aren&rsquo;t simplified.
</p>
<p>There is no support for distributing <code class="code">%and</code> over <code class="code">%or</code>;
neither is there support for distributing a logical negation over
<code class="code">%and</code>.
</p>
<p><b class="b">To use</b> <code class="code">load(&quot;to_poly_solve&quot;)</code>
</p>
<p><b class="b">Related functions</b> <code class="code">%or, %if, and, or, not</code>
</p>
<p><b class="b">Status</b> The operator <code class="code">%and</code> is experimental; the
specifications of this function might change and its functionality
might be merged into other Maxima functions.
</p>
</dd></dl>

<a class="anchor" id="Item_003a-to_005fpoly_005fsolve_002fdeffn_002f_0025if"></a><dl class="first-deffn">
<dt class="deffn" id="index-_0025if"><span class="category-def">Operator: </span><span><strong class="def-name">%if</strong> <var class="def-var-arguments">(<var class="var">bool</var>, <var class="var">a</var>, <var class="var">b</var>)</var><a class="copiable-link" href='#index-_0025if'> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-conditional-evaluation"></a>

<p>The operator <code class="code">%if</code> is a simplifying conditional.  The
<i class="i">conditional</i> <var class="var">bool</var> should be boolean-valued.  When the
conditional is true, return the second argument; when the conditional is
false, return the third; in all other cases, return a noun form.
</p>
<p>Maxima inequations (either an inequality or an equality) are <i class="i">not</i>
boolean-valued; for example, Maxima does <i class="i">not</i> simplify <em class="math tex2jax_process">\(5 < 6\)</em>
to true, and it does not simplify <em class="math tex2jax_process">\(5 = 6\)</em> to false; however, in
the context of a conditional to an <code class="code">%if</code> statement, Maxima
<i class="i">automatically</i> attempts to determine the truth value of an
inequation.  Examples:
</p>
<div class="example">
<pre class="example-preformatted">(%i1) f : %if(x # 1, 2, 8);
(%o1)                 %if(x - 1 # 0, 2, 8)
(%i2) [subst(x = -1,f), subst(x=1,f)];
(%o2)                        [2, 8]
</pre></div>

<p>If the conditional involves an inequation, Maxima simplifies it using
the Fourier elimination package.
</p>
<p><b class="b">Notes</b> 
</p>
<ul class="itemize mark-bullet">
<li>If the conditional is manifestly non-boolean, Maxima returns a noun form:
</li></ul>

<div class="example">
<pre class="example-preformatted">(%i3) %if(42,1,2);
(%o3)                     %if(42, 1, 2)
</pre></div>

<ul class="itemize mark-bullet">
<li>The Maxima operator <code class="code">if</code> is nary, the operator <code class="code">%if</code> <i class="i">isn&rsquo;t</i>
nary.
</li></ul>

<p><b class="b">Limitations</b> The Fourier elimination code only simplifies nonlinear
inequations that are readily convertible to an equivalent linear
inequation.
</p>
<p><b class="b">To use:</b> <code class="code">load(&quot;to_poly_solve&quot;)</code>
</p>
<p><b class="b">Status:</b> The operator <code class="code">%if</code> is experimental; its
specifications might change and its functionality might be merged into
other Maxima functions.
</p>
</dd></dl>
  
<a class="anchor" id="Item_003a-to_005fpoly_005fsolve_002fdeffn_002f_0025or"></a><dl class="first-deffn">
<dt class="deffn" id="index-_0025or"><span class="category-def">Operator: </span><span><strong class="def-name">%or</strong><a class="copiable-link" href='#index-_0025or'> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-Logical-disjunction-1"></a>

<p>The operator <code class="code">%or</code> is a simplifying nonshort-circuited logical
disjunction.  Maxima simplifies an <code class="code">%or</code> expression to either
true, false, or a logically equivalent, but simplified,
expression.  The operator <code class="code">%or</code> is associative, commutative, and
idempotent.  Thus when <code class="code">%or</code> returns a noun form, the arguments
of <code class="code">%or</code> form a non-redundant sorted list; for example
</p>
<div class="example">
<pre class="example-preformatted">(%i1) a %or (a %or b);
(%o1)                        a %or b
</pre></div>

<p>If one member of the disjunction is the <i class="i">explicit</i> the negation of another
member, <code class="code">%or</code> returns true:
</p>
<div class="example">
<pre class="example-preformatted">(%i2) a %or (not a);
(%o2)                         true
</pre></div>

<p>If any member of the disjunction is true, the disjunction simplifies
to true even if other members of the disjunction are manifestly non-boolean;
for example
</p>
<div class="example">
<pre class="example-preformatted">(%i3) 42 %or true;
(%o3)                         true
</pre></div>

<p>Any argument of an <code class="code">%or</code> expression that is an inequation (that
is, an inequality or equation), is simplified using the Fourier
elimination package.  The Fourier elimination code simplifies
<code class="code">abs(x) + 1 &gt; 0</code> to true, so we have
</p>
<div class="example">
<pre class="example-preformatted">(%i4) (x &lt; 1) %or (abs(x) + 1 &gt; 0);
(%o4)                         true
</pre></div>

<p><b class="b">Notes</b>  
</p><ul class="itemize mark-bullet">
<li>The option variable <code class="code">prederror</code> does <i class="i">not</i> alter the 
simplification of <code class="code">%or</code> expressions.

</li><li>You should parenthesize compound expressions involving the
operators <code class="code">%and, %or</code>, and <code class="code">not</code>; the binding powers of these
operators might not match your expectations.

</li><li>The Maxima operators <code class="code">and</code> and <code class="code">or</code> are both short-circuited.
Thus <code class="code">or</code> isn&rsquo;t associative or commutative.

</li></ul>

<p><b class="b">Limitations</b> The conjunction <code class="code">%or</code> simplifies inequations
<i class="i">locally, not globally</i>.  This means that conjunctions such as
</p>

<div class="example">
<pre class="example-preformatted">(%i1) (x &lt; 1) %or (x &gt;= 1);
(%o1) (x &gt; 1) %or (x &gt;= 1)
</pre></div>

<p>do <i class="i">not</i> simplify to true.  Further, the Fourier elimination code ignores
the fact database;
</p>
<div class="example">
<pre class="example-preformatted">(%i2) assume(x &gt; 5);
(%o2)                        [x &gt; 5]
(%i3) (x &gt; 1) %and (x &gt; 2);
(%o3)                 (x &gt; 1) %and (x &gt; 2)
</pre></div>

<p>Finally, nonlinear inequations that aren&rsquo;t easily converted into an
equivalent linear inequation aren&rsquo;t simplified.
</p>
<p>The algorithm that looks for terms that cannot both be false is weak;
also there is no support for distributing <code class="code">%or</code> over <code class="code">%and</code>;
neither is there support for distributing a logical negation over
<code class="code">%or</code>.
</p>
<p><b class="b">To use</b> <code class="code">load(&quot;to_poly_solve&quot;)</code>
</p>
<p><b class="b">Related functions</b> <code class="code">%or, %if, and, or, not</code>
</p>
<p><b class="b">Status</b> The operator <code class="code">%or</code> is experimental; the
specifications of this function might change and its functionality
might be merged into other Maxima functions.
</p>
</dd></dl>

<a class="anchor" id="complex_005fnumber_005fp"></a><a class="anchor" id="Item_003a-to_005fpoly_005fsolve_002fdeffn_002fcomplex_005fnumber_005fp"></a><dl class="first-deffn">
<dt class="deffn" id="index-complex_005fnumber_005fp"><span class="category-def">Function: </span><span><strong class="def-name">complex_number_p</strong> <var class="def-var-arguments">(<var class="var">x</var>)</var><a class="copiable-link" href='#index-complex_005fnumber_005fp'> &para;</a></span></dt>
<dd>
<p>The predicate <code class="code">complex_number_p</code> returns true if its argument is
either <code class="code">a + %i * b</code>, <code class="code">a</code>, <code class="code">%i b</code>, or <code class="code">%i</code>,
where <code class="code">a</code> and <code class="code">b</code> are either rational or floating point
numbers (including big floating point); for all other inputs,
<code class="code">complex_number_p</code> returns false; for example
</p>
<div class="example">
<pre class="example-preformatted">(%i1) map('complex_number_p,[2/3, 2 + 1.5 * %i, %i]);
(%o1)                  [true, true, true]
(%i2) complex_number_p((2+%i)/(5-%i));
(%o2)                         false
(%i3) complex_number_p(cos(5 - 2 * %i));
(%o3)                         false
</pre></div>

<p><b class="b">Related functions</b> <code class="code">isreal_p</code>
</p>
<p><b class="b">To use</b> <code class="code">load(&quot;to_poly_solve&quot;)</code>
</p>
<p><b class="b">Status</b> The operator <code class="code">complex_number_p</code> is experimental; its
specifications might change and its functionality might be merged into
other Maxima functions.
</p>
</dd></dl>

<a class="anchor" id="compose_005ffunctions"></a><a class="anchor" id="Item_003a-to_005fpoly_005fsolve_002fdeffn_002fcompose_005ffunctions"></a><dl class="first-deffn">
<dt class="deffn" id="index-compose_005ffunctions"><span class="category-def">Function: </span><span><strong class="def-name">compose_functions</strong> <var class="def-var-arguments">(<var class="var">l</var>)</var><a class="copiable-link" href='#index-compose_005ffunctions'> &para;</a></span></dt>
<dd>
<p>The function call <code class="code">compose_functions(l)</code> returns a lambda form that is
the <i class="i">composition</i> of the functions in the list <var class="var">l</var>.  The functions are
applied from <i class="i">right</i> to <i class="i">left</i>; for example
</p>
<div class="example">
<pre class="example-preformatted">(%i1) compose_functions([cos, exp]);
                                        %g151
(%o1)             lambda([%g151], cos(%e     ))
(%i2) %(x);
                                  x
(%o2)                       cos(%e )
</pre></div>

<p>When the function list is empty, return the identity function:
</p>
<div class="example">
<pre class="example-preformatted">(%i3) compose_functions([]);
(%o3)                lambda([%g152], %g152)
(%i4)  %(x);
(%o4)                           x
</pre></div>

<p><b class="b">Notes</b> 
</p><ul class="itemize mark-bullet">
<li>When Maxima determines that a list member isn&rsquo;t a symbol or
a lambda form, <code class="code">funmake</code> (<i class="i">not</i> <code class="code">compose_functions</code>)
signals an error:
</li></ul>

<div class="example">
<pre class="example-preformatted">(%i5) compose_functions([a &lt; b]);

funmake: first argument must be a symbol, subscripted symbol,
string, or lambda expression; found: a &lt; b
#0: compose_functions(l=[a &lt; b])(to_poly_solve.mac line 40)
 -- an error. To debug this try: debugmode(true);
</pre></div>

<ul class="itemize mark-bullet">
<li>To avoid name conflicts, the independent variable is determined by the
function <code class="code">new_variable</code>.

<div class="example">
<pre class="example-preformatted">(%i6) compose_functions([%g0]);
(%o6)              lambda([%g154], %g0(%g154))
(%i7) compose_functions([%g0]);
(%o7)              lambda([%g155], %g0(%g155))
</pre></div>

<p>Although the independent variables are different, Maxima is able to to
deduce that these lambda forms are semantically equal:
</p>
<div class="example">
<pre class="example-preformatted">(%i8) is(equal(%o6,%o7));
(%o8)                         true
</pre></div>
</li></ul>

<p><b class="b">To use</b> <code class="code">load(&quot;to_poly_solve&quot;)</code>
</p>
<p><b class="b">Status</b>  The function <code class="code">compose_functions</code> is experimental; its
specifications might change and its functionality might be merged into
other Maxima functions.
</p></dd></dl>

<a class="anchor" id="dfloat"></a><a class="anchor" id="Item_003a-to_005fpoly_005fsolve_002fdeffn_002fdfloat"></a><dl class="first-deffn">
<dt class="deffn" id="index-dfloat"><span class="category-def">Function: </span><span><strong class="def-name">dfloat</strong> <var class="def-var-arguments">(<var class="var">x</var>)</var><a class="copiable-link" href='#index-dfloat'> &para;</a></span></dt>
<dd>
<p>The function <code class="code">dfloat</code> is a similar to <code class="code">float</code>, but the function
<code class="code">dfloat</code> applies <code class="code">rectform</code> when <code class="code">float</code> fails to evaluate
to an IEEE double floating point number; thus
</p>
<div class="example">
<pre class="example-preformatted">(%i1) float(4.5^(1 + %i));
                               %i + 1
(%o1)                       4.5
(%i2) dfloat(4.5^(1 + %i));
(%o2)        4.48998802962884 %i + .3000124893895671
</pre></div>

<p><b class="b">Notes</b> 
</p>
<ul class="itemize mark-bullet">
<li>The rectangular form of an expression might be poorly suited for
numerical evaluation&ndash;for example, the rectangular form might
needlessly involve the difference of floating point numbers
(subtractive cancellation).


</li><li>The identifier <code class="code">float</code> is both an option variable (default
value false) and a function name.


</li></ul>

<p><b class="b">Related functions</b> <code class="code">float, bfloat</code>
</p>
<p><b class="b">To use</b> <code class="code">load(&quot;to_poly_solve&quot;)</code>
</p>
<p><b class="b">Status</b> The function <code class="code">dfloat</code> is experimental; its
specifications might change and its functionality might be merged into
other Maxima functions.
</p>
</dd></dl>

<a class="anchor" id="elim"></a><a class="anchor" id="Item_003a-to_005fpoly_005fsolve_002fdeffn_002felim"></a><dl class="first-deffn">
<dt class="deffn" id="index-elim"><span class="category-def">Function: </span><span><strong class="def-name">elim</strong> <var class="def-var-arguments">(<var class="var">l</var>, <var class="var">x</var>)</var><a class="copiable-link" href='#index-elim'> &para;</a></span></dt>
<dd>
<p>The function <code class="code">elim</code> eliminates the variables in the set or list
<code class="code">x</code> from the equations in the set or list <code class="code">l</code>.  Each member
of <code class="code">x</code> must be a symbol; the members of <code class="code">l</code> can either be
equations, or expressions that are assumed to equal zero.
</p>
<p>The function <code class="code">elim</code> returns a list of two lists; the first is
the list of expressions with the variables eliminated; the second
is the list of pivots; thus, the second list is a list of
expressions that <code class="code">elim</code> used to eliminate the variables.
</p>
<p>Here is an example of eliminating between linear equations:
</p>
<div class="example">
<pre class="example-preformatted">(%i1) elim(set(x + y + z = 1, x - y  - z = 8, x - z = 1), 
           set(x,y));
(%o1)            [[2 z - 7], [y + 7, z - x + 1]]
</pre></div>

<p>Eliminating <code class="code">x</code> and <code class="code">y</code> yields the single equation <code class="code">2 z - 7 = 0</code>;
the equations <code class="code">y + 7 = 0</code> and <code class="code">z - z + 1 = 1</code> were used as pivots.
Eliminating all three variables from these equations, triangularizes the linear
system:
</p>
<div class="example">
<pre class="example-preformatted">(%i2) elim(set(x + y + z = 1, x - y  - z = 8, x - z = 1),
           set(x,y,z));
(%o2)           [[], [2 z - 7, y + 7, z - x + 1]]
</pre></div>

<p>Of course, the equations needn&rsquo;t be linear:
</p>
<div class="example">
<pre class="example-preformatted">(%i3) elim(set(x^2 - 2 * y^3 = 1,  x - y = 5), [x,y]);
                     3    2
(%o3)       [[], [2 y  - y  - 10 y - 24, y - x + 5]]
</pre></div>

<p>The user doesn&rsquo;t control the order the variables are
eliminated.  Instead, the algorithm uses a heuristic to <i class="i">attempt</i> to
choose the best pivot and the best elimination order.
</p>
<p><b class="b">Notes</b> 
</p>
<ul class="itemize mark-bullet">
<li>Unlike the related function <code class="code">eliminate</code>, the function
<code class="code">elim</code> does <i class="i">not</i> invoke <code class="code">solve</code> when the number of equations
equals the number of variables.

</li><li>The function <code class="code">elim</code> works by applying resultants; the option
variable <code class="code">resultant</code> determines which algorithm Maxima
uses.  Using <code class="code">sqfr</code>, Maxima factors each resultant and suppresses
multiple zeros.

</li><li>The <code class="code">elim</code> will triangularize a nonlinear set of polynomial
equations; the solution set of the triangularized set <i class="i">can</i> be larger
than that solution set of the untriangularized set.  Thus, the triangularized
equations can have <i class="i">spurious</i> solutions.
</li></ul>

<p><b class="b">Related functions</b> <i class="i">elim_allbut, eliminate_using, eliminate</i>
</p>
<p><b class="b">Option variables</b> <i class="i">resultant</i>
</p>
<p><b class="b">To use</b> <code class="code">load(&quot;to_poly&quot;)</code>
</p>
<p><b class="b">Status</b> The function <code class="code">elim</code> is experimental; its
specifications might change and its functionality might be merged into
other Maxima functions.
</p>
</dd></dl>
 
<a class="anchor" id="elim_005fallbut"></a><a class="anchor" id="Item_003a-to_005fpoly_005fsolve_002fdeffn_002felim_005fallbut"></a><dl class="first-deffn">
<dt class="deffn" id="index-elim_005fallbut"><span class="category-def">Function: </span><span><strong class="def-name">elim_allbut</strong> <var class="def-var-arguments">(<var class="var">l</var>, <var class="var">x</var>)</var><a class="copiable-link" href='#index-elim_005fallbut'> &para;</a></span></dt>
<dd>
<p>This function is similar to <code class="code">elim</code>, except that it eliminates all the
variables in the list of equations <code class="code">l</code> <i class="i">except</i> for those variables that
in in the list <code class="code">x</code>
</p>
<div class="example">
<pre class="example-preformatted">(%i1) elim_allbut([x+y = 1, x - 5*y = 1],[]);
(%o1)                 [[], [y, y + x - 1]]
(%i2) elim_allbut([x+y = 1, x - 5*y = 1],[x]);
(%o2)                [[x - 1], [y + x - 1]]
</pre></div>

<p><b class="b">To use</b> <code class="code">load(&quot;to_poly&quot;)</code>
</p>
<p><b class="b">Option variables</b> <i class="i">resultant</i>
</p>
<p><b class="b">Related functions</b> <i class="i">elim, eliminate_using, eliminate</i>
</p>
<p><b class="b">Status</b> The function <code class="code">elim_allbut</code> is experimental; its
specifications might change and its functionality might be merged into
other Maxima functions.
</p>
</dd></dl>

<a class="anchor" id="eliminate_005fusing"></a><a class="anchor" id="Item_003a-to_005fpoly_005fsolve_002fdeffn_002feliminate_005fusing"></a><dl class="first-deffn">
<dt class="deffn" id="index-eliminate_005fusing"><span class="category-def">Function: </span><span><strong class="def-name">eliminate_using</strong> <var class="def-var-arguments">(<var class="var">l</var>, <var class="var">e</var>, <var class="var">x</var>)</var><a class="copiable-link" href='#index-eliminate_005fusing'> &para;</a></span></dt>
<dd>
<p>Using <code class="code">e</code> as the pivot, eliminate the symbol <code class="code">x</code> from the
list or set of equations in <code class="code">l</code>.  The function <code class="code">eliminate_using</code>
returns a set.
</p>
<div class="example">
<pre class="example-preformatted">(%i1) eq : [x^2 - y^2 - z^3 , x*y - z^2 - 5, x - y + z];
               3    2    2     2
(%o1)      [- z  - y  + x , - z  + x y - 5, z - y + x]
(%i2) eliminate_using(eq,first(eq),z);
        3              2      2      3    2
(%o2) {y  + (1 - 3 x) y  + 3 x  y - x  - x , 
                        4    3  3       2  2             4
                       y  - x  y  + 13 x  y  - 75 x y + x  + 125}
(%i3) eliminate_using(eq,second(eq),z);
        2            2       4    3  3       2  2             4
(%o3) {y  - 3 x y + x  + 5, y  - x  y  + 13 x  y  - 75 x y + x
                                                           + 125}
(%i4) eliminate_using(eq, third(eq),z);
        2            2       3              2      2      3    2
(%o4) {y  - 3 x y + x  + 5, y  + (1 - 3 x) y  + 3 x  y - x  - x }
</pre></div>

<p><b class="b">Option variables</b> <i class="i">resultant</i>
</p>
<p><b class="b">Related functions</b> <i class="i">elim, eliminate, elim_allbut</i>
</p>
<p><b class="b">To use</b> <code class="code">load(&quot;to_poly&quot;)</code>
</p>
<p><b class="b">Status</b> The function <code class="code">eliminate_using</code> is experimental; its
specifications might change and its functionality might be merged into
other Maxima functions.
</p>
</dd></dl>

<a class="anchor" id="fourier_005felim"></a><a class="anchor" id="Item_003a-to_005fpoly_005fsolve_002fdeffn_002ffourier_005felim"></a><dl class="first-deffn">
<dt class="deffn" id="index-fourier_005felim"><span class="category-def">Function: </span><span><strong class="def-name">fourier_elim</strong> <var class="def-var-arguments">([<var class="var">eq1</var>, <var class="var">eq2</var>, &hellip;], [<var class="var">var1</var>, <var class="var">var</var>, &hellip;])</var><a class="copiable-link" href='#index-fourier_005felim'> &para;</a></span></dt>
<dd>
<p>Fourier elimination is the analog of Gauss elimination for linear inequations
(equations or inequalities).  The function call <code class="code">fourier_elim([eq1, eq2,
...], [var1, var2, ...])</code> does Fourier elimination on a list of linear
inequations <code class="code">[eq1, eq2, ...]</code> with respect to the variables
<code class="code">[var1, var2, ...]</code>; for example
</p>
<div class="example">
<pre class="example-preformatted">(%i1) fourier_elim([y-x &lt; 5, x - y &lt; 7, 10 &lt; y],[x,y]);
(%o1)            [y - 5 &lt; x, x &lt; y + 7, 10 &lt; y]
(%i2) fourier_elim([y-x &lt; 5, x - y &lt; 7, 10 &lt; y],[y,x]);
(%o2)        [max(10, x - 7) &lt; y, y &lt; x + 5, 5 &lt; x]
</pre></div>

<p>Eliminating first with respect to <em class="math tex2jax_process">\(x\)</em> and second with respect to
<em class="math tex2jax_process">\(y\)</em> yields lower and upper bounds for <em class="math tex2jax_process">\(x\)</em> that depend on
<em class="math tex2jax_process">\(y\)</em>, and lower and upper bounds for <em class="math tex2jax_process">\(y\)</em> that are numbers.
Eliminating in the other order gives <em class="math tex2jax_process">\(x\)</em> dependent lower and
upper bounds for <em class="math tex2jax_process">\(y\)</em>, and numerical lower and upper bounds for
<em class="math tex2jax_process">\(x\)</em>.
</p>
<p>When necessary, <code class="code">fourier_elim</code> returns a <em class="emph">disjunction</em> of lists of
inequations:
</p>
<div class="example">
<pre class="example-preformatted">(%i3) fourier_elim([x # 6],[x]);
(%o3)                  [x &lt; 6] or [6 &lt; x]
</pre></div>

<p>When the solution set is empty,  <code class="code">fourier_elim</code> returns <code class="code">emptyset</code>,
and when the solution set is all reals, <code class="code">fourier_elim</code> returns <code class="code">universalset</code>;
for example
</p>
<div class="example">
<pre class="example-preformatted">(%i4) fourier_elim([x &lt; 1, x &gt; 1],[x]);
(%o4)                       emptyset
(%i5) fourier_elim([minf &lt; x, x &lt; inf],[x]);
(%o5)                     universalset
</pre></div>

<p>For nonlinear inequations, <code class="code">fourier_elim</code> returns a (somewhat) 
simplified list of inequations:
</p>
<div class="example">
<pre class="example-preformatted">(%i6) fourier_elim([x^3 - 1 &gt; 0],[x]);
</pre><div class="group"><pre class="example-preformatted">               2                             2
(%o6) [1 &lt; x, x  + x + 1 &gt; 0] or [x &lt; 1, - (x  + x + 1) &gt; 0]
</pre></div><pre class="example-preformatted">(%i7) fourier_elim([cos(x) &lt; 1/2],[x]);
(%o7)                  [1 - 2 cos(x) &gt; 0]
</pre></div>

<p>Instead of a list of inequations, the first argument to <code class="code">fourier_elim</code>
may be a logical disjunction or conjunction:
</p>
<div class="example">
<pre class="example-preformatted">(%i8) fourier_elim((x + y &lt; 5) and (x - y &gt;8),[x,y]);
                                              3
(%o8)            [y + 8 &lt; x, x &lt; 5 - y, y &lt; - -]
                                              2
(%i9) fourier_elim(((x + y &lt; 5) and x &lt; 1) or  (x - y &gt;8),[x,y]);
(%o9)          [y + 8 &lt; x] or [x &lt; min(1, 5 - y)]
</pre></div>

<p>The function <code class="code">fourier_elim</code> supports the inequation operators 
<code class="code">&lt;, &lt;=, &gt;, &gt;=, #</code>, and <code class="code">=</code>.
</p>
<p>The Fourier elimination code has a preprocessor that converts some
nonlinear inequations that involve the absolute value, minimum, and
maximum functions into linear in equations.  Additionally, the preprocessor
handles some expressions that are the product or quotient of linear terms:
</p>
<div class="example">
<pre class="example-preformatted">(%i10) fourier_elim([max(x,y) &gt; 6, x # 8, abs(y-1) &gt; 12],[x,y]);
(%o10) [6 &lt; x, x &lt; 8, y &lt; - 11] or [8 &lt; x, y &lt; - 11]
 or [x &lt; 8, 13 &lt; y] or [x = y, 13 &lt; y] or [8 &lt; x, x &lt; y, 13 &lt; y]
 or [y &lt; x, 13 &lt; y]
(%i11) fourier_elim([(x+6)/(x-9) &lt;= 6],[x]);
(%o11)           [x = 12] or [12 &lt; x] or [x &lt; 9]
(%i12) fourier_elim([x^2 - 1 # 0],[x]);
(%o12)      [- 1 &lt; x, x &lt; 1] or [1 &lt; x] or [x &lt; - 1]
</pre></div>

<p><b class="b">To use</b> <code class="code">load(&quot;fourier_elim&quot;)</code>
</p>
</dd></dl>

<a class="anchor" id="isreal_005fp"></a><a class="anchor" id="Item_003a-to_005fpoly_005fsolve_002fdeffn_002fisreal_005fp"></a><dl class="first-deffn">
<dt class="deffn" id="index-isreal_005fp"><span class="category-def">Function: </span><span><strong class="def-name">isreal_p</strong> <var class="def-var-arguments">(<var class="var">e</var>)</var><a class="copiable-link" href='#index-isreal_005fp'> &para;</a></span></dt>
<dd>
<p>The predicate <code class="code">isreal_p</code> returns true when Maxima is able to
determine that <code class="code">e</code> is real-valued on the <i class="i">entire</i> real line; it
returns false when Maxima is able to determine that <code class="code">e</code> <i class="i">isn&rsquo;t</i>
real-valued on some nonempty subset of the real line; and it returns a
noun form for all other cases.
</p>
<div class="example">
<pre class="example-preformatted">(%i1) map('isreal_p, [-1, 0, %i, %pi]);
(%o1)               [true, true, false, true]
</pre></div>

<p>Maxima variables are assumed to be real; thus
</p>
<div class="example">
<pre class="example-preformatted">(%i2) isreal_p(x);
(%o2)                         true
</pre></div>

<p>The function <code class="code">isreal_p</code> examines the fact database:
</p>
<div class="example">
<pre class="example-preformatted">(%i3) declare(z,complex)$

(%i4) isreal_p(z);
(%o4)                      isreal_p(z)
</pre></div>

<p><b class="b">Limitations</b>
Too often, <code class="code">isreal_p</code> returns a noun form when it should be able
to return false; a simple example: the logarithm function isn&rsquo;t
real-valued on the entire real line, so <code class="code">isreal_p(log(x))</code> should
return false; however
</p>
<div class="example">
<pre class="example-preformatted">(%i5) isreal_p(log(x));
(%o5)                   isreal_p(log(x))
</pre></div>

<p><b class="b">To use</b> <code class="code">load(&quot;to_poly_solve&quot;)</code>
</p>
<p><b class="b">Related functions</b> <i class="i">complex_number_p</i>
</p>
<p><b class="b">Status</b> The function <code class="code">isreal_p</code> is experimental; its
specifications might change and its functionality might be merged into
other Maxima functions.
</p></dd></dl>


<a class="anchor" id="new_005fvariable"></a><a class="anchor" id="Item_003a-to_005fpoly_005fsolve_002fdeffn_002fnew_005fvariable"></a><dl class="first-deffn">
<dt class="deffn" id="index-new_005fvariable"><span class="category-def">Function: </span><span><strong class="def-name">new_variable</strong> <var class="def-var-arguments">(type)</var><a class="copiable-link" href='#index-new_005fvariable'> &para;</a></span></dt>
<dd>
<p>Return a unique symbol of the form <code class="code">%[z,n,r,c,g]k</code>, where
<code class="code">k</code> is an integer.  The allowed values for <em class="math tex2jax_process">\(type\)</em> are
<i class="i">integer, natural_number, real, complex,</i> and <i class="i">general</i>.
(By natural number, we mean the <i class="i">nonnegative integers</i>; thus zero is
a natural number.  Some, but not all, definitions of natural number
<i class="i">exclude</i> zero.)
</p>
<p>When <em class="math tex2jax_process">\(type\)</em> isn&rsquo;t one of the allowed values, <em class="math tex2jax_process">\(type\)</em> defaults
to <em class="math tex2jax_process">\(general\)</em>.  For integers, natural numbers, and complex numbers,
Maxima automatically appends this information to the fact database.
</p>
<div class="example">
<pre class="example-preformatted">(%i1) map('new_variable,
          ['integer, 'natural_number, 'real, 'complex, 'general]);
(%o1)          [%z144, %n145, %r146, %c147, %g148]
(%i2) nicedummies(%);
(%o2)               [%z0, %n0, %r0, %c0, %g0]
(%i3) featurep(%z0, 'integer);
(%o3)                         true
(%i4) featurep(%n0, 'integer);
(%o4)                         true
(%i5) is(%n0 &gt;= 0);
(%o5)                         true
(%i6) featurep(%c0, 'complex);
(%o6)                         true
</pre></div>

<p><b class="b">Note</b> Generally, the argument to <code class="code">new_variable</code> should be quoted.  The quote
will protect against errors similar to
</p>
<div class="example">
<pre class="example-preformatted">(%i7) integer : 12$

(%i8) new_variable(integer);
(%o8)                         %g149
(%i9) new_variable('integer);
(%o9)                         %z150
</pre></div>

<p><b class="b">Related functions</b> <i class="i">nicedummies</i>
</p>
<p><b class="b">To use</b> <code class="code">load(&quot;to_poly_solve&quot;)</code>
</p>
<p><b class="b">Status</b> The function <code class="code">new_variable</code> is experimental; its
specifications might change and its functionality might be merged into
other Maxima functions.
</p>
</dd></dl>

<a class="anchor" id="nicedummies"></a><a class="anchor" id="Item_003a-to_005fpoly_005fsolve_002fdeffn_002fnicedummies"></a><dl class="first-deffn">
<dt class="deffn" id="index-nicedummies"><span class="category-def">Function: </span><span><strong class="def-name">nicedummies</strong><a class="copiable-link" href='#index-nicedummies'> &para;</a></span></dt>
<dd>
<p>Starting with zero, the function <code class="code">nicedummies</code> re-indexes the variables 
in an expression that were introduced by <code class="code">new_variable</code>;
</p>
<div class="example">
<pre class="example-preformatted">(%i1) new_variable('integer) + 52 * new_variable('integer);
(%o1)                   52 %z136 + %z135
(%i2) new_variable('integer) - new_variable('integer);
(%o2)                     %z137 - %z138
(%i3) nicedummies(%);
(%o3)                       %z0 - %z1
</pre></div>

<p><b class="b">Related functions</b> <i class="i">new_variable</i>
</p>
<p><b class="b">To use</b> <code class="code">load(&quot;to_poly_solve&quot;)</code>
</p>
<p><b class="b">Status</b> The function <code class="code">nicedummies</code> is experimental; its
specifications might change and its functionality might be merged into
other Maxima functions.
</p>
</dd></dl>

<a class="anchor" id="Item_003a-to_005fpoly_005fsolve_002fdeffn_002fparg"></a><dl class="first-deffn">
<dt class="deffn" id="index-parg"><span class="category-def">Function: </span><span><strong class="def-name">parg</strong> <var class="def-var-arguments">(<var class="var">x</var>)</var><a class="copiable-link" href='#index-parg'> &para;</a></span></dt>
<dd>
<p>The function <code class="code">parg</code> is a simplifying version of the complex argument function 
<code class="code">carg</code>; thus
</p>
<div class="example">
<pre class="example-preformatted">(%i1) map('parg,[1,1+%i,%i, -1 + %i, -1]);
                        %pi  %pi  3 %pi
(%o1)               [0, ---, ---, -----, %pi]
                         4    2     4
</pre></div>

<p>Generally, for a non-constant input, <code class="code">parg</code> returns a noun form; thus
</p>
<div class="example">
<pre class="example-preformatted">(%i2) parg(x + %i * sqrt(x));
(%o2)                 parg(x + %i sqrt(x))
</pre></div>

<p>When <code class="code">sign</code> can determine that the input is a positive or negative real
number, <code class="code">parg</code> will return a non-noun form for a non-constant input.
Here are two examples:
</p>

<div class="example">
<pre class="example-preformatted">(%i3) parg(abs(x));
(%o3) 0
(%i4) parg(-x^2-1);
(%o4)                          %pi
</pre></div>

<p><b class="b">Note</b> The <code class="code">sign</code> function mostly ignores the variables that are declared
to be complex (<code class="code">declare(x,complex)</code>); for variables that are declared
to be complex, the <code class="code">parg</code> can return incorrect values; for example
</p>

<div class="example">
<pre class="example-preformatted">(%i1) declare(x,complex)$

(%i2) parg(x^2 + 1);
(%o2) 0
</pre></div>

<p><b class="b">Related function</b> <i class="i">carg, isreal_p</i>
</p>
<p><b class="b">To use</b> <code class="code">load(&quot;to_poly_solve&quot;)</code>
</p>
<p><b class="b">Status</b> The function <code class="code">parg</code> is experimental; its
specifications might change and its functionality might be merged into
other Maxima functions.
</p>
</dd></dl>

<a class="anchor" id="real_005fimagpart_005fto_005fconjugate"></a><a class="anchor" id="Item_003a-to_005fpoly_005fsolve_002fdeffn_002freal_005fimagpart_005fto_005fconjugate"></a><dl class="first-deffn">
<dt class="deffn" id="index-real_005fimagpart_005fto_005fconjugate"><span class="category-def">Function: </span><span><strong class="def-name">real_imagpart_to_conjugate</strong> <var class="def-var-arguments">(<var class="var">e</var>)</var><a class="copiable-link" href='#index-real_005fimagpart_005fto_005fconjugate'> &para;</a></span></dt>
<dd>
<p>The function <code class="code">real_imagpart_to_conjugate</code> replaces all occurrences
of <code class="code">realpart</code> and <code class="code">imagpart</code> to algebraically equivalent expressions
involving the <code class="code">conjugate</code>.
</p>
<div class="example">
<pre class="example-preformatted">(%i1) declare(x, complex)$

(%i2) real_imagpart_to_conjugate(realpart(x) +  imagpart(x) = 3);
          conjugate(x) + x   %i (x - conjugate(x))
(%o2)     ---------------- - --------------------- = 3
                 2                     2
</pre></div>

<p><b class="b">To use</b> <code class="code">load(&quot;to_poly_solve&quot;)</code>
</p>
<p><b class="b">Status</b> The function <code class="code">real_imagpart_to_conjugate</code> is experimental; its
specifications might change and its functionality might be merged into
other Maxima functions.
</p>
</dd></dl>

<a class="anchor" id="rectform_005flog_005fif_005fconstant"></a><a class="anchor" id="Item_003a-to_005fpoly_005fsolve_002fdeffn_002frectform_005flog_005fif_005fconstant"></a><dl class="first-deffn">
<dt class="deffn" id="index-rectform_005flog_005fif_005fconstant"><span class="category-def">Function: </span><span><strong class="def-name">rectform_log_if_constant</strong> <var class="def-var-arguments">(<var class="var">e</var>)</var><a class="copiable-link" href='#index-rectform_005flog_005fif_005fconstant'> &para;</a></span></dt>
<dd>
<p>The function <code class="code">rectform_log_if_constant</code> converts all terms of the form
<code class="code"> log(c)</code> to  <code class="code">rectform(log(c))</code>, where <code class="code">c</code> is
either a declared constant expression or explicitly declared constant
</p>
<div class="example">
<pre class="example-preformatted">(%i1) rectform_log_if_constant(log(1-%i) - log(x - %i));
                                 log(2)   %i %pi
(%o1)            - log(x - %i) + ------ - ------
                                   2        4
(%i2) declare(a,constant, b,constant)$

(%i3) rectform_log_if_constant(log(a + %i*b));
                       2    2
                  log(b  + a )
(%o3)             ------------ + %i atan2(b, a)
                       2
</pre></div>

<p><b class="b">To use</b> <code class="code">load(&quot;to_poly_solve&quot;)</code>
</p>
<p><b class="b">Status</b> The function <code class="code">rectform_log_if_constant</code> is
experimental; the specifications of this function might change might change and its functionality
might be merged into other Maxima functions.
</p>
</dd></dl>

<a class="anchor" id="simp_005finequality"></a><a class="anchor" id="Item_003a-to_005fpoly_005fsolve_002fdeffn_002fsimp_005finequality"></a><dl class="first-deffn">
<dt class="deffn" id="index-simp_005finequality"><span class="category-def">Function: </span><span><strong class="def-name">simp_inequality</strong> <var class="def-var-arguments">(<var class="var">e</var>)</var><a class="copiable-link" href='#index-simp_005finequality'> &para;</a></span></dt>
<dd>
<p>The function <code class="code">simp_inequality</code> applies basic simplifications to inequations,
returning either a boolean value (true or false) or the original inequation.
</p>
<p>The simplification rules used by <code class="code">simp_inequality</code>
include some facts about the ranges of the absolute value, power,
and exponential functions along with some elementary algebra facts.
</p>
<p>For conjunctions or disjunctions of inequations,
<code class="code">simp_inequality</code> is applied to each individual inequation,
but no effort is made to simplify the entire logical expression.
</p>
<p>Effectively, simp_inequality creates a new empty context,
so database facts are not used to simplify inequations.
</p>
<p><code class="code">load(&quot;to_poly_solve&quot;)</code> loads this function.
</p>
<p>Examples:
</p>
<div class="example">
<pre class="example-preformatted">(%i2) simp_inequality(1 # 0);
(%o2) true
</pre></div>

<div class="example">
<pre class="example-preformatted">(%i3) simp_inequality(1 &lt; 0);
(%o3) false
</pre></div>

<div class="example">
<pre class="example-preformatted">(%i4) simp_inequality(a=a);
(%o4) true
</pre></div>

<div class="example">
<pre class="example-preformatted">(%i5) simp_inequality(a # a);
(%o5) false
</pre></div>

<div class="example">
<pre class="example-preformatted">(%i6) simp_inequality(a + 1 # a);
(%o6) true
</pre></div>

<div class="example">
<pre class="example-preformatted">(%i7) simp_inequality(a &lt; a+1);
(%o7) true
</pre></div>

<div class="example">
<pre class="example-preformatted">(%i8) simp_inequality(abs(x) &gt;= 0);
(%o8) true
</pre></div>

<div class="example">
<pre class="example-preformatted">(%i9) simp_inequality(exp(x)  &gt; 0);
(%o9) true
</pre></div>

<div class="example">
<pre class="example-preformatted">(%i10) simp_inequality(x^2 &gt;= 0);
(%o10) true
</pre></div>

<div class="example">
<pre class="example-preformatted">(%i11) simp_inequality(2^x  # 0);
(%o11) true
</pre></div>

<div class="example">
<pre class="example-preformatted">(%i12) simp_inequality(2^(x+1) &gt; 2^x);
(%o12) true
</pre></div>

<p>The fact database is not consulted.
For example:
</p>
<div class="example">
<pre class="example-preformatted">(%i13) assume(xx &gt; 0)$
(%i14) simp_inequality(xx &gt; 0);
(%o14) xx&gt;0
</pre></div>

<p>And finally, for conjunctions or disjunctions of inequations,
each inequation is simplified,
but no effort is made to simplify the entire logical expression;
for example:
</p>
<div class="example">
<pre class="example-preformatted">(%i15) simp_inequality((1 &gt; 0) and (x &lt; 0) and (x &gt; 0));
(%o15) x&lt;0 and x&gt;0
</pre></div>

</dd></dl>

<a class="anchor" id="standardize_005finverse_005ftrig"></a><a class="anchor" id="Item_003a-to_005fpoly_005fsolve_002fdeffn_002fstandardize_005finverse_005ftrig"></a><dl class="first-deffn">
<dt class="deffn" id="index-standardize_005finverse_005ftrig"><span class="category-def">Function: </span><span><strong class="def-name">standardize_inverse_trig</strong> <var class="def-var-arguments">(<var class="var">e</var>)</var><a class="copiable-link" href='#index-standardize_005finverse_005ftrig'> &para;</a></span></dt>
<dd>
<p>This function applies the identities <code class="code">cot(x) = atan(1/x),
acsc(x) = asin(1/x),</code> and similarly for <code class="code">asec, acoth, acsch</code>
and <code class="code">asech</code> to an expression.  See Abramowitz and Stegun, 
Eqs. 4.4.6 through 4.4.8 and 4.6.4 through 4.6.6.
</p>
<p><b class="b">To use</b> <code class="code">load(&quot;to_poly_solve&quot;)</code>
</p>
<p><b class="b">Status</b> The function <code class="code">standardize_inverse_trig</code> is experimental; its
specifications might change and its functionality might be merged into
other Maxima functions.
</p></dd></dl>

<a class="anchor" id="subst_005fparallel"></a><a class="anchor" id="Item_003a-to_005fpoly_005fsolve_002fdeffn_002fsubst_005fparallel"></a><dl class="first-deffn">
<dt class="deffn" id="index-subst_005fparallel"><span class="category-def">Function: </span><span><strong class="def-name">subst_parallel</strong> <var class="def-var-arguments">(<var class="var">l</var>, <var class="var">e</var>)</var><a class="copiable-link" href='#index-subst_005fparallel'> &para;</a></span></dt>
<dd>
<p>When <code class="code">l</code> is a single equation or a list of equations, substitute
the right hand side of each equation for the left hand side.  The
substitutions are made in parallel; for example
</p>
<div class="example">
<pre class="example-preformatted">(%i1) load(&quot;to_poly_solve&quot;)$

(%i2) subst_parallel([x=y,y=x], [x,y]);
(%o2)                        [y, x]
</pre></div>

<p>Compare this to substitutions made serially:
</p>
<div class="example">
<pre class="example-preformatted">(%i3) subst([x=y,y=x],[x,y]);
(%o3)                        [x, x]
</pre></div>

<p>The function <code class="code">subst_parallel</code> is similar to <code class="code">sublis</code> except that
<code class="code">subst_parallel</code> allows for substitution of nonatoms; for example
</p>
<div class="example">
<pre class="example-preformatted">(%i4) subst_parallel([x^2 = a, y = b], x^2 * y);
(%o4)                          a b
(%i5) sublis([x^2 = a, y = b], x^2 * y);

                                                             2
sublis: left-hand side of equation must be a symbol; found: x
 -- an error. To debug this try: debugmode(true);
</pre></div>

<p>The substitutions made by <code class="code">subst_parallel</code> are literal, not semantic; thus 
<code class="code">subst_parallel</code> <i class="i">does not</i> recognize that <em class="math tex2jax_process">\(x * y\)</em> is a subexpression 
of <em class="math tex2jax_process">\(x^2 * y\)</em>
</p>
<div class="example">
<pre class="example-preformatted">(%i6) subst_parallel([x * y = a], x^2 * y);
                               2
(%o6)                         x  y
</pre></div>

<p>The function <code class="code">subst_parallel</code> completes all substitutions
<i class="i">before</i> simplifications.  This allows for substitutions into
conditional expressions where errors might occur if the
simplifications were made earlier:
</p>
<div class="example">
<pre class="example-preformatted">(%i7) subst_parallel([x = 0], %if(x &lt; 1, 5, log(x)));
(%o7)                           5
(%i8) subst([x = 0], %if(x &lt; 1, 5, log(x)));

log: encountered log(0).
 -- an error. To debug this try: debugmode(true);
</pre></div>

<p><b class="b">Related functions</b> <i class="i">subst, sublis, ratsubst</i>
</p>
<p><b class="b">To use</b> <code class="code">load(&quot;to_poly_solve_extra.lisp&quot;)</code>
</p>
<p><b class="b">Status</b> The function <code class="code">subst_parallel</code> is experimental; the
specifications of this function might change might change and its
functionality might be merged into other Maxima functions.
</p>
</dd></dl>

<a class="anchor" id="to_005fpoly"></a><a class="anchor" id="Item_003a-to_005fpoly_005fsolve_002fdeffn_002fto_005fpoly"></a><dl class="first-deffn">
<dt class="deffn" id="index-to_005fpoly"><span class="category-def">Function: </span><span><strong class="def-name">to_poly</strong> <var class="def-var-arguments">(<var class="var">e</var>, <var class="var">l</var>)</var><a class="copiable-link" href='#index-to_005fpoly'> &para;</a></span></dt>
<dd>
<p>The function <code class="code">to_poly</code> attempts to convert the equation <code class="code">e</code>
into a polynomial system along with inequality constraints; the
solutions to the polynomial system that satisfy the constraints are
solutions to the equation <code class="code">e</code>.  Informally, <code class="code">to_poly</code>
attempts to polynomialize the equation <var class="var">e</var>; an example might
clarify:
</p>
<div class="example">
<pre class="example-preformatted">(%i1) load(&quot;to_poly_solve&quot;)$

(%i2) to_poly(sqrt(x) = 3, [x]);
                            2
(%o2) [[%g130 - 3, x = %g130 ], 
                      %pi                               %pi
                   [- --- &lt; parg(%g130), parg(%g130) &lt;= ---], []]
                       2                                 2
</pre></div>

<p>The conditions <code class="code">-%pi/2&lt;parg(%g130),parg(%g130)&lt;=%pi/2</code> tell us that
<code class="code">%g130</code> is in the range of the square root function.  When this is
true, the solution set to <code class="code">sqrt(x) = 3</code> is the same as the
solution set to <code class="code">%g130-3,x=%g130^2</code>.
</p>
<p>To polynomialize trigonometric expressions, it is necessary to
introduce a non algebraic substitution; these non algebraic substitutions
are returned in the third list returned by <code class="code">to_poly</code>; for example
</p>
<div class="example">
<pre class="example-preformatted">(%i3) to_poly(cos(x),[x]);
                2                                 %i x
(%o3)    [[%g131  + 1], [2 %g131 # 0], [%g131 = %e    ]]
</pre></div>

<p>Constant terms aren&rsquo;t polynomializied unless the number one is a member of
the variable list; for example
</p>
<div class="example">
<pre class="example-preformatted">(%i4) to_poly(x = sqrt(5),[x]);
(%o4)                [[x - sqrt(5)], [], []]
(%i5) to_poly(x = sqrt(5),[1,x]);
                            2
(%o5) [[x - %g132, 5 = %g132 ], 
                      %pi                               %pi
                   [- --- &lt; parg(%g132), parg(%g132) &lt;= ---], []]
                       2                                 2
</pre></div>

<p>To generate a polynomial with <em class="math tex2jax_process">\(sqrt(5) + sqrt(7)\)</em> as
one of its roots, use the commands
</p>
<div class="example">
<pre class="example-preformatted">(%i6) first(elim_allbut(first(to_poly(x = sqrt(5) + sqrt(7),
                                      [1,x])), [x]));
                          4       2
(%o6)                   [x  - 24 x  + 4]
</pre></div>

<p><b class="b">Related functions</b> <i class="i">to_poly_solve</i>
</p>
<p><b class="b">To use</b> <code class="code">load(&quot;to_poly&quot;)</code>
</p>
<p><b class="b">Status:</b> The function <code class="code">to_poly</code> is experimental; its
specifications might change and its functionality might be merged into
other Maxima functions.
</p>
</dd></dl>

<a class="anchor" id="Item_003a-to_005fpoly_005fsolve_002fdeffn_002fto_005fpoly_005fsolve"></a><dl class="first-deffn">
<dt class="deffn" id="index-to_005fpoly_005fsolve"><span class="category-def">Function: </span><span><strong class="def-name">to_poly_solve</strong> <var class="def-var-arguments">(<var class="var">e</var>, <var class="var">l</var>, [options])</var><a class="copiable-link" href='#index-to_005fpoly_005fsolve'> &para;</a></span></dt>
<dd>
<p>The function <code class="code">to_poly_solve</code> tries to solve the equations <em class="math tex2jax_process">\(e\)</em>
for the variables <em class="math tex2jax_process">\(l\)</em>.  The equation(s) <em class="math tex2jax_process">\(e\)</em> can either be a
single expression or a set or list of expressions; similarly, <em class="math tex2jax_process">\(l\)</em>
can either be a single symbol or a list of set of symbols.  When
a member of <em class="math tex2jax_process">\(e\)</em> isn&rsquo;t explicitly an equation, for example <em class="math tex2jax_process">\(x^2 -1\)</em>,
the solver assumes that the expression vanishes.
</p>
<p>The basic strategy of <code class="code">to_poly_solve</code> is to convert the input into a polynomial form and to 
call <code class="code">algsys</code> on the polynomial system. Internally  <code class="code">to_poly_solve</code> defaults <code class="code">algexact</code> 
to true. To change the default for <code class="code">algexact</code>, append &rsquo;algexact=false to the <code class="code">to_poly_solve</code> 
argument list.
</p>
<p>When <code class="code">to_poly_solve</code> is able to determine the solution set, each
member of the solution set is a list in a <code class="code">%union</code> object:
</p>
<div class="example">
<pre class="example-preformatted">(%i1) load(&quot;to_poly_solve&quot;)$

(%i2) to_poly_solve(x*(x-1) = 0, x);
(%o2)               %union([x = 0], [x = 1])
</pre></div>

<p>When  <code class="code">to_poly_solve</code> is <i class="i">unable</i> to determine the solution set, a
<code class="code">%solve</code> nounform is returned (in this case, a warning is printed)
</p>
<div class="example">
<pre class="example-preformatted">(%i3) to_poly_solve(x^k + 2* x + 1 = 0, x);

Nonalgebraic argument given to 'to_poly'
unable to solve
                          k
(%o3)            %solve([x  + 2 x + 1 = 0], [x])
</pre></div>

<p>Substitution into a <code class="code">%solve</code> nounform can sometimes result in the solution
</p>
<div class="example">
<pre class="example-preformatted">(%i4) subst(k = 2, %);
(%o4)                   %union([x = - 1])
</pre></div>

<p>Especially for trigonometric equations, the solver sometimes needs
to introduce an arbitrary integer.  These arbitrary integers have the 
form <code class="code">%zXXX</code>, where <code class="code">XXX</code> is an integer; for example
</p>
<div class="example">
<pre class="example-preformatted">(%i5) to_poly_solve(sin(x) = 0, x);
(%o5)   %union([x = 2 %pi %z33 + %pi], [x = 2 %pi %z35])
</pre></div>

<p>To re-index these variables to zero, use <code class="code">nicedummies</code>:
</p>
<div class="example">
<pre class="example-preformatted">(%i6) nicedummies(%);
(%o6)    %union([x = 2 %pi %z0 + %pi], [x = 2 %pi %z1])
</pre></div>

<p>Occasionally, the solver introduces an arbitrary complex number of the
form <code class="code">%cXXX</code> or an  arbitrary real number of the form <code class="code">%rXXX</code>.
The function <code class="code">nicedummies</code> will re-index these identifiers to zero.
</p>
<p>The solution set sometimes involves simplifying versions of various
of logical operators including <code class="code">%and</code>, <code class="code">%or</code>, or <code class="code">%if</code>
for conjunction, disjunction, and implication, respectively; for example
</p>
<div class="example">
<pre class="example-preformatted">(%i7) sol : to_poly_solve(abs(x) = a, x);
(%o7) %union(%if(isnonnegative_p(a), [x = - a], %union()), 
                      %if(isnonnegative_p(a), [x = a], %union()))
(%i8) subst(a = 42, sol);
(%o8)             %union([x = - 42], [x = 42])
(%i9) subst(a = -42, sol);
(%o9)                       %union()
</pre></div>

<p>The empty set is represented by <code class="code">%union()</code>.
</p>
<p>The function <code class="code">to_poly_solve</code> is able to solve some, but not all,
equations involving rational powers, some nonrational powers, absolute
values, trigonometric functions, and minimum and maximum.  Also, some it
can solve some equations that are solvable in in terms of the Lambert W
function; some examples:
</p>
<div class="example">
<pre class="example-preformatted">(%i1) load(&quot;to_poly_solve&quot;)$

(%i2) to_poly_solve(set(max(x,y) = 5, x+y = 2), set(x,y));
(%o2)      %union([x = - 3, y = 5], [x = 5, y = - 3])
(%i3) to_poly_solve(abs(1-abs(1-x)) = 10,x);
(%o3)             %union([x = - 10], [x = 12])
(%i4) to_poly_solve(set(sqrt(x) + sqrt(y) = 5, x + y = 10),
                    set(x,y));
                     3/2               3/2
                    5    %i - 10      5    %i + 10
(%o4) %union([x = - ------------, y = ------------], 
                         2                 2
                                3/2                 3/2
                               5    %i + 10        5    %i - 10
                          [x = ------------, y = - ------------])
                                    2                   2
(%i5) to_poly_solve(cos(x) * sin(x) = 1/2,x,
                    'simpfuncs = ['expand, 'nicedummies]);
                                         %pi
(%o5)              %union([x = %pi %z0 + ---])
                                          4
(%i6) to_poly_solve(x^(2*a) + x^a + 1,x);
                                        2 %i %pi %z81
                                        -------------
                                  1/a         a
                  (sqrt(3) %i - 1)    %e
(%o6) %union([x = -----------------------------------], 
                                  1/a
                                 2
</pre><div class="group"><pre class="example-preformatted">                                                  2 %i %pi %z83
                                                  -------------
                                            1/a         a
                          (- sqrt(3) %i - 1)    %e
                     [x = -------------------------------------])
                                           1/a
                                          2
</pre></div><pre class="example-preformatted">(%i7) to_poly_solve(x * exp(x) = a, x);
(%o7)              %union([x = lambert_w(a)])
</pre></div>

<p>For <i class="i">linear</i> inequalities, <code class="code">to_poly_solve</code> automatically does Fourier
elimination:
</p>
<div class="example">
<pre class="example-preformatted">(%i8) to_poly_solve([x + y &lt; 1, x - y &gt;= 8], [x,y]);
                               7
(%o8) %union([x = y + 8, y &lt; - -], 
                               2
                                                              7
                                 [y + 8 &lt; x, x &lt; 1 - y, y &lt; - -])
                                                              2
</pre></div>

<p>Each optional argument to <code class="code">to_poly_solve</code> must be an equation;
generally, the order of these options does not matter.
</p>
<ul class="itemize mark-bullet">
<li><code class="code">simpfuncs = l</code>, where <code class="code">l</code> is a list of functions.
Apply the composition of the members of l to each solution.

<div class="example">
<pre class="example-preformatted">(%i1) to_poly_solve(x^2=%i,x);
                               1/4             1/4
(%o1)       %union([x = - (- 1)   ], [x = (- 1)   ])
(%i2) to_poly_solve(x^2= %i,x, 'simpfuncs = ['rectform]);
                      %i         1             %i         1
(%o2) %union([x = - ------- - -------], [x = ------- + -------])
                    sqrt(2)   sqrt(2)        sqrt(2)   sqrt(2)
</pre></div>

<p>Sometimes additional simplification can revert a simplification; for example
</p>
<div class="example">
<pre class="example-preformatted">(%i3) to_poly_solve(x^2=1,x);
(%o3)              %union([x = - 1], [x = 1])
(%i4) to_poly_solve(x^2= 1,x, 'simpfuncs = [polarform]);
                                        %i %pi
(%o4)            %union([x = 1], [x = %e      ]
</pre></div>

<p>Maxima doesn&rsquo;t try to check that each member of the function list <code class="code">l</code> is
purely a simplification; thus
</p>
<div class="example">
<pre class="example-preformatted">(%i5) to_poly_solve(x^2 = %i,x, 'simpfuncs = [lambda([s],s^2)]);
(%o5)                   %union([x = %i])
</pre></div>

<p>To convert each solution to a double float, use <code class="code">simpfunc = ['dfloat]</code>:
</p>
<div class="example">
<pre class="example-preformatted">(%i6) to_poly_solve(x^3 +x + 1 = 0,x, 
                    'simpfuncs = ['dfloat]), algexact : true;
(%o6) %union([x = - .6823278038280178], 
[x = .3411639019140089 - 1.161541399997251 %i], 
[x = 1.161541399997251 %i + .3411639019140089])
</pre></div>

</li><li><code class="code">use_grobner = true</code> With this option, the function
<code class="code">poly_reduced_grobner</code> is applied to the equations before
attempting their solution.  Primarily, this option provides a workaround
for weakness in the function <code class="code">algsys</code>.  Here is an example of
such a workaround:

<div class="example">
<pre class="example-preformatted">(%i7) to_poly_solve([x^2+y^2=2^2,(x-1)^2+(y-1)^2=2^2],[x,y],
                    'use_grobner = true);
</pre><div class="group"><pre class="example-preformatted">                    sqrt(7) - 1      sqrt(7) + 1
(%o7) %union([x = - -----------, y = -----------], 
                         2                2
</pre></div><pre class="example-preformatted">                                 sqrt(7) + 1        sqrt(7) - 1
                            [x = -----------, y = - -----------])
                                      2                  2
(%i8) to_poly_solve([x^2+y^2=2^2,(x-1)^2+(y-1)^2=2^2],[x,y]);
(%o8)                       %union()
</pre></div>

</li><li><code class="code">maxdepth = k</code>, where <code class="code">k</code> is a positive integer.  This
function controls the maximum recursion depth for the solver.  The
default value for <code class="code">maxdepth</code> is five.  When the recursions depth is
exceeded, the solver signals an error:

<div class="example">
<pre class="example-preformatted">(%i9) to_poly_solve(cos(x) = x,x, 'maxdepth = 2);

Unable to solve
Unable to solve
(%o9)        %solve([cos(x) = x], [x], maxdepth = 2)
</pre></div>

</li><li><code class="code">parameters = l</code>, where <code class="code">l</code> is a list of symbols.  The solver
attempts to return a solution that is valid for all members of the list
<code class="code">l</code>; for example:

<div class="example">
<pre class="example-preformatted">(%i10) to_poly_solve(a * x = x, x);
(%o10)                   %union([x = 0])
(%i11) to_poly_solve(a * x = x, x, 'parameters = [a]);
(%o11) %union(%if(a - 1 = 0, [x = %c111], %union()), 
                               %if(a - 1 # 0, [x = 0], %union()))
</pre></div>

<p>In <code class="code">(%o2)</code>, the solver introduced a dummy variable; to re-index the
these dummy variables, use the function <code class="code">nicedummies</code>:
</p>
<div class="example">
<pre class="example-preformatted">(%i12) nicedummies(%);
(%o12) %union(%if(a - 1 = 0, [x = %c0], %union()), 
                               %if(a - 1 # 0, [x = 0], %union()))
</pre></div>
</li></ul>

<p>The <code class="code">to_poly_solve</code> uses data stored in the hashed array
<code class="code">one_to_one_reduce</code> to solve equations of the form <em class="math tex2jax_process">\(f(a) =
f(b)\)</em>.  The assignment <code class="code">one_to_one_reduce['f,'f] : lambda([a,b],
a=b)</code> tells <code class="code">to_poly_solve</code> that the solution set of <em class="math tex2jax_process">\(f(a)
= f(b)\)</em> equals the solution set of <em class="math tex2jax_process">\(a=b\)</em>; for example
</p>
<div class="example">
<pre class="example-preformatted">(%i13) one_to_one_reduce['f,'f] : lambda([a,b], a=b)$

(%i14) to_poly_solve(f(x^2-1) = f(0),x);
(%o14)             %union([x = - 1], [x = 1])
</pre></div>

<p>More generally, the assignment <code class="code">one_to_one_reduce['f,'g] : lambda([a,b],
w(a, b) = 0</code> tells <code class="code">to_poly_solve</code> that the solution set of <em class="math tex2jax_process">\(f(a)
= f(b)\)</em> equals the solution set of <em class="math tex2jax_process">\(w(a,b) = 0\)</em>; for example
</p>
<div class="example">
<pre class="example-preformatted">(%i15) one_to_one_reduce['f,'g] : lambda([a,b], a = 1 + b/2)$

(%i16) to_poly_solve(f(x) - g(x),x);
(%o16)                   %union([x = 2])
</pre></div>

<p>Additionally, the function <code class="code">to_poly_solve</code> uses data stored in the hashed array 
<code class="code">function_inverse</code> to solve equations of the form <em class="math tex2jax_process">\(f(a) = b\)</em>.
The assignment <code class="code">function_inverse['f] : lambda([s], g(s))</code> 
informs  <code class="code">to_poly_solve</code> that the solution set to <code class="code">f(x) = b</code> equals
the solution set to <code class="code">x = g(b)</code>; two examples:
</p>
<div class="example">
<pre class="example-preformatted">(%i17) function_inverse['Q] : lambda([s], P(s))$

(%i18) to_poly_solve(Q(x-1) = 2009,x);
(%o18)              %union([x = P(2009) + 1])
(%i19) function_inverse['G] : lambda([s], s+new_variable(integer));
(%o19)       lambda([s], s + new_variable(integer))
(%i20) to_poly_solve(G(x - a) = b,x);
(%o20)             %union([x = b + a + %z125])
</pre></div>


<p><b class="b">Notes</b>
</p>
<ul class="itemize mark-bullet">
<li>The solve variables needn&rsquo;t be symbols; when <code class="code">fullratsubst</code> is 
able to appropriately make substitutions, the solve variables can be nonsymbols:
</li></ul>

<div class="example">
<pre class="example-preformatted">(%i1) to_poly_solve([x^2 + y^2 + x * y = 5, x * y = 8],
                    [x^2 + y^2, x * y]);
                                  2    2
(%o1)           %union([x y = 8, y  + x  = - 3])
</pre></div>

<ul class="itemize mark-bullet">
<li>For equations that involve complex conjugates, the solver automatically
appends the conjugate equations; for example
</li></ul>

<div class="example">
<pre class="example-preformatted">(%i1) declare(x,complex)$

(%i2) to_poly_solve(x + (5 + %i) * conjugate(x) = 1, x);
                                   %i + 21
(%o2)              %union([x = - -----------])
                                 25 %i - 125
(%i3) declare(y,complex)$

(%i4) to_poly_solve(set(conjugate(x) - y = 42 + %i,
                        x + conjugate(y) = 0), set(x,y));
                           %i - 42        %i + 42
(%o4)        %union([x = - -------, y = - -------])
                              2              2
</pre></div>

<ul class="itemize mark-bullet">
<li>For an equation that involves the absolute value function, the
<code class="code">to_poly_solve</code> consults the fact database to decide if the
argument to the absolute value is complex valued.  When

<div class="example">
<pre class="example-preformatted">(%i1) to_poly_solve(abs(x) = 6, x);
(%o1)              %union([x = - 6], [x = 6])
(%i2) declare(z,complex)$

(%i3) to_poly_solve(abs(z) = 6, z);
(%o3) %union(%if((%c11 # 0) %and (%c11 conjugate(%c11) - 36 = 
                                       0), [z = %c11], %union()))
</pre></div>

<p><i class="i">This is the only situation that the solver consults the fact database.  If
a solve variable is declared to be an integer, for example, <code class="code">to_poly_solve</code>
ignores this declaration</i>.
</p></li></ul>

<p><b class="b">Relevant option variables</b> <i class="i">algexact, resultant, algebraic</i>
</p>
<p><b class="b">Related functions</b> <i class="i">to_poly</i>
</p>
<p><b class="b">To use</b> <code class="code">load(&quot;to_poly_solve&quot;)</code>
</p>
<p><b class="b">Status:</b> The function <code class="code">to_poly_solve</code> is experimental; its
specifications might change and its functionality might be merged into
other Maxima functions.
</p></dd></dl>

<a class="anchor" id="g_t_0025union"></a><a class="anchor" id="Item_003a-to_005fpoly_005fsolve_002fdeffn_002f_0025union"></a><dl class="first-deffn">
<dt class="deffn" id="index-_0025union"><span class="category-def">Operator: </span><span><strong class="def-name">%union</strong> <var class="def-var-arguments">(<var class="var">soln_1</var>, <var class="var">soln_2</var>, <var class="var">soln_3</var>, ...)</var><a class="copiable-link" href='#index-_0025union'> &para;</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-_0025union-1"><span class="category-def">Operator: </span><span><strong class="def-name">%union</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href='#index-_0025union-1'> &para;</a></span></dt>
<dd>
<p><code class="code">%union(<var class="var">soln_1</var>, <var class="var">soln_2</var>, <var class="var">soln_3</var>, ...)</code> represents the union of its arguments,
each of which represents a solution set,
as determined by <code class="code">to_poly_solve</code>.
<code class="code">%union()</code> represents the empty set.
</p>
<p>In many cases, a solution is a list of equations <code class="code">[<var class="var">x</var> = ..., <var class="var">y</var> = ..., <var class="var">z</var> = ...]</code>
where <var class="var">x</var>, <var class="var">y</var>, and <var class="var">z</var> are one or more unknowns.
In such cases, <code class="code">to_poly_solve</code> returns a <code class="code">%union</code> expression
containing one or more such lists.
</p>
<p>The solution set sometimes involves simplifying versions of various
of logical operators including <code class="code">%and</code>, <code class="code">%or</code>, or <code class="code">%if</code>
for conjunction, disjunction, and implication, respectively.
</p>
<p>Examples:
</p>
<p><code class="code">%union(...)</code> represents the union of its arguments,
each of which represents a solution set,
as determined by <code class="code">to_poly_solve</code>.
In many cases, a solution is a list of equations.
</p>
<div class="example">
<pre class="example-preformatted">(%i1) load (&quot;to_poly_solve&quot;) $
(%i2) to_poly_solve ([sqrt(x^2 - y^2), x + y], [x, y]);
(%o2)    %union([x = 0, y = 0], [x = %c13, y = - %c13])
</pre></div>

<p><code class="code">%union()</code> represents the empty set.
</p>
<div class="example">
<pre class="example-preformatted">(%i1) load (&quot;to_poly_solve&quot;) $
(%i2) to_poly_solve (abs(x) = -1, x);
(%o2)                       %union()
</pre></div>

<p>The solution set sometimes involves simplifying versions of various
of logical operators.
</p>
<div class="example">
<pre class="example-preformatted">(%i1) load (&quot;to_poly_solve&quot;) $
(%i2) sol : to_poly_solve (abs(x) = a, x);
(%o2) %union(%if(isnonnegative_p(a), [x = - a], %union()), 
                      %if(isnonnegative_p(a), [x = a], %union()))
(%i3) subst (a = 42, sol);
(%o3)             %union([x = - 42], [x = 42])
(%i4) subst (a = -42, sol);
(%o4)                       %union()
</pre></div>

</dd></dl>

</div>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="maxima_92.html#unit_002dpkg" accesskey="n" rel="next">unit</a>, Previous: <a href="maxima_90.html#stringproc_002dpkg" accesskey="p" rel="prev">stringproc</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>


<a href="js_licenses.html" rel="jslicense"><small>JavaScript license information</small></a>
</body>
</html>
