<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.0.3, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>itensor (Maxima 5.47.0 Manual)</title>

<meta name="description" content="itensor (Maxima 5.47.0 Manual)">
<meta name="keywords" content="itensor (Maxima 5.47.0 Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="maxima_toc.html" rel="start" title="Top">
<link href="Function-and-Variable-Index.html" rel="index" title="Function and Variable Index">
<link href="maxima_toc.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="maxima_toc.html" rel="up" title="Top">
<link href="maxima_25.html#ctensor" rel="next" title="ctensor">
<link href="maxima_23.html#Affine" rel="prev" title="Affine">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 1em; padding-bottom: 1em;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%; display: block; margin-left: auto; margin-right: auto}

-->
</style>


</head>

<body lang="en">
<div class="chapter-level-extent" id="itensor">
<div class="nav-panel">
<p>
Next: <a href="maxima_25.html#ctensor" accesskey="n" rel="next">ctensor</a>, Previous: <a href="maxima_23.html#Affine" accesskey="p" rel="prev">Affine</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<h2 class="chapter" id="itensor-1">25 itensor</h2>



<a class="anchor" id="Item_003a-Itensor_002fnode_002fIntroduction-to-itensor"></a><ul class="mini-toc">
<li><a href="#Introduction-to-itensor" accesskey="1">Introduction to itensor</a></li>
<li><a href="#Functions-and-Variables-for-itensor" accesskey="2">Functions and Variables for itensor</a></li>
</ul>
<hr>
<div class="section-level-extent" id="Introduction-to-itensor">
<div class="nav-panel">
<p>
Next: <a href="#Functions-and-Variables-for-itensor" accesskey="n" rel="next">Functions and Variables for itensor</a>, Previous: <a href="#itensor" accesskey="p" rel="prev">itensor</a>, Up: <a href="#itensor" accesskey="u" rel="up">itensor</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Introduction-to-itensor-1">25.1 Introduction to itensor</h3>

<p>Maxima implements symbolic tensor manipulation of two distinct types:
component tensor manipulation (<code class="code">ctensor</code> package) and indicial tensor
manipulation (<code class="code">itensor</code> package).
</p>
<p>Nota bene: Please see the note on &rsquo;new tensor notation&rsquo; below.
</p>
<p>Component tensor manipulation means that geometrical tensor
objects are represented as arrays or matrices. Tensor operations such
as contraction or covariant differentiation are carried out by
actually summing over repeated (dummy) indices with <code class="code">do</code> statements.
That is, one explicitly performs operations on the appropriate tensor
components stored in an array or matrix.
</p>
<p>Indicial tensor manipulation is implemented by representing
tensors as functions of their covariant, contravariant and derivative
indices. Tensor operations such as contraction or covariant
differentiation are performed by manipulating the indices themselves
rather than the components to which they correspond.
</p>
<p>These two approaches to the treatment of differential, algebraic and
analytic processes in the context of Riemannian geometry have various
advantages and disadvantages which reveal themselves only through the
particular nature and difficulty of the user&rsquo;s problem.  However, one
should keep in mind the following characteristics of the two
implementations:
</p>
<p>The representation of tensors and tensor operations explicitly in
terms of their components makes <code class="code">ctensor</code> easy to use. Specification of
the metric and the computation of the induced tensors and invariants
is straightforward. Although all of Maxima&rsquo;s powerful simplification
capacity is at hand, a complex metric with intricate functional and
coordinate dependencies can easily lead to expressions whose size is
excessive and whose structure is hidden. In addition, many calculations
involve intermediate expressions which swell causing programs to
terminate before completion. Through experience, a user can avoid
many of these difficulties.
</p>
<p>Because of the special way in which tensors and tensor operations
are represented in terms of symbolic operations on their indices,
expressions which in the component representation would be
unmanageable can sometimes be greatly simplified by using the special
routines for symmetrical objects in <code class="code">itensor</code>. In this way the structure
of a large expression may be more transparent. On the other hand, because
of the special indicial representation in <code class="code">itensor</code>, in some cases the
user may find difficulty with the specification of the metric, function
definition, and the evaluation of differentiated &quot;indexed&quot; objects.
</p>
<p>The <code class="code">itensor</code> package can carry out differentiation with respect to an indexed
variable, which allows one to use the package when dealing with Lagrangian
and Hamiltonian formalisms. As it is possible to differentiate a field
Lagrangian with respect to an (indexed) field variable, one can use Maxima
to derive the corresponding Euler-Lagrange equations in indicial form. These
equations can be translated into component tensor (<code class="code">ctensor</code>) programs using
the <code class="code">ic_convert</code> function, allowing us to solve the field equations in a
particular coordinate representation, or to recast the equations of motion
in Hamiltonian form. See <code class="code">einhil.dem</code> and <code class="code">bradic.dem</code> for two comprehensive
examples. The first, <code class="code">einhil.dem</code>, uses the Einstein-Hilbert action to derive
the Einstein field tensor in the homogeneous and isotropic case (Friedmann
equations) and the spherically symmetric, static case (Schwarzschild
solution.) The second, <code class="code">bradic.dem</code>, demonstrates how to compute the Friedmann
equations from the action of Brans-Dicke gravity theory, and also derives
the Hamiltonian associated with the theory&rsquo;s scalar field.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Tensors">Tensors</a>
&middot;
<a class="ref" href="Documentation-Categories.html#Category_003a-Share-packages">Share packages</a>
&middot;
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>

<ul class="mini-toc">
<li><a href="#New-tensor-notation" accesskey="1">New tensor notation</a></li>
<li><a href="#Indicial-tensor-manipulation" accesskey="2">Indicial tensor manipulation</a></li>
</ul>
<div class="subsection-level-extent" id="New-tensor-notation">
<h4 class="subsection">25.1.1 New tensor notation</h4>

<p>Earlier versions of the <code class="code">itensor</code> package in Maxima used a notation that sometimes
led to incorrect index ordering. Consider the following, for instance:
</p>
<div class="example">
<pre class="example-preformatted">(%i2) imetric(g);
(%o2)                                done
(%i3) ishow(g([],[j,k])*g([],[i,l])*a([i,j],[]))$
                                 i l  j k
(%t3)                           g    g    a
                                           i j
(%i4) ishow(contract(%))$
                                      k l
(%t4)                                a
</pre></div>

<p>This result is incorrect unless <code class="code">a</code> happens to be a symmetric tensor.
The reason why this happens is that although <code class="code">itensor</code> correctly maintains
the order within the set of covariant and contravariant indices, once an
index is raised or lowered, its position relative to the other set of
indices is lost.
</p>
<p>To avoid this problem, a new notation has been developed that remains fully
compatible with the existing notation and can be used interchangeably. In
this notation, contravariant indices are inserted in the appropriate
positions in the covariant index list, but with a minus sign prepended.
Functions like <code class="code"><a class="ref" href="#contract_005fItensor">contract_Itensor</a></code> and <code class="code"><a class="ref" href="#ishow">ishow</a></code> are now aware of this
new index notation and can process tensors appropriately.
</p>
<p>In this new notation, the previous example yields a correct result:
</p>
<div class="example">
<pre class="example-preformatted">(%i5) ishow(g([-j,-k],[])*g([-i,-l],[])*a([i,j],[]))$
                                 i l       j k
(%t5)                           g    a    g
                                      i j
(%i6) ishow(contract(%))$
                                      l k
(%t6)                                a
</pre></div>

<p>Presently, the only code that makes use of this notation is the <code class="code">lc2kdt</code>
function. Through this notation, it achieves consistent results as it
applies the metric tensor to resolve Levi-Civita symbols without resorting
to numeric indices.
</p>
<p>Since this code is brand new, it probably contains bugs. While it has been
tested to make sure that it doesn&rsquo;t break anything using the &quot;old&quot; tensor
notation, there is a considerable chance that &quot;new&quot; tensors will fail to
interoperate with certain functions or features. These bugs will be fixed
as they are encountered... until then, caveat emptor!
</p>
</div>
<div class="subsection-level-extent" id="Indicial-tensor-manipulation">
<h4 class="subsection">25.1.2 Indicial tensor manipulation</h4>

<p>The indicial tensor manipulation package may be loaded by
<code class="code">load(&quot;itensor&quot;)</code>. Demos are also available: try <code class="code">demo(&quot;tensor&quot;)</code>.
</p>
<p>In <code class="code">itensor</code> a tensor is represented as an &quot;indexed object&quot; .  This is a
function of 3 groups of indices which represent the covariant,
contravariant and derivative indices.  The covariant indices are
specified by a list as the first argument to the indexed object, and
the contravariant indices by a list as the second argument. If the
indexed object lacks either of these groups of indices then the empty
list <code class="code">[]</code> is given as the corresponding argument.  Thus, <code class="code">g([a,b],[c])</code>
represents an indexed object called <code class="code">g</code> which has two covariant indices
<code class="code">(a,b)</code>, one contravariant index (<code class="code">c</code>) and no derivative indices.
</p>
<p>The derivative indices, if they are present, are appended as
additional arguments to the symbolic function representing the tensor.
They can be explicitly specified by the user or be created in the
process of differentiation with respect to some coordinate variable.
Since ordinary differentiation is commutative, the derivative indices
are sorted alphanumerically, unless <code class="code">iframe_flag</code> is set to <code class="code">true</code>,
indicating that a frame metric is being used. This canonical ordering makes it
possible for Maxima to recognize that, for example, <code class="code">t([a],[b],i,j)</code> is
the same as <code class="code">t([a],[b],j,i)</code>.  Differentiation of an indexed object with
respect to some coordinate whose index does not appear as an argument
to the indexed object would normally yield zero. This is because
Maxima would not know that the tensor represented by the indexed
object might depend implicitly on the corresponding coordinate.  By
modifying the existing Maxima function <code class="code">diff</code> in <code class="code">itensor</code>, Maxima now
assumes that all indexed objects depend on any variable of
differentiation unless otherwise stated.  This makes it possible for
the summation convention to be extended to derivative indices. It
should be noted that <code class="code">itensor</code> does not possess the capabilities of
raising derivative indices, and so they are always treated as
covariant.
</p>
<p>The following functions are available in the tensor package for
manipulating indexed objects.  At present, with respect to the
simplification routines, it is assumed that indexed objects do not
by default possess symmetry properties. This can be overridden by
setting the variable <code class="code">allsym[false]</code> to <code class="code">true</code>, which will
result in treating all indexed objects completely symmetric in their
lists of covariant indices and symmetric in their lists of
contravariant indices.
</p>
<p>The <code class="code">itensor</code> package generally treats tensors as opaque objects. Tensorial
equations are manipulated based on algebraic rules, specifically symmetry
and contraction rules. In addition, the <code class="code">itensor</code> package understands
covariant differentiation, curvature, and torsion. Calculations can be
performed relative to a metric of moving frame, depending on the setting
of the <code class="code">iframe_flag</code> variable.
</p>
<p>A sample session below demonstrates how to load the <code class="code">itensor</code> package,
specify the name of the metric, and perform some simple calculations.
</p>
<div class="example">
<pre class="example-preformatted">(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric(g);
(%o2)                                done
(%i3) components(g([i,j],[]),p([i,j],[])*e([],[]))$
(%i4) ishow(g([k,l],[]))$
(%t4)                               e p
                                       k l
(%i5) ishow(diff(v([i],[]),t))$
(%t5)                                  0
(%i6) depends(v,t);
(%o6)                               [v(t)]
(%i7) ishow(diff(v([i],[]),t))$
                                    d
(%t7)                               -- (v )
                                    dt   i
(%i8) ishow(idiff(v([i],[]),j))$
(%t8)                                v
                                      i,j
(%i9) ishow(extdiff(v([i],[]),j))$
(%t9)                             v    - v
                                   j,i    i,j
                                  -----------
                                       2
(%i10) ishow(liediff(v,w([i],[])))$
                               %3          %3
(%t10)                        v   w     + v   w
                                   i,%3    ,i  %3
(%i11) ishow(covdiff(v([i],[]),j))$
                                              %4
(%t11)                        v    - v   ichr2
                               i,j    %4      i j
(%i12) ishow(ev(%,ichr2))$
                %4 %5
(%t12) v    - (g      v   (e p       + e   p     - e p       - e    p
        i,j            %4     j %5,i    ,i  j %5      i j,%5    ,%5  i j

                                         + e p       + e   p    ))/2
                                              i %5,j    ,j  i %5
(%i13) iframe_flag:true;
(%o13)                               true
(%i14) ishow(covdiff(v([i],[]),j))$
                                             %6
(%t14)                        v    - v   icc2
                               i,j    %6     i j
(%i15) ishow(ev(%,icc2))$
                                             %6
(%t15)                        v    - v   ifc2
                               i,j    %6     i j
(%i16) ishow(radcan(ev(%,ifc2,ifc1)))$
             %6 %7                    %6 %7
(%t16) - (ifg      v   ifb       + ifg      v   ifb       - 2 v
                    %6    j %7 i             %6    i j %7      i,j

                                             %6 %7
                                        - ifg      v   ifb      )/2
                                                    %6    %7 i j
(%i17) ishow(canform(s([i,j],[])-s([j,i])))$
(%t17)                            s    - s
                                   i j    j i
(%i18) decsym(s,2,0,[sym(all)],[]);
(%o18)                               done
(%i19) ishow(canform(s([i,j],[])-s([j,i])))$
(%t19)                                 0
(%i20) ishow(canform(a([i,j],[])+a([j,i])))$
(%t20)                            a    + a
                                   j i    i j
(%i21) decsym(a,2,0,[anti(all)],[]);
(%o21)                               done
(%i22) ishow(canform(a([i,j],[])+a([j,i])))$
(%t22)                                 0
</pre></div>


<a class="anchor" id="Item_003a-Itensor_002fnode_002fFunctions-and-Variables-for-itensor"></a><hr>
</div>
</div>
<div class="section-level-extent" id="Functions-and-Variables-for-itensor">
<div class="nav-panel">
<p>
Previous: <a href="#Introduction-to-itensor" accesskey="p" rel="prev">Introduction to itensor</a>, Up: <a href="#itensor" accesskey="u" rel="up">itensor</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Functions-and-Variables-for-itensor-1">25.2 Functions and Variables for itensor</h3>
<ul class="mini-toc">
<li><a href="#Managing-indexed-objects" accesskey="1">Managing indexed objects</a></li>
<li><a href="#Tensor-symmetries" accesskey="2">Tensor symmetries</a></li>
<li><a href="#Indicial-tensor-calculus" accesskey="3">Indicial tensor calculus</a></li>
<li><a href="#Tensors-in-curved-spaces" accesskey="4">Tensors in curved spaces</a></li>
<li><a href="#Moving-frames" accesskey="5">Moving frames</a></li>
<li><a href="#Torsion-and-nonmetricity" accesskey="6">Torsion and nonmetricity</a></li>
<li><a href="#Exterior-algebra" accesskey="7">Exterior algebra</a></li>
<li><a href="#Exporting-TeX-expressions" accesskey="8">Exporting TeX expressions</a></li>
<li><a href="#Interfacing-with-ctensor" accesskey="9">Interfacing with ctensor</a></li>
<li><a href="#Reserved-words">Reserved words</a></li>
</ul>
<div class="subsection-level-extent" id="Managing-indexed-objects">
<h4 class="subsection">25.2.1 Managing indexed objects</h4>

<a class="anchor" id="dispcon"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fdispcon"></a><dl class="first-deffn">
<dt class="deffn" id="index-dispcon"><span class="category-def">Function: </span><span><strong class="def-name">dispcon</strong> <var class="def-var-arguments"><br>&nbsp;&nbsp;&nbsp;&nbsp;<code class="t">dispcon</code> (<var class="var">tensor_1</var>, <var class="var">tensor_2</var>, &hellip;) <br>&nbsp;&nbsp;&nbsp;&nbsp;<code class="t">dispcon</code> (all)</var><a class="copiable-link" href='#index-dispcon'> &para;</a></span></dt>
<dd>
<p>Displays the contraction properties of its arguments as were given to
<code class="code">defcon</code>.  <code class="code">dispcon (all)</code> displays all the contraction properties
which were defined.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Display-functions">Display functions</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="entertensor"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fentertensor"></a><dl class="first-deffn">
<dt class="deffn" id="index-entertensor"><span class="category-def">Function: </span><span><strong class="def-name">entertensor</strong> <var class="def-var-arguments">(<var class="var">name</var>)</var><a class="copiable-link" href='#index-entertensor'> &para;</a></span></dt>
<dd>
<p>is a function which, by prompting, allows one to create an indexed
object called <var class="var">name</var> with any number of tensorial and derivative
indices. Either a single index or a list of indices (which may be
null) is acceptable input (see the example under <code class="code"><a class="ref" href="#covdiff">covdiff</a></code>).
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="changename"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fchangename"></a><dl class="first-deffn">
<dt class="deffn" id="index-changename"><span class="category-def">Function: </span><span><strong class="def-name">changename</strong> <var class="def-var-arguments">(<var class="var">old</var>, <var class="var">new</var>, <var class="var">expr</var>)</var><a class="copiable-link" href='#index-changename'> &para;</a></span></dt>
<dd>
<p>will change the name of all indexed objects called <var class="var">old</var> to <var class="var">new</var>
in <var class="var">expr</var>. <var class="var">old</var> may be either a symbol or a list of the form
<code class="code">[<var class="var">name</var>, <var class="var">m</var>, <var class="var">n</var>]</code> in which case only those indexed objects called
<var class="var">name</var> with <var class="var">m</var> covariant and <var class="var">n</var> contravariant indices will be
renamed to <var class="var">new</var>.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="Item_003a-Itensor_002fdeffn_002flistoftens"></a><dl class="first-deffn">
<dt class="deffn" id="index-listoftens"><span class="category-def">Function: </span><span><strong class="def-name">listoftens</strong><a class="copiable-link" href='#index-listoftens'> &para;</a></span></dt>
<dd>
<a class="anchor" id="listoftens"></a>
<p>Lists all tensors in a tensorial expression, complete with their indices. E.g.,
</p>
<div class="example">
<pre class="example-preformatted">

(%i6) ishow(a([i,j],[k])*b([u],[],v)+c([x,y],[])*d([],[])*e)$
                                         k
(%t6)                        d e c    + a    b
                                  x y    i j  u,v
(%i7) ishow(listoftens(%))$
                               k
(%t7)                        [a   , b   , c   , d]
                               i j   u,v   x y

</pre></div>

<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="ishow"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fishow"></a><dl class="first-deffn">
<dt class="deffn" id="index-ishow"><span class="category-def">Function: </span><span><strong class="def-name">ishow</strong> <var class="def-var-arguments">(<var class="var">expr</var>)</var><a class="copiable-link" href='#index-ishow'> &para;</a></span></dt>
<dd>
<p>displays <var class="var">expr</var> with the indexed objects in it shown having their
covariant indices as subscripts and contravariant indices as
superscripts. The derivative indices are displayed as subscripts,
separated from the covariant indices by a comma (see the examples
throughout this document).
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="indices"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002findices"></a><dl class="first-deffn">
<dt class="deffn" id="index-indices"><span class="category-def">Function: </span><span><strong class="def-name">indices</strong> <var class="def-var-arguments">(<var class="var">expr</var>)</var><a class="copiable-link" href='#index-indices'> &para;</a></span></dt>
<dd>
<p>Returns a list of two elements.  The first is a list of the free
indices in <var class="var">expr</var> (those that occur only once). The second is the
list of the dummy indices in <var class="var">expr</var> (those that occur exactly twice)
as the following example demonstrates.
</p>
<div class="example">
<pre class="example-preformatted">

(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i,j],[k,l],m,n)*b([k,o],[j,m,p],q,r))$
                                k l      j m p
(%t2)                          a        b
                                i j,m n  k o,q r
(%i3) indices(%);
(%o3)                 [[l, p, i, n, o, q, r], [k, j, m]]

</pre></div>

<p>A tensor product containing the same index more than twice is syntactically
illegal. <code class="code">indices</code> attempts to deal with these expressions in a
reasonable manner; however, when it is called to operate upon such an
illegal expression, its behavior should be considered undefined.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="rename"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002frename"></a><dl class="first-deffn">
<dt class="deffn" id="index-rename"><span class="category-def">Function: </span><span><strong class="def-name">rename</strong> <var class="def-var-arguments"><br>&nbsp;&nbsp;&nbsp;&nbsp;<code class="t">rename</code> (<var class="var">expr</var>) <br>&nbsp;&nbsp;&nbsp;&nbsp;<code class="t">rename</code> (<var class="var">expr</var>, <var class="var">count</var>)</var><a class="copiable-link" href='#index-rename'> &para;</a></span></dt>
<dd>
<p>Returns an expression equivalent to <var class="var">expr</var> but with the dummy indices
in each term chosen from the set <code class="code">[%1, %2,...]</code>, if the optional second
argument is omitted. Otherwise, the dummy indices are indexed
beginning at the value of <var class="var">count</var>.  Each dummy index in a product
will be different. For a sum, <code class="code">rename</code> will operate upon each term in
the sum resetting the counter with each term. In this way <code class="code">rename</code> can
serve as a tensorial simplifier. In addition, the indices will be
sorted alphanumerically (if <code class="code"><a class="ref" href="#allsym">allsym</a></code> is <code class="code">true</code>) with respect to
covariant or contravariant indices depending upon the value of <code class="code"><a class="ref" href="#flipflag">flipflag</a></code>.
If <code class="code">flipflag</code> is <code class="code">false</code> then the indices will be renamed according
to the order of the contravariant indices. If <code class="code">flipflag</code> is <code class="code">true</code>
the renaming will occur according to the order of the covariant
indices. It often happens that the combined effect of the two renamings will
reduce an expression more than either one by itself.
</p>
<div class="example">
<pre class="example-preformatted">

(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) allsym:true;
(%o2)                                true
(%i3) g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%4],[%3])*
ichr2([%2,%3],[u])*ichr2([%5,%6],[%1])*ichr2([%7,r],[%2])-
g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%2],[u])*
ichr2([%3,%5],[%1])*ichr2([%4,%6],[%3])*ichr2([%7,r],[%2]),noeval$
(%i4) expr:ishow(%)$
</pre><div class="group"><pre class="example-preformatted">       %4 %5  %6 %7      %3         u          %1         %2
(%t4) g      g      ichr2      ichr2      ichr2      ichr2
                         %1 %4      %2 %3      %5 %6      %7 r

        %4 %5  %6 %7      u          %1         %3         %2
     - g      g      ichr2      ichr2      ichr2      ichr2
                          %1 %2      %3 %5      %4 %6      %7 r
</pre></div><pre class="example-preformatted">(%i5) flipflag:true;
(%o5)                                true
(%i6) ishow(rename(expr))$
       %2 %5  %6 %7      %4         u          %1         %3
(%t6) g      g      ichr2      ichr2      ichr2      ichr2
                         %1 %2      %3 %4      %5 %6      %7 r

        %4 %5  %6 %7      u          %1         %3         %2
     - g      g      ichr2      ichr2      ichr2      ichr2
                          %1 %2      %3 %4      %5 %6      %7 r
(%i7) flipflag:false;
(%o7)                                false
(%i8) rename(%th(2));
(%o8)                                  0
(%i9) ishow(rename(expr))$
       %1 %2  %3 %4      %5         %6         %7        u
(%t9) g      g      ichr2      ichr2      ichr2     ichr2
                         %1 %6      %2 %3      %4 r      %5 %7

        %1 %2  %3 %4      %6         %5         %7        u
     - g      g      ichr2      ichr2      ichr2     ichr2
                          %1 %3      %2 %6      %4 r      %5 %7
</pre></div>

<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="flipflag"></a><a class="anchor" id="Item_003a-Itensor_002fdefvr_002fflipflag"></a><dl class="first-defvr">
<dt class="defvr" id="index-flipflag"><span class="category-def">Option variable: </span><span><strong class="def-name">flipflag</strong><a class="copiable-link" href='#index-flipflag'> &para;</a></span></dt>
<dd><p>Default value: <code class="code">false</code>
</p>
<p>If <code class="code">false</code> then the indices will be
renamed according to the order of the contravariant indices,
otherwise according to the order of the covariant indices.
</p>
<p>If <code class="code">flipflag</code> is <code class="code">false</code> then <code class="code">rename</code> forms a list
of the contravariant indices as they are encountered from left to right
(if <code class="code">true</code> then of the covariant indices). The first dummy
index in the list is renamed to <code class="code">%1</code>, the next to <code class="code">%2</code>, etc.
Then sorting occurs after the <code class="code">rename</code>-ing (see the example
under <code class="code">rename</code>).
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="defcon"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fdefcon"></a><dl class="first-deffn">
<dt class="deffn" id="index-defcon"><span class="category-def">Function: </span><span><strong class="def-name">defcon</strong> <var class="def-var-arguments"><br>&nbsp;&nbsp;&nbsp;&nbsp;<code class="t">defcon</code> (<var class="var">tensor_1</var>) <br>&nbsp;&nbsp;&nbsp;&nbsp;<code class="t">defcon</code> (<var class="var">tensor_1</var>, <var class="var">tensor_2</var>, <var class="var">tensor_3</var>)</var><a class="copiable-link" href='#index-defcon'> &para;</a></span></dt>
<dd>
<p>gives <var class="var">tensor_1</var> the property that the
contraction of a product of <var class="var">tensor_1</var> and <var class="var">tensor_2</var> results in <var class="var">tensor_3</var>
with the appropriate indices.  If only one argument, <var class="var">tensor_1</var>, is
given, then the contraction of the product of <var class="var">tensor_1</var> with any indexed
object having the appropriate indices (say <code class="code">my_tensor</code>) will yield an
indexed object with that name, i.e. <code class="code">my_tensor</code>, and with a new set of
indices reflecting the contractions performed.
    For example, if <code class="code">imetric:g</code>, then <code class="code">defcon(g)</code> will implement the
raising and lowering of indices through contraction with the metric
tensor.
    More than one <code class="code">defcon</code> can be given for the same indexed object; the
latest one given which applies in a particular contraction will be
used.
<code class="code">contractions</code> is a list of those indexed objects which have been given
contraction properties with <code class="code">defcon</code>.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="remcon"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fremcon"></a><dl class="first-deffn">
<dt class="deffn" id="index-remcon"><span class="category-def">Function: </span><span><strong class="def-name">remcon</strong> <var class="def-var-arguments"><br>&nbsp;&nbsp;&nbsp;&nbsp;<code class="t">remcon</code> (<var class="var">tensor_1</var>, ..., <var class="var">tensor_n</var>) <br>&nbsp;&nbsp;&nbsp;&nbsp;<code class="t">remcon</code> (all)</var><a class="copiable-link" href='#index-remcon'> &para;</a></span></dt>
<dd>
<p>Removes all the contraction properties
from the (<var class="var">tensor_1</var>, ..., <var class="var">tensor_n</var>). <code class="code">remcon(all)</code> removes all contraction
properties from all indexed objects.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="contract_005fItensor"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fcontract"></a><dl class="first-deffn">
<dt class="deffn" id="index-contract"><span class="category-def">Function: </span><span><strong class="def-name">contract</strong> <var class="def-var-arguments">(<var class="var">expr</var>)</var><a class="copiable-link" href='#index-contract'> &para;</a></span></dt>
<dd>
<p>Carries out the tensorial contractions in <var class="var">expr</var> which may be any
combination of sums and products. This function uses the information
given to the <code class="code">defcon</code> function. For best results, <code class="code">expr</code>
should be fully expanded. <code class="code"><a class="ref" href="maxima_13.html#ratexpand">ratexpand</a></code> is the fastest way to expand
products and powers of sums if there are no variables in the denominators
of the terms. The <code class="code"><a class="ref" href="maxima_13.html#gcd">gcd</a></code> switch should be <code class="code">false</code> if GCD
cancellations are unnecessary.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="indexed_005ftensor"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002findexed_005ftensor"></a><dl class="first-deffn">
<dt class="deffn" id="index-indexed_005ftensor"><span class="category-def">Function: </span><span><strong class="def-name">indexed_tensor</strong> <var class="def-var-arguments">(<var class="var">tensor</var>)</var><a class="copiable-link" href='#index-indexed_005ftensor'> &para;</a></span></dt>
<dd>
<p>Must be executed before assigning components to a <var class="var">tensor</var> for which
a built in value already exists as with <code class="code">ichr1</code>, <code class="code">ichr2</code>,
<code class="code">icurvature</code>. See the example under <code class="code"><a class="ref" href="#icurvature">icurvature</a></code>.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="components"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fcomponents"></a><dl class="first-deffn">
<dt class="deffn" id="index-components"><span class="category-def">Function: </span><span><strong class="def-name">components</strong> <var class="def-var-arguments">(<var class="var">tensor</var>, <var class="var">expr</var>)</var><a class="copiable-link" href='#index-components'> &para;</a></span></dt>
<dd>
<p>permits one to assign an indicial value to an expression
<var class="var">expr</var> giving the values of the components of <var class="var">tensor</var>. These
are automatically substituted for the tensor whenever it occurs with
all of its indices. The tensor must be of the form <code class="code">t([...],[...])</code>
where either list may be empty. <var class="var">expr</var> can be any indexed expression
involving other objects with the same free indices as <var class="var">tensor</var>. When
used to assign values to the metric tensor wherein the components
contain dummy indices one must be careful to define these indices to
avoid the generation of multiple dummy indices. Removal of this
assignment is given to the function <code class="code"><a class="ref" href="#remcomps">remcomps</a></code>.
</p>
<p>It is important to keep in mind that <code class="code">components</code> cares only about
the valence of a tensor, not about any particular index ordering. Thus
assigning components to, say, <code class="code">x([i,-j],[])</code>, <code class="code">x([-j,i],[])</code>, or
<code class="code">x([i],[j])</code> all produce the same result, namely components being
assigned to a tensor named <code class="code">x</code> with valence <code class="code">(1,1)</code>.
</p>
<p>Components can be assigned to an indexed expression in four ways, two
of which involve the use of the <code class="code">components</code> command:
</p>
<p>1) As an indexed expression. For instance:
</p>
<div class="example">
<pre class="example-preformatted">(%i2) components(g([],[i,j]),e([],[i])*p([],[j]))$
(%i3) ishow(g([],[i,j]))$
                                      i  j
(%t3)                                e  p

</pre></div>

<p>2) As a matrix:
</p>
<div class="example">
<pre class="example-preformatted">

(%i5) lg:-ident(4)$lg[1,1]:1$lg;
</pre><div class="group"><pre class="example-preformatted">                            [ 1   0    0    0  ]
                            [                  ]
                            [ 0  - 1   0    0  ]
(%o5)                       [                  ]
                            [ 0   0   - 1   0  ]
                            [                  ]
                            [ 0   0    0   - 1 ]
</pre></div><pre class="example-preformatted">(%i6) components(g([i,j],[]),lg);
(%o6)                                done
(%i7) ishow(g([i,j],[]))$
(%t7)                                g
                                      i j
(%i8) g([1,1],[]);
(%o8)                                  1
(%i9) g([4,4],[]);
(%o9)                                 - 1
</pre></div>

<p>3) As a function. You can use a Maxima function to specify the
components of a tensor based on its indices. For instance, the following
code assigns <code class="code"><a class="ref" href="#kdelta">kdelta</a></code> to <code class="code">h</code> if <code class="code">h</code> has the same number
of covariant and contravariant indices and no derivative indices, and
<code class="code">g</code> otherwise:
</p>
<div class="example">
<pre class="example-preformatted">

(%i4) h(l1,l2,[l3]):=if length(l1)=length(l2) and length(l3)=0
  then kdelta(l1,l2) else apply(g,append([l1,l2], l3))$
(%i5) ishow(h([i],[j]))$
                                          j
(%t5)                               kdelta
                                          i
(%i6) ishow(h([i,j],[k],l))$
                                     k
(%t6)                               g
                                     i j,l
</pre></div>

<p>4) Using Maxima&rsquo;s pattern matching capabilities, specifically the
<code class="code"><a class="ref" href="maxima_33.html#defrule">defrule</a></code> and <code class="code"><a class="ref" href="maxima_33.html#applyb1">applyb1</a></code> commands:
</p>
<div class="example">
<pre class="example-preformatted">

(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) matchdeclare(l1,listp);
(%o2)                                done
(%i3) defrule(r1,m(l1,[]),(i1:idummy(),
      g([l1[1],l1[2]],[])*q([i1],[])*e([],[i1])))$

(%i4) defrule(r2,m([],l1),(i1:idummy(),
      w([],[l1[1],l1[2]])*e([i1],[])*q([],[i1])))$

(%i5) ishow(m([i,n],[])*m([],[i,m]))$
</pre><div class="group"><pre class="example-preformatted">                                    i m
(%t5)                              m    m
                                         i n
</pre></div><pre class="example-preformatted">(%i6) ishow(rename(applyb1(%,r1,r2)))$
                           %1  %2  %3 m
(%t6)                     e   q   w     q   e   g
                                         %1  %2  %3 n
</pre></div>

<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="remcomps"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fremcomps"></a><dl class="first-deffn">
<dt class="deffn" id="index-remcomps"><span class="category-def">Function: </span><span><strong class="def-name">remcomps</strong> <var class="def-var-arguments">(<var class="var">tensor</var>)</var><a class="copiable-link" href='#index-remcomps'> &para;</a></span></dt>
<dd>
<p>Unbinds all values from <var class="var">tensor</var> which were assigned with the
<code class="code"><a class="ref" href="#components">components</a></code> function.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>


<a class="anchor" id="showcomps"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fshowcomps"></a><dl class="first-deffn">
<dt class="deffn" id="index-showcomps"><span class="category-def">Function: </span><span><strong class="def-name">showcomps</strong> <var class="def-var-arguments">(<var class="var">tensor</var>)</var><a class="copiable-link" href='#index-showcomps'> &para;</a></span></dt>
<dd>
<p>Shows component assignments of a tensor, as made using the <code class="code"><a class="ref" href="#components">components</a></code>
command. This function can be particularly useful when a matrix is assigned
to an indicial tensor using <code class="code">components</code>, as demonstrated by the
following example:
</p>
<div class="example">
<pre class="example-preformatted">

(%i1) load(&quot;ctensor&quot;);
(%o1)       /share/tensor/ctensor.mac
(%i2) load(&quot;itensor&quot;);
(%o2)      /share/tensor/itensor.lisp
(%i3) lg:matrix([sqrt(r/(r-2*m)),0,0,0],[0,r,0,0],
                [0,0,sin(theta)*r,0],[0,0,0,sqrt((r-2*m)/r)]);
        [         r                                     ]
        [ sqrt(-------)  0       0              0       ]
        [      r - 2 m                                  ]
        [                                               ]
        [       0        r       0              0       ]
(%o3)   [                                               ]
        [       0        0  r sin(theta)        0       ]
        [                                               ]
        [                                      r - 2 m  ]
        [       0        0       0        sqrt(-------) ]
        [                                         r     ]
(%i4) components(g([i,j],[]),lg);
(%o4)                                done
(%i5) showcomps(g([i,j],[]));
             [         r                                     ]
             [ sqrt(-------)  0       0              0       ]
             [      r - 2 m                                  ]
             [                                               ]
             [       0        r       0              0       ]
(%t5) g    = [                                               ]
       i j   [       0        0  r sin(theta)        0       ]
             [                                               ]
             [                                      r - 2 m  ]
             [       0        0       0        sqrt(-------) ]
             [                                         r     ]
(%o5)                                false

</pre></div>

<p>The <code class="code">showcomps</code> command can also display components of a tensor of
rank higher than 2.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="idummy"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fidummy"></a><dl class="first-deffn">
<dt class="deffn" id="index-idummy"><span class="category-def">Function: </span><span><strong class="def-name">idummy</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href='#index-idummy'> &para;</a></span></dt>
<dd>
<p>Increments <code class="code"><a class="ref" href="#icounter">icounter</a></code> and returns as its value an index of the form
<code class="code">%n</code> where n is a positive integer.  This guarantees that dummy indices
which are needed in forming expressions will not conflict with indices
already in use (see the example under <code class="code"><a class="ref" href="#indices">indices</a></code>).
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="idummyx"></a><a class="anchor" id="Item_003a-Itensor_002fdefvr_002fidummyx"></a><dl class="first-defvr">
<dt class="defvr" id="index-idummyx"><span class="category-def">Option variable: </span><span><strong class="def-name">idummyx</strong><a class="copiable-link" href='#index-idummyx'> &para;</a></span></dt>
<dd><p>Default value: <code class="code">%</code>
</p>
<p>Is the prefix for dummy indices (see the example under <code class="code"><a class="ref" href="#indices">indices</a></code>).
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="icounter"></a><a class="anchor" id="Item_003a-Itensor_002fdefvr_002ficounter"></a><dl class="first-defvr">
<dt class="defvr" id="index-icounter"><span class="category-def">Option variable: </span><span><strong class="def-name">icounter</strong><a class="copiable-link" href='#index-icounter'> &para;</a></span></dt>
<dd><p>Default value: <code class="code">1</code>
</p>
<p>Determines the numerical suffix to be used in
generating the next dummy index in the tensor package.  The prefix is
determined by the option <code class="code"><a class="ref" href="#idummy">idummy</a></code> (default: <code class="code">%</code>).
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="kdelta"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fkdelta"></a><dl class="first-deffn">
<dt class="deffn" id="index-kdelta"><span class="category-def">Function: </span><span><strong class="def-name">kdelta</strong> <var class="def-var-arguments">(<var class="var">L1</var>, <var class="var">L2</var>)</var><a class="copiable-link" href='#index-kdelta'> &para;</a></span></dt>
<dd><p>is the generalized Kronecker delta function defined in
the <code class="code">itensor</code> package with <var class="var">L1</var> the list of covariant indices and <var class="var">L2</var>
the list of contravariant indices.  <code class="code">kdelta([i],[j])</code> returns the ordinary
Kronecker delta.  The command <code class="code">ev(<var class="var">expr</var>,kdelta)</code> causes the evaluation of
an expression containing <code class="code">kdelta([],[])</code> to the dimension of the
manifold.
</p>
<p>In what amounts to an abuse of this notation, <code class="code">itensor</code> also allows
<code class="code">kdelta</code> to have 2 covariant and no contravariant, or 2 contravariant
and no covariant indices, in effect providing a co(ntra)variant &quot;unit matrix&quot;
capability. This is strictly considered a programming aid and not meant to
imply that <code class="code">kdelta([i,j],[])</code> is a valid tensorial object.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="kdels"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fkdels"></a><dl class="first-deffn">
<dt class="deffn" id="index-kdels"><span class="category-def">Function: </span><span><strong class="def-name">kdels</strong> <var class="def-var-arguments">(<var class="var">L1</var>, <var class="var">L2</var>)</var><a class="copiable-link" href='#index-kdels'> &para;</a></span></dt>
<dd>
<p>Symmetrized Kronecker delta, used in some calculations. For instance:
</p>
<div class="example">
<pre class="example-preformatted">

(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) kdelta([1,2],[2,1]);
(%o2)                                 - 1
(%i3) kdels([1,2],[2,1]);
(%o3)                                  1
(%i4) ishow(kdelta([a,b],[c,d]))$
                             c       d         d       c
(%t4)                  kdelta  kdelta  - kdelta  kdelta
                             a       b         a       b
(%i4) ishow(kdels([a,b],[c,d]))$
                             c       d         d       c
(%t4)                  kdelta  kdelta  + kdelta  kdelta
                             a       b         a       b

</pre></div>

<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="levi_005fcivita"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002flevi_005fcivita"></a><dl class="first-deffn">
<dt class="deffn" id="index-levi_005fcivita"><span class="category-def">Function: </span><span><strong class="def-name">levi_civita</strong> <var class="def-var-arguments">(<var class="var">L</var>)</var><a class="copiable-link" href='#index-levi_005fcivita'> &para;</a></span></dt>
<dd><p>is the permutation (or Levi-Civita) tensor which yields 1 if
the list <var class="var">L</var> consists of an even permutation of integers, -1 if it
consists of an odd permutation, and 0 if some indices in <var class="var">L</var> are
repeated.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="lc2kdt"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002flc2kdt"></a><dl class="first-deffn">
<dt class="deffn" id="index-lc2kdt"><span class="category-def">Function: </span><span><strong class="def-name">lc2kdt</strong> <var class="def-var-arguments">(<var class="var">expr</var>)</var><a class="copiable-link" href='#index-lc2kdt'> &para;</a></span></dt>
<dd><p>Simplifies expressions containing the Levi-Civita symbol, converting these
to Kronecker-delta expressions when possible. The main difference between
this function and simply evaluating the Levi-Civita symbol is that direct
evaluation often results in Kronecker expressions containing numerical
indices. This is often undesirable as it prevents further simplification.
The <code class="code">lc2kdt</code> function avoids this problem, yielding expressions that
are more easily simplified with <code class="code"><a class="ref" href="#rename">rename</a></code> or <code class="code"><a class="ref" href="maxima_29.html#contract">contract</a></code>.
</p>
<div class="example">
<pre class="example-preformatted">

(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) expr:ishow('levi_civita([],[i,j])
                 *'levi_civita([k,l],[])*a([j],[k]))$
                                  i j  k
(%t2)                  levi_civita    a  levi_civita
                                       j            k l
(%i3) ishow(ev(expr,levi_civita))$
                                  i j  k       1 2
(%t3)                       kdelta    a  kdelta
                                  1 2  j       k l
(%i4) ishow(ev(%,kdelta))$
             i       j         j       i   k
(%t4) (kdelta  kdelta  - kdelta  kdelta ) a
             1       2         1       2   j

                               1       2         2       1
                        (kdelta  kdelta  - kdelta  kdelta )
                               k       l         k       l
(%i5) ishow(lc2kdt(expr))$
                     k       i       j    k       j       i
(%t5)               a  kdelta  kdelta  - a  kdelta  kdelta
                     j       k       l    j       k       l
(%i6) ishow(contract(expand(%)))$
                                 i           i
(%t6)                           a  - a kdelta
                                 l           l
</pre></div>

<p>The <code class="code">lc2kdt</code> function sometimes makes use of the metric tensor.
If the metric tensor was not defined previously with <code class="code"><a class="ref" href="#imetric">imetric</a></code>,
this results in an error.
</p>
<div class="example">
<pre class="example-preformatted">

(%i7) expr:ishow('levi_civita([],[i,j])
                 *'levi_civita([],[k,l])*a([j,k],[]))$
</pre><div class="group"><pre class="example-preformatted">                                 i j            k l
(%t7)                 levi_civita    levi_civita    a
                                                     j k
</pre></div><pre class="example-preformatted">(%i8) ishow(lc2kdt(expr))$
Maxima encountered a Lisp error:

 Error in $IMETRIC [or a callee]:
 $IMETRIC [or a callee] requires less than two arguments.

Automatically continuing.
To re-enable the Lisp debugger set *debugger-hook* to nil.
(%i9) imetric(g);
(%o9)                                done
(%i10) ishow(lc2kdt(expr))$
         %3 i       k   %4 j       l     %3 i       l   %4 j
(%t10) (g     kdelta   g     kdelta   - g     kdelta   g    
                    %3             %4               %3
              k
        kdelta  ) a
              %4   j k
(%i11) ishow(contract(expand(%)))$
                                  l i    l i  j
(%t11)                           a    - g    a
                                              j
</pre></div>


<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>


<a class="anchor" id="lc_005fl"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002flc_005fl"></a><dl class="first-deffn">
<dt class="deffn" id="index-lc_005fl"><span class="category-def">Function: </span><span><strong class="def-name">lc_l</strong><a class="copiable-link" href='#index-lc_005fl'> &para;</a></span></dt>
<dd><p>Simplification rule used for expressions containing the unevaluated Levi-Civita
symbol (<code class="code"><a class="ref" href="#levi_005fcivita">levi_civita</a></code>). Along with <code class="code"><a class="ref" href="#lc_005fu">lc_u</a></code>, it can be used to simplify
many expressions more efficiently than the evaluation of <code class="code">levi_civita</code>.
For example:
</p>
<div class="example">
<pre class="example-preformatted">

(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) el1:ishow('levi_civita([i,j,k],[])*a([],[i])*a([],[j]))$
                             i  j
(%t2)                       a  a  levi_civita
                                             i j k
(%i3) el2:ishow('levi_civita([],[i,j,k])*a([i])*a([j]))$
                                       i j k
(%t3)                       levi_civita      a  a
                                              i  j
(%i4) canform(contract(expand(applyb1(el1,lc_l,lc_u))));
(%t4)                                  0
(%i5) canform(contract(expand(applyb1(el2,lc_l,lc_u))));
(%t5)                                  0

</pre></div>

<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>


<a class="anchor" id="lc_005fu"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002flc_005fu"></a><dl class="first-deffn">
<dt class="deffn" id="index-lc_005fu"><span class="category-def">Function: </span><span><strong class="def-name">lc_u</strong><a class="copiable-link" href='#index-lc_005fu'> &para;</a></span></dt>
<dd>
<p>Simplification rule used for expressions containing the unevaluated Levi-Civita
symbol (<code class="code"><a class="ref" href="#levi_005fcivita">levi_civita</a></code>). Along with <code class="code">lc_u</code>, it can be used to simplify
many expressions more efficiently than the evaluation of <code class="code">levi_civita</code>.
For details, see <code class="code"><a class="ref" href="#lc_005fl">lc_l</a></code>.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="canten"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fcanten"></a><dl class="first-deffn">
<dt class="deffn" id="index-canten"><span class="category-def">Function: </span><span><strong class="def-name">canten</strong> <var class="def-var-arguments">(<var class="var">expr</var>)</var><a class="copiable-link" href='#index-canten'> &para;</a></span></dt>
<dd><p>Simplifies <var class="var">expr</var> by renaming (see <code class="code"><a class="ref" href="#rename">rename</a></code>)
and permuting dummy indices. <code class="code">rename</code> is restricted to sums of tensor
products in which no derivatives are present. As such it is limited
and should only be used if <code class="code"><a class="ref" href="#canform">canform</a></code> is not capable of carrying out the
required simplification.
</p>
<p>The <code class="code">canten</code> function returns a mathematically correct result only
if its argument is an expression that is fully symmetric in its indices.
For this reason, <code class="code">canten</code> returns an error if <code class="code"><a class="ref" href="#allsym">allsym</a></code> is not
set to <code class="code">true</code>.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="concan"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fconcan"></a><dl class="first-deffn">
<dt class="deffn" id="index-concan"><span class="category-def">Function: </span><span><strong class="def-name">concan</strong> <var class="def-var-arguments">(<var class="var">expr</var>)</var><a class="copiable-link" href='#index-concan'> &para;</a></span></dt>
<dd><p>Similar to <code class="code"><a class="ref" href="#canten">canten</a></code> but also performs index contraction.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

</div>
<div class="subsection-level-extent" id="Tensor-symmetries">
<h4 class="subsection">25.2.2 Tensor symmetries</h4>

<a class="anchor" id="allsym"></a><a class="anchor" id="Item_003a-Itensor_002fdefvr_002fallsym"></a><dl class="first-defvr">
<dt class="defvr" id="index-allsym"><span class="category-def">Option variable: </span><span><strong class="def-name">allsym</strong><a class="copiable-link" href='#index-allsym'> &para;</a></span></dt>
<dd><p>Default value: <code class="code">false</code>
</p>
<p>If <code class="code">true</code> then all indexed objects
are assumed symmetric in all of their covariant and contravariant
indices. If <code class="code">false</code> then no symmetries of any kind are assumed
in these indices. Derivative indices are always taken to be symmetric
unless <code class="code">iframe_flag</code> is set to <code class="code">true</code>.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="decsym"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fdecsym"></a><dl class="first-deffn">
<dt class="deffn" id="index-decsym"><span class="category-def">Function: </span><span><strong class="def-name">decsym</strong> <var class="def-var-arguments">(<var class="var">tensor</var>, <var class="var">m</var>, <var class="var">n</var>, [<var class="var">cov_1</var>, <var class="var">cov_2</var>, ...], [<var class="var">contr_1</var>, <var class="var">contr_2</var>, ...])</var><a class="copiable-link" href='#index-decsym'> &para;</a></span></dt>
<dd>
<p>Declares symmetry properties for <var class="var">tensor</var> of <var class="var">m</var> covariant and
<var class="var">n</var> contravariant indices. The <var class="var">cov_i</var> and <var class="var">contr_i</var> are
pseudofunctions expressing symmetry relations among the covariant and
contravariant indices respectively.  These are of the form
<code class="code">symoper(<var class="var">index_1</var>, <var class="var">index_2</var>,...)</code> where <code class="code">symoper</code> is one of
<code class="code">sym</code>, <code class="code">anti</code> or <code class="code">cyc</code> and the <var class="var">index_i</var> are integers
indicating the position of the index in the <var class="var">tensor</var>.  This will
declare <var class="var">tensor</var> to be symmetric, antisymmetric or cyclic respectively
in the <var class="var">index_i</var>. <code class="code">symoper(all)</code> is also an allowable form which
indicates all indices obey the symmetry condition. For example, given an
object <code class="code">b</code> with 5 covariant indices,
<code class="code">decsym(b,5,3,[sym(1,2),anti(3,4)],[cyc(all)])</code> declares <code class="code">b</code>
symmetric in its first and second and antisymmetric in its third and
fourth covariant indices, and cyclic in all of its contravariant indices.
Either list of symmetry declarations may be null.  The function which
performs the simplifications is <code class="code">canform</code> as the example below
illustrates.
</p>
<div class="example">
<pre class="example-preformatted">

(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) expr:contract( expand( a([i1, j1, k1], [])
           *kdels([i, j, k], [i1, j1, k1])))$
(%i3) ishow(expr)$
</pre><div class="group"><pre class="example-preformatted">(%t3)         a      + a      + a      + a      + a      + a
               k j i    k i j    j k i    j i k    i k j    i j k
</pre></div><pre class="example-preformatted">(%i4) decsym(a,3,0,[sym(all)],[]);
(%o4)                                done
(%i5) ishow(canform(expr))$
(%t5)                              6 a
                                      i j k
(%i6) remsym(a,3,0);
(%o6)                                done
(%i7) decsym(a,3,0,[anti(all)],[]);
(%o7)                                done
(%i8) ishow(canform(expr))$
(%t8)                                  0
(%i9) remsym(a,3,0);
(%o9)                                done
(%i10) decsym(a,3,0,[cyc(all)],[]);
(%o10)                               done
(%i11) ishow(canform(expr))$
(%t11)                        3 a      + 3 a
                                 i k j      i j k
(%i12) dispsym(a,3,0);
(%o12)                     [[cyc, [[1, 2, 3]], []]]

</pre></div>

<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="remsym"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fremsym"></a><dl class="first-deffn">
<dt class="deffn" id="index-remsym"><span class="category-def">Function: </span><span><strong class="def-name">remsym</strong> <var class="def-var-arguments">(<var class="var">tensor</var>, <var class="var">m</var>, <var class="var">n</var>)</var><a class="copiable-link" href='#index-remsym'> &para;</a></span></dt>
<dd><p>Removes all symmetry properties from <var class="var">tensor</var> which has <var class="var">m</var>
covariant indices and <var class="var">n</var> contravariant indices.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="dispsym"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fdispsym"></a><dl class="first-deffn">
<dt class="deffn" id="index-dispsym"><span class="category-def">Function: </span><span><strong class="def-name">dispsym</strong> <var class="def-var-arguments">(<var class="var">tensor</var>, <var class="var">m</var>, <var class="var">n</var>)</var><a class="copiable-link" href='#index-dispsym'> &para;</a></span></dt>
<dd><p>Displays all of the defined symmetries from <var class="var">tensor</var> which has <var class="var">m</var>
covariant indices and <var class="var">n</var> contravariant indices. See <code class="code"><a class="ref" href="#decsym">decsym</a></code>
for an example.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="canform"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fcanform"></a><dl class="first-deffn">
<dt class="deffn" id="index-canform"><span class="category-def">Function: </span><span><strong class="def-name">canform</strong> <var class="def-var-arguments"><br>&nbsp;&nbsp;&nbsp;&nbsp;<code class="t">canform</code> (<var class="var">expr</var>) <br>&nbsp;&nbsp;&nbsp;&nbsp;<code class="t">canform</code> (<var class="var">expr</var>, <var class="var">rename</var>)</var><a class="copiable-link" href='#index-canform'> &para;</a></span></dt>
<dd>
<p>Simplifies <var class="var">expr</var> by renaming dummy
indices and reordering all indices as dictated by symmetry conditions
imposed on them. If <code class="code">allsym</code> is <code class="code">true</code> then all indices are assumed
symmetric, otherwise symmetry information provided by <code class="code">decsym</code>
declarations will be used. The dummy indices are renamed in the same
manner as in the <code class="code"><a class="ref" href="#rename">rename</a></code> function. When <code class="code">canform</code> is applied to a large
expression the calculation may take a considerable amount of time.
This time can be shortened by calling <code class="code">rename</code> on the expression first.
Also see the example under <code class="code"><a class="ref" href="#decsym">decsym</a></code>. Note: <code class="code">canform</code> may not be able to
reduce an expression completely to its simplest form although it will
always return a mathematically correct result.
</p>
<p>The optional second parameter <var class="var">rename</var>, if set to <code class="code">false</code>, suppresses renaming.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

</div>
<div class="subsection-level-extent" id="Indicial-tensor-calculus">
<h4 class="subsection">25.2.3 Indicial tensor calculus</h4>

<a class="anchor" id="itensor_005fdiff"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fdiff"></a><dl class="first-deffn">
<dt class="deffn" id="index-diff-1"><span class="category-def">Function: </span><span><strong class="def-name">diff</strong> <var class="def-var-arguments">(<var class="var">expr</var>, <var class="var">v_1</var>, [<var class="var">n_1</var>, [<var class="var">v_2</var>, <var class="var">n_2</var>] ...])</var><a class="copiable-link" href='#index-diff-1'> &para;</a></span></dt>
<dd>
<p>is the usual Maxima differentiation function which has been expanded
in its abilities for <code class="code">itensor</code>. It takes the derivative of <var class="var">expr</var> with
respect to <var class="var">v_1</var> <var class="var">n_1</var> times, with respect to <var class="var">v_2</var> <var class="var">n_2</var>
times, etc. For the tensor package, the function has been modified so
that the <var class="var">v_i</var> may be integers from 1 up to the value of the variable
<code class="code">dim</code>.  This will cause the differentiation to be carried out with
respect to the <var class="var">v_i</var>th member of the list <code class="code">vect_coords</code>.  If
<code class="code">vect_coords</code> is bound to an atomic variable, then that variable
subscripted by <var class="var">v_i</var> will be used for the variable of
differentiation.  This permits an array of coordinate names or
subscripted names like <code class="code">x[1]</code>, <code class="code">x[2]</code>, ...  to be used.
</p>
<p>A further extension adds the ability to <code class="code">diff</code> to compute derivatives
with respect to an indexed variable. In particular, the tensor package knows
how to differentiate expressions containing combinations of the metric tensor
and its derivatives with respect to the metric tensor and its first and
second derivatives. This capability is particularly useful when considering
Lagrangian formulations of a gravitational theory, allowing one to derive
the Einstein tensor and field equations from the action principle.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="idiff"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fidiff"></a><dl class="first-deffn">
<dt class="deffn" id="index-idiff"><span class="category-def">Function: </span><span><strong class="def-name">idiff</strong> <var class="def-var-arguments">(<var class="var">expr</var>, <var class="var">v_1</var>, [<var class="var">n_1</var>, [<var class="var">v_2</var>, <var class="var">n_2</var>] ...])</var><a class="copiable-link" href='#index-idiff'> &para;</a></span></dt>
<dd><p>Indicial differentiation. Unlike <code class="code">diff</code>, which differentiates
with respect to an independent variable, <code class="code">idiff)</code> can be used
to differentiate with respect to a coordinate. For an indexed object,
this amounts to appending the <var class="var">v_i</var> as derivative indices.
Subsequently, derivative indices will be sorted, unless <code class="code">iframe_flag</code>
is set to <code class="code">true</code>.
</p>
<p><code class="code">idiff</code> can also differentiate the determinant of the metric
tensor. Thus, if <code class="code">imetric</code> has been bound to <code class="code">G</code> then
<code class="code">idiff(determinant(g),k)</code> will return
<code class="code">2 * determinant(g) * ichr2([%i,k],[%i])</code> where the dummy index <code class="code">%i</code>
is chosen appropriately.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="liediff"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fliediff"></a><dl class="first-deffn">
<dt class="deffn" id="index-liediff"><span class="category-def">Function: </span><span><strong class="def-name">liediff</strong> <var class="def-var-arguments">(<var class="var">v</var>, <var class="var">ten</var>)</var><a class="copiable-link" href='#index-liediff'> &para;</a></span></dt>
<dd>
<p>Computes the Lie-derivative of the tensorial expression <var class="var">ten</var> with
respect to the vector field <var class="var">v</var>. <var class="var">ten</var> should be any indexed
tensor expression; <var class="var">v</var> should be the name (without indices) of a vector
field. For example:
</p>
<div class="example">
<pre class="example-preformatted">

(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(liediff(v,a([i,j],[])*b([],[k],l)))$
       k    %2            %2          %2
(%t2) b   (v   a       + v   a     + v   a    )
       ,l       i j,%2    ,j  i %2    ,i  %2 j

                          %1  k        %1  k      %1  k
                      + (v   b      - b   v    + v   b   ) a
                              ,%1 l    ,l  ,%1    ,l  ,%1   i j

</pre></div>

<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="rediff"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002frediff"></a><dl class="first-deffn">
<dt class="deffn" id="index-rediff"><span class="category-def">Function: </span><span><strong class="def-name">rediff</strong> <var class="def-var-arguments">(<var class="var">ten</var>)</var><a class="copiable-link" href='#index-rediff'> &para;</a></span></dt>
<dd>
<p>Evaluates all occurrences of the <code class="code"><a class="ref" href="#idiff">idiff</a></code> command in the tensorial
expression <var class="var">ten</var>.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="undiff"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fundiff"></a><dl class="first-deffn">
<dt class="deffn" id="index-undiff"><span class="category-def">Function: </span><span><strong class="def-name">undiff</strong> <var class="def-var-arguments">(<var class="var">expr</var>)</var><a class="copiable-link" href='#index-undiff'> &para;</a></span></dt>
<dd>
<p>Returns an expression equivalent to <var class="var">expr</var> but with all derivatives
of indexed objects replaced by the noun form of the <code class="code"><a class="ref" href="#idiff">idiff</a></code> function. Its
arguments would yield that indexed object if the differentiation were
carried out.  This is useful when it is desired to replace a
differentiated indexed object with some function definition resulting
in <var class="var">expr</var> and then carry out the differentiation by saying
<code class="code">ev(<var class="var">expr</var>, idiff)</code>.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="evundiff"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fevundiff"></a><dl class="first-deffn">
<dt class="deffn" id="index-evundiff"><span class="category-def">Function: </span><span><strong class="def-name">evundiff</strong> <var class="def-var-arguments">(<var class="var">expr</var>)</var><a class="copiable-link" href='#index-evundiff'> &para;</a></span></dt>
<dd>
<p>Equivalent to the execution of <code class="code"><a class="ref" href="#undiff">undiff</a></code>, followed by <code class="code"><a class="ref" href="maxima_7.html#ev">ev</a></code> and
<code class="code"><a class="ref" href="#rediff">rediff</a></code>.
</p>
<p>The point of this operation is to easily evaluate expressions that cannot
be directly evaluated in derivative form. For instance, the following
causes an error:
</p>
<div class="example">
<pre class="example-preformatted">(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) icurvature([i,j,k],[l],m);
Maxima encountered a Lisp error:

 Error in $ICURVATURE [or a callee]:
 $ICURVATURE [or a callee] requires less than three arguments.

Automatically continuing.
To re-enable the Lisp debugger set *debugger-hook* to nil.
</pre></div>

<p>However, if <code class="code"><a class="ref" href="#icurvature">icurvature</a></code> is entered in noun form, it can be evaluated
using <code class="code">evundiff</code>:
</p>
<div class="example">
<pre class="example-preformatted">(%i3) ishow('icurvature([i,j,k],[l],m))$
                                         l
(%t3)                          icurvature
                                         i j k,m
(%i4) ishow(evundiff(%))$
             l              l         %1           l           %1
(%t4) - ichr2        - ichr2     ichr2      - ichr2       ichr2
             i k,j m        %1 j      i k,m        %1 j,m      i k

             l              l         %1           l           %1
      + ichr2        + ichr2     ichr2      + ichr2       ichr2
             i j,k m        %1 k      i j,m        %1 k,m      i j
</pre></div>

<p>Note: In earlier versions of Maxima, derivative forms of the
Christoffel-symbols also could not be evaluated. This has been fixed now,
so <code class="code">evundiff</code> is no longer necessary for expressions like this:
</p>
<div class="example">
<pre class="example-preformatted">(%i5) imetric(g);
(%o5)                                done
(%i6) ishow(ichr2([i,j],[k],l))$
       k %3
      g     (g         - g         + g        )
              j %3,i l    i j,%3 l    i %3,j l
(%t6) -----------------------------------------
                          2

                         k %3
                        g     (g       - g       + g      )
                         ,l     j %3,i    i j,%3    i %3,j
                      + -----------------------------------
                                         2
</pre></div>

<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="flush"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fflush"></a><dl class="first-deffn">
<dt class="deffn" id="index-flush"><span class="category-def">Function: </span><span><strong class="def-name">flush</strong> <var class="def-var-arguments">(<var class="var">expr</var>, <var class="var">tensor_1</var>, <var class="var">tensor_2</var>, ...)</var><a class="copiable-link" href='#index-flush'> &para;</a></span></dt>
<dd><p>Set to zero, in
<var class="var">expr</var>, all occurrences of the <var class="var">tensor_i</var> that have no derivative indices.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="flushd"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fflushd"></a><dl class="first-deffn">
<dt class="deffn" id="index-flushd"><span class="category-def">Function: </span><span><strong class="def-name">flushd</strong> <var class="def-var-arguments">(<var class="var">expr</var>, <var class="var">tensor_1</var>, <var class="var">tensor_2</var>, ...)</var><a class="copiable-link" href='#index-flushd'> &para;</a></span></dt>
<dd><p>Set to zero, in
<var class="var">expr</var>, all occurrences of the <var class="var">tensor_i</var> that have derivative indices.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="flushnd"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fflushnd"></a><dl class="first-deffn">
<dt class="deffn" id="index-flushnd"><span class="category-def">Function: </span><span><strong class="def-name">flushnd</strong> <var class="def-var-arguments">(<var class="var">expr</var>, <var class="var">tensor</var>, <var class="var">n</var>)</var><a class="copiable-link" href='#index-flushnd'> &para;</a></span></dt>
<dd><p>Set to zero, in <var class="var">expr</var>, all
occurrences of the differentiated object <var class="var">tensor</var> that have <var class="var">n</var> or more
derivative indices as the following example demonstrates.
</p><div class="example">
<pre class="example-preformatted">

(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i],[J,r],k,r)+a([i],[j,r,s],k,r,s))$
                                J r      j r s
(%t2)                          a      + a
                                i,k r    i,k r s
(%i3) ishow(flushnd(%,a,3))$
                                     J r
(%t3)                               a
                                     i,k r
</pre></div>

<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="coord"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fcoord"></a><dl class="first-deffn">
<dt class="deffn" id="index-coord"><span class="category-def">Function: </span><span><strong class="def-name">coord</strong> <var class="def-var-arguments">(<var class="var">tensor_1</var>, <var class="var">tensor_2</var>, ...)</var><a class="copiable-link" href='#index-coord'> &para;</a></span></dt>
<dd>
<p>Gives <var class="var">tensor_i</var> the coordinate differentiation property that the
derivative of contravariant vector whose name is one of the
<var class="var">tensor_i</var> yields a Kronecker delta. For example, if <code class="code">coord(x)</code> has
been done then <code class="code">idiff(x([],[i]),j)</code> gives <code class="code">kdelta([i],[j])</code>.
<code class="code">coord</code> is a list of all indexed objects having this property.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="remcoord"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fremcoord"></a><dl class="first-deffn">
<dt class="deffn" id="index-remcoord"><span class="category-def">Function: </span><span><strong class="def-name">remcoord</strong> <var class="def-var-arguments"><br>&nbsp;&nbsp;&nbsp;&nbsp;<code class="t">remcoord</code> (<var class="var">tensor_1</var>, <var class="var">tensor_2</var>, ...) <br>&nbsp;&nbsp;&nbsp;&nbsp;<code class="t">remcoord</code> (all)</var><a class="copiable-link" href='#index-remcoord'> &para;</a></span></dt>
<dd>
<p>Removes the coordinate differentiation property from the <code class="code">tensor_i</code>
that was established by the function <code class="code">coord</code>.  <code class="code">remcoord(all)</code>
removes this property from all indexed objects.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="makebox"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fmakebox"></a><dl class="first-deffn">
<dt class="deffn" id="index-makebox"><span class="category-def">Function: </span><span><strong class="def-name">makebox</strong> <var class="def-var-arguments">(<var class="var">expr</var>,<var class="var">g</var>)</var><a class="copiable-link" href='#index-makebox'> &para;</a></span></dt>
<dd><p>Display <var class="var">expr</var> using the metric <var class="var">g</var> such that
any tensor d&rsquo;Alembertian occurring in <var class="var">expr</var> will be indicated using the
symbol <code class="code">[]</code>.  For example, <code class="code">[]p([m],[n])</code> represents
<code class="code">g([],[i,j])*p([m],[n],i,j)</code>.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="conmetderiv"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fconmetderiv"></a><dl class="first-deffn">
<dt class="deffn" id="index-conmetderiv"><span class="category-def">Function: </span><span><strong class="def-name">conmetderiv</strong> <var class="def-var-arguments">(<var class="var">expr</var>, <var class="var">tensor</var>)</var><a class="copiable-link" href='#index-conmetderiv'> &para;</a></span></dt>
<dd>
<p>Simplifies expressions containing ordinary derivatives of
both covariant and contravariant forms of the metric tensor (the
current restriction).  For example, <code class="code">conmetderiv</code> can relate the
derivative of the contravariant metric tensor with the Christoffel
symbols as seen from the following:
</p>
<div class="example">
<pre class="example-preformatted">

(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(g([],[a,b],c))$
                                      a b
(%t2)                                g
                                      ,c
(%i3) ishow(conmetderiv(%,g))$
                         %1 b      a       %1 a      b
(%t3)                 - g     ichr2     - g     ichr2
                                   %1 c              %1 c
</pre></div>

<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="simpmetderiv"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fsimpmetderiv"></a><dl class="first-deffn">
<dt class="deffn" id="index-simpmetderiv"><span class="category-def">Function: </span><span><strong class="def-name">simpmetderiv</strong> <var class="def-var-arguments"><br>&nbsp;&nbsp;&nbsp;&nbsp;<code class="t">simpmetderiv</code> (<var class="var">expr</var>) <br>&nbsp;&nbsp;&nbsp;&nbsp;<code class="t">simpmetderiv</code> (<var class="var">expr</var>[, <var class="var">stop</var>])</var><a class="copiable-link" href='#index-simpmetderiv'> &para;</a></span></dt>
<dd>
<p>Simplifies expressions containing products of the derivatives of the
metric tensor. Specifically, <code class="code">simpmetderiv</code> recognizes two identities:
</p>
<div class="example">
<pre class="example-preformatted">

   ab        ab           ab                 a
  g   g   + g   g     = (g   g  )   = (kdelta )   = 0
   ,d  bc        bc,d         bc ,d          c ,d

</pre></div>

<p>hence
</p>
<div class="example">
<pre class="example-preformatted">

   ab          ab
  g   g   = - g   g
   ,d  bc          bc,d
</pre></div>

<p>and
</p>
<div class="example">
<pre class="example-preformatted">

  ab          ab
 g   g     = g   g
  ,j  ab,i    ,i  ab,j

</pre></div>

<p>which follows from the symmetries of the Christoffel symbols.
</p>
<p>The <code class="code">simpmetderiv</code> function takes one optional parameter which, when
present, causes the function to stop after the first successful
substitution in a product expression. The <code class="code">simpmetderiv</code> function
also makes use of the global variable <code class="code"><a class="ref" href="#flipflag">flipflag</a></code> which determines
how to apply a &ldquo;canonical&rdquo; ordering to the product indices.
</p>
<p>Put together, these capabilities can be used to achieve powerful
simplifications that are difficult or impossible to accomplish otherwise.
This is demonstrated through the following example that explicitly uses the
partial simplification features of <code class="code">simpmetderiv</code> to obtain a
contractible expression:
</p>
<div class="example">
<pre class="example-preformatted">

(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric(g);
(%o2)                                done
(%i3) ishow(g([],[a,b])*g([],[b,c])*g([a,b],[],d)*g([b,c],[],e))$
                             a b  b c
(%t3)                       g    g    g      g
                                       a b,d  b c,e
(%i4) ishow(canform(%))$

errexp1 has improper indices
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) ishow(simpmetderiv(%))$
                             a b  b c
(%t5)                       g    g    g      g
                                       a b,d  b c,e
(%i6) flipflag:not flipflag;
(%o6)                                true
(%i7) ishow(simpmetderiv(%th(2)))$
                               a b  b c
(%t7)                         g    g    g    g
                               ,d   ,e   a b  b c
(%i8) flipflag:not flipflag;
(%o8)                                false
(%i9) ishow(simpmetderiv(%th(2),stop))$
                               a b  b c
(%t9)                       - g    g    g      g
                                    ,e   a b,d  b c
(%i10) ishow(contract(%))$
                                    b c
(%t10)                           - g    g
                                    ,e   c b,d

</pre></div>

<p>See also <code class="code">weyl.dem</code> for an example that uses <code class="code"><a class="ref" href="#simpmetderiv">simpmetderiv</a></code>
and <code class="code"><a class="ref" href="#conmetderiv">conmetderiv</a></code> together to simplify contractions of the Weyl tensor.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="flush1deriv"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fflush1deriv"></a><dl class="first-deffn">
<dt class="deffn" id="index-flush1deriv"><span class="category-def">Function: </span><span><strong class="def-name">flush1deriv</strong> <var class="def-var-arguments">(<var class="var">expr</var>, <var class="var">tensor</var>)</var><a class="copiable-link" href='#index-flush1deriv'> &para;</a></span></dt>
<dd>
<p>Set to zero, in <code class="code">expr</code>, all occurrences of <code class="code">tensor</code> that have
exactly one derivative index.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

</div>
<div class="subsection-level-extent" id="Tensors-in-curved-spaces">
<h4 class="subsection">25.2.4 Tensors in curved spaces</h4>

<a class="anchor" id="imetric"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fimetric"></a><dl class="first-deffn">
<dt class="deffn" id="index-imetric"><span class="category-def">Function: </span><span><strong class="def-name">imetric</strong> <var class="def-var-arguments">(<var class="var">g</var>)</var><a class="copiable-link" href='#index-imetric'> &para;</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-imetric-1"><span class="category-def">System variable: </span><span><strong class="def-name">imetric</strong><a class="copiable-link" href='#index-imetric-1'> &para;</a></span></dt>
<dd>
<p>Specifies the metric by assigning the variable <code class="code">imetric:<var class="var">g</var></code> in
addition, the contraction properties of the metric <var class="var">g</var> are set up by
executing the commands <code class="code">defcon(<var class="var">g</var>), defcon(<var class="var">g</var>, <var class="var">g</var>, kdelta)</code>.
The variable <code class="code">imetric</code> (unbound by default), is bound to the metric, assigned by
the <code class="code">imetric(<var class="var">g</var>)</code> command.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="idim"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fidim"></a><dl class="first-deffn">
<dt class="deffn" id="index-idim"><span class="category-def">Function: </span><span><strong class="def-name">idim</strong> <var class="def-var-arguments">(<var class="var">n</var>)</var><a class="copiable-link" href='#index-idim'> &para;</a></span></dt>
<dd><p>Sets the dimensions of the metric. Also initializes the antisymmetry
properties of the Levi-Civita symbols for the given dimension.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="ichr1"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fichr1"></a><dl class="first-deffn">
<dt class="deffn" id="index-ichr1"><span class="category-def">Function: </span><span><strong class="def-name">ichr1</strong> <var class="def-var-arguments">([<var class="var">i</var>, <var class="var">j</var>, <var class="var">k</var>])</var><a class="copiable-link" href='#index-ichr1'> &para;</a></span></dt>
<dd><p>Yields the Christoffel symbol of the first kind via the
definition
</p><div class="example">
<pre class="example-preformatted">       (g      + g      - g     )/2 .
         ik,j     jk,i     ij,k
</pre></div>
<p>To evaluate the Christoffel symbols for a particular metric, the
variable <code class="code">imetric</code> must be assigned a name as in the example under <code class="code">chr2</code>.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="ichr2"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fichr2"></a><dl class="first-deffn">
<dt class="deffn" id="index-ichr2"><span class="category-def">Function: </span><span><strong class="def-name">ichr2</strong> <var class="def-var-arguments">([<var class="var">i</var>, <var class="var">j</var>], [<var class="var">k</var>])</var><a class="copiable-link" href='#index-ichr2'> &para;</a></span></dt>
<dd><p>Yields the Christoffel symbol of the second kind
defined by the relation
</p><div class="example">
<pre class="example-preformatted">                       ks
   ichr2([i,j],[k]) = g    (g      + g      - g     )/2
                             is,j     js,i     ij,s
</pre></div>

<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="icurvature"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002ficurvature"></a><dl class="first-deffn">
<dt class="deffn" id="index-icurvature"><span class="category-def">Function: </span><span><strong class="def-name">icurvature</strong> <var class="def-var-arguments">([<var class="var">i</var>, <var class="var">j</var>, <var class="var">k</var>], [<var class="var">h</var>])</var><a class="copiable-link" href='#index-icurvature'> &para;</a></span></dt>
<dd><p>Yields the Riemann
curvature tensor in terms of the Christoffel symbols of the second
kind (<code class="code">ichr2</code>).  The following notation is used:
</p><div class="example">
<pre class="example-preformatted">            h             h            h         %1         h
  icurvature     = - ichr2      - ichr2     ichr2    + ichr2
            i j k         i k,j        %1 j      i k        i j,k
                            h          %1
                     + ichr2      ichr2
                            %1 k       i j
</pre></div>

<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="covdiff"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fcovdiff"></a><dl class="first-deffn">
<dt class="deffn" id="index-covdiff"><span class="category-def">Function: </span><span><strong class="def-name">covdiff</strong> <var class="def-var-arguments">(<var class="var">expr</var>, <var class="var">v_1</var>, <var class="var">v_2</var>, ...)</var><a class="copiable-link" href='#index-covdiff'> &para;</a></span></dt>
<dd><p>Yields the covariant derivative of <var class="var">expr</var> with
respect to the variables <var class="var">v_i</var> in terms of the Christoffel symbols of the
second kind (<code class="code">ichr2</code>).  In order to evaluate these, one should use
<code class="code">ev(<var class="var">expr</var>,ichr2)</code>.
</p>
<div class="example">
<pre class="example-preformatted">

(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) entertensor()$
Enter tensor name: a;
Enter a list of the covariant indices: [i,j];
Enter a list of the contravariant indices: [k];
Enter a list of the derivative indices: [];
                                      k
(%t2)                                a
                                      i j
(%i3) ishow(covdiff(%,s))$
             k         %1     k         %1     k
(%t3)     - a     ichr2    - a     ichr2    + a
             i %1      j s    %1 j      i s    i j,s

             k     %1
      + ichr2     a
             %1 s  i j
(%i4) imetric:g;
(%o4)                                  g
(%i5) ishow(ev(%th(2),ichr2))$
         %1 %4  k
        g      a     (g       - g       + g      )
                i %1   s %4,j    j s,%4    j %4,s
(%t5) - ------------------------------------------
                            2
</pre><div class="group"><pre class="example-preformatted">    %1 %3  k
   g      a     (g       - g       + g      )
           %1 j   s %3,i    i s,%3    i %3,s
 - ------------------------------------------
                       2
    k %2  %1
   g     a    (g        - g        + g       )
          i j   s %2,%1    %1 s,%2    %1 %2,s     k
 + ------------------------------------------- + a
                        2                         i j,s
</pre></div><pre class="example-preformatted">(%i6)
</pre></div>

<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="lorentz"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002florentz_005fgauge"></a><dl class="first-deffn">
<dt class="deffn" id="index-lorentz_005fgauge"><span class="category-def">Function: </span><span><strong class="def-name">lorentz_gauge</strong> <var class="def-var-arguments">(<var class="var">expr</var>)</var><a class="copiable-link" href='#index-lorentz_005fgauge'> &para;</a></span></dt>
<dd><p>Imposes the Lorentz condition by substituting 0 for all
indexed objects in <var class="var">expr</var> that have a derivative index identical to a
contravariant index.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="igeodesic_005fcoords"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002figeodesic_005fcoords"></a><dl class="first-deffn">
<dt class="deffn" id="index-igeodesic_005fcoords"><span class="category-def">Function: </span><span><strong class="def-name">igeodesic_coords</strong> <var class="def-var-arguments">(<var class="var">expr</var>, <var class="var">name</var>)</var><a class="copiable-link" href='#index-igeodesic_005fcoords'> &para;</a></span></dt>
<dd>
<p>Causes undifferentiated Christoffel symbols and
first derivatives of the metric tensor vanish in <var class="var">expr</var>. The <var class="var">name</var>
in the <code class="code"><a class="ref" href="#igeodesic_005fcoords">igeodesic_coords</a></code> function refers to the metric <var class="var">name</var>
(if it appears in <var class="var">expr</var>) while the connection coefficients must be
called with the names <code class="code">ichr1</code> and/or <code class="code">ichr2</code>. The following example
demonstrates the verification of the cyclic identity satisfied by the Riemann
curvature tensor using the <code class="code">igeodesic_coords</code> function.
</p>
<div class="example">
<pre class="example-preformatted">

(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(icurvature([r,s,t],[u]))$
             u            u         %1         u     
(%t2) - ichr2      - ichr2     ichr2    + ichr2      
             r t,s        %1 s      r t        r s,t 

                                              u         %1
                                       + ichr2     ichr2
                                              %1 t      r s
(%i3) ishow(igeodesic_coords(%,ichr2))$
                                 u            u
(%t3)                       ichr2      - ichr2
                                 r s,t        r t,s
(%i4) ishow(igeodesic_coords(icurvature([r,s,t],[u]),ichr2)+
            igeodesic_coords(icurvature([s,t,r],[u]),ichr2)+
            igeodesic_coords(icurvature([t,r,s],[u]),ichr2))$
             u            u            u            u
(%t4) - ichr2      + ichr2      + ichr2      - ichr2
             t s,r        t r,s        s t,r        s r,t

                                             u            u
                                      - ichr2      + ichr2
                                             r t,s        r s,t
(%i5) canform(%);
(%o5)                                  0

</pre></div>

<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

</div>
<div class="subsection-level-extent" id="Moving-frames">
<h4 class="subsection">25.2.5 Moving frames</h4>

<p>Maxima now has the ability to perform calculations using moving frames.
These can be orthonormal frames (tetrads, vielbeins) or an arbitrary frame.
</p>
<p>To use frames, you must first set <code class="code">iframe_flag</code> to <code class="code">true</code>. This
causes the Christoffel-symbols, <code class="code">ichr1</code> and <code class="code">ichr2</code>, to be replaced
by the more general frame connection coefficients <code class="code">icc1</code> and <code class="code">icc2</code>
in calculations. Specifically, the behavior of <code class="code"><a class="ref" href="#covdiff">covdiff</a></code> and
<code class="code">icurvature</code> is changed.
</p>
<p>The frame is defined by two tensors: the inverse frame field (<code class="code"><a class="ref" href="#ifri">ifri</a></code>,
the dual basis tetrad),
and the frame metric <code class="code"><a class="ref" href="#ifg">ifg</a></code>. The frame metric is the identity matrix for
orthonormal frames, or the Lorentz metric for orthonormal frames in Minkowski
spacetime. The inverse frame field defines the frame base (unit vectors).
Contraction properties are defined for the frame field and the frame metric.
</p>
<p>When <code class="code">iframe_flag</code> is true, many <code class="code">itensor</code> expressions use the frame
metric <code class="code">ifg</code> instead of the metric defined by <code class="code">imetric</code> for
raising and lowerind indices.
</p>
<p>IMPORTANT: Setting the variable <code class="code">iframe_flag</code> to <code class="code">true</code> does NOT
undefine the contraction properties of a metric defined by a call to
<code class="code">defcon</code> or <code class="code">imetric</code>. If a frame field is used, it is best to
define the metric by assigning its name to the variable <code class="code">imetric</code>
and NOT invoke the <code class="code">imetric</code> function.
</p>
<p>Maxima uses these two tensors to define the frame coefficients (<code class="code">ifc1</code>
and <code class="code">ifc2</code>) which form part of the connection coefficients (<code class="code">icc1</code>
and <code class="code">icc2</code>), as the following example demonstrates:
</p>
<div class="example">
<pre class="example-preformatted">

(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) iframe_flag:true;
(%o2)                                true
(%i3) ishow(covdiff(v([],[i]),j))$
                               i        i     %1
(%t3)                         v   + icc2     v
                               ,j       %1 j
(%i4) ishow(ev(%,icc2))$
                               %1     i       i
(%t4)                         v   ifc2     + v
                                      %1 j    ,j
(%i5) ishow(ev(%,ifc2))$
                          %1    i %2                i
(%t5)                    v   ifg     ifc1        + v
                                         %1 j %2    ,j
(%i6) ishow(ev(%,ifc1))$
</pre><div class="group"><pre class="example-preformatted">            %1    i %2
           v   ifg     (ifb        - ifb        + ifb       )
                           j %2 %1      %2 %1 j      %1 j %2     i
(%t6)      -------------------------------------------------- + v
                                   2                             ,j
</pre></div><pre class="example-preformatted">(%i7) ishow(ifb([a,b,c]))$
                                                   %3    %4
(%t7)               (ifri        - ifri       ) ifr   ifr
                         a %3,%4       a %4,%3     b     c

</pre></div>

<p>An alternate method is used to compute the frame bracket (<code class="code">ifb</code>) if
the <code class="code">iframe_bracket_form</code> flag is set to <code class="code">false</code>:
</p>
<div class="example">
<pre class="example-preformatted">

(%i8) block([iframe_bracket_form:false],ishow(ifb([a,b,c])))$
                                %6    %5        %5      %6
(%t8)              ifri     (ifr   ifr     - ifr     ifr  )
                       a %5     b     c,%6      b,%6    c

</pre></div>

<a class="anchor" id="iframes"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fiframes"></a><dl class="first-deffn">
<dt class="deffn" id="index-iframes"><span class="category-def">Function: </span><span><strong class="def-name">iframes</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href='#index-iframes'> &para;</a></span></dt>
<dd>
<p>Since in this version of Maxima, contraction identities for <code class="code"><a class="ref" href="#ifr">ifr</a></code> and
<code class="code"><a class="ref" href="#ifri">ifri</a></code> are always defined, as is the frame bracket (<code class="code"><a class="ref" href="#ifb">ifb</a></code>), this
function does nothing.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="ifb"></a><a class="anchor" id="Item_003a-Itensor_002fdefvr_002fifb"></a><dl class="first-defvr">
<dt class="defvr" id="index-ifb"><span class="category-def">Variable: </span><span><strong class="def-name">ifb</strong><a class="copiable-link" href='#index-ifb'> &para;</a></span></dt>
<dd>
<p>The frame bracket. The contribution of the frame metric to the connection
coefficients is expressed using the frame bracket:
</p>
<div class="example">
<pre class="example-preformatted">

          - ifb      + ifb      + ifb
               c a b      b c a      a b c
ifc1    = --------------------------------
    abc                  2

</pre></div>

<p>The frame bracket itself is defined in terms of the frame field and frame
metric. Two alternate methods of computation are used depending on the
value of <code class="code">frame_bracket_form</code>. If true (the default) or if the
<code class="code">itorsion_flag</code> is <code class="code">true</code>:
</p>
<div class="example">
<pre class="example-preformatted">

          d      e                                      f
ifb =  ifr    ifr   (ifri      - ifri      - ifri    itr   )
   abc    b      c       a d,e       a e,d       a f    d e


</pre></div>

<p>Otherwise:
</p>
<div class="example">
<pre class="example-preformatted">

             e      d        d      e
ifb    = (ifr    ifr    - ifr    ifr   ) ifri
   abc       b      c,e      b,e    c        a d

</pre></div>

<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="icc1"></a><a class="anchor" id="Item_003a-Itensor_002fdefvr_002ficc1"></a><dl class="first-defvr">
<dt class="defvr" id="index-icc1"><span class="category-def">Variable: </span><span><strong class="def-name">icc1</strong><a class="copiable-link" href='#index-icc1'> &para;</a></span></dt>
<dd>
<p>Connection coefficients of the first kind. In <code class="code">itensor</code>, defined as
</p>
<div class="example">
<pre class="example-preformatted">

icc1    = ichr1    - ikt1    - inmc1
    abc        abc       abc        abc

</pre></div>

<p>In this expression, if <code class="code">iframe_flag</code> is true, the Christoffel-symbol
<code class="code">ichr1</code> is replaced with the frame connection coefficient <code class="code">ifc1</code>.
If <code class="code">itorsion_flag</code> is <code class="code">false</code>, <code class="code"><a class="ref" href="#ikt1">ikt1</a></code>
will be omitted. It is also omitted if a frame base is used, as the
torsion is already calculated as part of the frame bracket.
Lastly, of <code class="code">inonmet_flag</code> is <code class="code">false</code>,
<code class="code"><a class="ref" href="#inmc1">inmc1</a></code> will not be present.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="icc2"></a><a class="anchor" id="Item_003a-Itensor_002fdefvr_002ficc2"></a><dl class="first-defvr">
<dt class="defvr" id="index-icc2"><span class="category-def">Variable: </span><span><strong class="def-name">icc2</strong><a class="copiable-link" href='#index-icc2'> &para;</a></span></dt>
<dd>
<p>Connection coefficients of the second kind. In <code class="code">itensor</code>, defined as
</p>
<div class="example">
<pre class="example-preformatted">

    c         c        c         c
icc2   = ichr2   - ikt2   - inmc2
    ab        ab       ab        ab

</pre></div>

<p>In this expression, if <code class="code">iframe_flag</code> is true, the Christoffel-symbol
<code class="code">ichr2</code> is replaced with the frame connection coefficient <code class="code">ifc2</code>.
If <code class="code">itorsion_flag</code> is <code class="code">false</code>, <code class="code">ikt2</code>
will be omitted. It is also omitted if a frame base is used, as the
torsion is already calculated as part of the frame bracket.
Lastly, of <code class="code">inonmet_flag</code> is <code class="code">false</code>,
<code class="code"><a class="ref" href="#inmc2">inmc2</a></code> will not be present.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="ifc1"></a><a class="anchor" id="Item_003a-Itensor_002fdefvr_002fifc1"></a><dl class="first-defvr">
<dt class="defvr" id="index-ifc1"><span class="category-def">Variable: </span><span><strong class="def-name">ifc1</strong><a class="copiable-link" href='#index-ifc1'> &para;</a></span></dt>
<dd>
<p>Frame coefficient of the first kind (also known as Ricci-rotation
coefficients.) This tensor represents the contribution
of the frame metric to the connection coefficient of the first kind. Defined
as:
</p>
<div class="example">
<pre class="example-preformatted">

          - ifb      + ifb      + ifb
               c a b      b c a      a b c
ifc1    = --------------------------------
    abc                   2


</pre></div>

<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="ifc2"></a><a class="anchor" id="Item_003a-Itensor_002fdefvr_002fifc2"></a><dl class="first-defvr">
<dt class="defvr" id="index-ifc2"><span class="category-def">Variable: </span><span><strong class="def-name">ifc2</strong><a class="copiable-link" href='#index-ifc2'> &para;</a></span></dt>
<dd>
<p>Frame coefficient of the second kind. This tensor represents the contribution
of the frame metric to the connection coefficient of the second kind. Defined
as a permutation of the frame bracket (<code class="code"><a class="ref" href="#ifb">ifb</a></code>) with the appropriate
indices raised and lowered as necessary:
</p>
<div class="example">
<pre class="example-preformatted">

    c       cd
ifc2   = ifg   ifc1
    ab             abd

</pre></div>

<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="ifr"></a><a class="anchor" id="Item_003a-Itensor_002fdefvr_002fifr"></a><dl class="first-defvr">
<dt class="defvr" id="index-ifr"><span class="category-def">Variable: </span><span><strong class="def-name">ifr</strong><a class="copiable-link" href='#index-ifr'> &para;</a></span></dt>
<dd>
<p>The frame field. Contracts with the inverse frame field (<code class="code"><a class="ref" href="#ifri">ifri</a></code>) to
form the frame metric (<code class="code"><a class="ref" href="#ifg">ifg</a></code>).
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="ifri"></a><a class="anchor" id="Item_003a-Itensor_002fdefvr_002fifri"></a><dl class="first-defvr">
<dt class="defvr" id="index-ifri"><span class="category-def">Variable: </span><span><strong class="def-name">ifri</strong><a class="copiable-link" href='#index-ifri'> &para;</a></span></dt>
<dd>
<p>The inverse frame field. Specifies the frame base (dual basis vectors). Along
with the frame metric, it forms the basis of all calculations based on
frames.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="ifg"></a><a class="anchor" id="Item_003a-Itensor_002fdefvr_002fifg"></a><dl class="first-defvr">
<dt class="defvr" id="index-ifg"><span class="category-def">Variable: </span><span><strong class="def-name">ifg</strong><a class="copiable-link" href='#index-ifg'> &para;</a></span></dt>
<dd>
<p>The frame metric. Defaults to <code class="code"><a class="ref" href="#kdelta">kdelta</a></code>, but can be changed using
<code class="code"><a class="ref" href="#components">components</a></code>.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="ifgi"></a><a class="anchor" id="Item_003a-Itensor_002fdefvr_002fifgi"></a><dl class="first-defvr">
<dt class="defvr" id="index-ifgi"><span class="category-def">Variable: </span><span><strong class="def-name">ifgi</strong><a class="copiable-link" href='#index-ifgi'> &para;</a></span></dt>
<dd>
<p>The inverse frame metric. Contracts with the frame metric (<code class="code"><a class="ref" href="#ifg">ifg</a></code>)
to <code class="code"><a class="ref" href="#kdelta">kdelta</a></code>.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="iframe_005fbracket_005fform"></a><a class="anchor" id="Item_003a-Itensor_002fdefvr_002fiframe_005fbracket_005fform"></a><dl class="first-defvr">
<dt class="defvr" id="index-iframe_005fbracket_005fform"><span class="category-def">Option variable: </span><span><strong class="def-name">iframe_bracket_form</strong><a class="copiable-link" href='#index-iframe_005fbracket_005fform'> &para;</a></span></dt>
<dd><p>Default value: <code class="code">true</code>
</p>
<p>Specifies how the frame bracket (<code class="code"><a class="ref" href="#ifb">ifb</a></code>) is computed.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

</div>
<div class="subsection-level-extent" id="Torsion-and-nonmetricity">
<h4 class="subsection">25.2.6 Torsion and nonmetricity</h4>

<p>Maxima can now take into account torsion and nonmetricity. When the flag
<code class="code">itorsion_flag</code> is set to <code class="code">true</code>, the contribution of torsion
is added to the connection coefficients. Similarly, when the flag
<code class="code">inonmet_flag</code> is true, nonmetricity components are included.
</p>
<a class="anchor" id="inm"></a><a class="anchor" id="Item_003a-Itensor_002fdefvr_002finm"></a><dl class="first-defvr">
<dt class="defvr" id="index-inm"><span class="category-def">Variable: </span><span><strong class="def-name">inm</strong><a class="copiable-link" href='#index-inm'> &para;</a></span></dt>
<dd>
<p>The nonmetricity vector. Conformal nonmetricity is defined through the
covariant derivative of the metric tensor. Normally zero, the metric
tensor&rsquo;s covariant derivative will evaluate to the following when
<code class="code">inonmet_flag</code> is set to <code class="code">true</code>:
</p>
<div class="example">
<pre class="example-preformatted">

g     =- g  inm
 ij;k     ij   k

</pre></div>

<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="inmc1"></a><a class="anchor" id="Item_003a-Itensor_002fdefvr_002finmc1"></a><dl class="first-defvr">
<dt class="defvr" id="index-inmc1"><span class="category-def">Variable: </span><span><strong class="def-name">inmc1</strong><a class="copiable-link" href='#index-inmc1'> &para;</a></span></dt>
<dd>
<p>Covariant permutation of the nonmetricity vector components. Defined as
</p>
<div class="example">
<pre class="example-preformatted">

           g   inm  - inm  g   - g   inm
            ab    c      a  bc    ac    b
inmc1    = ------------------------------
     abc                 2

</pre></div>

<p>(Substitute <code class="code"><a class="ref" href="#ifg">ifg</a></code> in place of <code class="code">g</code> if a frame metric is used.)
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="inmc2"></a><a class="anchor" id="Item_003a-Itensor_002fdefvr_002finmc2"></a><dl class="first-defvr">
<dt class="defvr" id="index-inmc2"><span class="category-def">Variable: </span><span><strong class="def-name">inmc2</strong><a class="copiable-link" href='#index-inmc2'> &para;</a></span></dt>
<dd>
<p>Contravariant permutation of the nonmetricity vector components. Used
in the connection coefficients if <code class="code">inonmet_flag</code> is <code class="code">true</code>. Defined
as:
</p>
<div class="example">
<pre class="example-preformatted">

                      c         c         cd
          -inm  kdelta  - kdelta  inm  + g   inm  g
     c        a       b         a    b          d  ab
inmc2   = -------------------------------------------
     ab                        2

</pre></div>

<p>(Substitute <code class="code"><a class="ref" href="#ifg">ifg</a></code> in place of <code class="code">g</code> if a frame metric is used.)
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="ikt1"></a><a class="anchor" id="Item_003a-Itensor_002fdefvr_002fikt1"></a><dl class="first-defvr">
<dt class="defvr" id="index-ikt1"><span class="category-def">Variable: </span><span><strong class="def-name">ikt1</strong><a class="copiable-link" href='#index-ikt1'> &para;</a></span></dt>
<dd>
<p>Covariant permutation of the torsion tensor (also known as contorsion).
Defined as:
</p>
<div class="example">
<pre class="example-preformatted">

                  d           d       d
          -g   itr  - g    itr   - itr   g
            ad    cb    bd    ca      ab  cd
ikt1    = ----------------------------------
    abc                   2

</pre></div>

<p>(Substitute <code class="code"><a class="ref" href="#ifg">ifg</a></code> in place of <code class="code">g</code> if a frame metric is used.)
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="ikt2"></a><a class="anchor" id="Item_003a-Itensor_002fdefvr_002fikt2"></a><dl class="first-defvr">
<dt class="defvr" id="index-ikt2"><span class="category-def">Variable: </span><span><strong class="def-name">ikt2</strong><a class="copiable-link" href='#index-ikt2'> &para;</a></span></dt>
<dd>
<p>Contravariant permutation of the torsion tensor (also known as contorsion).
Defined as:
</p>
<div class="example">
<pre class="example-preformatted">

    c     cd
ikt2   = g   ikt1
    ab           abd

</pre></div>

<p>(Substitute <code class="code"><a class="ref" href="#ifg">ifg</a></code> in place of <code class="code">g</code> if a frame metric is used.)
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="itr"></a><a class="anchor" id="Item_003a-Itensor_002fdefvr_002fitr"></a><dl class="first-defvr">
<dt class="defvr" id="index-itr"><span class="category-def">Variable: </span><span><strong class="def-name">itr</strong><a class="copiable-link" href='#index-itr'> &para;</a></span></dt>
<dd>
<p>The torsion tensor. For a metric with torsion, repeated covariant
differentiation on a scalar function will not commute, as demonstrated
by the following example:
</p>
<div class="example">
<pre class="example-preformatted">

(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric:g;
(%o2)                                  g
(%i3) covdiff( covdiff( f( [], []), i), j)
                      - covdiff( covdiff( f( [], []), j), i)$
(%i4) ishow(%)$
                                   %4              %2
(%t4)                    f    ichr2    - f    ichr2
                          ,%4      j i    ,%2      i j
(%i5) canform(%);
(%o5)                                  0
(%i6) itorsion_flag:true;
(%o6)                                true
(%i7) covdiff( covdiff( f( [], []), i), j)
                      - covdiff( covdiff( f( [], []), j), i)$
(%i8) ishow(%)$
                           %8             %6
(%t8)             f    icc2    - f    icc2    - f     + f
                   ,%8     j i    ,%6     i j    ,j i    ,i j
(%i9) ishow(canform(%))$
                                   %1             %1
(%t9)                     f    icc2    - f    icc2
                           ,%1     j i    ,%1     i j
(%i10) ishow(canform(ev(%,icc2)))$
                                   %1             %1
(%t10)                    f    ikt2    - f    ikt2
                           ,%1     i j    ,%1     j i
(%i11) ishow(canform(ev(%,ikt2)))$
                      %2 %1                    %2 %1
(%t11)          f    g      ikt1       - f    g      ikt1
                 ,%2            i j %1    ,%2            j i %1
(%i12) ishow(factor(canform(rename(expand(ev(%,ikt1))))))$
                           %3 %2            %1       %1
                     f    g      g      (itr    - itr   )
                      ,%3         %2 %1     j i      i j
(%t12)               ------------------------------------
                                      2
(%i13) decsym(itr,2,1,[anti(all)],[]);
(%o13)                               done
(%i14) defcon(g,g,kdelta);
(%o14)                               done
(%i15) subst(g,nounify(g),%th(3))$
(%i16) ishow(canform(contract(%)))$
                                           %1
(%t16)                           - f    itr
                                    ,%1    i j

</pre></div>

<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

</div>
<div class="subsection-level-extent" id="Exterior-algebra">
<h4 class="subsection">25.2.7 Exterior algebra</h4>

<p>The <code class="code">itensor</code> package can perform operations on totally antisymmetric
covariant tensor fields. A totally antisymmetric tensor field of rank
(0,L) corresponds with a differential L-form. On these objects, a
multiplication operation known as the exterior product, or wedge product,
is defined.
</p>
<p>Unfortunately, not all authors agree on the definition of the wedge
product. Some authors prefer a definition that corresponds with the
notion of antisymmetrization: in these works, the wedge product of
two vector fields, for instance, would be defined as
</p>
<div class="example">
<pre class="example-preformatted">            a a  - a a
             i j    j i
 a  /\ a  = -----------
  i     j        2
</pre></div>

<p>More generally, the product of a p-form and a q-form would be defined as
</p>
<div class="example">
<pre class="example-preformatted">                       1     k1..kp l1..lq
A       /\ B       = ------ D              A       B
 i1..ip     j1..jq   (p+q)!  i1..ip j1..jq  k1..kp  l1..lq
</pre></div>

<p>where <code class="code">D</code> stands for the Kronecker-delta.
</p>
<p>Other authors, however, prefer a &ldquo;geometric&rdquo; definition that corresponds
with the notion of the volume element:
</p>
<div class="example">
<pre class="example-preformatted">a  /\ a  = a a  - a a
 i     j    i j    j i
</pre></div>

<p>and, in the general case
</p>
<div class="example">
<pre class="example-preformatted">                       1    k1..kp l1..lq
A       /\ B       = ----- D              A       B
 i1..ip     j1..jq   p! q!  i1..ip j1..jq  k1..kp  l1..lq
</pre></div>

<p>Since <code class="code">itensor</code> is a tensor algebra package, the first of these two
definitions appears to be the more natural one. Many applications, however,
utilize the second definition. To resolve this dilemma, a flag has been
implemented that controls the behavior of the wedge product: if
<code class="code"><a class="ref" href="#igeowedge_005fflag">igeowedge_flag</a></code> is <code class="code">false</code> (the default), the first, &quot;tensorial&quot;
definition is used, otherwise the second, &quot;geometric&quot; definition will
be applied.
</p>
<a class="anchor" id="g_t_007e"></a><a class="anchor" id="Item_003a-Itensor_002fdefvr_002f_007e"></a><dl class="first-defvr">
<dt class="defvr" id="index-_007e"><span class="category-def">Operator: </span><span><strong class="def-name">~</strong><a class="copiable-link" href='#index-_007e'> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-Wedge-product"></a>

<p>The wedge product operator is denoted by the tilde <code class="code">~</code>. This is
a binary operator. Its arguments should be expressions involving scalars,
covariant tensors of rank one, or covariant tensors of rank <code class="code">l</code> that
have been declared antisymmetric in all covariant indices.
</p>
<p>The behavior of the wedge product operator is controlled by the
<code class="code"><a class="ref" href="#igeowedge_005fflag">igeowedge_flag</a></code> flag, as in the following example:
</p>
<div class="example">
<pre class="example-preformatted">(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i])~b([j]))$
                                 a  b  - b  a
                                  i  j    i  j
(%t2)                            -------------
                                       2
(%i3) decsym(a,2,0,[anti(all)],[]);
(%o3)                                done
(%i4) ishow(a([i,j])~b([k]))$
                          a    b  + b  a    - a    b
                           i j  k    i  j k    i k  j
(%t4)                     ---------------------------
                                       3
(%i5) igeowedge_flag:true;
(%o5)                                true
(%i6) ishow(a([i])~b([j]))$
(%t6)                            a  b  - b  a
                                  i  j    i  j
(%i7) ishow(a([i,j])~b([k]))$
(%t7)                     a    b  + b  a    - a    b
                           i j  k    i  j k    i k  j
</pre></div>

<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
<a class="ref" href="Documentation-Categories.html#Category_003a-Operators">Operators</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="g_t_007c"></a><a class="anchor" id="Item_003a-Itensor_002fdefvr_002f_007c"></a><dl class="first-defvr">
<dt class="defvr" id="index-_007c"><span class="category-def">Operator: </span><span><strong class="def-name">|</strong><a class="copiable-link" href='#index-_007c'> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-Contraction-with-a-vector"></a>

<p>The vertical bar <code class="code">|</code> denotes the &quot;contraction with a vector&quot; binary
operation. When a totally antisymmetric covariant tensor is contracted
with a contravariant vector, the result is the same regardless which index
was used for the contraction. Thus, it is possible to define the
contraction operation in an index-free manner.
</p>
<p>In the <code class="code">itensor</code> package, contraction with a vector is always carried out
with respect to the first index in the literal sorting order. This ensures
better simplification of expressions involving the <code class="code">|</code> operator. For instance:
</p>
<div class="example">
<pre class="example-preformatted">(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) decsym(a,2,0,[anti(all)],[]);
(%o2)                                done
(%i3) ishow(a([i,j],[])|v)$
                                    %1
(%t3)                              v   a
                                        %1 j
(%i4) ishow(a([j,i],[])|v)$
                                     %1
(%t4)                             - v   a
                                         %1 j
</pre></div>

<p>Note that it is essential that the tensors used with the <code class="code">|</code> operator be
declared totally antisymmetric in their covariant indices. Otherwise,
the results will be incorrect.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
<a class="ref" href="Documentation-Categories.html#Category_003a-Operators">Operators</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="extdiff"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fextdiff"></a><dl class="first-deffn">
<dt class="deffn" id="index-extdiff"><span class="category-def">Function: </span><span><strong class="def-name">extdiff</strong> <var class="def-var-arguments">(<var class="var">expr</var>, <var class="var">i</var>)</var><a class="copiable-link" href='#index-extdiff'> &para;</a></span></dt>
<dd>
<p>Computes the exterior derivative of <var class="var">expr</var> with respect to the index
<var class="var">i</var>. The exterior derivative is formally defined as the wedge
product of the partial derivative operator and a differential form. As
such, this operation is also controlled by the setting of <code class="code"><a class="ref" href="#igeowedge_005fflag">igeowedge_flag</a></code>.
For instance:
</p>
<div class="example">
<pre class="example-preformatted">(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(extdiff(v([i]),j))$
                                  v    - v
                                   j,i    i,j
(%t2)                             -----------
                                       2
(%i3) decsym(a,2,0,[anti(all)],[]);
(%o3)                                done
(%i4) ishow(extdiff(a([i,j]),k))$
                           a      - a      + a
                            j k,i    i k,j    i j,k
(%t4)                      ------------------------
                                      3
(%i5) igeowedge_flag:true;
(%o5)                                true
(%i6) ishow(extdiff(v([i]),j))$
(%t6)                             v    - v
                                   j,i    i,j
(%i7) ishow(extdiff(a([i,j]),k))$
(%t7)                    - (a      - a      + a     )
                             k j,i    k i,j    j i,k

</pre></div>

<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="hodge"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fhodge"></a><dl class="first-deffn">
<dt class="deffn" id="index-hodge"><span class="category-def">Function: </span><span><strong class="def-name">hodge</strong> <var class="def-var-arguments">(<var class="var">expr</var>)</var><a class="copiable-link" href='#index-hodge'> &para;</a></span></dt>
<dd>
<p>Compute the Hodge-dual of <var class="var">expr</var>. For instance:
</p>
<div class="example">
<pre class="example-preformatted">

(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric(g);
(%o2)                            done
(%i3) idim(4);
(%o3)                            done
(%i4) icounter:100;
(%o4)                             100
(%i5) decsym(A,3,0,[anti(all)],[])$

(%i6) ishow(A([i,j,k],[]))$
(%t6)                           A
                                 i j k
(%i7) ishow(canform(hodge(%)))$
                          %1 %2 %3 %4
               levi_civita            g        A
                                       %1 %102  %2 %3 %4
(%t7)          -----------------------------------------
                                   6
(%i8) ishow(canform(hodge(%)))$
                 %1 %2 %3 %8            %4 %5 %6 %7
(%t8) levi_civita            levi_civita            g       
                                                     %1 %106
                             g        g        g      A         /6
                              %2 %107  %3 %108  %4 %8  %5 %6 %7
(%i9) lc2kdt(%)$

(%i10) %,kdelta$

(%i11) ishow(canform(contract(expand(%))))$
(%t11)                     - A
                              %106 %107 %108

</pre></div>

<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

<a class="anchor" id="igeowedge_005fflag"></a><a class="anchor" id="Item_003a-Itensor_002fdefvr_002figeowedge_005fflag"></a><dl class="first-defvr">
<dt class="defvr" id="index-igeowedge_005fflag"><span class="category-def">Option variable: </span><span><strong class="def-name">igeowedge_flag</strong><a class="copiable-link" href='#index-igeowedge_005fflag'> &para;</a></span></dt>
<dd><p>Default value: <code class="code">false</code>
</p>
<p>Controls the behavior of the wedge product and exterior derivative. When
set to <code class="code">false</code> (the default), the notion of differential forms will
correspond with that of a totally antisymmetric covariant tensor field.
When set to <code class="code">true</code>, differential forms will agree with the notion
of the volume element.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
</div>
</dd></dl>

</div>
<div class="subsection-level-extent" id="Exporting-TeX-expressions">
<h4 class="subsection">25.2.8 Exporting TeX expressions</h4>

<p>The <code class="code">itensor</code> package provides limited support for exporting tensor
expressions to TeX. Since <code class="code">itensor</code> expressions appear as function calls,
the regular Maxima <code class="code"><a class="ref" href="maxima_12.html#tex">tex</a></code> command will not produce the expected
output. You can try instead the <code class="code"><a class="ref" href="#tentex">tentex</a></code> command, which attempts
to translate tensor expressions into appropriately indexed TeX objects.
</p>
<a class="anchor" id="tentex"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002ftentex"></a><dl class="first-deffn">
<dt class="deffn" id="index-tentex"><span class="category-def">Function: </span><span><strong class="def-name">tentex</strong> <var class="def-var-arguments">(<var class="var">expr</var>)</var><a class="copiable-link" href='#index-tentex'> &para;</a></span></dt>
<dd>
<p>To use the <code class="code">tentex</code> function, you must first load <code class="code">tentex</code>,
as in the following example:
</p>
<div class="example">
<pre class="example-preformatted">(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) load(&quot;tentex&quot;);
(%o2)       /share/tensor/tentex.lisp
(%i3) idummyx:m;
(%o3)                                  m
(%i4) ishow(icurvature([j,k,l],[i]))$
            m1       i           m1       i           i
(%t4)  ichr2    ichr2     - ichr2    ichr2     - ichr2
            j k      m1 l        j l      m1 k        j l,k

                                                      i
                                               + ichr2
                                                      j k,l
(%i5) tentex(%)$
$$\Gamma_{j\,k}^{m_1}\,\Gamma_{l\,m_1}^{i}-\Gamma_{j\,l}^{m_1}\,
 \Gamma_{k\,m_1}^{i}-\Gamma_{j\,l,k}^{i}+\Gamma_{j\,k,l}^{i}$$
</pre></div>

<p>Note the use of the <code class="code">idummyx</code> assignment, to avoid the appearance
of the percent sign in the TeX expression, which may lead to compile errors.
</p>
<p>NB: This version of the <code class="code">tentex</code> function is somewhat experimental.
</p>
<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
<a class="ref" href="Documentation-Categories.html#Category_003a-TeX-output">TeX output</a>
&middot;
</div>
</dd></dl>

</div>
<div class="subsection-level-extent" id="Interfacing-with-ctensor">
<h4 class="subsection">25.2.9 Interfacing with ctensor</h4>

<p>The <code class="code">itensor</code> package has the ability to generate Maxima code that can
then be executed in the context of the <code class="code">ctensor</code> package. The function that performs
this task is <code class="code"><a class="ref" href="#ic_005fconvert">ic_convert</a></code>.
</p>
<a class="anchor" id="ic_005fconvert"></a><a class="anchor" id="Item_003a-Itensor_002fdeffn_002fic_005fconvert"></a><dl class="first-deffn">
<dt class="deffn" id="index-ic_005fconvert"><span class="category-def">Function: </span><span><strong class="def-name">ic_convert</strong> <var class="def-var-arguments">(<var class="var">eqn</var>)</var><a class="copiable-link" href='#index-ic_005fconvert'> &para;</a></span></dt>
<dd>
<p>Converts the <code class="code">itensor</code> equation <var class="var">eqn</var> to a <code class="code">ctensor</code> assignment statement.
Implied sums over dummy indices are made explicit while indexed
objects are transformed into arrays (the array subscripts are in the
order of covariant followed by contravariant indices of the indexed
objects). The derivative of an indexed object will be replaced by the
noun form of <code class="code"><a class="ref" href="maxima_17.html#diff">diff</a></code> taken with respect to <code class="code"><a class="ref" href="maxima_25.html#ct_005fcoords">ct_coords</a></code> subscripted
by the derivative index. The Christoffel symbols <code class="code"><a class="ref" href="#ichr1">ichr1</a></code> and <code class="code"><a class="ref" href="#ichr2">ichr2</a></code>
will be translated to <code class="code">lcs</code> and <code class="code">mcs</code>, respectively and if
<code class="code">metricconvert</code> is <code class="code">true</code> then all occurrences of the metric
with two covariant (contravariant) indices will be renamed to <code class="code">lg</code>
(<code class="code">ug</code>). In addition, <code class="code"><a class="ref" href="maxima_36.html#do">do</a></code> loops will be introduced summing over
all free indices so that the
transformed assignment statement can be evaluated by just doing
<code class="code"><a class="ref" href="maxima_7.html#ev">ev</a></code>. The following examples demonstrate the features of this
function.
</p>
<div class="example">
<pre class="example-preformatted">(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) eqn:ishow(t([i,j],[k])=f([],[])*g([l,m],[])*a([],[m],j)
      *b([i],[l,k]))$
                             k        m   l k
(%t2)                       t    = f a   b    g
                             i j      ,j  i    l m
(%i3) ic_convert(eqn);
(%o3) for i thru dim do (for j thru dim do (
       for k thru dim do
        t        : f sum(sum(diff(a , ct_coords ) b
         i, j, k                   m           j   i, l, k

 g    , l, 1, dim), m, 1, dim)))
  l, m
(%i4) imetric(g);
(%o4)                                done
(%i5) metricconvert:true;
(%o5)                                true
(%i6) ic_convert(eqn);
(%o6) for i thru dim do (for j thru dim do (
       for k thru dim do
        t        : f sum(sum(diff(a , ct_coords ) b
         i, j, k                   m           j   i, l, k

 lg    , l, 1, dim), m, 1, dim)))
   l, m
</pre></div>

<div class=categorybox>
Categories:
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-itensor">Package itensor</a>
&middot;
<a class="ref" href="Documentation-Categories.html#Category_003a-Package-ctensor">Package ctensor</a>
&middot;
</div>
</dd></dl>

</div>
<div class="subsection-level-extent" id="Reserved-words">
<h4 class="subsection">25.2.10 Reserved words</h4>

<p>The following Maxima words are used by the <code class="code">itensor</code> package internally and
should not be redefined:
</p>
<div class="example">
<pre class="example-preformatted">  Keyword    Comments
  ------------------------------------------
  indices2() Internal version of indices()
  conti      Lists contravariant indices
  covi       Lists covariant indices of an indexed object
  deri       Lists derivative indices of an indexed object
  name       Returns the name of an indexed object
  concan
  irpmon
  lc0
  _lc2kdt0
  _lcprod
  _extlc
</pre></div>

</div>
</div>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="maxima_25.html#ctensor" accesskey="n" rel="next">ctensor</a>, Previous: <a href="maxima_23.html#Affine" accesskey="p" rel="prev">Affine</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
