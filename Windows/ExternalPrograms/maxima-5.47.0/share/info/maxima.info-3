This is maxima.info, produced by makeinfo version 7.0.3 from
maxima.texi.

This is a Texinfo Maxima Manual

   Copyright 1994,2001 William F. Schelter

INFO-DIR-SECTION Math
START-INFO-DIR-ENTRY
* Maxima: (maxima).     A computer algebra system.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Functions and Variables for pictures,  Next: Functions and Variables for worldmap,  Prev: Functions and Variables for draw,  Up: draw-pkg

53.3 Functions and Variables for pictures
=========================================

 -- Function: get_pixel (<pic>,<x>,<y>)
     Returns pixel from picture.  Coordinates <x> and <y> range from 0
     to ‘width-1’ and ‘height-1’, respectively.

 -- Function: make_level_picture
          make_level_picture (<data>)
          make_level_picture (<data>,<width>,<height>)

     Returns a levels <picture> object.  ‘make_level_picture (<data>)’
     builds the <picture> object from matrix <data>.
     ‘make_level_picture (<data>,<width>,<height>)’ builds the object
     from a list of numbers; in this case, both the <width> and the
     <height> must be given.

     The returned <picture> object contains the following four parts:

       1. symbol ‘level’
       2. image width
       3. image height
       4. an integer array with pixel data ranging from 0 to 255.
          Argument <data> must contain only numbers ranged from 0 to
          255; negative numbers are substituted by 0, and those which
          are greater than 255 are set to 255.

     Example:

     Level picture from matrix.
          (%i1) make_level_picture(matrix([3,2,5],[7,-9,3000]));
          (%o1)         picture(level, 3, 2, {Array:  #(3 2 5 7 0 255)})

     Level picture from numeric list.
          (%i1) make_level_picture([-2,0,54,%pi],2,2);
          (%o1)            picture(level, 2, 2, {Array:  #(0 0 54 3)})

 -- Function: make_rgb_picture (<redlevel>,<greenlevel>,<bluelevel>)
     Returns an rgb-coloured <picture> object.  All three arguments must
     be levels picture; with red, green and blue levels.

     The returned <picture> object contains the following four parts:

       1. symbol ‘rgb’
       2. image width
       3. image height
       4. an integer array of length <3*width*height> with pixel data
          ranging from 0 to 255.  Each pixel is represented by three
          consecutive numbers (red, green, blue).

     Example:

          (%i1) red: make_level_picture(matrix([3,2],[7,260]));
          (%o1)           picture(level, 2, 2, {Array:  #(3 2 7 255)})
          (%i2) green: make_level_picture(matrix([54,23],[73,-9]));
          (%o2)           picture(level, 2, 2, {Array:  #(54 23 73 0)})
          (%i3) blue: make_level_picture(matrix([123,82],[45,32.5698]));
          (%o3)          picture(level, 2, 2, {Array:  #(123 82 45 33)})
          (%i4) make_rgb_picture(red,green,blue);
          (%o4) picture(rgb, 2, 2,
                        {Array:  #(3 54 123 2 23 82 7 73 45 255 0 33)})

 -- Function: negative_picture (<pic>)
     Returns the negative of a (<level> or <rgb>) picture.

 -- Function: picture_equalp (<x>,<y>)
     Returns ‘true’ in case of equal pictures, and ‘false’ otherwise.

 -- Function: picturep (<x>)
     Returns ‘true’ if the argument is a well formed image, and ‘false’
     otherwise.

 -- Function: read_xpm (<xpm_file>)
     Reads a file in xpm and returns a picture object.

 -- Function: rgb2level (<pic>)
     Transforms an <rgb> picture into a <level> one by averaging the
     red, green and blue channels.

 -- Function: take_channel (<im>,<color>)
     If argument <color> is ‘red’, ‘green’ or ‘blue’, function
     ‘take_channel’ returns the corresponding color channel of picture
     <im>.  Example:

          (%i1) red: make_level_picture(matrix([3,2],[7,260]));
          (%o1)           picture(level, 2, 2, {Array:  #(3 2 7 255)})
          (%i2) green: make_level_picture(matrix([54,23],[73,-9]));
          (%o2)           picture(level, 2, 2, {Array:  #(54 23 73 0)})
          (%i3) blue: make_level_picture(matrix([123,82],[45,32.5698]));
          (%o3)          picture(level, 2, 2, {Array:  #(123 82 45 33)})
          (%i4) make_rgb_picture(red,green,blue);
          (%o4) picture(rgb, 2, 2,
                        {Array:  #(3 54 123 2 23 82 7 73 45 255 0 33)})
          (%i5) take_channel(%,'green);  /* simple quote!!! */
          (%o5)           picture(level, 2, 2, {Array:  #(54 23 73 0)})


File: maxima.info,  Node: Functions and Variables for worldmap,  Prev: Functions and Variables for pictures,  Up: draw-pkg

53.4 Functions and Variables for worldmap
=========================================

53.4.1 Variables and Functions
------------------------------

 -- Global variable: boundaries_array
     Default value: ‘false’

     ‘boundaries_array’ is where the graphic object ‘geomap’ looks for
     boundaries coordinates.

     Each component of ‘boundaries_array’ is an array of floating point
     quantities, the coordinates of a polygonal segment or map boundary.

     See also ‘geomap’.

 -- Function: numbered_boundaries (<nlist>)
     Draws a list of polygonal segments (boundaries), labeled by its
     numbers (‘boundaries_array’ coordinates).  This is of great help
     when building new geographical entities.

     Example:

     Map of Europe labeling borders with their component number in
     ‘boundaries_array’.
          (%i1) load("worldmap")$
          (%i2) european_borders:
                     region_boundaries(-31.81,74.92,49.84,32.06)$
          (%i3) numbered_boundaries(european_borders)$

 -- Function: make_poly_continent
          make_poly_continent (<continent_name>)
          make_poly_continent (<country_list>)

     Makes the necessary polygons to draw a colored continent or a list
     of countries.

     Example:

          (%i1) load("worldmap")$
          (%i2) /* A continent */
                make_poly_continent(Africa)$
          (%i3) apply(draw2d, %)$
     (Figure worldmap_make_poly_continent)
          (%i4) /* A list of countries */
                make_poly_continent([Germany,Denmark,Poland])$
          (%i5) apply(draw2d, %)$
     (Figure worldmap_make_poly_continent2)

 -- Function: make_poly_country (<country_name>)
     Makes the necessary polygons to draw a colored country.  If islands
     exist, one country can be defined with more than just one polygon.

     Example:

          (%i1) load("worldmap")$
          (%i2) make_poly_country(India)$
          (%i3) apply(draw2d, %)$
     (Figure worldmap_make_poly_country)

 -- Function: make_polygon (<nlist>)
     Returns a ‘polygon’ object from boundary indices.  Argument <nlist>
     is a list of components of ‘boundaries_array’.

     Example:

     Bhutan is defined by boundary numbers 171, 173 and 1143, so that
     ‘make_polygon([171,173,1143])’ appends arrays of coordinates
     ‘boundaries_array[171]’, ‘boundaries_array[173]’ and
     ‘boundaries_array[1143]’ and returns a ‘polygon’ object suited to
     be plotted by ‘draw’.  To avoid an error message, arrays must be
     compatible in the sense that any two consecutive arrays have two
     coordinates in the extremes in common.  In this example, the two
     first components of ‘boundaries_array[171]’ are equal to the last
     two coordinates of ‘boundaries_array[173]’, and the two first of
     ‘boundaries_array[173]’ are equal to the two first of
     ‘boundaries_array[1143]’; in conclusion, boundary numbers 171, 173
     and 1143 (in this order) are compatible and the colored polygon can
     be drawn.
          (%i1) load("worldmap")$
          (%i2) Bhutan;
          (%o2)                        [[171, 173, 1143]]
          (%i3) boundaries_array[171];
          (%o3) {Array:
                 #(88.750549 27.14727 88.806351 27.25305 88.901367 27.282221
                   88.917877 27.321039)}
          (%i4) boundaries_array[173];
          (%o4) {Array:
                 #(91.659554 27.76511 91.6008 27.66666 91.598022 27.62499
                   91.631348 27.536381 91.765533 27.45694 91.775253 27.4161
                   92.007751 27.471939 92.11441 27.28583 92.015259 27.168051
                   92.015533 27.08083 92.083313 27.02277 92.112183 26.920271
                   92.069977 26.86194 91.997192 26.85194 91.915253 26.893881
                   91.916924 26.85416 91.8358 26.863331 91.712479 26.799999
                   91.542191 26.80444 91.492188 26.87472 91.418854 26.873329
                   91.371353 26.800831 91.307457 26.778049 90.682457 26.77417
                   90.392197 26.903601 90.344131 26.894159 90.143044 26.75333
                   89.98996 26.73583 89.841919 26.70138 89.618301 26.72694
                   89.636093 26.771111 89.360786 26.859989 89.22081 26.81472
                   89.110237 26.829161 88.921631 26.98777 88.873016 26.95499
                   88.867737 27.080549 88.843307 27.108601 88.750549
                   27.14727)}
          (%i5) boundaries_array[1143];
          (%o5) {Array:
                 #(91.659554 27.76511 91.666924 27.88888 91.65831 27.94805
                   91.338028 28.05249 91.314972 28.096661 91.108856 27.971109
                   91.015808 27.97777 90.896927 28.05055 90.382462 28.07972
                   90.396088 28.23555 90.366074 28.257771 89.996353 28.32333
                   89.83165 28.24888 89.58609 28.139999 89.35997 27.87166
                   89.225517 27.795 89.125793 27.56749 88.971077 27.47361
                   88.917877 27.321039)}
          (%i6) Bhutan_polygon: make_polygon([171,173,1143])$
          (%i7) draw2d(Bhutan_polygon)$
     (Figure worldmap_make_polygon)

 -- Function: region_boundaries (<x1>,<y1>,<x2>,<y2>)
     Detects polygonal segments of global variable ‘boundaries_array’
     fully contained in the rectangle with vertices (<x1>,<y1>) -upper
     left- and (<x2>,<y2>) -bottom right-.

     Example:

     Returns segment numbers for plotting southern Italy.
          (%i1) load("worldmap")$
          (%i2) region_boundaries(10.4,41.5,20.7,35.4);
          (%o2)                [1846, 1863, 1864, 1881, 1888, 1894]
          (%i3) draw2d(geomap(%))$
     (Figure worldmap_region_boundaries)

 -- Function: region_boundaries_plus (<x1>,<y1>,<x2>,<y2>)
     Detects polygonal segments of global variable ‘boundaries_array’
     containing at least one vertex in the rectangle defined by vertices
     (<x1>,<y1>) -upper left- and (<x2>,<y2>) -bottom right-.

     Example:

          (%i1) load("worldmap")$
          (%i2) region_boundaries_plus(10.4,41.5,20.7,35.4);
          (%o2) [1060, 1062, 1076, 1835, 1839, 1844, 1846, 1858,
                 1861, 1863, 1864, 1871, 1881, 1888, 1894, 1897]
          (%i3) draw2d(geomap(%))$
     (Figure worldmap_region_boundaries_plus)

53.4.2 Graphic objects
----------------------

 -- Graphic object: geomap
          geomap (<numlist>)
          geomap (<numlist>,<3Dprojection>)

     Draws cartographic maps in 2D and 3D.

     2D

     This function works together with global variable
     ‘boundaries_array’.

     Argument <numlist> is a list containing numbers or lists of
     numbers.  All these numbers must be integers greater or equal than
     zero, representing the components of global array
     ‘boundaries_array’.

     Each component of ‘boundaries_array’ is an array of floating point
     quantities, the coordinates of a polygonal segment or map boundary.

     ‘geomap (<numlist>)’ flattens its arguments and draws the
     associated boundaries in ‘boundaries_array’.

     This object is affected by the following graphic options:
     ‘line_width’, ‘line_type’ and ‘color’.

     Examples:

     A simple map defined by hand:
          (%i1) load("worldmap")$
          (%i2) /* Vertices of boundary #0: {(1,1),(2,5),(4,3)} */
             ( bnd0: make_array(flonum,6),
               bnd0[0]:1.0, bnd0[1]:1.0, bnd0[2]:2.0,
               bnd0[3]:5.0, bnd0[4]:4.0, bnd0[5]:3.0 )$
          (%i3) /* Vertices of boundary #1: {(4,3),(5,4),(6,4),(5,1)} */
             ( bnd1: make_array(flonum,8),
               bnd1[0]:4.0, bnd1[1]:3.0, bnd1[2]:5.0, bnd1[3]:4.0,
               bnd1[4]:6.0, bnd1[5]:4.0, bnd1[6]:5.0, bnd1[7]:1.0)$
          (%i4) /* Vertices of boundary #2: {(5,1), (3,0), (1,1)} */
             ( bnd2: make_array(flonum,6),
               bnd2[0]:5.0, bnd2[1]:1.0, bnd2[2]:3.0,
               bnd2[3]:0.0, bnd2[4]:1.0, bnd2[5]:1.0 )$
          (%i5) /* Vertices of boundary #3: {(1,1), (4,3)} */
             ( bnd3: make_array(flonum,4),
               bnd3[0]:1.0, bnd3[1]:1.0, bnd3[2]:4.0, bnd3[3]:3.0)$
          (%i6) /* Vertices of boundary #4: {(4,3), (5,1)} */
             ( bnd4: make_array(flonum,4),
               bnd4[0]:4.0, bnd4[1]:3.0, bnd4[2]:5.0, bnd4[3]:1.0)$
          (%i7) /* Pack all together in boundaries_array */
             ( boundaries_array: make_array(any,5),
               boundaries_array[0]: bnd0, boundaries_array[1]: bnd1,
               boundaries_array[2]: bnd2, boundaries_array[3]: bnd3,
               boundaries_array[4]: bnd4 )$
          (%i8) draw2d(geomap([0,1,2,3,4]))$
     (Figure worldmap_geomap)

     The auxiliary package ‘worldmap’ sets the global variable
     ‘boundaries_array’ to real world boundaries in (longitude,
     latitude) coordinates.  These data are in the public domain and
     come from
     <https://web.archive.org/web/20100310124019/http://www-cger.nies.go.jp/grid-e/gridtxt/grid19.html>.
     Package ‘worldmap’ defines also boundaries for countries,
     continents and coastlines as lists with the necessary components of
     ‘boundaries_array’ (see file ‘share/draw/worldmap.mac’ for more
     information).  Package ‘worldmap’ automatically loads package
     ‘worldmap’.
          (%i1) load("worldmap")$
          (%i2) c1: gr2d(geomap([Canada,United_States,
                                 Mexico,Cuba]))$
          (%i3) c2: gr2d(geomap(Africa))$
          (%i4) c3: gr2d(geomap([Oceania,China,Japan]))$
          (%i5) c4: gr2d(geomap([France,Portugal,Spain,
                                 Morocco,Western_Sahara]))$
          (%i6) draw(columns  = 2,
                     c1,c2,c3,c4)$
     (Figure worldmap_geomap2)

     Package ‘worldmap’ is also useful for plotting countries as
     polygons.  In this case, graphic object ‘geomap’ is no longer
     necessary and the ‘polygon’ object is used instead.  Since lists
     are now used and not arrays, maps rendering will be slower.  See
     also ‘make_poly_country’ and ‘make_poly_continent’ to understand
     the following code.
          (%i1) load("worldmap")$
          (%i2) mymap: append(
             [color      = white],  /* borders are white */
             [fill_color = red],             make_poly_country(Bolivia),
             [fill_color = cyan],            make_poly_country(Paraguay),
             [fill_color = green],           make_poly_country(Colombia),
             [fill_color = blue],            make_poly_country(Chile),
             [fill_color = "#23ab0f"],       make_poly_country(Brazil),
             [fill_color = goldenrod],       make_poly_country(Argentina),
             [fill_color = "midnight-blue"], make_poly_country(Uruguay))$
          (%i3) apply(draw2d, mymap)$
     (Figure worldmap_geomap3)

     3D

     ‘geomap (<numlist>)’ projects map boundaries on the sphere of
     radius 1 centered at (0,0,0).  It is possible to change the sphere
     or the projection type by using ‘geomap
     (<numlist>,<3Dprojection>)’.

     Available 3D projections:

        • ‘[spherical_projection,<x>,<y>,<z>,<r>]’: projects map
          boundaries on the sphere of radius <r> centered at
          (<x>,<y>,<z>).
               (%i1) load("worldmap")$
               (%i2) draw3d(geomap(Australia), /* default projection */
                            geomap(Australia,
                                   [spherical_projection,2,2,2,3]))$
          (Figure worldmap_geomap4)

        • ‘[cylindrical_projection,<x>,<y>,<z>,<r>,<rc>]’: re-projects
          spherical map boundaries on the cylinder of radius <rc> and
          axis passing through the poles of the globe of radius <r>
          centered at (<x>,<y>,<z>).
               (%i1) load("worldmap")$
               (%i2) draw3d(geomap([America_coastlines,Eurasia_coastlines],
                                   [cylindrical_projection,2,2,2,3,4]))$
          (Figure worldmap_geomap5)

        • ‘[conic_projection,<x>,<y>,<z>,<r>,<alpha>]’: re-projects
          spherical map boundaries on the cones of angle <alpha>, with
          axis passing through the poles of the globe of radius <r>
          centered at (<x>,<y>,<z>).  Both the northern and southern
          cones are tangent to sphere.
               (%i1) load("worldmap")$
               (%i2) draw3d(geomap(World_coastlines,
                                   [conic_projection,0,0,0,1,90]))$
     (Figure worldmap_geomap6)

     See also <http://riotorto.users.sf.net/gnuplot/geomap> for more
     elaborated examples.


File: maxima.info,  Node: drawdf-pkg,  Next: dynamics-pkg,  Prev: draw-pkg,  Up: Top

54 drawdf
*********

* Menu:

* Introduction to drawdf::
* Functions and Variables for drawdf::


File: maxima.info,  Node: Introduction to drawdf,  Next: Functions and Variables for drawdf,  Prev: drawdf-pkg,  Up: drawdf-pkg

54.1 Introduction to drawdf
===========================

The function ‘drawdf’ draws the direction field of a first-order
Ordinary Differential Equation (ODE) or a system of two autonomous
first-order ODE’s.

   Since this is an additional package, in order to use it you must
first load it with ‘load("drawdf")’.  Drawdf is built upon the ‘draw’
package, which requires Gnuplot 4.2.

   To plot the direction field of a single ODE, the ODE must be written
in the form:
            dy
            -- = F(x,y)
            dx

   and the function <F> should be given as the argument for ‘drawdf’.
If the independent and dependent variables are not <x>, and <y>, as in
the equation above, then those two variables should be named explicitly
in a list given as an argument to the drawdf command (see the examples).

   To plot the direction field of a set of two autonomous ODE’s, they
must be written in the form
            dx             dy
            -- = G(x,y)    -- = F(x,y)
            dt             dt

   and the argument for ‘drawdf’ should be a list with the two functions
<G> and <F>, in that order; namely, the first expression in the list
will be taken to be the time derivative of the variable represented on
the horizontal axis, and the second expression will be the time
derivative of the variable represented on the vertical axis.  Those two
variables do not have to be <x> and <y>, but if they are not, then the
second argument given to drawdf must be another list naming the two
variables, first the one on the horizontal axis and then the one on the
vertical axis.

   If only one ODE is given, ‘drawdf’ will implicitly admit ‘x=t’, and
‘G(x,y)=1’, transforming the non-autonomous equation into a system of
two autonomous equations.


File: maxima.info,  Node: Functions and Variables for drawdf,  Prev: Introduction to drawdf,  Up: drawdf-pkg

54.2 Functions and Variables for drawdf
=======================================

54.2.1 Functions
----------------

 -- Function: drawdf
          drawdf (<dydx>, ...options and objects...)
          drawdf (<dvdu>, [<u>,<v>], ...options and objects...)
          drawdf (<dvdu>, [<u>,<umin>,<umax>], [<v>,<vmin>,<vmax>],
          ...options and objects...)
          drawdf ([<dxdt>,<dydt>], ...options and objects...)
          drawdf ([<dudt>,<dvdt>], [<u>,<v>], ...options and objects...)

          drawdf ([<dudt>,<dvdt>], [<u>,<umin>,<umax>],
          [<v>,<vmin>,<vmax>], ...options and objects...)

     Function ‘drawdf’ draws a 2D direction field with optional solution
     curves and other graphics using the ‘draw’ package.

     The first argument specifies the derivative(s), and must be either
     an expression or a list of two expressions.  <dydx>, <dxdt> and
     <dydt> are expressions that depend on <x> and <y>.  <dvdu>, <dudt>
     and <dvdt> are expressions that depend on <u> and <v>.

     If the independent and dependent variables are not <x> and <y>,
     then their names must be specified immediately following the
     derivative(s), either as a list of two names ‘[’<u>,<v>‘]’, or as
     two lists of the form ‘[’<u>,<umin>,<umax>‘]’ and
     ‘[’<v>,<vmin>,<vmax>‘]’.

     The remaining arguments are graphic options, graphic objects, or
     lists containing graphic options and objects, nested to arbitrary
     depth.  The set of graphic options and objects supported by
     ‘drawdf’ is a superset of those supported by ‘draw2d’ and ‘gr2d’
     from the ‘draw’ package.

     The arguments are interpreted sequentially: graphic options affect
     all following graphic objects.  Furthermore, graphic objects are
     drawn on the canvas in order specified, and may obscure graphics
     drawn earlier.  Some graphic options affect the global appearance
     of the scene.

     The additional graphic objects supported by ‘drawdf’ include:
     ‘solns_at’, ‘points_at’, ‘saddles_at’, ‘soln_at’, ‘point_at’, and
     ‘saddle_at’.

     The additional graphic options supported by ‘drawdf’ include:
     ‘field_degree’, ‘soln_arrows’, ‘field_arrows’, ‘field_grid’,
     ‘field_color’, ‘show_field’, ‘tstep’, ‘nsteps’, ‘duration’,
     ‘direction’, ‘field_tstep’, ‘field_nsteps’, and ‘field_duration’.

     Commonly used graphic objects inherited from the ‘draw’ package
     include: ‘explicit’, ‘implicit’, ‘parametric’, ‘polygon’, ‘points’,
     ‘vector’, ‘label’, and all others supported by ‘draw2d’ and ‘gr2d’.

     Commonly used graphic options inherited from the ‘draw’ package
     include:
     ‘points_joined’, ‘color’, ‘point_type’, ‘point_size’, ‘line_width’,
     ‘line_type’, ‘key’, ‘title’, ‘xlabel’, ‘ylabel’, ‘user_preamble’,
     ‘terminal’, ‘dimensions’, ‘file_name’, and all others supported by
     ‘draw2d’ and ‘gr2d’.

     See also ‘draw2d’, ‘rk’, ‘desolve’ and ‘ode2’.

     Users of wxMaxima or Imaxima may optionally use ‘wxdrawdf’, which
     is identical to ‘drawdf’ except that the graphics are drawn within
     the notebook using ‘wxdraw’.

     To make use of this function, write first ‘load("drawdf")’.

     Examples:

          (%i1) load("drawdf")$
          (%i2) drawdf(exp(-x)+y)$        /* default vars: x,y */
          (%i3) drawdf(exp(-t)+y, [t,y])$ /* default range: [-10,10] */
          (%i4) drawdf([y,-9*sin(x)-y/5], [x,1,5], [y,-2,2])$

     For backward compatibility, ‘drawdf’ accepts most of the parameters
     supported by plotdf.

          (%i5) drawdf(2*cos(t)-1+y, [t,y], [t,-5,10], [y,-4,9],
                       [trajectory_at,0,0])$

     ‘soln_at’ and ‘solns_at’ draw solution curves passing through the
     specified points, using a slightly enhanced 4th-order Runge Kutta
     numerical integrator.

          (%i6) drawdf(2*cos(t)-1+y, [t,-5,10], [y,-4,9],
                       solns_at([0,0.1],[0,-0.1]),
                       color=blue, soln_at(0,0))$

     ‘field_degree=2’ causes the field to be composed of quadratic
     splines, based on the first and second derivatives at each grid
     point.  ‘field_grid=[’<COLS>,<ROWS>‘]’ specifies the number of
     columns and rows in the grid.

          (%i7) drawdf(2*cos(t)-1+y, [t,-5,10], [y,-4,9],
                       field_degree=2, field_grid=[20,15],
                       solns_at([0,0.1],[0,-0.1]),
                       color=blue, soln_at(0,0))$

     ‘soln_arrows=true’ adds arrows to the solution curves, and (by
     default) removes them from the direction field.  It also changes
     the default colors to emphasize the solution curves.

          (%i8) drawdf(2*cos(t)-1+y, [t,-5,10], [y,-4,9],
                       soln_arrows=true,
                       solns_at([0,0.1],[0,-0.1],[0,0]))$

     ‘duration=40’ specifies the time duration of numerical integration
     (default 10).  Integration will also stop automatically if the
     solution moves too far away from the plotted region, or if the
     derivative becomes complex or infinite.  Here we also specify
     ‘field_degree=2’ to plot quadratic splines.  The equations below
     model a predator-prey system.

          (%i9) drawdf([x*(1-x-y), y*(3/4-y-x/2)], [x,0,1.1], [y,0,1],
                       field_degree=2, duration=40,
                       soln_arrows=true, point_at(1/2,1/2),
                       solns_at([0.1,0.2], [0.2,0.1], [1,0.8], [0.8,1],
                                [0.1,0.1], [0.6,0.05], [0.05,0.4],
                                [1,0.01], [0.01,0.75]))$

     ‘field_degree='solns’ causes the field to be composed of many small
     solution curves computed by 4th-order Runge Kutta, with better
     results in this case.

          (%i10) drawdf([x*(1-x-y), y*(3/4-y-x/2)], [x,0,1.1], [y,0,1],
                        field_degree='solns, duration=40,
                        soln_arrows=true, point_at(1/2,1/2),
                        solns_at([0.1,0.2], [0.2,0.1], [1,0.8],
                                 [0.8,1], [0.1,0.1], [0.6,0.05],
                                 [0.05,0.4], [1,0.01], [0.01,0.75]))$

     ‘saddles_at’ attempts to automatically linearize the equation at
     each saddle, and to plot a numerical solution corresponding to each
     eigenvector, including the separatrices.  ‘tstep=0.05’ specifies
     the maximum time step for the numerical integrator (the default is
     0.1).  Note that smaller time steps will sometimes be used in order
     to keep the x and y steps small.  The equations below model a
     damped pendulum.

          (%i11) drawdf([y,-9*sin(x)-y/5], tstep=0.05,
                        soln_arrows=true, point_size=0.5,
                        points_at([0,0], [2*%pi,0], [-2*%pi,0]),
                        field_degree='solns,
                        saddles_at([%pi,0], [-%pi,0]))$

     ‘show_field=false’ suppresses the field entirely.

          (%i12) drawdf([y,-9*sin(x)-y/5], tstep=0.05,
                        show_field=false, soln_arrows=true,
                        point_size=0.5,
                        points_at([0,0], [2*%pi,0], [-2*%pi,0]),
                        saddles_at([3*%pi,0], [-3*%pi,0],
                                   [%pi,0], [-%pi,0]))$

     ‘drawdf’ passes all unrecognized parameters to ‘draw2d’ or ‘gr2d’,
     allowing you to combine the full power of the ‘draw’ package with
     ‘drawdf’.

          (%i13) drawdf(x^2+y^2, [x,-2,2], [y,-2,2], field_color=gray,
                        key="soln 1", color=black, soln_at(0,0),
                        key="soln 2", color=red, soln_at(0,1),
                        key="isocline", color=green, line_width=2,
                        nticks=100, parametric(cos(t),sin(t),t,0,2*%pi))$

     ‘drawdf’ accepts nested lists of graphic options and objects,
     allowing convenient use of makelist and other function calls to
     generate graphics.

          (%i14) colors : ['red,'blue,'purple,'orange,'green]$
          (%i15) drawdf([x-x*y/2, (x*y - 3*y)/4],
                        [x,2.5,3.5], [y,1.5,2.5],
                        field_color = gray,
                        makelist([ key   = concat("soln",k),
                                   color = colors[k],
                                   soln_at(3, 2 + k/20) ],
                                 k,1,5))$


File: maxima.info,  Node: dynamics-pkg,  Next: engineering-format-pkg,  Prev: drawdf-pkg,  Up: Top

55 dynamics
***********

* Menu:

* The dynamics package::
* Graphical analysis of discrete dynamical systems::
* Visualization with VTK::


File: maxima.info,  Node: The dynamics package,  Next: Graphical analysis of discrete dynamical systems,  Prev: dynamics-pkg,  Up: dynamics-pkg

55.1 The dynamics package
=========================

Package ‘dynamics’ includes functions for 3D visualization, animations,
graphical analysis of differential and difference equations and
numerical solution of differential equations.  The functions for
differential equations are described in the section on ‘Numerical
Methods’ and the functions to plot the Mandelbrot and Julia sets are
described in the section on ‘Plotting’.

   All the functions in this package will be loaded automatically the
first time they are used.


File: maxima.info,  Node: Graphical analysis of discrete dynamical systems,  Next: Visualization with VTK,  Prev: The dynamics package,  Up: dynamics-pkg

55.2 Graphical analysis of discrete dynamical systems
=====================================================

 -- Function: chaosgame ([[<x1>, <y1>]...[<xm>, <ym>]], [<x0>, <y0>],
          <b>, <n>, <options>, ...);

     Implements the so-called chaos game: the initial point (<x0>, <y0>)
     is plotted and then one of the <m> points [<x1>, <y1>]...<xm>,
     <ym>] will be selected at random.  The next point plotted will be
     on the segment from the previous point plotted to the point chosen
     randomly, at a distance from the random point which will be <b>
     times that segment’s length.  The procedure is repeated <n> times.
     The options are the same as for ‘plot2d’.

     *Example*.  A plot of Sierpinsky’s triangle:

          (%i1) chaosgame([[0, 0], [1, 0], [0.5, sqrt(3)/2]], [0.1, 0.1], 1/2,
                           30000, [style, dots]);

 -- Function: evolution (<F>, <y0>, <n>, ..., <options>, ...);

     Draws <n+1> points in a two-dimensional graph, where the horizontal
     coordinates of the points are the integers 0, 1, 2, ..., <n>, and
     the vertical coordinates are the corresponding values <y(n)> of the
     sequence defined by the recurrence relation
                  y(n+1) = F(y(n))

     With initial value <y(0)> equal to <y0>.  <F> must be an expression
     that depends only on one variable (in the example, it depend on
     <y>, but any other variable can be used), <y0> must be a real
     number and <n> must be a positive integer.  This function accepts
     the same options as ‘plot2d’.

     *Example*.

          (%i1) evolution(cos(y), 2, 11);

 -- Function: evolution2d ([<F>, <G>], [<u>, <v>], [<u0>, <y0>], <n>,
          <options>, ...);

     Shows, in a two-dimensional plot, the first <n+1> points in the
     sequence of points defined by the two-dimensional discrete
     dynamical system with recurrence relations
                  u(n+1) = F(u(n), v(n))    v(n+1) = G(u(n), v(n))

     With initial values <u0> and <v0>.  <F> and <G> must be two
     expressions that depend only on two variables, <u> and <v>, which
     must be named explicitly in a list.  The options are the same as
     for ‘plot2d’.

     *Example*.  Evolution of a two-dimensional discrete dynamical
     system:

          (%i1) f: 0.6*x*(1+2*x)+0.8*y*(x-1)-y^2-0.9$
          (%i2) g: 0.1*x*(1-6*x+4*y)+0.1*y*(1+9*y)-0.4$
          (%i3) evolution2d([f,g], [x,y], [-0.5,0], 50000, [style,dots]);

     And an enlargement of a small region in that fractal:

          (%i9) evolution2d([f,g], [x,y], [-0.5,0], 300000, [x,-0.8,-0.6],
                            [y,-0.4,-0.2], [style, dots]);

 -- Function: ifs ([<r1>, ..., <rm>], [<A1>,..., <Am>], [[<x1>, <y1>],
          ..., [<xm>, <ym>]], [<x0>, <y0>], <n>, <options>, ...);

     Implements the Iterated Function System method.  This method is
     similar to the method described in the function ‘chaosgame’.  but
     instead of shrinking the segment from the current point to the
     randomly chosen point, the 2 components of that segment will be
     multiplied by the 2 by 2 matrix <Ai> that corresponds to the point
     chosen randomly.

     The random choice of one of the <m> attractive points can be made
     with a non-uniform probability distribution defined by the weights
     <r1>,...,<rm>.  Those weights are given in cumulative form; for
     instance if there are 3 points with probabilities 0.2, 0.5 and 0.3,
     the weights <r1>, <r2> and <r3> could be 2, 7 and 10.  The options
     are the same as for ‘plot2d’.

     *Example*.  Barnsley’s fern, obtained with 4 matrices and 4 points:

          (%i1) a1: matrix([0.85,0.04],[-0.04,0.85])$
          (%i2) a2: matrix([0.2,-0.26],[0.23,0.22])$
          (%i3) a3: matrix([-0.15,0.28],[0.26,0.24])$
          (%i4) a4: matrix([0,0],[0,0.16])$
          (%i5) p1: [0,1.6]$
          (%i6) p2: [0,1.6]$
          (%i7) p3: [0,0.44]$
          (%i8) p4: [0,0]$
          (%i9) w: [85,92,99,100]$
          (%i10) ifs(w, [a1,a2,a3,a4], [p1,p2,p3,p4], [5,0], 50000, [style,dots]);

 -- Function: orbits (<F>, <y0>, <n1>, <n2>, [<x>, <x0>, <xf>, <xstep>],
          <options>, ...);

     Draws the orbits diagram for a family of one-dimensional discrete
     dynamical systems, with one parameter <x>; that kind of diagram is
     used to study the bifurcations of an one-dimensional discrete
     system.

     The function <F(y)> defines a sequence with a starting value of
     <y0>, as in the case of the function ‘evolution’, but in this case
     that function will also depend on a parameter <x> that will take
     values in the interval from <x0> to <xf> with increments of
     <xstep>.  Each value used for the parameter <x> is shown on the
     horizontal axis.  The vertical axis will show the <n2> values of
     the sequence <y(n1+1)>,..., <y(n1+n2+1)> obtained after letting the
     sequence evolve <n1> iterations.  In addition to the options
     accepted by ‘plot2d’, it accepts an option <pixels> that sets up
     the maximum number of different points that will be represented in
     the vertical direction.

     *Example*.  Orbits diagram of the quadratic map, with a parameter
     <a>:

          (%i1) orbits(x^2+a, 0, 50, 200, [a, -2, 0.25], [style, dots]);

     To enlarge the region around the lower bifurcation near x ‘=’ -1.25
     use:
          (%i2) orbits(x^2+a, 0, 100, 400, [a,-1,-1.53], [x,-1.6,-0.8],
                       [nticks, 400], [style,dots]);

 -- Function: staircase (<F>, <y0>, <n>,<options>,...);

     Draws a staircase diagram for the sequence defined by the
     recurrence relation
                  y(n+1) = F(y(n))

     The interpretation and allowed values of the input parameters is
     the same as for the function ‘evolution’.  A staircase diagram
     consists of a plot of the function <F(y)>, together with the line
     <G(y)> ‘=’ <y>.  A vertical segment is drawn from the point (<y0>,
     <y0>) on that line until the point where it intersects the function
     <F>.  From that point a horizontal segment is drawn until it
     reaches the point (<y1>, <y1>) on the line, and the procedure is
     repeated <n> times until the point (<yn>, <yn>) is reached.  The
     options are the same as for ‘plot2d’.

     *Example*.

          (%i1) staircase(cos(y), 1, 11, [y, 0, 1.2]);


File: maxima.info,  Node: Visualization with VTK,  Prev: Graphical analysis of discrete dynamical systems,  Up: dynamics-pkg

55.3 Visualization with VTK
===========================

Function scene creates 3D images and animations using the _Visualization
ToolKit_ (VTK) software.  In order to use that function, Xmaxima and VTK
should be installed in your system (including the TCL bindings of VTK,
which in some system might come in a separate package).

 -- Function: scene (<objects>, ..., <options>, ...);

     Accepts an empty list or a list of several ‘objects’ and ‘options’.
     The program launches Xmaxima, which opens an external window
     representing the given objects in a 3-dimensional space and
     applying the options given.  Each object must belong to one of the
     following 4 classes: sphere, cube, cylinder or cone (see ‘Scene
     objects’).  Objects are identified by giving their name or by a
     list in which the first element is the class name and the following
     elements are options for that object.

     *Example*.  A hexagonal pyramid with a blue background:
          (%i1) scene(cone, [background,"#9980e5"])$

     By holding down the left button of the mouse while it is moved on
     the graphics window, the camera can be rotated showing different
     views of the pyramid.  The two plot options ‘elevation’ and
     ‘azimuth’ can also be used to change the initial orientation of the
     viewing camera.  The camera can be moved by holding the middle
     mouse button while moving it and holding the right-side mouse
     button while moving it up or down will zoom in or out.

     Each object option should be a list starting with the option name,
     followed by its value.  The list of allowed options can be found in
     the ‘Scene object's options’ section.

     *Example*.  This will show a sphere falling to the ground and
     bouncing off without losing any energy.  To start or pause the
     animation, press the play/pause button.

          (%i1) p: makelist ([0,0,2.1- 9.8*t^2/2], t, 0, 0.64, 0.01)$

          (%i2) p: append (p, reverse(p))$

          (%i3) ball: [sphere, [radius,0.1], [thetaresolution,20],
            [phiresolution,20], [position,0,0,2.1], [color,red],
            [animate,position,p]]$

          (%i4) ground: [cube, [xlength,2], [ylength,2], [zlength,0.2],
            [position,0,0,-0.1],[color,violet]]$

          (%i5) scene (ball, ground, restart)$

     The <restart> option was used to make the animation restart
     automatically every time the last point in the position list is
     reached.  The accepted values for the colors are the same as for
     the ‘color’ option of plot2d.

55.3.1 Scene options
--------------------

 -- Scene option: azimuth [azimuth, <angle>]
     Default value: ‘135’

     The rotation of the camera on the horizontal (x, y) plane.  <angle>
     must be a real number; an angle of 0 means that the camera points
     in the direction of the y axis and the x axis will appear on the
     right.

 -- Scene option: background [background, <color>]
     Default value: ‘black’

     The color of the graphics window’s background.  It accepts color
     names or hexadecimal red-green-blue strings (see the ‘color’ option
     of plot2d).

 -- Scene option: elevation [elevation, <angle>]
     Default value: ‘30’

     The vertical rotation of the camera.  The <angle> must be a real
     number; an angle of 0 means that the camera points on the
     horizontal, and the default angle of 30 means that the camera is
     pointing 30 degrees down from the horizontal.

 -- Scene option: height [height, <pixels>]
     Default value: ‘500’

     The height, in pixels, of the graphics window.  <pixels> must be a
     positive integer number.

 -- Scene option: restart [restart, <value>]
     Default value: ‘false’

     A true value means that animations will restart automatically when
     the end of the list is reached.  Writing just “restart” is
     equivalent to [restart, <true>].

 -- Scene option: tstep [tstep, <time>]
     Default value: ‘10’

     The amount of time, in mili-seconds, between iterations among
     consecutive animation frames.  <time> must be a real number.

 -- Scene option: width [width, <pixels>]
     Default value: ‘500’

     The width, in pixels, of the graphics window.  <pixels> must be a
     positive integer number.

 -- Scene option: windowname [windowtitle, <name>]
     Default value: ‘.scene’

     <name> must be a string that can be used as the name of the Tk
     window created by Xmaxima for the ‘scene’ graphics.  The default
     value ‘.scene’ implies that a new top level window will be created.

 -- Scene option: windowtitle [windowtitle, <name>]
     Default value: ‘Xmaxima: scene’

     <name> must be a string that will be written in the title of the
     window created by ‘scene’.

55.3.2 Scene objects
--------------------

 -- Scene object: cone [cone, <options>]

     Creates a regular pyramid with height equal to 1 and a hexagonal
     base with vertices 0.5 units away from the axis.  Options ‘height’
     and ‘radius’ can be used to change those defaults and option
     ‘resolution’ can be used to change the number of edges of the base;
     higher values will make it look like a cone.  By default, the axis
     will be along the x axis, the middle point of the axis will be at
     the origin and the vertex on the positive side of the x axis; use
     options ‘orientation’ and ‘center’ to change those defaults.

     *Example*.  This shows a pyramid that starts rotating around the z
     axis when the play button is pressed.

          (%i1) scene([cone, [orientation,0,30,0], [tstep,100],
             [animate,orientation,makelist([0,30,i],i,5,360,5)]], restart)$

 -- Scene object: cube [cube, <options>]

     A cube with edges of 1 unit and faces parallel to the xy, xz and yz
     planes.  The lengths of the three edges can be changed with options
     ‘xlength’, ‘ylength’ and ‘zlength’, turning it into a rectangular
     box and the faces can be rotated with option ‘orientation’.

 -- Scene object: cylinder [cylinder, <options>]

     Creates a regular prism with height equal to 1 and a hexagonal base
     with vertices 0.5 units away from the axis.  Options ‘height’ and
     ‘radius’ can be used to change those defaults and option
     ‘resolution’ can be used to change the number of edges of the base;
     higher values will make it look like a cylinder.  The default
     height can be changed with the option ‘height’.  By default, the
     axis will be along the x axis and the middle point of the axis will
     be at the origin; use options ‘orientation’ and ‘center’ to change
     those defaults.

 -- Scene object: sphere [sphere, <options>]

     A sphere with default radius of 0.5 units and center at the origin.

55.3.3 Scene object’s options
-----------------------------

 -- Object option: animation [animation, <property>, <positions>]

     <property> should be one of the following 4 object’s properties:
     ‘origin’, ‘scale’, ‘position’ or ‘orientation’ and <positions>
     should be a list of points.  When the play button is pressed, the
     object property will be changed sequentially through all the values
     in the list, at intervals of time given by the option ‘tstep’.  The
     rewind button can be used to point at the start of the sequence
     making the animation restart after the play button is pressed
     again.

     See also ‘track’.

 -- Object option: capping [capping, <number>]
     Default value: ‘1’

     In a cone or a cylinder, it defines whether the base (or bases)
     will be shown.  A value of 1 for <number> makes the base visible
     and a value of 0 makes it invisible.

 -- Object option: center [center, <point>]
     Default value: ‘[0, 0, 0]’

     The coordinates of the object’s geometric center, with respect to
     its ‘position’.  <point> can be a list with 3 real numbers, or 3
     real numbers separated by commas.  In a cylinder, cone or cube it
     will be at half its height and in a sphere at its center.

 -- Object option: color [color, <colorname>]
     Default value: ‘white’

     The color of the object.  It accepts color names or hexadecimal
     red-green-blue strings (see the ‘color’ option of plot2d).

 -- Object option: endphi [endphi, <angle>]
     Default value: ‘180’

     In a sphere phi is the angle on the vertical plane that passes
     through the z axis, measured from the positive part of the z axis.
     <angle> must be a number between 0 and 180 that sets the final
     value of phi at which the surface will end.  A value smaller than
     180 will eliminate a part of the sphere’s surface.

     See also ‘startphi’ and ‘phiresolution’.

 -- Object option: endtheta [endtheta, <angle>]
     Default value: ‘360’

     In a sphere theta is the angle on the horizontal plane (longitude),
     measured from the positive part of the x axis.  <angle> must be a
     number between 0 and 360 that sets the final value of theta at
     which the surface will end.  A value smaller than 360 will
     eliminate a part of the sphere’s surface.

     See also ‘starttheta’ and ‘thetaresolution’.

 -- Object option: height [height, <value>]
     Default value: ‘1’

     <value> must be a positive number which sets the height of a cone
     or a cylinder.

 -- Object option: linewidth [linewidth, <value>]
     Default value: ‘1’

     The width of the lines, when option ‘wireframe’ is used.  <value>
     must be a positive number.

 -- Object option: opacity [opacity, <value>]
     Default value: ‘1’

     <value> must be a number between 0 and 1.  The lower the number,
     the more transparent the object will become.  The default value of
     1 means a completely opaque object.

 -- Object option: orientation [orientation, <angles>]
     Default value: ‘[0, 0, 0]’

     Three angles by which the object will be rotated with respect to
     the three axis.  <angles> can be a list with 3 real numbers, or 3
     real numbers separated by commas.  *Example*: ‘[0, 0, 90]’ rotates
     the x axis of the object to the y axis of the reference frame.

 -- Object option: origin [origin, <point>]
     Default value: ‘[0, 0, 0]’

     The coordinates of the object’s origin, with respect to which its
     other dimensions are defined.  <point> can be a list with 3 real
     numbers, or 3 real numbers separated by commas.

 -- Object option: phiresolution [phiresolution, <num>]
     Default value: ‘’

     The number of sub-intervals into which the phi angle interval from
     ‘startphi’ to ‘endphi’ will be divided.  <num> must be a positive
     integer.

     See also ‘startphi’ and ‘endphi’.

 -- Object option: points [points]

     Only the vertices of the triangulation used to render the surface
     will be shown.  *Example*: ‘[sphere, [points]]’

     See also ‘surface’ and ‘wireframe’.

 -- Object option: pointsize [pointsize, <value>]
     Default value: ‘1’

     The size of the points, when option ‘points’ is used.  <value> must
     be a positive number.

 -- Object option: position [position, <point>]
     Default value: ‘[0, 0, 0]’

     The coordinates of the object’s position.  <point> can be a list
     with 3 real numbers, or 3 real numbers separated by commas.

 -- Object option: radius [radius, <value>]
     Default value: ‘0.5’

     The radius or a sphere or the distance from the axis to the base’s
     vertices in a cylinder or a cone.  <value> must be a positive
     number.

 -- Object option: resolution [resolution, <number>]
     Default value: ‘6’

     <number> must be an integer greater than 2 that sets the number of
     edges in the base of a cone or a cylinder.

 -- Object option: scale [scale, <factors>]
     Default value: ‘[1, 1, 1]’

     Three numbers by which the object will be scaled with respect to
     the three axis.  <factors> can be a list with 3 real numbers, or 3
     real numbers separated by commas.  *Example*: ‘[2, 0.5, 1]’
     enlarges the object to twice its size in the x direction, reduces
     the dimensions in the y direction to half and leaves the z
     dimensions unchanged.

 -- Object option: startphi [startphi, <angle>]
     Default value: ‘0’

     In a sphere phi is the angle on the vertical plane that passes
     through the z axis, measured from the positive part of the z axis.
     <angle> must be a number between 0 and 180 that sets the initial
     value of phi at which the surface will start.  A value bigger than
     0 will eliminate a part of the sphere’s surface.

     See also ‘endphi’ and ‘phiresolution’.

 -- Object option: starttheta [starttheta, <angle>]
     Default value: ‘0’

     In a sphere theta is the angle on the horizontal plane (longitude),
     measured from the positive part of the x axis.  <angle> must be a
     number between 0 and 360 that sets the initial value of theta at
     which the surface will start.  A value bigger than 0 will eliminate
     a part of the sphere’s surface.

     See also ‘endtheta’ and ‘thetaresolution’.

 -- Object option: surface [surface]

     The surfaces of the object will be rendered and the lines and
     points of the triangulation used to build the surface will not be
     shown.  This is the default behavior, which can be changed using
     either the option ‘points’ or ‘wireframe’.

 -- Object option: thetaresolution [thetaresolution, <num>]
     Default value: ‘’

     The number of sub-intervals into which the theta angle interval
     from ‘starttheta’ to ‘endtheta’ will be divided.  <num> must be a
     positive integer.

     See also ‘starttheta’ and ‘endtheta’.

 -- Object option: track [track, <positions>]

     <positions> should be a list of points.  When the play button is
     pressed, the object position will be changed sequentially through
     all the points in the list, at intervals of time given by the
     option ‘tstep’, leaving behind a track of the object’s trajectory.
     The rewind button can be used to point at the start of the sequence
     making the animation restart after the play button is pressed
     again.

     *Example*.  This will show the trajectory of a ball thrown with
     speed of 5 m/s, at an angle of 45 degrees, when the air resistance
     can be neglected:

          (%i1) p: makelist ([0,4*t,4*t- 9.8*t^2/2], t, 0, 0.82, 0.01)$

          (%i2) ball: [sphere, [radius,0.1], [color,red], [track,p]]$

          (%i3) ground: [cube, [xlength,2], [ylength,4], [zlength,0.2],
                [position,0,1.5,-0.2],[color,green]]$

          (%i4) scene (ball, ground)$

     See also ‘animation’.

 -- Object option: xlength [xlength, <length>]
     Default value: ‘1’

     The height of a cube in the x direction.  <length> must be a
     positive number.  See also ‘ylength’ and ‘zlength’.

 -- Object option: ylength [ylength, <length>]
     Default value: ‘1’

     The height of a cube in the y direction.  <length> must be a
     positive number.  See also ‘xlength’ and ‘zlength’.

 -- Object option: zlength [zlength, <length>]
     Default value: ‘1’

     The height of a cube in z the direction.  <length> must be a
     positive number.  See also ‘xlength’ and ‘ylength’.

 -- Object option: wireframe [wireframe]

     Only the edges of the triangulation used to render the surface will
     be shown.  *Example*: ‘[cube, [wireframe]]’

     See also ‘surface’ and ‘points’.


File: maxima.info,  Node: engineering-format-pkg,  Next: ezunits-pkg,  Prev: dynamics-pkg,  Up: Top

56 engineering-format
*********************

Engineering-format changes the way maxima outputs floating-point numbers
to the notation engineers are used to: ‘a*10^b’ with ‘b’ dividable by
three.
* Menu:

* Functions and Variables for engineering-format::


File: maxima.info,  Node: Functions and Variables for engineering-format,  Prev: engineering-format-pkg,  Up: engineering-format-pkg

56.1 Functions and Variables for engineering-format
===================================================

 -- Option variable: engineering_format_floats
     Default value: ‘true’

     This variable allows to temporarily switch off engineering-format.
          (%i1) load("engineering-format");
          (%o1) /home/gunter/src/maxima-code/share/contrib/engineering-for\
          mat.lisp
          (%i2) float(sin(10)/10000);
          (%o2)                - 54.40211108893698e-6
          (%i3) engineering_format_floats:false$
          (%i4) float(sin(10)/10000);
          (%o4)                - 5.440211108893698e-5

     See also ‘fpprintprec’ and ‘float’.

 -- Option variable: engineering_format_min
     Default value: ‘0.0’

     The minimum absolute value that isn’t automatically converted to
     the engineering format.  See also ‘engineering_format_max’ and
     ‘engineering_format_floats’.

          (%i1) lst: float([.05,.5,5,500,5000,500000]);
          (%o1)       [0.05, 0.5, 5.0, 500.0, 5000.0, 500000.0]
          (%i2) load("engineering-format");
          (%o2) /home/gunter/src/maxima-code/share/contrib/engineering-for\
          mat.lisp
          (%i3) lst;
          (%o3) [50.0e-3, 500.0e-3, 5.0e+0, 500.0e+0, 5.0e+3, 500.0e+3]
          (%i4) engineering_format_min:.1$
          (%i5) engineering_format_max:1000$
          (%i6) lst;
          (%o6)     [50.0e-3, 0.5, 5.0, 500.0, 5.0e+3, 500.0e+3]

 -- Option variable: engineering_format_max
     Default value: ‘0.0’

     The maximum absolute value that isn’t automatically converted to
     the engineering format.  See also ‘engineering_format_min’ and
     ‘engineering_format_floats’.


File: maxima.info,  Node: ezunits-pkg,  Next: f90-pkg,  Prev: engineering-format-pkg,  Up: Top

57 ezunits
**********

* Menu:

* Introduction to ezunits::
* Introduction to physical_constants::
* Functions and Variables for ezunits::


File: maxima.info,  Node: Introduction to ezunits,  Next: Introduction to physical_constants,  Prev: ezunits-pkg,  Up: ezunits-pkg

57.1 Introduction to ezunits
============================

‘ezunits’ is a package for working with dimensional quantities,
including some functions for dimensional analysis.  ‘ezunits’ can carry
out arithmetic operations on dimensional quantities and unit
conversions.  The built-in units include Systeme Internationale (SI) and
US customary units, and other units can be declared.  See also
‘physical_constants’, a collection of physical constants.

   ‘load("ezunits")’ loads this package.  ‘demo("ezunits")’ displays
several examples.  The convenience function ‘known_units’ returns a list
of the built-in and user-declared units, while
‘display_known_unit_conversions’ displays the set of known conversions
in an easy-to-read format.

   An expression a ` b represents a dimensional quantity, with ‘a’
indicating a nondimensional quantity and ‘b’ indicating the dimensional
units.  A symbol can be used as a unit without declaring it as such;
unit symbols need not have any special properties.  The quantity and
unit of an expression a ` b can be extracted by the ‘qty’ and ‘units’
functions, respectively.

   A symbol may be declared to be a dimensional quantity, with specified
quantity or specified units or both.

   An expression a ` b `` c converts from unit ‘b’ to unit ‘c’.
‘ezunits’ has built-in conversions for SI base units, SI derived units,
and some non-SI units.  Unit conversions not already known to ‘ezunits’
can be declared.  The unit conversions known to ‘ezunits’ are specified
by the global variable ‘known_unit_conversions’, which comprises
built-in and user-defined conversions.  Conversions for products,
quotients, and powers of units are derived from the set of known unit
conversions.

   As Maxima generally prefers exact numbers (integers or rationals) to
inexact (float or bigfloat), so ‘ezunits’ preserves exact numbers when
they appear in dimensional quantities.  All built-in unit conversions
are expressed in terms of exact numbers; inexact numbers in declared
conversions are coerced to exact.

   There is no preferred system for display of units; input units are
not converted to other units unless conversion is explicitly indicated.
‘ezunits’ recognizes the prefixes m-, k-, M, and G- (for milli-, kilo-,
mega-, and giga-) as applied to SI base units and SI derived units, but
such prefixes are applied only when indicated by an explicit conversion.

   Arithmetic operations on dimensional quantities are carried out by
conventional rules for such operations.

   • (x ` a) * (y ` b) is equal to (x * y) ` (a * b).
   • (x ` a) + (y ` a) is equal to (x + y) ` a.
   • (x ` a)^y is equal to x^y ` a^y when ‘y’ is nondimensional.

   ‘ezunits’ does not require that units in a sum have the same
dimensions; such terms are not added together, and no error is reported.

   ‘ezunits’ includes functions for elementary dimensional analysis,
namely the fundamental dimensions and fundamental units of a dimensional
quantity, and computation of dimensionless quantities and natural units.
The functions for dimensional analysis were adapted from similar
functions in another package, written by Barton Willis.

   For the purpose of dimensional analysis, a list of fundamental
dimensions and an associated list of fundamental units are maintained;
by default the fundamental dimensions are length, mass, time, charge,
temperature, and quantity, and the fundamental units are the associated
SI units, but other fundamental dimensions and units can be declared.


File: maxima.info,  Node: Introduction to physical_constants,  Next: Functions and Variables for ezunits,  Prev: Introduction to ezunits,  Up: ezunits-pkg

57.2 Introduction to physical_constants
=======================================

‘physical_constants’ is a collection of physical constants, copied from
CODATA 2006 recommended values
(<https://physics.nist.gov/cuu/Constants/>).  ‘load
("physical_constants")’ loads this package, and loads ‘ezunits’ also, if
it is not already loaded.

   A physical constant is represented as a symbol which has a property
which is the constant value.  The constant value is a dimensional
quantity, as represented by ‘ezunits’.  The function ‘constvalue’
fetches the constant value; the constant value is not the ordinary value
of the symbol, so symbols of physical constants persist in evaluated
expressions until their values are fetched by ‘constvalue’.

   ‘physical_constants’ includes some auxiliary information, namely, a
description string for each constant, an estimate of the error of its
numerical value, and a property for TeX display.  To identify physical
constants, each symbol has the ‘physical_constant’ property;
‘propvars(physical_constant)’ therefore shows the list of all such
symbols.

   ‘physical_constants’ comprises the following constants.

‘%c’
     speed of light in vacuum
‘%mu_0’
     magnetic constant
‘%e_0’
     electric constant
‘%Z_0’
     characteristic impedance of vacuum
‘%G’
     Newtonian constant of gravitation
‘%h’
     Planck constant
‘%h_bar’
     Planck constant
‘%m_P’
     Planck mass
‘%T_P’
     Planck temperature
‘%l_P’
     Planck length
‘%t_P’
     Planck time
‘%%e’
     elementary charge
‘%Phi_0’
     magnetic flux quantum
‘%G_0’
     conductance quantum
‘%K_J’
     Josephson constant
‘%R_K’
     von Klitzing constant
‘%mu_B’
     Bohr magneton
‘%mu_N’
     nuclear magneton
‘%alpha’
     fine-structure constant
‘%R_inf’
     Rydberg constant
‘%a_0’
     Bohr radius
‘%E_h’
     Hartree energy
‘%ratio_h_me’
     quantum of circulation
‘%m_e’
     electron mass
‘%N_A’
     Avogadro constant
‘%m_u’
     atomic mass constant
‘%F’
     Faraday constant
‘%R’
     molar gas constant
‘%%k’
     Boltzmann constant
‘%V_m’
     molar volume of ideal gas
‘%n_0’
     Loschmidt constant
‘%ratio_S0_R’
     Sackur-Tetrode constant (absolute entropy constant)
‘%sigma’
     Stefan-Boltzmann constant
‘%c_1’
     first radiation constant
‘%c_1L’
     first radiation constant for spectral radiance
‘%c_2’
     second radiation constant
‘%b’
     Wien displacement law constant
‘%b_prime’
     Wien displacement law constant

   Reference: <https://physics.nist.gov/cuu/Constants/>

   Examples:

   The list of all symbols which have the ‘physical_constant’ property.

     (%i1) load ("physical_constants")$
     (%i2) propvars (physical_constant);
     (%o2) [%c, %mu_0, %e_0, %Z_0, %G, %h, %h_bar, %m_P, %T_P, %l_P,
     %t_P, %%e, %Phi_0, %G_0, %K_J, %R_K, %mu_B, %mu_N, %alpha,
     %R_inf, %a_0, %E_h, %ratio_h_me, %m_e, %N_A, %m_u, %F, %R, %%k,
     %V_m, %n_0, %ratio_S0_R, %sigma, %c_1, %c_1L, %c_2, %b, %b_prime]

   Properties of the physical constant ‘%c’.

     (%i1) load ("physical_constants")$
     (%i2) constantp (%c);
     (%o2)                         true
     (%i3) get (%c, description);
     (%o3)               speed of light in vacuum
     (%i4) constvalue (%c);
                                           m
     (%o4)                     299792458 ` -
                                           s
     (%i5) get (%c, RSU);
     (%o5)                           0
     (%i6) tex (%c);
     $$c$$
     (%o6)                         false

   The energy equivalent of 1 pound-mass.  The symbol ‘%c’ persists
until its value is fetched by ‘constvalue’.

     (%i1) load ("physical_constants")$
     (%i2) m * %c^2;
                                     2
     (%o2)                         %c  m
     (%i3) %, m = 1 ` lbm;
                                   2
     (%o3)                       %c  ` lbm
     (%i4) constvalue (%);
                                                 2
                                            lbm m
     (%o4)              89875517873681764 ` ------
                                               2
                                              s
     (%i5) E : % `` J;
     Computing conversions to base units; may take a moment.
                          366838848464007200
     (%o5)                ------------------ ` J
                                  9
     (%i6) E `` GJ;
                           458548560580009
     (%o6)                 --------------- ` GJ
                              11250000
     (%i7) float (%);
     (%o7)              4.0759872051556356e+7 ` GJ


File: maxima.info,  Node: Functions and Variables for ezunits,  Prev: Introduction to physical_constants,  Up: ezunits-pkg

57.3 Functions and Variables for ezunits
========================================

 -- Operator: `

     The dimensional quantity operator.  An expression a ` b represents
     a dimensional quantity, with ‘a’ indicating a nondimensional
     quantity and ‘b’ indicating the dimensional units.  A symbol can be
     used as a unit without declaring it as such; unit symbols need not
     have any special properties.  The quantity and unit of an
     expression a ` b can be extracted by the ‘qty’ and ‘units’
     functions, respectively.

     Arithmetic operations on dimensional quantities are carried out by
     conventional rules for such operations.

        • (x ` a) * (y ` b) is equal to (x * y) ` (a * b).
        • (x ` a) + (y ` a) is equal to (x + y) ` a.
        • (x ` a)^y is equal to x^y ` a^y when ‘y’ is nondimensional.

     ‘ezunits’ does not require that units in a sum have the same
     dimensions; such terms are not added together, and no error is
     reported.

     ‘load ("ezunits")’ enables this operator.

     Examples:

     SI (Systeme Internationale) units.

          (%i1) load ("ezunits")$
          (%i2) foo : 10 ` m;
          (%o2)                        10 ` m
          (%i3) qty (foo);
          (%o3)                          10
          (%i4) units (foo);
          (%o4)                           m
          (%i5) dimensions (foo);
          (%o5)                        length

     "Customary" units.

          (%i1) load ("ezunits")$
          (%i2) bar : x ` acre;
          (%o2)                       x ` acre
          (%i3) dimensions (bar);
                                             2
          (%o3)                        length
          (%i4) fundamental_units (bar);
                                          2
          (%o4)                          m

     Units ad hoc.

          (%i1) load ("ezunits")$
          (%i2) baz : 3 ` sheep + 8 ` goat + 1 ` horse;
          (%o2)           8 ` goat + 3 ` sheep + 1 ` horse
          (%i3) subst ([sheep = 3*goat, horse = 10*goat], baz);
          (%o3)                       27 ` goat
          (%i4) baz2 : 1000`gallon/fortnight;
                                          gallon
          (%o4)                   1000 ` ---------
                                         fortnight
          (%i5) subst (fortnight = 14*day, baz2);
                                    500   gallon
          (%o5)                     --- ` ------
                                     7     day

     Arithmetic operations on dimensional quantities.

          (%i1) load ("ezunits")$
          (%i2) 100 ` kg + 200 ` kg;
          (%o2)                       300 ` kg
          (%i3) 100 ` m^3 - 100 ` m^3;
                                            3
          (%o3)                        0 ` m
          (%i4) (10 ` kg) * (17 ` m/s^2);
                                           kg m
          (%o4)                      170 ` ----
                                             2
                                            s
          (%i5) (x ` m) / (y ` s);
                                        x   m
          (%o5)                         - ` -
                                        y   s
          (%i6) (a ` m)^2;
                                        2    2
          (%o6)                        a  ` m

 -- Operator: ``

     The unit conversion operator.  An expression a ` b `` c converts
     from unit ‘b’ to unit ‘c’.  ‘ezunits’ has built-in conversions for
     SI base units, SI derived units, and some non-SI units.  Unit
     conversions not already known to ‘ezunits’ can be declared.  The
     unit conversions known to ‘ezunits’ are specified by the global
     variable ‘known_unit_conversions’, which comprises built-in and
     user-defined conversions.  Conversions for products, quotients, and
     powers of units are derived from the set of known unit conversions.

     There is no preferred system for display of units; input units are
     not converted to other units unless conversion is explicitly
     indicated.  ‘ezunits’ does not attempt to simplify units by
     prefixes (milli-, centi-, deci-, etc) unless such conversion is
     explicitly indicated.

     ‘load ("ezunits")’ enables this operator.

     Examples:

     The set of known unit conversions.

          (%i1) load ("ezunits")$
          (%i2) display2d : false$
          (%i3) known_unit_conversions;
          (%o3) {acre = 4840*yard^2,Btu = 1055*J,cfm = feet^3/minute,
                 cm = m/100,day = 86400*s,feet = 381*m/1250,ft = feet,
                 g = kg/1000,gallon = 757*l/200,GHz = 1000000000*Hz,
                 GOhm = 1000000000*Ohm,GPa = 1000000000*Pa,
                 GWb = 1000000000*Wb,Gg = 1000000*kg,Gm = 1000000000*m,
                 Gmol = 1000000*mol,Gs = 1000000000*s,ha = hectare,
                 hectare = 100*m^2,hour = 3600*s,Hz = 1/s,inch = feet/12,
                 km = 1000*m,kmol = 1000*mol,ks = 1000*s,l = liter,
                 lbf = pound_force,lbm = pound_mass,liter = m^3/1000,
                 metric_ton = Mg,mg = kg/1000000,MHz = 1000000*Hz,
                 microgram = kg/1000000000,micrometer = m/1000000,
                 micron = micrometer,microsecond = s/1000000,
                 mile = 5280*feet,minute = 60*s,mm = m/1000,
                 mmol = mol/1000,month = 2629800*s,MOhm = 1000000*Ohm,
                 MPa = 1000000*Pa,ms = s/1000,MWb = 1000000*Wb,
                 Mg = 1000*kg,Mm = 1000000*m,Mmol = 1000000000*mol,
                 Ms = 1000000*s,ns = s/1000000000,ounce = pound_mass/16,
                 oz = ounce,Ohm = s*J/C^2,
                 pound_force = 32*ft*pound_mass/s^2,
                 pound_mass = 200*kg/441,psi = pound_force/inch^2,
                 Pa = N/m^2,week = 604800*s,Wb = J/A,yard = 3*feet,
                 year = 31557600*s,C = s*A,F = C^2/J,GA = 1000000000*A,
                 GC = 1000000000*C,GF = 1000000000*F,GH = 1000000000*H,
                 GJ = 1000000000*J,GK = 1000000000*K,GN = 1000000000*N,
                 GS = 1000000000*S,GT = 1000000000*T,GV = 1000000000*V,
                 GW = 1000000000*W,H = J/A^2,J = m*N,kA = 1000*A,
                 kC = 1000*C,kF = 1000*F,kH = 1000*H,kHz = 1000*Hz,
                 kJ = 1000*J,kK = 1000*K,kN = 1000*N,kOhm = 1000*Ohm,
                 kPa = 1000*Pa,kS = 1000*S,kT = 1000*T,kV = 1000*V,
                 kW = 1000*W,kWb = 1000*Wb,mA = A/1000,mC = C/1000,
                 mF = F/1000,mH = H/1000,mHz = Hz/1000,mJ = J/1000,
                 mK = K/1000,mN = N/1000,mOhm = Ohm/1000,mPa = Pa/1000,
                 mS = S/1000,mT = T/1000,mV = V/1000,mW = W/1000,
                 mWb = Wb/1000,MA = 1000000*A,MC = 1000000*C,
                 MF = 1000000*F,MH = 1000000*H,MJ = 1000000*J,
                 MK = 1000000*K,MN = 1000000*N,MS = 1000000*S,
                 MT = 1000000*T,MV = 1000000*V,MW = 1000000*W,
                 N = kg*m/s^2,R = 5*K/9,S = 1/Ohm,T = J/(m^2*A),V = J/C,
                 W = J/s}

     Elementary unit conversions.

          (%i1) load ("ezunits")$
          (%i2) 1 ` ft `` m;
          Computing conversions to base units; may take a moment.
                                      381
          (%o2)                       ---- ` m
                                      1250
          (%i3) %, numer;
          (%o3)                      0.3048 ` m
          (%i4) 1 ` kg `` lbm;
                                      441
          (%o4)                       --- ` lbm
                                      200
          (%i5) %, numer;
          (%o5)                      2.205 ` lbm
          (%i6) 1 ` W `` Btu/hour;
                                     720   Btu
          (%o6)                      --- ` ----
                                     211   hour
          (%i7) %, numer;
                                                  Btu
          (%o7)               3.412322274881517 ` ----
                                                  hour
          (%i8) 100 ` degC `` degF;
          (%o8)                      212 ` degF
          (%i9) -40 ` degF `` degC;
          (%o9)                     (- 40) ` degC
          (%i10) 1 ` acre*ft `` m^3;
                                  60228605349    3
          (%o10)                  ----------- ` m
                                   48828125
          (%i11) %, numer;
                                                    3
          (%o11)                1233.48183754752 ` m

     Coercing quantities in feet and meters to one or the other.

          (%i1) load ("ezunits")$
          (%i2) 100 ` m + 100 ` ft;
          (%o2)                  100 ` m + 100 ` ft
          (%i3) (100 ` m + 100 ` ft) `` ft;
          Computing conversions to base units; may take a moment.
                                     163100
          (%o3)                      ------ ` ft
                                      381
          (%i4) %, numer;
          (%o4)                428.0839895013123 ` ft
          (%i5) (100 ` m + 100 ` ft) `` m;
                                      3262
          (%o5)                       ---- ` m
                                       25
          (%i6) %, numer;
          (%o6)                      130.48 ` m

     Dimensional analysis to find fundamental dimensions and fundamental
     units.

          (%i1) load ("ezunits")$
          (%i2) foo : 1 ` acre * ft;
          (%o2)                      1 ` acre ft
          (%i3) dimensions (foo);
                                             3
          (%o3)                        length
          (%i4) fundamental_units (foo);
                                          3
          (%o4)                          m
          (%i5) foo `` m^3;
          Computing conversions to base units; may take a moment.
                                  60228605349    3
          (%o5)                   ----------- ` m
                                   48828125
          (%i6) %, numer;
                                                    3
          (%o6)                 1233.48183754752 ` m

     Declared unit conversions.

          (%i1) load ("ezunits")$
          (%i2) declare_unit_conversion (MMBtu = 10^6*Btu, kW = 1000*W);
          (%o2)                         done
          (%i3) declare_unit_conversion (kWh = kW*hour, MWh = 1000*kWh,
                                         bell = 1800*s);
          (%o3)                         done
          (%i4) 1 ` kW*s `` MWh;
          Computing conversions to base units; may take a moment.
                                       1
          (%o4)                     ------- ` MWh
                                    3600000
          (%i5) 1 ` kW/m^2 `` MMBtu/bell/ft^2;
                                 1306449      MMBtu
          (%o5)                 ---------- ` --------
                                8242187500          2
                                             bell ft

 -- Function: constvalue (<x>)

     Shows the value and the units of one of the constants declared by
     package ‘physical_constants’, which includes a list of physical
     constants, or of a new constant declared in package ‘ezunits’ (see
     ‘declare_constvalue’).

     Note that constant values as recognized by ‘constvalue’ are
     separate from values declared by ‘numerval’ and recognized by
     ‘constantp’.

     Example:

          (%i1) load ("physical_constants")$
          (%i2) constvalue (%G);
                                               3
                                              m
          (%o2)                    6.67428 ` -----
                                                 2
                                             kg s
          (%i3) get ('%G, 'description);
          (%o3)           Newtonian constant of gravitation

 -- Function: declare_constvalue (<a>, <x>)

     Declares the value of a constant to be used in package ‘ezunits’.
     This function should be loaded with ‘load ("ezunits")’.

     Example:

          (%i1) load ("ezunits")$
          (%i2) declare_constvalue (FOO, 100 ` lbm / acre);
                                           lbm
          (%o2)                      100 ` ----
                                           acre
          (%i3) FOO * (50 ` acre);
          (%o3)                     50 FOO ` acre
          (%i4) constvalue (%);
          (%o4)                      5000 ` lbm

 -- Function: remove_constvalue (<a>)

     Reverts the effect of ‘declare_constvalue’.  This function should
     be loaded with ‘load ("ezunits")’.

 -- Function: units (<x>)

     Returns the units of a dimensional quantity <x>, or returns 1 if
     <x> is nondimensional.

     <x> may be a literal dimensional expression a ` b, a symbol with
     declared units via ‘declare_units’, or an expression containing
     either or both of those.

     This function should be loaded with ‘load ("ezunits")’.

     Example:

          (%i1) load ("ezunits")$
          (%i2) foo : 100 ` kg;
          (%o2)                       100 ` kg
          (%i3) bar : x ` m/s;
                                            m
          (%o3)                         x ` -
                                            s
          (%i4) units (foo);
          (%o4)                          kg
          (%i5) units (bar);
                                          m
          (%o5)                           -
                                          s
          (%i6) units (foo * bar);
                                        kg m
          (%o6)                         ----
                                         s
          (%i7) units (foo / bar);
                                        kg s
          (%o7)                         ----
                                         m
          (%i8) units (foo^2);
                                           2
          (%o8)                          kg

 -- Function: declare_units (<a>, <u>)

     Declares that ‘units’ should return units <u> for <a>, where <u> is
     an expression.  This function should be loaded with ‘load
     ("ezunits")’.

     Example:

          (%i1) load ("ezunits")$
          (%i2) units (aa);
          (%o2)                           1
          (%i3) declare_units (aa, J);
          (%o3)                           J
          (%i4) units (aa);
          (%o4)                           J
          (%i5) units (aa^2);
                                          2
          (%o5)                          J
          (%i6) foo : 100 ` kg;
          (%o6)                       100 ` kg
          (%i7) units (aa * foo);
          (%o7)                         kg J

 -- Function: qty (<x>)

     Returns the nondimensional part of a dimensional quantity <x>, or
     returns <x> if <x> is nondimensional.  <x> may be a literal
     dimensional expression a ` b, a symbol with declared quantity, or
     an expression containing either or both of those.

     This function should be loaded with ‘load ("ezunits")’.

     Example:

          (%i1) load ("ezunits")$
          (%i2) foo : 100 ` kg;
          (%o2)                       100 ` kg
          (%i3) qty (foo);
          (%o3)                          100
          (%i4) bar : v ` m/s;
                                            m
          (%o4)                         v ` -
                                            s
          (%i5) foo * bar;
                                            kg m
          (%o5)                     100 v ` ----
                                             s
          (%i6) qty (foo * bar);
          (%o6)                         100 v

 -- Function: declare_qty (<a>, <x>)

     Declares that ‘qty’ should return <x> for symbol <a>, where <x> is
     a nondimensional quantity.  This function should be loaded with
     ‘load ("ezunits")’.

     Example:

          (%i1) load ("ezunits")$
          (%i2) declare_qty (aa, xx);
          (%o2)                          xx
          (%i3) qty (aa);
          (%o3)                          xx
          (%i4) qty (aa^2);
                                           2
          (%o4)                          xx
          (%i5) foo : 100 ` kg;
          (%o5)                       100 ` kg
          (%i6) qty (aa * foo);
          (%o6)                        100 xx

 -- Function: unitp (<x>)

     Returns ‘true’ if <x> is a literal dimensional expression, a symbol
     declared dimensional, or an expression in which the main operator
     is declared dimensional.  ‘unitp’ returns ‘false’ otherwise.

     ‘load ("ezunits")’ loads this function.

     Examples:

     ‘unitp’ applied to a literal dimensional expression.

          (%i1) load ("ezunits")$
          (%i2) unitp (100 ` kg);
          (%o2)                         true

     ‘unitp’ applied to a symbol declared dimensional.

          (%i1) load ("ezunits")$
          (%i2) unitp (foo);
          (%o2)                         false
          (%i3) declare (foo, dimensional);
          (%o3)                         done
          (%i4) unitp (foo);
          (%o4)                         true

     ‘unitp’ applied to an expression in which the main operator is
     declared dimensional.

          (%i1) load ("ezunits")$
          (%i2) unitp (bar (x, y, z));
          (%o2)                         false
          (%i3) declare (bar, dimensional);
          (%o3)                         done
          (%i4) unitp (bar (x, y, z));
          (%o4)                         true

 -- Function: declare_unit_conversion (<u> = <v>, ...)

     Appends equations <u> = <v>, ...  to the list of unit conversions
     known to the unit conversion operator ``.  <u> and <v> are both
     multiplicative terms, in which any variables are units, or both
     literal dimensional expressions.

     At present, it is necessary to express conversions such that the
     left-hand side of each equation is a simple unit (not a
     multiplicative expression) or a literal dimensional expression with
     the quantity equal to 1 and the unit being a simple unit.  This
     limitation might be relaxed in future versions.

     ‘known_unit_conversions’ is the list of known unit conversions.

     This function should be loaded with ‘load ("ezunits")’.

     Examples:

     Unit conversions expressed by equations of multiplicative terms.

          (%i1) load ("ezunits")$
          (%i2) declare_unit_conversion (nautical_mile = 1852 * m,
                                         fortnight = 14 * day);
          (%o2)                         done
          (%i3) 100 ` nautical_mile / fortnight `` m/s;
          Computing conversions to base units; may take a moment.
                                      463    m
          (%o3)                       ---- ` -
                                      3024   s

     Unit conversions expressed by equations of literal dimensional
     expressions.

          (%i1) load ("ezunits")$
          (%i2) declare_unit_conversion (1 ` fluid_ounce = 2 ` tablespoon);
          (%o2)                         done
          (%i3) declare_unit_conversion (1 ` tablespoon = 3 ` teaspoon);
          (%o3)                         done
          (%i4) 15 ` fluid_ounce `` teaspoon;
          Computing conversions to base units; may take a moment.
          (%o4)                     90 ` teaspoon

 -- Function: declare_dimensions (<a_1>, <d_1>, ..., <a_n>, <d_n>)

     Declares <a_1>, ..., <a_n> to have dimensions <d_1>, ..., <d_n>,
     respectively.

     Each <a_k> is a symbol or a list of symbols.  If it is a list, then
     every symbol in <a_k> is declared to have dimension <d_k>.

     ‘load ("ezunits")’ loads these functions.

     Examples:

          (%i1) load ("ezunits") $
          (%i2) declare_dimensions ([x, y, z], length, [t, u], time);
          (%o2)                         done
          (%i3) dimensions (y^2/u);
                                             2
                                       length
          (%o3)                        -------
                                        time
          (%i4) fundamental_units (y^2/u);
          0 errors, 0 warnings
                                          2
                                         m
          (%o4)                          --
                                         s

 -- Function: remove_dimensions (<a_1>, ..., <a_n>)

     Reverts the effect of ‘declare_dimensions’.  This function should
     be loaded with ‘load ("ezunits")’.

 -- Function: declare_fundamental_dimensions (<d_1>, <d_2>, <d_3>, ...)
 -- Function: remove_fundamental_dimensions (<d_1>, <d_2>, <d_3>, ...)
 -- Global variable: fundamental_dimensions

     ‘declare_fundamental_dimensions’ declares fundamental dimensions.
     Symbols <d_1>, <d_2>, <d_3>, ...  are appended to the list of
     fundamental dimensions, if they are not already on the list.

     ‘remove_fundamental_dimensions’ reverts the effect of
     ‘declare_fundamental_dimensions’.

     ‘fundamental_dimensions’ is the list of fundamental dimensions.  By
     default, the list comprises several physical dimensions.

     ‘load ("ezunits")’ loads these functions.

     Examples:

          (%i1) load ("ezunits") $
          (%i2) fundamental_dimensions;
          (%o2) [length, mass, time, current, temperature, quantity]
          (%i3) declare_fundamental_dimensions (money, cattle, happiness);
          (%o3)                         done
          (%i4) fundamental_dimensions;
          (%o4) [length, mass, time, current, temperature, quantity,
                                                  money, cattle, happiness]
          (%i5) remove_fundamental_dimensions (cattle, happiness);
          (%o5)                         done
          (%i6) fundamental_dimensions;
          (%o6) [length, mass, time, current, temperature, quantity, money]

 -- Function: declare_fundamental_units (<u_1>, <d_1>, ..., <u_n>,
          <d_n>)
 -- Function: remove_fundamental_units (<u_1>, ..., <u_n>)

     ‘declare_fundamental_units’ declares <u_1>, ..., <u_n> to have
     dimensions <d_1>, ..., <d_n>, respectively.  All arguments must be
     symbols.

     After calling ‘declare_fundamental_units’, ‘dimensions(<u_k>)’
     returns <d_k> for each argument <u_1>, ..., <u_n>, and
     ‘fundamental_units(<d_k>)’ returns <u_k> for each argument <d_1>,
     ..., <d_n>.

     ‘remove_fundamental_units’ reverts the effect of
     ‘declare_fundamental_units’.

     ‘load ("ezunits")’ loads these functions.

     Examples:

          (%i1) load ("ezunits") $
          (%i2) declare_fundamental_dimensions (money, cattle, happiness);
          (%o2)                         done
          (%i3) declare_fundamental_units (dollar, money, goat, cattle,
                                           smile, happiness);
          (%o3)                 [dollar, goat, smile]
          (%i4) dimensions (100 ` dollar/goat/km^2);
                                       money
          (%o4)                    --------------
                                                2
                                   cattle length
          (%i5) dimensions (x ` smile/kg);
                                      happiness
          (%o5)                       ---------
                                        mass
          (%i6) fundamental_units (money*cattle/happiness);
          0 errors, 0 warnings
                                     dollar goat
          (%o6)                      -----------
                                        smile

 -- Function: dimensions (<x>)
 -- Function: dimensions_as_list (<x>)

     ‘dimensions’ returns the dimensions of the dimensional quantity <x>
     as an expression comprising products and powers of base dimensions.

     ‘dimensions_as_list’ returns the dimensions of the dimensional
     quantity <x> as a list, in which each element is an integer which
     indicates the power of the corresponding base dimension in the
     dimensions of <x>.

     ‘load ("ezunits")’ loads these functions.

     Examples:

          (%i1) load ("ezunits")$
          (%i2) dimensions (1000 ` kg*m^2/s^3);
                                          2
                                    length  mass
          (%o2)                     ------------
                                           3
                                       time
          (%i3) declare_units (foo, acre*ft/hour);
                                       acre ft
          (%o3)                        -------
                                        hour
          (%i4) dimensions (foo);
                                             3
                                       length
          (%o4)                        -------
                                        time

          (%i1) load ("ezunits")$
          (%i2) fundamental_dimensions;
          (%o2)  [length, mass, time, charge, temperature, quantity]
          (%i3) dimensions_as_list (1000 ` kg*m^2/s^3);
          (%o3)                 [2, 1, - 3, 0, 0, 0]
          (%i4) declare_units (foo, acre*ft/hour);
                                       acre ft
          (%o4)                        -------
                                        hour
          (%i5) dimensions_as_list (foo);
          (%o5)                 [3, 0, - 1, 0, 0, 0]

 -- Function: fundamental_units
          fundamental_units (<x>)
          fundamental_units ()

     ‘fundamental_units(<x>)’ returns the units associated with the
     fundamental dimensions of <x>.  as determined by ‘dimensions(<x>)’.

     <x> may be a literal dimensional expression a ` b, a symbol with
     declared units via ‘declare_units’, or an expression containing
     either or both of those.

     ‘fundamental_units()’ returns the list of all known fundamental
     units, as declared by ‘declare_fundamental_units’.

     ‘load ("ezunits")’ loads this function.

     Examples:

          (%i1) load ("ezunits")$
          (%i2) fundamental_units ();
          (%o2)                 [m, kg, s, A, K, mol]
          (%i3) fundamental_units (100 ` mile/hour);
                                          m
          (%o3)                           -
                                          s
          (%i4) declare_units (aa, g/foot^2);
                                          g
          (%o4)                         -----
                                            2
                                        foot
          (%i5) fundamental_units (aa);
                                         kg
          (%o5)                          --
                                          2
                                         m

 -- Function: dimensionless (<L>)

     Returns a basis for the dimensionless quantities which can be
     formed from a list <L> of dimensional quantities.

     ‘load ("ezunits")’ loads this function.

     Examples:

          (%i1) load ("ezunits") $
          (%i2) dimensionless ([x ` m, y ` m/s, z ` s]);
          0 errors, 0 warnings
          0 errors, 0 warnings
                                         y z
          (%o2)                         [---]
                                          x

     Dimensionless quantities derived from fundamental physical
     quantities.  Note that the first element on the list is
     proportional to the fine-structure constant.

          (%i1) load ("ezunits") $
          (%i2) load ("physical_constants") $
          (%i3) dimensionless([%h_bar, %m_e, %m_P, %%e, %c, %e_0]);
          0 errors, 0 warnings
          0 errors, 0 warnings
                                        2
                                     %%e        %m_e
          (%o3)                [--------------, ----]
                                %c %e_0 %h_bar  %m_P

 -- Function: natural_unit (<expr>, [<v_1>, ..., <v_n>])

     Finds exponents <e_1>, ..., <e_n> such that ‘dimension(<expr>) =
     dimension(<v_1>^<e_1> ... <v_n>^<e_n>)’.

     ‘load ("ezunits")’ loads this function.

     Examples:



File: maxima.info,  Node: f90-pkg,  Next: finance-pkg,  Prev: ezunits-pkg,  Up: Top

58 f90
******

* Menu:

* Package f90::


File: maxima.info,  Node: Package f90,  Prev: f90-pkg,  Up: f90-pkg

58.1 Package f90
================

 -- Option variable: f90_output_line_length_max
     Default value: 65

     ‘f90_output_line_length_max’ is the maximum number of characters of
     Fortran code which are output by ‘f90’ per line.  Longer lines of
     code are divided, and printed with an ampersand ‘&’ at the end of
     an output line and an ampersand at the beginning of the following
     line.

     ‘f90_output_line_length_max’ must be a positive integer.

     Example:

          (%i1) load ("f90")$
          (%i2) foo : expand ((xxx + yyy + 7)^4);
                   4            3         3        2    2             2
          (%o2) yyy  + 4 xxx yyy  + 28 yyy  + 6 xxx  yyy  + 84 xxx yyy
                    2        3             2
           + 294 yyy  + 4 xxx  yyy + 84 xxx  yyy + 588 xxx yyy + 1372 yyy
                4         3          2
           + xxx  + 28 xxx  + 294 xxx  + 1372 xxx + 2401
          (%i3) f90_output_line_length_max;
          (%o3)                          65
          (%i4) f90 ('foo = foo);
          foo = yyy**4+4*xxx*yyy**3+28*yyy**3+6*xxx**2*yyy**2+84*xxx*yyy**2&
          &+294*yyy**2+4*xxx**3*yyy+84*xxx**2*yyy+588*xxx*yyy+1372*yyy+xxx**&
          &4+28*xxx**3+294*xxx**2+1372*xxx+2401
          (%o4)                         false
          (%i5) f90_output_line_length_max : 40 $
          (%i6) f90 ('foo = foo);
          foo = yyy**4+4*xxx*yyy**3+28*yyy**3+6*xx&
          &x**2*yyy**2+84*xxx*yyy**2+294*yyy**2+4*x&
          &xx**3*yyy+84*xxx**2*yyy+588*xxx*yyy+1372&
          &*yyy+xxx**4+28*xxx**3+294*xxx**2+1372*xx&
          &x+2401
          (%o6)                         false

 -- Function: f90 (<expr_1>, ..., <expr_n>)

     Prints one or more expressions <expr_1>, ..., <expr_n> as a Fortran
     90 program.  Output is printed to the standard output.

     ‘f90’ prints output in the so-called "free form" input format for
     Fortran 90: there is no special attention to column positions.
     Long lines are split at a fixed width with the ampersand ‘&’
     continuation character; the number of output characters per line,
     not including ampersands, is specified by
     ‘f90_output_line_length_max’.  ‘f90’ outputs an ampersand at the
     end of a split line and another at the beginning of the next line.

     ‘load("f90")’ loads this function.  See also the function
     ‘fortran’.

     Examples:

          (%i1) load ("f90")$
          (%i2) foo : expand ((xxx + yyy + 7)^4);
                   4            3         3        2    2             2
          (%o2) yyy  + 4 xxx yyy  + 28 yyy  + 6 xxx  yyy  + 84 xxx yyy
                    2        3             2
           + 294 yyy  + 4 xxx  yyy + 84 xxx  yyy + 588 xxx yyy + 1372 yyy
                4         3          2
           + xxx  + 28 xxx  + 294 xxx  + 1372 xxx + 2401
          (%i3) f90 ('foo = foo);
          foo = yyy**4+4*xxx*yyy**3+28*yyy**3+6*xxx**2*yyy**2+84*xxx*yyy**2&
          &+294*yyy**2+4*xxx**3*yyy+84*xxx**2*yyy+588*xxx*yyy+1372*yyy+xxx**&
          &4+28*xxx**3+294*xxx**2+1372*xxx+2401
          (%o3)                         false

     Multiple expressions.  Capture standard output into a file via the
     ‘with_stdout’ function.

          (%i1) load ("f90")$
          (%i2) foo : sin (3*x + 1) - cos (7*x - 2);
          (%o2)              sin(3 x + 1) - cos(7 x - 2)
          (%i3) with_stdout ("foo.f90",
                             f90 (x=0.25, y=0.625, 'foo=foo, 'stop, 'end));
          (%o3)                         false
          (%i4) printfile ("foo.f90");
          x = 0.25
          y = 0.625
          foo = sin(3*x+1)-cos(7*x-2)
          stop
          end
          (%o4)                        foo.f90


File: maxima.info,  Node: finance-pkg,  Next: fractals-pkg,  Prev: f90-pkg,  Up: Top

59 finance
**********

* Menu:

* Introduction to finance::
* Functions and Variables for finance::


File: maxima.info,  Node: Introduction to finance,  Next: Functions and Variables for finance,  Prev: finance-pkg,  Up: finance-pkg

59.1 Introduction to finance
============================

This is the Finance Package (Ver 0.1).

   In all the functions, <rate> is the compound interest rate, <num> is
the number of periods and must be positive and <flow> refers to cash
flow so if you have an Output the flow is negative and positive for
Inputs.

   Note that before using the functions defined in this package, you
have to load it writing ‘load("finance")$’.

   Author: Nicolas Guarin Zapata.


File: maxima.info,  Node: Functions and Variables for finance,  Prev: Introduction to finance,  Up: finance-pkg

59.2 Functions and Variables for finance
========================================

 -- Function: days360 (<year1>,<month1>,<day1>,<year2>,<month2>,<day2>)

     Calculates the distance between 2 dates, assuming 360 days years,
     30 days months.

     Example:

          (%i1) load("finance")$
          (%i2) days360(2008,12,16,2007,3,25);
          (%o2)                      - 621

 -- Function: fv (<rate>,<PV>,<num>)

     We can calculate the future value of a Present one given a certain
     interest rate.  <rate> is the interest rate, <PV> is the present
     value and <num> is the number of periods.

     Example:

          (%i1) load("finance")$
          (%i2) fv(0.12,1000,3);
          (%o2)                     1404.928

 -- Function: pv (<rate>,<FV>,<num>)

     We can calculate the present value of a Future one given a certain
     interest rate.  <rate> is the interest rate, <FV> is the future
     value and <num> is the number of periods.

     Example:

          (%i1) load("finance")$
          (%i2) pv(0.12,1000,3);
          (%o2)                711.7802478134108

 -- Function: graph_flow (<val>)

     Plots the money flow in a time line, the positive values are in
     blue and upside; the negative ones are in red and downside.  The
     direction of the flow is given by the sign of the value.  <val> is
     a list of flow values.

     Example:

          (%i1) load("finance")$
          (%i2) graph_flow([-5000,-3000,800,1300,1500,2000])$

 -- Function: annuity_pv (<rate>,<PV>,<num>)

     We can calculate the annuity knowing the present value (like an
     amount), it is a constant and periodic payment.  <rate> is the
     interest rate, <PV> is the present value and <num> is the number of
     periods.

     Example:

          (%i1) load("finance")$
          (%i2) annuity_pv(0.12,5000,10);
          (%o2)                884.9208207992202

 -- Function: annuity_fv (<rate>,<FV>,<num>)

     We can calculate the annuity knowing the desired value (future
     value), it is a constant and periodic payment.  <rate> is the
     interest rate, <FV> is the future value and <num> is the number of
     periods.

     Example:

          (%i1) load("finance")$
          (%i2) annuity_fv(0.12,65000,10);
          (%o2)                3703.970670389863

 -- Function: geo_annuity_pv (<rate>,<growing_rate>,<PV>,<num>)

     We can calculate the annuity knowing the present value (like an
     amount), in a growing periodic payment.  <rate> is the interest
     rate, <growing_rate> is the growing rate, <PV> is the present value
     and <num> is the number of periods.

     Example:

          (%i1) load("finance")$
          (%i2) geo_annuity_pv(0.14,0.05,5000,10);
          (%o2)                802.6888176505123

 -- Function: geo_annuity_fv (<rate>,<growing_rate>,<FV>,<num>)

     We can calculate the annuity knowing the desired value (future
     value), in a growing periodic payment.  <rate> is the interest
     rate, <growing_rate> is the growing rate, <FV> is the future value
     and <num> is the number of periods.

     Example:

          (%i1) load("finance")$
          (%i2) geo_annuity_fv(0.14,0.05,5000,10);
          (%o2)                216.5203395312695

 -- Function: amortization (<rate>,<amount>,<num>)

     Amortization table determined by a specific rate.  <rate> is the
     interest rate, <amount> is the amount value, and <num> is the
     number of periods.

     Example:

          (%i1) load("finance")$
          (%i2) amortization(0.05,56000,12)$
                "n"    "Balance"     "Interest"   "Amortization"  "Payment"
               0.000     56000.000         0.000         0.000         0.000
               1.000     52481.777      2800.000      3518.223      6318.223
               2.000     48787.643      2624.089      3694.134      6318.223
               3.000     44908.802      2439.382      3878.841      6318.223
               4.000     40836.019      2245.440      4072.783      6318.223
               5.000     36559.597      2041.801      4276.422      6318.223
               6.000     32069.354      1827.980      4490.243      6318.223
               7.000     27354.599      1603.468      4714.755      6318.223
               8.000     22404.106      1367.730      4950.493      6318.223
               9.000     17206.088      1120.205      5198.018      6318.223
              10.000     11748.170       860.304      5457.919      6318.223
              11.000      6017.355       587.408      5730.814      6318.223
              12.000         0.000       300.868      6017.355      6318.223

 -- Function: arit_amortization (<rate>,<increment>,<amount>,<num>)

     The amortization table determined by a specific rate and with
     growing payment can be calculated by ‘arit_amortization’.  Notice
     that the payment is not constant, it presents an arithmetic
     growing, increment is then the difference between two consecutive
     rows in the "Payment" column.  <rate> is the interest rate,
     <increment> is the increment, <amount> is the amount value, and
     <num> is the number of periods.

     Example:

          (%i1) load("finance")$
          (%i2) arit_amortization(0.05,1000,56000,12)$
                "n"    "Balance"     "Interest"   "Amortization"  "Payment"
               0.000     56000.000         0.000         0.000         0.000
               1.000     57403.679      2800.000     -1403.679      1396.321
               2.000     57877.541      2870.184      -473.863      2396.321
               3.000     57375.097      2893.877       502.444      3396.321
               4.000     55847.530      2868.755      1527.567      4396.321
               5.000     53243.586      2792.377      2603.945      5396.321
               6.000     49509.443      2662.179      3734.142      6396.321
               7.000     44588.594      2475.472      4920.849      7396.321
               8.000     38421.703      2229.430      6166.892      8396.321
               9.000     30946.466      1921.085      7475.236      9396.321
              10.000     22097.468      1547.323      8848.998     10396.321
              11.000     11806.020      1104.873     10291.448     11396.321
              12.000        -0.000       590.301     11806.020     12396.321

 -- Function: geo_amortization (<rate>,<growing_rate>,<amount>,<num>)

     The amortization table determined by rate, amount, and number of
     periods can be found by ‘geo_amortization’.  Notice that the
     payment is not constant, it presents a geometric growing,
     <growing_rate> is then the quotient between two consecutive rows in
     the "Payment" column.  <rate> is the interest rate, <amount> is the
     amount value, and <num> is the number of periods.

     Example:

          (%i1) load("finance")$
          (%i2) geo_amortization(0.05,0.03,56000,12)$
                "n"    "Balance"     "Interest"   "Amortization"  "Payment"
               0.000     56000.000         0.000         0.000         0.000
               1.000     53365.296      2800.000      2634.704      5434.704
               2.000     50435.816      2668.265      2929.480      5597.745
               3.000     47191.930      2521.791      3243.886      5765.677
               4.000     43612.879      2359.596      3579.051      5938.648
               5.000     39676.716      2180.644      3936.163      6116.807
               6.000     35360.240      1983.836      4316.475      6300.311
               7.000     30638.932      1768.012      4721.309      6489.321
               8.000     25486.878      1531.947      5152.054      6684.000
               9.000     19876.702      1274.344      5610.176      6884.520
              10.000     13779.481       993.835      6097.221      7091.056
              11.000      7164.668       688.974      6614.813      7303.787
              12.000         0.000       358.233      7164.668      7522.901

 -- Function: saving (<rate>,<amount>,<num>)

     The table that represents the values in a constant and periodic
     saving can be found by ‘saving’.  <amount> represents the desired
     quantity and num the number of periods to save.

     Example:

          (%i1) load("finance")$
          (%i2) saving(0.15,12000,15)$
                "n"    "Balance"     "Interest"   "Payment"
               0.000         0.000         0.000         0.000
               1.000       252.205         0.000       252.205
               2.000       542.240        37.831       252.205
               3.000       875.781        81.336       252.205
               4.000      1259.352       131.367       252.205
               5.000      1700.460       188.903       252.205
               6.000      2207.733       255.069       252.205
               7.000      2791.098       331.160       252.205
               8.000      3461.967       418.665       252.205
               9.000      4233.467       519.295       252.205
              10.000      5120.692       635.020       252.205
              11.000      6141.000       768.104       252.205
              12.000      7314.355       921.150       252.205
              13.000      8663.713      1097.153       252.205
              14.000     10215.474      1299.557       252.205
              15.000     12000.000      1532.321       252.205

 -- Function: npv (<rate>,<val>)

     Calculates the present value of a value series to evaluate the
     viability in a project.  <val> is a list of varying cash flows.

     Example:

          (%i1) load("finance")$
          (%i2) npv(0.25,[100,500,323,124,300]);
          (%o2)                714.4703999999999

 -- Function: irr (<val>,<IO>)

     IRR (Internal Rate of Return) is the value of rate which makes Net
     Present Value zero.  <flowValues> is a list of varying cash flows,
     <I0> is the initial investment.

     Example:

          (%i1) load("finance")$
          (%i2) res:irr([-5000,0,800,1300,1500,2000],0)$
          (%i3) rhs(res[1][1]);
          (%o3)                .03009250374237132

 -- Function: benefit_cost (<rate>,<input>,<output>)

     Calculates the ratio Benefit/Cost.  Benefit is the Net Present
     Value (NPV) of the inputs, and Cost is the Net Present Value (NPV)
     of the outputs.  Notice that if there is not an input or output
     value in a specific period, the input/output would be a zero for
     that period.  <rate> is the interest rate, <input> is a list of
     input values, and <output> is a list of output values.

     Example:

          (%i1) load("finance")$
          (%i2) benefit_cost(0.24,[0,300,500,150],[100,320,0,180]);
          (%o2)               1.427249324905784


File: maxima.info,  Node: fractals-pkg,  Next: gentran-pkg,  Prev: finance-pkg,  Up: Top

60 fractals
***********

* Menu:

* Introduction to fractals::
* Definitions for IFS fractals::
* Definitions for complex fractals::
* Definitions for Koch snowflakes::
* Definitions for Peano maps::


File: maxima.info,  Node: Introduction to fractals,  Next: Definitions for IFS fractals,  Prev: fractals-pkg,  Up: fractals-pkg

60.1 Introduction to fractals
=============================

This package defines some well known fractals:

   - with random IFS (Iterated Function System): the Sierpinsky
triangle, a Tree and a Fern

   - Complex Fractals: the Mandelbrot and Julia Sets

   - the Koch snowflake sets

   - Peano maps: the Sierpinski and Hilbert maps

   Author: José Ramírez Labrador.

   For questions, suggestions and bugs, please feel free to contact me
at

   pepe DOT ramirez AAATTT uca DOT es


File: maxima.info,  Node: Definitions for IFS fractals,  Next: Definitions for complex fractals,  Prev: Introduction to fractals,  Up: fractals-pkg

60.2 Definitions for IFS fractals
=================================

Some fractals can be generated by iterative applications of contractive
affine transformations in a random way; see

   Hoggar S. G., "Mathematics for computer graphics", Cambridge
University Press 1994.

   We define a list with several contractive affine transformations, and
we randomly select the transformation in a recursive way.  The
probability of the choice of a transformation must be related with the
contraction ratio.

   You can change the transformations and find another fractal

 -- Function: sierpinskiale (<n>)

     Sierpinski Triangle: 3 contractive maps; .5 contraction constant
     and translations; all maps have the same contraction ratio.
     Argument <n> must be great enough, 10000 or greater.

     Example:

          (%i1) load("fractals")$
          (%i2) n: 10000$
          (%i3) plot2d([discrete,sierpinskiale(n)], [style,dots])$

 -- Function: treefale (<n>)

     3 contractive maps all with the same contraction ratio.  Argument
     <n> must be great enough, 10000 or greater.

     Example:

          (%i1) load("fractals")$
          (%i2) n: 10000$
          (%i3) plot2d([discrete,treefale(n)], [style,dots])$

 -- Function: fernfale (<n>)

     4 contractive maps, the probability to choice a transformation must
     be related with the contraction ratio.  Argument <n> must be great
     enough, 10000 or greater.

     Example:

          (%i1) load("fractals")$
          (%i2) n: 10000$
          (%i3) plot2d([discrete,fernfale(n)], [style,dots])$


File: maxima.info,  Node: Definitions for complex fractals,  Next: Definitions for Koch snowflakes,  Prev: Definitions for IFS fractals,  Up: Top

60.3 Definitions for complex fractals
=====================================

 -- Function: mandelbrot_set (<x>, <y>)

     Mandelbrot set.

     Example:

     This program is time consuming because it must make a lot of
     operations; the computing time is also related with the number of
     grid points.

          (%i1) load("fractals")$
          (%i2) plot3d (mandelbrot_set, [x, -2.5, 1], [y, -1.5, 1.5],
                          [gnuplot_preamble, "set view map"],
                          [gnuplot_pm3d, true],
                          [grid, 150, 150])$

 -- Function: julia_set (<x>, <y>)

     Julia sets.

     This program is time consuming because it must make a lot of
     operations; the computing time is also related with the number of
     grid points.

     Example:

          (%i1) load("fractals")$
          (%i2) plot3d (julia_set, [x, -2, 1], [y, -1.5, 1.5],
                          [gnuplot_preamble, "set view map"],
                          [gnuplot_pm3d, true],
                          [grid, 150, 150])$

     See also ‘julia_parameter’.

 -- Optional variable: julia_parameter
     Default value: ‘%i’

     Complex parameter for Julia fractals.  Its default value is ‘%i’;
     we suggest the values ‘-.745+%i*.113002’, ‘-.39054-%i*.58679’,
     ‘-.15652+%i*1.03225’, ‘-.194+%i*.6557’ and ‘.011031-%i*.67037’.

 -- Function: julia_sin (<x>, <y>)

     While function ‘julia_set’ implements the transformation
     ‘julia_parameter+z^2’, function ‘julia_sin’ implements
     ‘julia_parameter*sin(z)’.  See source code for more details.

     This program runs slowly because it calculates a lot of sines.

     Example:

     This program is time consuming because it must make a lot of
     operations; the computing time is also related with the number of
     grid points.

          (%i1) load("fractals")$
          (%i2) julia_parameter:1+.1*%i$
          (%i3) plot3d (julia_sin, [x, -2, 2], [y, -3, 3],
                          [gnuplot_preamble, "set view map"],
                          [gnuplot_pm3d, true],
                          [grid, 150, 150])$

     See also ‘julia_parameter’.


File: maxima.info,  Node: Definitions for Koch snowflakes,  Next: Definitions for Peano maps,  Prev: Definitions for complex fractals,  Up: Top

60.4 Definitions for Koch snowflakes
====================================

 -- Function: snowmap (<ent>, <nn>)

     Koch snowflake sets.  Function ‘snowmap’ plots the snow Koch map
     over the vertex of an initial closed polygonal, in the complex
     plane.  Here the orientation of the polygon is important.  Argument
     <nn> is the number of recursive applications of Koch
     transformation; <nn> must be small (5 or 6).

     Examples:

          (%i1) load("fractals")$
          (%i2) plot2d([discrete,
                        snowmap([1,exp(%i*%pi*2/3),exp(-%i*%pi*2/3),1],4)])$
          (%i3) plot2d([discrete,
                        snowmap([1,exp(-%i*%pi*2/3),exp(%i*%pi*2/3),1],4)])$
          (%i4) plot2d([discrete, snowmap([0,1,1+%i,%i,0],4)])$
          (%i5) plot2d([discrete, snowmap([0,%i,1+%i,1,0],4)])$


File: maxima.info,  Node: Definitions for Peano maps,  Prev: Definitions for Koch snowflakes,  Up: fractals-pkg

60.5 Definitions for Peano maps
===============================

Continuous curves that cover an area.  Warning: the number of points
exponentially grows with <n>.

 -- Function: hilbertmap (<nn>)

     Hilbert map.  Argument <nn> must be small (5, for example).  Maxima
     can crash if <nn> is 7 or greater.

     Example:

          (%i1) load("fractals")$
          (%i2) plot2d([discrete,hilbertmap(6)])$

 -- Function: sierpinskimap (<nn>)

     Sierpinski map.  Argument <nn> must be small (5, for example).
     Maxima can crash if <nn> is 7 or greater.

     Example:

          (%i1) load("fractals")$
          (%i2) plot2d([discrete,sierpinskimap(6)])$


File: maxima.info,  Node: gentran-pkg,  Next: ggf-pkg,  Prev: fractals-pkg,  Up: Top

61 Gentran
**********

* Menu:

* Introduction to Gentran::
* Functions for Gentran::
* Gentran Mode Switches::
* Gentran Option Variables::
* Gentran Evaluation Forms::


File: maxima.info,  Node: Introduction to Gentran,  Next: Functions for Gentran,  Prev: gentran-pkg

61.1 Introduction to Gentran
============================

Original Authors Barbara Gates and Paul Wang

   Gentran is a powerful generator of foreign language code.  Currently
it can generate FORTRAN, ’C’, and RATFOR code from Maxima language code.
Gentran can translate mathematical expressions, iteration loops,
conditional branching statements, data type information, function
definitions, matrtices and arrays, and more.


File: maxima.info,  Node: Functions for Gentran,  Next: Gentran Mode Switches,  Prev: Introduction to Gentran,  Up: gentran-pkg

61.2 Functions for Gentran
==========================

 -- Function: gentran (<stmt1>, <stmt2>, ... , <stmtn> , <[f1, f2, ... ,
          fm]>)
     Translates each stmt into formatted code in the target language.  A
     substantial subset of expressions and statements in the Maxima
     programming language can be translated directly into numerical
     code.  The *gentran* command translates Maxima statements or
     procedure definitions into code in the target language
     (*gentranlang:* fortran, c, or ratfor).  Expressions may optionally
     be given to Maxima for evaluation prior to translation.

     _stmt1, stmt2, ...  , stmtn_ is a sequence of one or more
     statements, each of which is any Maxima user level expression,
     (simple, group, or block) statement, or procedure definition that
     can be translated into the target language.

     _[f1, f2, ...  , fm]_ is an optional list of output files to which
     translated output will be written.  They can be any of the
     following:

     _*string*_ = the name of an output file in quotes

     *true* (no quotes) = the terminal

     *false* = the current output file(s)

     *all* = all files currently open for output by gentran

     If the files are not open they will be opened; if they are open,
     output will be appended to them.  Filenames are given as quoted
     strings.  If the optional variable *genoutpath* (string, including
     the final /) default *false* is set, it will be prepended to the
     output file names.  If the output file list is omitted, output will
     be written to the current output, generally the terminal.
     *gentran* returns (a list of) the name(s) of file(s) to which code
     was written.

 -- Function: gentranout (<f1>, <f2>, ... , <fn>)

     Gentran maintains a list of files currently open for output by
     gentran commands only.  gentranout inserts each file name
     represented by _f1, f2,...  , fn_ into that list and opens each one
     for output.  It also resets the current output file(s) to include
     all files in _f1, f2, ...  , fn_.  gentranout returns the list of
     files represented by _f1, f2, ...  , fn_; i.e., the current output
     file(s) after the command has been executed.

 -- Function: gentranshut (<f1>, <f2>, ... , <fn>)

     gentranshut creates a list of file names from _f1, f2, ...  , fn_,
     deletes each from the output file list, and closes the
     corresponding files.  If (all of) the current output file(s) are
     closed, then the current output file is reset to the terminal.
     gentranshut returns (a list of) the current output file(s) after
     the command has been executed.  *gentranshut*(*all*) will close all
     gentran output files.

 -- Function: gentranpush (<f1>, <f2>, ... , <fn>)

     gentranpush pushes the file list onto the output stack.  Each file
     in the list that is not already open for output is opened at this
     time.  The current output file is reset to this new element on the
     top of the stack.

 -- Function: gentranpop (<f1>, <f2>, ... , <fn>)

     gentranpop deletes the top-most occurrence of the single element
     containing the file name(s) represented by _f1, f2, ...  , fn_ from
     the output stack.  Files whose names have been completely removed
     from the output stack are closed.  The current output file is reset
     to the (new) element on the top of the output stack.  gentranpop
     returns the current output file(s) after this command has been
     executed.

 -- Function: gentranin (<f1>, <f2>, ... , <fn>, [<f1>,<f2>, ... ,
          <fm>])

     gentranin processes mixed-language template files consisting of
     active parts (delimited by <<...>>) containing Maxima statements,
     including calls to gentran, and passive parts, assumed to contain
     statements in the target language (including comments), which are
     transcribed verbatim.  Input files are processed sequentially and
     the results appended to the output.  The presence of >> in passive
     parts of the file (except for in comments) is interpreted as an
     end-of-file and terminates processing of that file.  The optional
     list of output files _[f1,f2, ...  , fm]_ each receive a copy of
     the entire output.  All filespecs are quoted strings.  Input files
     may be given as (quoted string) filenames, which will be located by
     Maxima *file_search*.  The optional variable *geninpath* (default
     *false* ) must be a _list_ of quoted strings describing the paths
     to be searched for the input files.  If it is set, that list
     replaces the standard Maxima search paths.

     Active parts may contain any number of Maxima expressions and
     statements.  They are not copied directly to the output.  Instead,
     they are given to Maxima for evaluation.  All output generated by
     each evaluation is sent to the output file(s).  Returned values are
     only printed on the terminal.  Active parts will most likely
     contain calls to gentran to generate code.  This means that the
     result of processing a template file will be the original template
     file with all active parts replaced by generated code.  If _[f1,
     f2, ...  , fm]_ is not supplied, then generated code is simply
     written to the current output file(s).  However, if it is given,
     then the current output file is temporarily overridden.  Generated
     code is written to each file represented by _f1, f2, ...  , fn_ for
     this command only.  Files which were open prior to the call to
     gentranin will remain open after the call, and files which did not
     exist prior to the call will be created, opened, written to, and
     closed.  The output file stack will be exactly the same both before
     and after the call.  gentranin returns (to the terminal) the
     name(s) of (all) file(s) written to by this command.

 -- Function: gentraninshut ()

     A cleanup function to close input files in case where gentranin
     hung due to error in template.

 -- Function: tempvar (<type>)

     Generates temporary variable names by concatenating *tempvarname*
     (default *’t*) with sequence numbers.  If _type_ is non-false,
     _e.g._  "real*8" the corresponding type is assigned to the variable
     in the gentran symbol table, which may be used to generate
     declarations depending on the setting of the *gendecs* flag.  It is
     the users responsibility to make sure temporary variable names do
     not conflict with the main program.

 -- Function: markvar (<vname>)

     markvar "marks" variable name _vname_ to indicate that it currently
     holds a significant value.

 -- Function: unmarkvar (<vname>)

     unmarkvar "unmarks" variable name _vname_ to indicate that it no
     longer holds a significant value.

 -- Function: markedvarp (<vname>)

     markedvarp tests whether the variable name _vname_ is currently
     marked.

 -- Function: gendecs (<name>)

     The gendecs command can be called any time the gendecs flag is
     switched off to retrieve all type declarations from Gentran’s
     symbol table for the given subprogram name (or the "current"
     subprogram if false is given as its argument).

 -- Function: gentran_on (<sw>)

     Turns on the mode switch _sw_.

 -- Function: gentran_off (<sw>)

     Turns the given switch, _sw_, off.


File: maxima.info,  Node: Gentran Mode Switches,  Next: Gentran Option Variables,  Prev: Functions for Gentran,  Up: gentran-pkg

61.3 Gentran Mode Switches
==========================

 -- Option variable: fortran
 -- Option variable: ratfor
 -- Option variable: c
     Default: off

     These mode switches change the default mode of Maxima from
     evaluation to translation.  They can be turned on and off with the
     gentran commands gentran_on and gentran_off.  Each time a new
     Maxima session is started up, the system is in evaluation mode.  It
     prints a prompt on the user’s terminal screen and waits for an
     expression or statement to be entered.  It then proceeds to
     evaluate the expression, prints a new prompt, and waits for the
     user to enter another expression or statement.  This mode can be
     changed to translation mode by turning on either the fortran,
     ratfor or c switches.  After one of these switches is turned on and
     until it is turned off, every expression or statement entered by
     the user is translated into the corresponding language just as if
     it had been given as an argument to the gentran command.  Each of
     the special functions that can be used from within a call to
     gentran can be used at the top level until the switch is turned
     off.

 -- Option variable: gendecs
     Default: on

     When the gendecs switch is turned on, gentran generates type
     declarations whenever possible.  When gendecs is switched off, type
     declarations are not generated.  Instead, type information is
     stored in gentran’s symbol table but is not retrieved in the form
     of declarations unless and until either the gendecs command is
     called or the gendecs flag is switched back.  *Note*: Generated
     declarations may often be placed in an inappropriate place (_e.g._
     in the middle of executable fortran code).  Therefore the gendecs
     flag is turned off during processing of templates by *gentranin*.


File: maxima.info,  Node: Gentran Option Variables,  Next: Gentran Evaluation Forms,  Prev: Gentran Mode Switches,  Up: gentran-pkg

61.4 Gentran Option Variables
=============================

 -- Option variable: gentranlang
     Default: fortran

     Selects the target numerical language.  Currently, gentranlang must
     be fortran, ratfor, or c.  Note that symbols entered in Maxima are
     case-sensitive.  gentranlang should not be set to FORTRAN, RATFOR
     or C.

 -- Option variable: fortlinelen
     default: 72

     Maximum number of characters printed on each line of generated
     FORTRAN code.

 -- Option variable: minfortlinelen
     Default: 40

     Minimum number of characters printed on each line of generated
     FORTRAN code.

 -- Option variable: fortcurrind
     Default: 0

     Number of blank spaces printed at the beginning of each line of
     generated FORTRAN code (after column 6).

 -- Option variable: ratlinelen
     Default: 80

     Maximum number of characters printed on each line of generated
     Ratfor code.

 -- Option variable: clinelen
     Default: 80

     Maximum number of characters printed on each line of generated ’C’
     code.

 -- Option variable: minclinelen
     Default: 40

     Minimum number of characters printed on each line of generated ’C’
     code.

 -- Option variable: ccurind
     Default: 0

     Number of blank spaces printed at the beginning of each line of
     generated’C’ code.

 -- Option variable: tablen
     Default: 4

     Number of blank spaces printed for each new level of indentation.
     (Automatic indentation can be turned off by setting this variable
     to 0.)

 -- Option variable: genfloat
     Default: false

     When set to true (or any non-false value), causes integers in
     generated numerical code to be converted to floating point numbers,
     except in the following places: array subscripts, exponents, and
     initial, final, and step values in do-loops.  An exception (for
     compatibility with Macsyma 2.4) is that numbers in exponentials
     (with base %e only) are double-floated even when genfloat is false.

 -- Option variable: dblfloat
     Default: *false* If dblfloat is set to true, floating point numbers
     in gentran output in implementations (such as Windows Maxima under
     CLISP) in which float and double-float are the same will be printed
     as *.d0.  In implementations in which float and double-float are
     different, floats will be coerced to double-float before being
     printed.

 -- Option variable: gentranseg
     Default: *true*

 -- Option variable: maxexpprintlen
     Default: 800

     When *gentranseg* is true (or any non-false value), causes Gentran
     to "segment" large expressions into subexpressions of manageable
     size.  The segmentation facility generates a sequence of assignment
     statements, each of which assigns a subexpression to an
     automatically generated temporary variable name.  This sequence is
     generated in such a way that temporary variables are re-used as
     soon as possible, thereby keeping the number of automatically
     generated variables to a minimum.  The maximum allowable expression
     size can be controlled by setting the *maxexpprintlen* variable to
     the maximum number of characters allowed in an expression printed
     in the target numerical language (excluding spaces and other
     whitespace characters automatically printed by the formatter).
     When the segmentation routine generates temporary variables, it
     places type declarations in the symbol table for those variables if
     possible.  It uses the following rules to determine their type:

     1.  If the type of the variable to which the large expression is
     being assigned is already known (i.e., has been declared by the
     user via a TYPE form), then the temporary variables will be
     declared to be of that same type.  2.  If the global variable
     *tempvartype* has a non-false value, then the temporary variables
     are declared to be of that type.  3.  Otherwise, the variables are
     not declared unless *implicit* has been set to *true*.

 -- Option variable: gentranopt
     Default: *false*

     When set to true (or any non-false value), causes Gentran to
     replace each block of straightline code by an optimized sequence of
     assignments obtained from the Maxima optimize command.  (The
     optimize command takes an expression and replaces common
     subexpressions by temporary variable names.  It returns the
     resulting assignment statement, preceded by
     common-subexpression-to-temporary-variable assignments.

 -- Option variable: tempvarname
     Default: *’t*

     Name used as the prefix when generating temporary variable names.

 -- Option variable: optimvarname
     default: *’u*

     is the preface used to generate temporary file names produced by
     the optimizer when *gentranopt* is *true*.  When both gentranseg
     and gentranopt are true, the optimizer generates temporary file
     names using *optimvarname* while the segmentation routine uses
     *tempvarname* preventing conflict.

 -- Option variable: tempvarnum
     Default: 0

     Number appended onto tempvarname to create a temporary variable
     name.  If the temporary variable name resulting from appending
     tempvarnum onto the end of tempvarname has already been generated
     and still holds a useful value or has a different type than
     requested, then the number is incremented until one is found that
     was not previously generated or does not still hold a significant
     value or a different type.

 -- Option variable: tempvartype
     Default: *false*

     Target language variable type (e.g., INTEGER, REAL*8, FLOAT, etc.)
     used as a default for automatically generated variables whose type
     cannot be determined otherwise.  If tempvartype is false, then
     generated temporary variables whose type cannot be determined are
     not automatically declared.

 -- Option variable: implicit
     Default: *false*

     If implicit is set to *true* temporary variables are assigned their
     implicit type according to Fortran rules based on the initial
     letter of the name.  If gendecs is on, this results in printed type
     declarations.

 -- Option variable: gentranparser
     Default: *false*

     If gentranparser is set to *true* Maxima forms input to gentran
     will be parsed and an error will be produced if an expression
     cannot be translated.  Otherwise, untranslatable expressions may
     generate anomalous output, sometimes containing explicit calls to
     Maxima functions.

 -- Option variable: genstmtno
     Default: 25000

     Number used when a statement number must be generated.  Note: it is
     the user’s responsibility to make sure this number will not clash
     with statement numbers in template files.

 -- Option variable: genstmtincr
     Default: 1

     number by which genstmtno is incremented each time a new statement
     number is generated.

 -- Option variable: usefortcomplex
     Default: *false*

     If usefortcomplex is true, real numbers in expressions declared to
     be complex by _type(complex,...)_ will be printed in Fortran
     complex number format _(realpart,0.0)_.  This is a purely syntactic
     device and does not carry out any complex calculations.


File: maxima.info,  Node: Gentran Evaluation Forms,  Prev: Gentran Option Variables,  Up: gentran-pkg

61.5 Gentran Evaluation Forms
=============================

The following special functions can be included in Maxima statements
which are to be translated by the gentran command to indicate that they
are to be partially or fully evaluated by Maxima before being translated
into numerical code.  Note that these functions have the described
effect only when supplied in arguments to the gentran command.

 -- Function: eval (<exp>)

     Where _exp_ is any Maxima expression or statement which, after
     evaluation by Maxima, results in an expression that can be
     translated by gentran into the target language.  When eval is
     called from an argument that is to be translated, it tells gentran
     to give the expression to Maxima for evaluation first, and then to
     translate the result of that evaluation.

 -- Function: rsetq (<var>, <exp>)

     Where _var_ is any Maxima variable, matrix or array element, and
     _exp_ is any Maxima expression which, after evaluation by Maxima
     results in an expression that can be translated by Gentran into the
     target language.  This is equivalent to VAR : EVAL(EXP) ;

 -- Function: lsetq (_var_, _exp_)

     Where _var_ is any Maxima user level matrix or array element with
     indices which, after evaluation by Maxima, will result in
     expressions that can be translated by Gentran, and _exp_ is any
     Maxima user level expression that can be translated into the target
     language.  This is equivalent to ‘var[eval(s1), eval(s2), ...]:
     exp’ where <s1>, <s2>, ...  are indices.

 -- Function: lrsetq (_var_, _exp_)

     Where _var_ is any Maxima matrix or array element with indices
     which, after evaluation by Maxima, will result in expressions that
     can be translated by Gentran; and _exp_ is any user level
     expression which, after evaluation, will result in an expression
     that can be translated by Gentran into the target language.  This
     is equivalent to ‘var[eval(s1), eval(s2), ...]: eval(exp);’.

 -- Function: type (_type,v1...vn_)

     Places information in the gentran symbol table to assign _type_ to
     variables _v1...vn_.  This may result in type declarations printed
     by gentran depending on the setting of gendecs.  *type* must be
     called from within gentran and does not evaluate its arguments
     unless *eval*() is used.

 -- Function: literal (_arg1, arg2, ... , argn_)

     where arg1, arg2, ...  , argn is an argument list containing one or
     more arg’s, each of which either is, or evaluates to, an atom.  The
     atoms _tab_ and _cr_ have special meanings.  arg’s are not
     evaluated unless given as arguments to eval.  This function call is
     replaced by the character sequence resulting from concatenation of
     the given atoms.  Double quotes are stripped from all string type
     arg’s, and each occurrence of the reserved atom _tab_ or _cr_ is
     replaced by a tab to the current level of indentation, or an
     end-of-line character.


File: maxima.info,  Node: ggf-pkg,  Next: graphs-pkg,  Prev: gentran-pkg,  Up: Top

62 ggf
******

* Menu:

* Functions and Variables for ggf::


File: maxima.info,  Node: Functions and Variables for ggf,  Prev: ggf-pkg,  Up: ggf-pkg

62.1 Functions and Variables for ggf
====================================

 -- Option variable: GGFINFINITY
     Default value: 3

     This is an option variable for function ‘ggf’.

     When computing the continued fraction of the generating function, a
     partial quotient having a degree (strictly) greater than
     <GGFINFINITY> will be discarded and the current convergent will be
     considered as the exact value of the generating function; most
     often the degree of all partial quotients will be 0 or 1; if you
     use a greater value, then you should give enough terms in order to
     make the computation accurate enough.

     See also ‘ggf’.

 -- Option variable: GGFCFMAX
     Default value: 3

     This is an option variable for function ‘ggf’.

     When computing the continued fraction of the generating function,
     if no good result has been found (see the <GGFINFINITY> flag) after
     having computed <GGFCFMAX> partial quotients, the generating
     function will be considered as not being a fraction of two
     polynomials and the function will exit.  Put freely a greater value
     for more complicated generating functions.

     See also ‘ggf’.

 -- Function: ggf (<l>)
     Compute the generating function (if it is a fraction of two
     polynomials) of a sequence, its first terms being given.  <l> is a
     list of numbers.

     The solution is returned as a fraction of two polynomials.  If no
     solution has been found, it returns with ‘done’.

     This function is controlled by global variables <GGFINFINITY> and
     <GGFCFMAX>.  See also <GGFINFINITY> and <GGFCFMAX>.

     To use this function write first ‘load("ggf")’.

          (%i1) load("ggf")$
          (%i2) makelist(fib(n),n,0,10);
          (%o2)                [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
          (%i3) ggf(%);
                                                 x
          (%o3)                            - ----------
                                              2
                                             x  + x - 1
          (%i4) taylor(%,x,0,10);
                        2      3      4      5      6       7       8       9       10
          (%o4)/T/ x + x  + 2 x  + 3 x  + 5 x  + 8 x  + 13 x  + 21 x  + 34 x  + 55 x
                                                                                  + . . .
          (%i5) makelist(2*fib(n+1)-fib(n),n,0,10);
          (%o5)              [2, 1, 3, 4, 7, 11, 18, 29, 47, 76, 123]
          (%i6) ggf(%);
                                              x - 2
          (%o6)                             ----------
                                             2
                                            x  + x - 1
          (%i7) taylor(%,x,0,10);
                              2      3      4       5       6       7       8       9
          (%o7)/T/ 2 + x + 3 x  + 4 x  + 7 x  + 11 x  + 18 x  + 29 x  + 47 x  + 76 x
                                                                               10
                                                                        + 123 x   + . . .

     As these examples show, the generating function does create a
     function whose Taylor series has coefficients that are the elements
     of the original list.


File: maxima.info,  Node: graphs-pkg,  Next: grobner-pkg,  Prev: ggf-pkg,  Up: Top

63 graphs
*********

* Menu:

* Introduction to graphs::
* Functions and Variables for graphs::


File: maxima.info,  Node: Introduction to graphs,  Next: Functions and Variables for graphs,  Prev: graphs-pkg,  Up: graphs-pkg

63.1 Introduction to graphs
===========================

The ‘graphs’ package provides graph and digraph data structure for
Maxima.  Graphs and digraphs are simple (have no multiple edges nor
loops), although digraphs can have a directed edge from <u> to <v> and a
directed edge from <v> to <u>.

   Internally graphs are represented by adjacency lists and implemented
as a lisp structures.  Vertices are identified by their ids (an id is an
integer).  Edges/arcs are represented by lists of length 2.  Labels can
be assigned to vertices of graphs/digraphs and weights can be assigned
to edges/arcs of graphs/digraphs.

   There is a ‘draw_graph’ function for drawing graphs.  Graphs are
drawn using a force based vertex positioning algorithm.  ‘draw_graph’
can also use graphviz programs available from
<https://www.graphviz.org>.  ‘draw_graph’ is based on the maxima ‘draw’
package.

   To use the ‘graphs’ package, first load it with ‘load("graphs")’.


File: maxima.info,  Node: Functions and Variables for graphs,  Prev: Introduction to graphs,  Up: graphs-pkg

63.2 Functions and Variables for graphs
=======================================

63.2.1 Building graphs
----------------------

 -- Function: create_graph
          create_graph (<v_list>, <e_list>)
          create_graph (<n>, <e_list>)
          create_graph (<v_list>, <e_list>, <directed>)

     Creates a new graph on the set of vertices <v_list> and with edges
     <e_list>.

     <v_list> is a list of vertices ‘[v1, v2, ..., vn]’ or a list of
     vertices together with vertex labels ‘[[v1, l1], [v2 ,l2], ...,
     [vn, ln]]’.  A vertex may be any integer, and <v_list> may contain
     vertices in any order.  A label may be any Maxima expression, and
     two or more vertices may have the same label.

     <n> is the number of vertices.  Vertices will be identified by
     integers from 0 to n-1.

     <e_list> is a list of edges ‘[e1, e2,..., em]’ or a list of edges
     together with edge-weights ‘[[e1, w1], ..., [em, wm]]’.

     If <directed> is not ‘false’, a directed graph will be returned.

     Example 1: create a cycle on 3 vertices:
          (%i1) load ("graphs")$
          (%i2) g : create_graph([1,2,3], [[1,2], [2,3], [1,3]])$
          (%i3) print_graph(g)$
          Graph on 3 vertices with 3 edges.
          Adjacencies:
            3 :  1  2
            2 :  3  1
            1 :  3  2

     Example 2: create a cycle on 3 vertices with edge weights:
          (%i1) load ("graphs")$
          (%i2) g : create_graph([1,2,3], [[[1,2], 1.0], [[2,3], 2.0],
                                    [[1,3], 3.0]])$
          (%i3) print_graph(g)$
          Graph on 3 vertices with 3 edges.
          Adjacencies:
            3 :  1  2
            2 :  3  1
            1 :  3  2

     Example 3: create a directed graph:
          (%i1) load ("graphs")$
          (%i2) d : create_graph(
                  [1,2,3,4],
                  [
                   [1,3], [1,4],
                   [2,3], [2,4]
                  ],
                  'directed = true)$
          (%i3) print_graph(d)$
          Digraph on 4 vertices with 4 arcs.
          Adjacencies:
            4 :
            3 :
            2 :  4  3
            1 :  4  3

 -- Function: copy_graph (<g>)
     Returns a copy of the graph <g>.

 -- Function: circulant_graph (<n>, <d>)
     Returns the circulant graph with parameters <n> and <d>.

     Example:
          (%i1) load ("graphs")$
          (%i2) g : circulant_graph(10, [1,3])$
          (%i3) print_graph(g)$
          Graph on 10 vertices with 20 edges.
          Adjacencies:
            9 :  2  6  0  8
            8 :  1  5  9  7
            7 :  0  4  8  6
            6 :  9  3  7  5
            5 :  8  2  6  4
            4 :  7  1  5  3
            3 :  6  0  4  2
            2 :  9  5  3  1
            1 :  8  4  2  0
            0 :  7  3  9  1

 -- Function: clebsch_graph ()
     Returns the Clebsch graph.

 -- Function: complement_graph (<g>)
     Returns the complement of the graph <g>.

 -- Function: complete_bipartite_graph (<n>, <m>)
     Returns the complete bipartite graph on <n+m> vertices.

 -- Function: complete_graph (<n>)
     Returns the complete graph on <n> vertices.

 -- Function: cycle_digraph (<n>)
     Returns the directed cycle on <n> vertices.

 -- Function: cycle_graph (<n>)
     Returns the cycle on <n> vertices.

 -- Function: cuboctahedron_graph (<n>)
     Returns the cuboctahedron graph.

 -- Function: cube_graph (<n>)
     Returns the <n>-dimensional cube.

 -- Function: dodecahedron_graph ()
     Returns the dodecahedron graph.

 -- Function: empty_graph (<n>)
     Returns the empty graph on <n> vertices.

 -- Function: flower_snark (<n>)
     Returns the flower graph on <4n> vertices.

     Example:
          (%i1) load ("graphs")$
          (%i2) f5 : flower_snark(5)$
          (%i3) chromatic_index(f5);
          (%o3)                           4

 -- Function: from_adjacency_matrix (<A>)
     Returns the graph represented by its adjacency matrix <A>.

 -- Function: frucht_graph ()
     Returns the Frucht graph.

 -- Function: graph_product (<g1>, <g1>)
     Returns the direct product of graphs <g1> and <g2>.

     Example:
          (%i1) load ("graphs")$
          (%i2) grid : graph_product(path_graph(3), path_graph(4))$
          (%i3) draw_graph(grid)$

 -- Function: graph_union (<g1>, <g1>)
     Returns the union (sum) of graphs <g1> and <g2>.

 -- Function: grid_graph (<n>, <m>)
     Returns the <n x m> grid.

 -- Function: great_rhombicosidodecahedron_graph ()
     Returns the great rhombicosidodecahedron graph.

 -- Function: great_rhombicuboctahedron_graph ()
     Returns the great rhombicuboctahedron graph.

 -- Function: grotzch_graph ()
     Returns the Grotzch graph.

 -- Function: heawood_graph ()
     Returns the Heawood graph.

 -- Function: icosahedron_graph ()
     Returns the icosahedron graph.

 -- Function: icosidodecahedron_graph ()
     Returns the icosidodecahedron graph.

 -- Function: induced_subgraph (<V>, <g>)
     Returns the graph induced on the subset <V> of vertices of the
     graph <g>.

     Example:
          (%i1) load ("graphs")$
          (%i2) p : petersen_graph()$
          (%i3) V : [0,1,2,3,4]$
          (%i4) g : induced_subgraph(V, p)$
          (%i5) print_graph(g)$
          Graph on 5 vertices with 5 edges.
          Adjacencies:
            4 :  3  0
            3 :  2  4
            2 :  1  3
            1 :  0  2
            0 :  1  4

 -- Function: line_graph (<g>)
     Returns the line graph of the graph <g>.

 -- Function: make_graph
          make_graph (<vrt>, <f>)
          make_graph (<vrt>, <f>, <oriented>)

     Creates a graph using a predicate function <f>.

     <vrt> is a list or set of vertices, or an integer.

     When <vrt> is a list or set, its elements may be any integers, and,
     if a list, may be listed in any order.

     When <vrt> is an integer, vertices of the graph will be integers
     from 1 to <vrt>.

     <f> is a predicate function.  Two vertices <a> and <b> will be
     connected if ‘f(a,b)=true’.

     If <directed> is not <false>, then the graph will be directed.

     Example 1:
          (%i1) load("graphs")$
          (%i2) g : make_graph(powerset({1,2,3,4,5}, 2), disjointp)$
          (%i3) is_isomorphic(g, petersen_graph());
          (%o3)                         true
          (%i4) get_vertex_label(1, g);
          (%o4)                        {1, 2}

     Example 2:
          (%i1) load("graphs")$
          (%i2) f(i, j) := is (mod(j, i)=0)$
          (%i3) g : make_graph(20, f, directed=true)$
          (%i4) out_neighbors(4, g);
          (%o4)                    [8, 12, 16, 20]
          (%i5) in_neighbors(18, g);
          (%o5)                    [1, 2, 3, 6, 9]

 -- Function: mycielski_graph (<g>)
     Returns the mycielskian graph of the graph <g>.

 -- Function: new_graph ()
     Returns the graph with no vertices and no edges.

 -- Function: path_digraph (<n>)
     Returns the directed path on <n> vertices.

 -- Function: path_graph (<n>)
     Returns the path on <n> vertices.

 -- Function: petersen_graph
          petersen_graph ()
          petersen_graph (<n>, <d>)

     Returns the petersen graph <P_{n,d}>.  The default values for <n>
     and <d> are ‘n=5’ and ‘d=2’.

 -- Function: random_bipartite_graph (<a>, <b>, <p>)
     Returns a random bipartite graph on ‘a+b’ vertices.  Each edge is
     present with probability <p>.

 -- Function: random_digraph (<n>, <p>)
     Returns a random directed graph on <n> vertices.  Each arc is
     present with probability <p>.

 -- Function: random_regular_graph
          random_regular_graph (<n>)
          random_regular_graph (<n>, <d>)

     Returns a random <d>-regular graph on <n> vertices.  The default
     value for <d> is ‘d=3’.

 -- Function: random_graph (<n>, <p>)
     Returns a random graph on <n> vertices.  Each edge is present with
     probability <p>.

 -- Function: random_graph1 (<n>, <m>)
     Returns a random graph on <n> vertices and random <m> edges.

 -- Function: random_network (<n>, <p>, <w>)
     Returns a random network on <n> vertices.  Each arc is present with
     probability <p> and has a weight in the range ‘[0,w]’.  The
     function returns a list ‘[network, source, sink]’.

     Example:
          (%i1) load ("graphs")$
          (%i2) [net, s, t] : random_network(50, 0.2, 10.0);
          (%o2)                   [DIGRAPH, 50, 51]
          (%i3) max_flow(net, s, t)$
          (%i4) first(%);
          (%o4)                   27.65981397932507

 -- Function: random_tournament (<n>)
     Returns a random tournament on <n> vertices.

 -- Function: random_tree (<n>)
     Returns a random tree on <n> vertices.

 -- Function: small_rhombicosidodecahedron_graph ()
     Returns the small rhombicosidodecahedron graph.

 -- Function: small_rhombicuboctahedron_graph ()
     Returns the small rhombicuboctahedron graph.

 -- Function: snub_cube_graph ()
     Returns the snub cube graph.

 -- Function: snub_dodecahedron_graph ()
     Returns the snub dodecahedron graph.

 -- Function: truncated_cube_graph ()
     Returns the truncated cube graph.

 -- Function: truncated_dodecahedron_graph ()
     Returns the truncated dodecahedron graph.

 -- Function: truncated_icosahedron_graph ()
     Returns the truncated icosahedron graph.

 -- Function: truncated_tetrahedron_graph ()
     Returns the truncated tetrahedron graph.

 -- Function: tutte_graph ()
     Returns the Tutte graph.

 -- Function: underlying_graph (<g>)
     Returns the underlying graph of the directed graph <g>.

 -- Function: wheel_graph (<n>)
     Returns the wheel graph on <n+1> vertices.

63.2.2 Graph properties
-----------------------

 -- Function: adjacency_matrix (<gr>)
     Returns the adjacency matrix of the graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) c5 : cycle_graph(4)$
          (%i3) adjacency_matrix(c5);
                                   [ 0  1  0  1 ]
                                   [            ]
                                   [ 1  0  1  0 ]
          (%o3)                    [            ]
                                   [ 0  1  0  1 ]
                                   [            ]
                                   [ 1  0  1  0 ]

 -- Function: average_degree (<gr>)
     Returns the average degree of vertices in the graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) average_degree(grotzch_graph());
                                         40
          (%o2)                          --
                                         11

 -- Function: biconnected_components (<gr>)
     Returns the (vertex sets of) 2-connected components of the graph
     <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) g : create_graph(
                      [1,2,3,4,5,6,7],
                      [
                       [1,2],[2,3],[2,4],[3,4],
                       [4,5],[5,6],[4,6],[6,7]
                      ])$
          (%i3) biconnected_components(g);
          (%o3)        [[6, 7], [4, 5, 6], [1, 2], [2, 3, 4]]

 -- Function: bipartition (<gr>)
     Returns a bipartition of the vertices of the graph <gr> or an empty
     list if <gr> is not bipartite.

     Example:

          (%i1) load ("graphs")$
          (%i2) h : heawood_graph()$
          (%i3) [A,B]:bipartition(h);
          (%o3)  [[8, 12, 6, 10, 0, 2, 4], [13, 5, 11, 7, 9, 1, 3]]
          (%i4) draw_graph(h, show_vertices=A, program=circular)$

 -- Function: chromatic_index (<gr>)
     Returns the chromatic index of the graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) p : petersen_graph()$
          (%i3) chromatic_index(p);
          (%o3)                           4

 -- Function: chromatic_number (<gr>)
     Returns the chromatic number of the graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) chromatic_number(cycle_graph(5));
          (%o2)                           3
          (%i3) chromatic_number(cycle_graph(6));
          (%o3)                           2

 -- Function: clear_edge_weight (<e>, <gr>)
     Removes the weight of the edge <e> in the graph <gr>.

     Example:

          (%i1) load ("graphs")$
          (%i2) g : create_graph(3, [[[0,1], 1.5], [[1,2], 1.3]])$
          (%i3) get_edge_weight([0,1], g);
          (%o3)                          1.5
          (%i4) clear_edge_weight([0,1], g)$
          (%i5) get_edge_weight([0,1], g);
          (%o5)                           1

 -- Function: clear_vertex_label (<v>, <gr>)
     Removes the label of the vertex <v> in the graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) g : create_graph([[0,"Zero"], [1, "One"]], [[0,1]])$
          (%i3) get_vertex_label(0, g);
          (%o3)                         Zero
          (%i4) clear_vertex_label(0, g);
          (%o4)                         done
          (%i5) get_vertex_label(0, g);
          (%o5)                         false

 -- Function: connected_components (<gr>)
     Returns the (vertex sets of) connected components of the graph
     <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) g: graph_union(cycle_graph(5), path_graph(4))$
          (%i3) connected_components(g);
          (%o3)            [[1, 2, 3, 4, 0], [8, 7, 6, 5]]

 -- Function: diameter (<gr>)
     Returns the diameter of the graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) diameter(dodecahedron_graph());
          (%o2)                           5

 -- Function: edge_coloring (<gr>)
     Returns an optimal coloring of the edges of the graph <gr>.

     The function returns the chromatic index and a list representing
     the coloring of the edges of <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) p : petersen_graph()$
          (%i3) [ch_index, col] : edge_coloring(p);
          (%o3) [4, [[[0, 5], 3], [[5, 7], 1], [[0, 1], 1], [[1, 6], 2],
          [[6, 8], 1], [[1, 2], 3], [[2, 7], 4], [[7, 9], 2], [[2, 3], 2],
          [[3, 8], 3], [[5, 8], 2], [[3, 4], 1], [[4, 9], 4], [[6, 9], 3],
          [[0, 4], 2]]]
          (%i4) assoc([0,1], col);
          (%o4)                           1
          (%i5) assoc([0,5], col);
          (%o5)                           3

 -- Function: degree_sequence (<gr>)
     Returns the list of vertex degrees of the graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) degree_sequence(random_graph(10, 0.4));
          (%o2)            [2, 2, 2, 2, 2, 2, 3, 3, 3, 3]

 -- Function: edge_connectivity (<gr>)
     Returns the edge-connectivity of the graph <gr>.

     See also ‘min_edge_cut’.

 -- Function: edges (<gr>)
     Returns the list of edges (arcs) in a (directed) graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) edges(complete_graph(4));
          (%o2)   [[2, 3], [1, 3], [1, 2], [0, 3], [0, 2], [0, 1]]

 -- Function: get_edge_weight
          get_edge_weight (<e>, <gr>)
          get_edge_weight (<e>, <gr>, <ifnot>)

     Returns the weight of the edge <e> in the graph <gr>.

     If there is no weight assigned to the edge, the function returns 1.
     If the edge is not present in the graph, the function signals an
     error or returns the optional argument <ifnot>.

     Example:
          (%i1) load ("graphs")$
          (%i2) c5 : cycle_graph(5)$
          (%i3) get_edge_weight([1,2], c5);
          (%o3)                           1
          (%i4) set_edge_weight([1,2], 2.0, c5);
          (%o4)                         done
          (%i5) get_edge_weight([1,2], c5);
          (%o5)                          2.0

 -- Function: get_vertex_label (<v>, <gr>)
     Returns the label of the vertex <v> in the graph <gr>.

     If no label is assigned to vertex <v>, ‘get_vertex_label’ returns
     ‘false’.

     Example:
          (%i1) load("graphs")$
          (%i2) g: create_graph([[0, "Zero"], [1, "One"], 2, 3], [])$
          (%i3) get_vertex_label(0, g);
          (%o3)                         Zero
          (%i4) get_vertex_label(2, g);
          (%o4)                         false

 -- Function: get_unique_vertex_by_label (<l>, <gr>)
     Returns the unique vertex which has the label <l> in graph <gr>.

     If there is no such vertex, ‘get_unique_vertex_by_label’ returns
     ‘false’.

     If there are two or more vertices with label <l>,
     ‘get_unique_vertex_by_label’ reports an error.

     Example:
          (%i1) load ("graphs")$
          (%i2) g: create_graph ([[0, "Zero"], [1, "One"], [2, "Other"], [3, "Other"]], []) $
          (%i3) get_unique_vertex_by_label ("Zero", g);
          (%o3)                           0
          (%i4) get_unique_vertex_by_label ("Two", g);
          (%o4)                         false
          (%i5) errcatch (get_unique_vertex_by_label ("Other", g));
          get_unique_vertex_by_label: two or more vertices have the same label "Other"
          (%o5)                          []

 -- Function: get_all_vertices_by_label (<l>, <gr>)
     Returns all vertices, if any, which have the label <l> in graph
     <gr>.

     If there are no such vertices, ‘get_all_vertices_by_label’ returns
     an empty list ‘[]’.

     Example:
          (%i1) load ("graphs")$
          (%i2) g: create_graph ([[0, "Zero"], [1, "One"], [2, "Other"], [3, "Other"]], []) $
          (%i3) get_all_vertices_by_label ("Zero", g);
          (%o3)                          [0]
          (%i4) get_all_vertices_by_label ("Two", g);
          (%o4)                          []
          (%i5) get_all_vertices_by_label ("Other", g);
          (%o5)                        [2, 3]

 -- Function: graph_charpoly (<gr>, <x>)
     Returns the characteristic polynomial (in variable <x>) of the
     graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) p : petersen_graph()$
          (%i3) graph_charpoly(p, x), factor;
                                             5        4
          (%o3)               (x - 3) (x - 1)  (x + 2)

 -- Function: graph_center (<gr>)
     Returns the center of the graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) g : grid_graph(5,5)$
          (%i3) graph_center(g);
          (%o3)                         [12]

 -- Function: graph_eigenvalues (<gr>)
     Returns the eigenvalues of the graph <gr>.  The function returns
     eigenvalues in the same format as maxima ‘eigenvalues’ function.

     Example:
          (%i1) load ("graphs")$
          (%i2) p : petersen_graph()$
          (%i3) graph_eigenvalues(p);
          (%o3)               [[3, - 2, 1], [1, 4, 5]]

 -- Function: graph_periphery (<gr>)
     Returns the periphery of the graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) g : grid_graph(5,5)$
          (%i3) graph_periphery(g);
          (%o3)                    [24, 20, 4, 0]

 -- Function: graph_size (<gr>)
     Returns the number of edges in the graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) p : petersen_graph()$
          (%i3) graph_size(p);
          (%o3)                          15

 -- Function: graph_order (<gr>)
     Returns the number of vertices in the graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) p : petersen_graph()$
          (%i3) graph_order(p);
          (%o3)                          10

 -- Function: girth (<gr>)
     Returns the length of the shortest cycle in <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) g : heawood_graph()$
          (%i3) girth(g);
          (%o3)                           6

 -- Function: hamilton_cycle (<gr>)
     Returns the Hamilton cycle of the graph <gr> or an empty list if
     <gr> is not hamiltonian.

     Example:
          (%i1) load ("graphs")$
          (%i2) c : cube_graph(3)$
          (%i3) hc : hamilton_cycle(c);
          (%o3)              [7, 3, 2, 6, 4, 0, 1, 5, 7]
          (%i4) draw_graph(c, show_edges=vertices_to_cycle(hc))$

 -- Function: hamilton_path (<gr>)
     Returns the Hamilton path of the graph <gr> or an empty list if
     <gr> does not have a Hamilton path.

     Example:
          (%i1) load ("graphs")$
          (%i2) p : petersen_graph()$
          (%i3) hp : hamilton_path(p);
          (%o3)            [0, 5, 7, 2, 1, 6, 8, 3, 4, 9]
          (%i4) draw_graph(p, show_edges=vertices_to_path(hp))$

 -- Function: isomorphism (<gr1>, <gr2>)

     Returns a an isomorphism between graphs/digraphs <gr1> and <gr2>.
     If <gr1> and <gr2> are not isomorphic, it returns an empty list.

     Example:
          (%i1) load ("graphs")$
          (%i2) clk5:complement_graph(line_graph(complete_graph(5)))$
          (%i3) isomorphism(clk5, petersen_graph());
          (%o3) [9 -> 0, 2 -> 1, 6 -> 2, 5 -> 3, 0 -> 4, 1 -> 5, 3 -> 6,
                                                    4 -> 7, 7 -> 8, 8 -> 9]

 -- Function: in_neighbors (<v>, <gr>)
     Returns the list of in-neighbors of the vertex <v> in the directed
     graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) p : path_digraph(3)$
          (%i3) in_neighbors(2, p);
          (%o3)                          [1]
          (%i4) out_neighbors(2, p);
          (%o4)                          []

 -- Function: is_biconnected (<gr>)
     Returns ‘true’ if <gr> is 2-connected and ‘false’ otherwise.

     Example:
          (%i1) load ("graphs")$
          (%i2) is_biconnected(cycle_graph(5));
          (%o2)                         true
          (%i3) is_biconnected(path_graph(5));
          (%o3)                         false

 -- Function: is_bipartite (<gr>)
     Returns ‘true’ if <gr> is bipartite (2-colorable) and ‘false’
     otherwise.

     Example:
          (%i1) load ("graphs")$
          (%i2) is_bipartite(petersen_graph());
          (%o2)                         false
          (%i3) is_bipartite(heawood_graph());
          (%o3)                         true

 -- Function: is_connected (<gr>)
     Returns ‘true’ if the graph <gr> is connected and ‘false’
     otherwise.

     Example:
          (%i1) load ("graphs")$
          (%i2) is_connected(graph_union(cycle_graph(4), path_graph(3)));
          (%o2)                         false

 -- Function: is_digraph (<gr>)
     Returns ‘true’ if <gr> is a directed graph and ‘false’ otherwise.

     Example:
          (%i1) load ("graphs")$
          (%i2) is_digraph(path_graph(5));
          (%o2)                         false
          (%i3) is_digraph(path_digraph(5));
          (%o3)                         true

 -- Function: is_edge_in_graph (<e>, <gr>)
     Returns ‘true’ if <e> is an edge (arc) in the (directed) graph <g>
     and ‘false’ otherwise.

     Example:
          (%i1) load ("graphs")$
          (%i2) c4 : cycle_graph(4)$
          (%i3) is_edge_in_graph([2,3], c4);
          (%o3)                         true
          (%i4) is_edge_in_graph([3,2], c4);
          (%o4)                         true
          (%i5) is_edge_in_graph([2,4], c4);
          (%o5)                         false
          (%i6) is_edge_in_graph([3,2], cycle_digraph(4));
          (%o6)                         false

 -- Function: is_graph (<gr>)
     Returns ‘true’ if <gr> is a graph and ‘false’ otherwise.

     Example:
          (%i1) load ("graphs")$
          (%i2) is_graph(path_graph(5));
          (%o2)                         true
          (%i3) is_graph(path_digraph(5));
          (%o3)                         false

 -- Function: is_graph_or_digraph (<gr>)
     Returns ‘true’ if <gr> is a graph or a directed graph and ‘false’
     otherwise.

     Example:
          (%i1) load ("graphs")$
          (%i2) is_graph_or_digraph(path_graph(5));
          (%o2)                         true
          (%i3) is_graph_or_digraph(path_digraph(5));
          (%o3)                         true

 -- Function: is_isomorphic (<gr1>, <gr2>)

     Returns ‘true’ if graphs/digraphs <gr1> and <gr2> are isomorphic
     and ‘false’ otherwise.

     See also ‘isomorphism’.

     Example:
          (%i1) load ("graphs")$
          (%i2) clk5:complement_graph(line_graph(complete_graph(5)))$
          (%i3) is_isomorphic(clk5, petersen_graph());
          (%o3)                         true

 -- Function: is_planar (<gr>)

     Returns ‘true’ if <gr> is a planar graph and ‘false’ otherwise.

     The algorithm used is the Demoucron’s algorithm, which is a
     quadratic time algorithm.

     Example:
          (%i1) load ("graphs")$
          (%i2) is_planar(dodecahedron_graph());
          (%o2)                         true
          (%i3) is_planar(petersen_graph());
          (%o3)                         false
          (%i4) is_planar(petersen_graph(10,2));
          (%o4)                         true

 -- Function: is_sconnected (<gr>)
     Returns ‘true’ if the directed graph <gr> is strongly connected and
     ‘false’ otherwise.

     Example:
          (%i1) load ("graphs")$
          (%i2) is_sconnected(cycle_digraph(5));
          (%o2)                         true
          (%i3) is_sconnected(path_digraph(5));
          (%o3)                         false

 -- Function: is_vertex_in_graph (<v>, <gr>)
     Returns ‘true’ if <v> is a vertex in the graph <g> and ‘false’
     otherwise.

     Example:
          (%i1) load ("graphs")$
          (%i2) c4 : cycle_graph(4)$
          (%i3) is_vertex_in_graph(0, c4);
          (%o3)                         true
          (%i4) is_vertex_in_graph(6, c4);
          (%o4)                         false

 -- Function: is_tree (<gr>)
     Returns ‘true’ if <gr> is a tree and ‘false’ otherwise.

     Example:
          (%i1) load ("graphs")$
          (%i2) is_tree(random_tree(4));
          (%o2)                         true
          (%i3) is_tree(graph_union(random_tree(4), random_tree(5)));
          (%o3)                         false

 -- Function: laplacian_matrix (<gr>)
     Returns the laplacian matrix of the graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) laplacian_matrix(cycle_graph(5));
                             [  2   - 1   0    0   - 1 ]
                             [                         ]
                             [ - 1   2   - 1   0    0  ]
                             [                         ]
          (%o2)              [  0   - 1   2   - 1   0  ]
                             [                         ]
                             [  0    0   - 1   2   - 1 ]
                             [                         ]
                             [ - 1   0    0   - 1   2  ]

 -- Function: max_clique (<gr>)
     Returns a maximum clique of the graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) g : random_graph(100, 0.5)$
          (%i3) max_clique(g);
          (%o3)          [6, 12, 31, 36, 52, 59, 62, 63, 80]

 -- Function: max_degree (<gr>)
     Returns the maximal degree of vertices of the graph <gr> and a
     vertex of maximal degree.

     Example:
          (%i1) load ("graphs")$
          (%i2) g : random_graph(100, 0.02)$
          (%i3) max_degree(g);
          (%o3)                        [6, 79]
          (%i4) vertex_degree(95, g);
          (%o4)                           2

 -- Function: max_flow (<net>, <s>, <t>)
     Returns a maximum flow through the network <net> with the source
     <s> and the sink <t>.

     The function returns the value of the maximal flow and a list
     representing the weights of the arcs in the optimal flow.

     Example:
          (%i1) load ("graphs")$
          (%i2) net : create_graph(
            [1,2,3,4,5,6],
            [[[1,2], 1.0],
             [[1,3], 0.3],
             [[2,4], 0.2],
             [[2,5], 0.3],
             [[3,4], 0.1],
             [[3,5], 0.1],
             [[4,6], 1.0],
             [[5,6], 1.0]],
            directed=true)$
          (%i3) [flow_value, flow] : max_flow(net, 1, 6);
          (%o3) [0.7, [[[1, 2], 0.5], [[1, 3], 0.2], [[2, 4], 0.2],
          [[2, 5], 0.3], [[3, 4], 0.1], [[3, 5], 0.1], [[4, 6], 0.3],
          [[5, 6], 0.4]]]
          (%i4) fl : 0$
          (%i5) for u in out_neighbors(1, net)
               do fl : fl + assoc([1, u], flow)$
          (%i6) fl;
          (%o6)                          0.7

 -- Function: max_independent_set (<gr>)
     Returns a maximum independent set of the graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) d : dodecahedron_graph()$
          (%i3) mi : max_independent_set(d);
          (%o3)             [0, 3, 5, 9, 10, 11, 18, 19]
          (%i4) draw_graph(d, show_vertices=mi)$

 -- Function: max_matching (<gr>)
     Returns a maximum matching of the graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) d : dodecahedron_graph()$
          (%i3) m : max_matching(d);
          (%o3) [[5, 7], [8, 9], [6, 10], [14, 19], [13, 18], [12, 17],
                                         [11, 16], [0, 15], [3, 4], [1, 2]]
          (%i4) draw_graph(d, show_edges=m)$

 -- Function: min_degree (<gr>)
     Returns the minimum degree of vertices of the graph <gr> and a
     vertex of minimum degree.

     Example:
          (%i1) load ("graphs")$
          (%i2) g : random_graph(100, 0.1)$
          (%i3) min_degree(g);
          (%o3)                        [3, 49]
          (%i4) vertex_degree(21, g);
          (%o4)                           9

 -- Function: min_edge_cut (<gr>)
     Returns the minimum edge cut in the graph <gr>.

     See also ‘edge_connectivity’.

 -- Function: min_vertex_cover (<gr>)
     Returns the minimum vertex cover of the graph <gr>.

 -- Function: min_vertex_cut (<gr>)
     Returns the minimum vertex cut in the graph <gr>.

     See also ‘vertex_connectivity’.

 -- Function: minimum_spanning_tree (<gr>)
     Returns the minimum spanning tree of the graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) g : graph_product(path_graph(10), path_graph(10))$
          (%i3) t : minimum_spanning_tree(g)$
          (%i4) draw_graph(g, show_edges=edges(t))$

 -- Function: neighbors (<v>, <gr>)
     Returns the list of neighbors of the vertex <v> in the graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) p : petersen_graph()$
          (%i3) neighbors(3, p);
          (%o3)                       [4, 8, 2]

 -- Function: odd_girth (<gr>)
     Returns the length of the shortest odd cycle in the graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) g : graph_product(cycle_graph(4), cycle_graph(7))$
          (%i3) girth(g);
          (%o3)                           4
          (%i4) odd_girth(g);
          (%o4)                           7

 -- Function: out_neighbors (<v>, <gr>)
     Returns the list of out-neighbors of the vertex <v> in the directed
     graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) p : path_digraph(3)$
          (%i3) in_neighbors(2, p);
          (%o3)                          [1]
          (%i4) out_neighbors(2, p);
          (%o4)                          []

 -- Function: planar_embedding (<gr>)

     Returns the list of facial walks in a planar embedding of <gr> and
     ‘false’ if <gr> is not a planar graph.

     The graph <gr> must be biconnected.

     The algorithm used is the Demoucron’s algorithm, which is a
     quadratic time algorithm.

     Example:
          (%i1) load ("graphs")$
          (%i2) planar_embedding(grid_graph(3,3));
          (%o2) [[3, 6, 7, 8, 5, 2, 1, 0], [4, 3, 0, 1], [3, 4, 7, 6],
                                                [8, 7, 4, 5], [1, 2, 5, 4]]

 -- Function: print_graph (<gr>)
     Prints some information about the graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) c5 : cycle_graph(5)$
          (%i3) print_graph(c5)$
          Graph on 5 vertices with 5 edges.
          Adjacencies:
            4 :  0  3
            3 :  4  2
            2 :  3  1
            1 :  2  0
            0 :  4  1
          (%i4) dc5 : cycle_digraph(5)$
          (%i5) print_graph(dc5)$
          Digraph on 5 vertices with 5 arcs.
          Adjacencies:
            4 :  0
            3 :  4
            2 :  3
            1 :  2
            0 :  1
          (%i6) out_neighbors(0, dc5);
          (%o6)                          [1]

 -- Function: radius (<gr>)
     Returns the radius of the graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) radius(dodecahedron_graph());
          (%o2)                           5

 -- Function: set_edge_weight (<e>, <w>, <gr>)
     Assigns the weight <w> to the edge <e> in the graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) g : create_graph([1, 2], [[[1,2], 1.2]])$
          (%i3) get_edge_weight([1,2], g);
          (%o3)                          1.2
          (%i4) set_edge_weight([1,2], 2.1, g);
          (%o4)                         done
          (%i5) get_edge_weight([1,2], g);
          (%o5)                          2.1

 -- Function: set_vertex_label (<v>, <l>, <gr>)
     Assigns the label <l> to the vertex <v> in the graph <gr>.

     A label may be any Maxima expression, and two or more vertices may
     have the same label.

     Example:
          (%i1) load ("graphs")$
          (%i2) g : create_graph([[1, "One"], [2, "Two"]], [[1, 2]])$
          (%i3) get_vertex_label(1, g);
          (%o3)                          One
          (%i4) set_vertex_label(1, "oNE", g);
          (%o4)                         done
          (%i5) get_vertex_label(1, g);
          (%o5)                          oNE
          (%i6) h : create_graph([[11, x], [22, y], [33, x + y]], [[11, 33], [22, 33]]) $
          (%i7) get_vertex_label (33, h);
          (%o7)                         y + x

 -- Function: shortest_path (<u>, <v>, <gr>)
     Returns the shortest path from <u> to <v> in the graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) d : dodecahedron_graph()$
          (%i3) path : shortest_path(0, 7, d);
          (%o3)                   [0, 1, 19, 13, 7]
          (%i4) draw_graph(d, show_edges=vertices_to_path(path))$

 -- Function: shortest_weighted_path (<u>, <v>, <gr>)
     Returns the length of the shortest weighted path and the shortest
     weighted path from <u> to <v> in the graph <gr>.

     The length of a weighted path is the sum of edge weights of edges
     in the path.  If an edge has no weight, then it has a default
     weight 1.

     Example:

          (%i1) load ("graphs")$
          (%i2) g: petersen_graph(20, 2)$
          (%i3) for e in edges(g) do set_edge_weight(e, random(1.0), g)$
          (%i4) shortest_weighted_path(0, 10, g);
          (%o4) [2.575143920268482, [0, 20, 38, 36, 34, 32, 30, 10]]

 -- Function: strong_components (<gr>)
     Returns the strong components of a directed graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) t : random_tournament(4)$
          (%i3) strong_components(t);
          (%o3)                 [[1], [0], [2], [3]]
          (%i4) vertex_out_degree(3, t);
          (%o4)                           3

 -- Function: topological_sort (<dag>)

     Returns a topological sorting of the vertices of a directed graph
     <dag> or an empty list if <dag> is not a directed acyclic graph.

     Example:
          (%i1) load ("graphs")$
          (%i2) g:create_graph(
                   [1,2,3,4,5],
                   [
                    [1,2], [2,5], [5,3],
                    [5,4], [3,4], [1,3]
                   ],
                   directed=true)$
          (%i3) topological_sort(g);
          (%o3)                    [1, 2, 5, 3, 4]

 -- Function: vertex_connectivity (<g>)
     Returns the vertex connectivity of the graph <g>.

     See also ‘min_vertex_cut’.

 -- Function: vertex_degree (<v>, <gr>)
     Returns the degree of the vertex <v> in the graph <gr>.

 -- Function: vertex_distance (<u>, <v>, <gr>)
     Returns the length of the shortest path between <u> and <v> in the
     (directed) graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) d : dodecahedron_graph()$
          (%i3) vertex_distance(0, 7, d);
          (%o3)                           4
          (%i4) shortest_path(0, 7, d);
          (%o4)                   [0, 1, 19, 13, 7]

 -- Function: vertex_eccentricity (<v>, <gr>)

     Returns the eccentricity of the vertex <v> in the graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) g:cycle_graph(7)$
          (%i3) vertex_eccentricity(0, g);
          (%o3)                           3

 -- Function: vertex_in_degree (<v>, <gr>)
     Returns the in-degree of the vertex <v> in the directed graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) p5 : path_digraph(5)$
          (%i3) print_graph(p5)$
          Digraph on 5 vertices with 4 arcs.
          Adjacencies:
            4 :
            3 :  4
            2 :  3
            1 :  2
            0 :  1
          (%i4) vertex_in_degree(4, p5);
          (%o4)                           1
          (%i5) in_neighbors(4, p5);
          (%o5)                          [3]

 -- Function: vertex_out_degree (<v>, <gr>)
     Returns the out-degree of the vertex <v> in the directed graph
     <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) t : random_tournament(10)$
          (%i3) vertex_out_degree(0, t);
          (%o3)                           2
          (%i4) out_neighbors(0, t);
          (%o4)                        [7, 1]

 -- Function: vertices (<gr>)
     Returns the list of vertices in the graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) vertices(complete_graph(4));
          (%o2)                     [3, 2, 1, 0]

 -- Function: vertex_coloring (<gr>)
     Returns an optimal coloring of the vertices of the graph <gr>.

     The function returns the chromatic number and a list representing
     the coloring of the vertices of <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) p:petersen_graph()$
          (%i3) vertex_coloring(p);
          (%o3) [3, [[0, 2], [1, 3], [2, 2], [3, 3], [4, 1], [5, 3],
                                           [6, 1], [7, 1], [8, 2], [9, 2]]]

 -- Function: wiener_index (<gr>)
     Returns the Wiener index of the graph <gr>.

     Example:
          (%i2) wiener_index(dodecahedron_graph());
          (%o2)                          500

63.2.3 Modifying graphs
-----------------------

 -- Function: add_edge (<e>, <gr>)
     Adds the edge <e> to the graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) p : path_graph(4)$
          (%i3) neighbors(0, p);
          (%o3)                          [1]
          (%i4) add_edge([0,3], p);
          (%o4)                         done
          (%i5) neighbors(0, p);
          (%o5)                        [3, 1]

 -- Function: add_edges (<e_list>, <gr>)
     Adds all edges in the list <e_list> to the graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) g : empty_graph(3)$
          (%i3) add_edges([[0,1],[1,2]], g)$
          (%i4) print_graph(g)$
          Graph on 3 vertices with 2 edges.
          Adjacencies:
            2 :  1
            1 :  2  0
            0 :  1

 -- Function: add_vertex (<v>, <gr>)
     Adds the vertex <v> to the graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) g : path_graph(2)$
          (%i3) add_vertex(2, g)$
          (%i4) print_graph(g)$
          Graph on 3 vertices with 1 edges.
          Adjacencies:
            2 :
            1 :  0
            0 :  1

 -- Function: add_vertices (<v_list>, <gr>)
     Adds all vertices in the list <v_list> to the graph <gr>.  A vertex
     may be any integer, and <v_list> may contain vertices in any order.

 -- Function: connect_vertices (<v_list>, <u_list>, <gr>)
     Connects all vertices from the list <v_list> with the vertices in
     the list <u_list> in the graph <gr>.

     <v_list> and <u_list> can be single vertices or lists of vertices.

     Example:
          (%i1) load ("graphs")$
          (%i2) g : empty_graph(4)$
          (%i3) connect_vertices(0, [1,2,3], g)$
          (%i4) print_graph(g)$
          Graph on 4 vertices with 3 edges.
          Adjacencies:
            3 :  0
            2 :  0
            1 :  0
            0 :  3  2  1

 -- Function: contract_edge (<e>, <gr>)
     Contracts the edge <e> in the graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) g: create_graph(
                8, [[0,3],[1,3],[2,3],[3,4],[4,5],[4,6],[4,7]])$
          (%i3) print_graph(g)$
          Graph on 8 vertices with 7 edges.
          Adjacencies:
            7 :  4
            6 :  4
            5 :  4
            4 :  7  6  5  3
            3 :  4  2  1  0
            2 :  3
            1 :  3
            0 :  3
          (%i4) contract_edge([3,4], g)$
          (%i5) print_graph(g)$
          Graph on 7 vertices with 6 edges.
          Adjacencies:
            7 :  3
            6 :  3
            5 :  3
            3 :  5  6  7  2  1  0
            2 :  3
            1 :  3
            0 :  3

 -- Function: remove_edge (<e>, <gr>)
     Removes the edge <e> from the graph <gr>.

     Example:
          (%i1) load ("graphs")$
          (%i2) c3 : cycle_graph(3)$
          (%i3) remove_edge([0,1], c3)$
          (%i4) print_graph(c3)$
          Graph on 3 vertices with 2 edges.
          Adjacencies:
            2 :  0  1
            1 :  2
            0 :  2

 -- Function: remove_vertex (<v>, <gr>)
     Removes the vertex <v> from the graph <gr>.

63.2.4 Reading and writing to files
-----------------------------------

 -- Function: dimacs_export
          dimacs_export (<gr>, <fl>)
          dimacs_export (<gr>, <fl>, <comment1>, ..., <commentn>)

     Exports the graph into the file <fl> in the DIMACS format.
     Optional comments will be added to the top of the file.

 -- Function: dimacs_import (<fl>)

     Returns the graph from file <fl> in the DIMACS format.

 -- Function: graph6_decode (<str>)

     Returns the graph encoded in the graph6 format in the string <str>.

 -- Function: graph6_encode (<gr>)

     Returns a string which encodes the graph <gr> in the graph6 format.

 -- Function: graph6_export (<gr_list>, <fl>)

     Exports graphs in the list <gr_list> to the file <fl> in the graph6
     format.

 -- Function: graph6_import (<fl>)

     Returns a list of graphs from the file <fl> in the graph6 format.

 -- Function: sparse6_decode (<str>)

     Returns the graph encoded in the sparse6 format in the string
     <str>.

 -- Function: sparse6_encode (<gr>)

     Returns a string which encodes the graph <gr> in the sparse6
     format.

 -- Function: sparse6_export (<gr_list>, <fl>)

     Exports graphs in the list <gr_list> to the file <fl> in the
     sparse6 format.

 -- Function: sparse6_import (<fl>)

     Returns a list of graphs from the file <fl> in the sparse6 format.

63.2.5 Visualization
--------------------

 -- Function: draw_graph
          draw_graph (<graph>)
          draw_graph (<graph>, <option1>, ..., <optionk>)

     Draws the graph using the *note draw-pkg:: package.

     The algorithm used to position vertices is specified by the
     optional argument <program>.  The default value is
     ‘program=spring_embedding’.  <draw_graph> can also use the graphviz
     programs for positioning vertices, but graphviz must be installed
     separately.

     Example 1:

          (%i1) load ("graphs")$
          (%i2) g:grid_graph(10,10)$
          (%i3) m:max_matching(g)$
          (%i4) draw_graph(g,
             spring_embedding_depth=100,
             show_edges=m, edge_type=dots,
             vertex_size=0)$

     Example 2:

          (%i1) load ("graphs")$
          (%i2) g:create_graph(16,
              [
               [0,1],[1,3],[2,3],[0,2],[3,4],[2,4],
               [5,6],[6,4],[4,7],[6,7],[7,8],[7,10],[7,11],
               [8,10],[11,10],[8,9],[11,12],[9,15],[12,13],
               [10,14],[15,14],[13,14]
              ])$
          (%i3) t:minimum_spanning_tree(g)$
          (%i4) draw_graph(
              g,
              show_edges=edges(t),
              show_edge_width=4,
              show_edge_color=green,
              vertex_type=filled_square,
              vertex_size=2
              )$

     Example 3:

          (%i1) load ("graphs")$
          (%i2) g:create_graph(16,
              [
               [0,1],[1,3],[2,3],[0,2],[3,4],[2,4],
               [5,6],[6,4],[4,7],[6,7],[7,8],[7,10],[7,11],
               [8,10],[11,10],[8,9],[11,12],[9,15],[12,13],
               [10,14],[15,14],[13,14]
              ])$
          (%i3) mi : max_independent_set(g)$
          (%i4) draw_graph(
              g,
              show_vertices=mi,
              show_vertex_type=filled_up_triangle,
              show_vertex_size=2,
              edge_color=cyan,
              edge_width=3,
              show_id=true,
              text_color=brown
              )$

     Example 4:

          (%i1) load ("graphs")$
          (%i2) net : create_graph(
              [0,1,2,3,4,5],
              [
               [[0,1], 3], [[0,2], 2],
               [[1,3], 1], [[1,4], 3],
               [[2,3], 2], [[2,4], 2],
               [[4,5], 2], [[3,5], 2]
              ],
              directed=true
              )$
          (%i3) draw_graph(
              net,
              show_weight=true,
              vertex_size=0,
              show_vertices=[0,5],
              show_vertex_type=filled_square,
              head_length=0.2,
              head_angle=10,
              edge_color="dark-green",
              text_color=blue
              )$

     Example 5:

          (%i1) load("graphs")$
          (%i2) g: petersen_graph(20, 2);
          (%o2)                         GRAPH
          (%i3) draw_graph(g, redraw=true, program=planar_embedding);
          (%o3)                         done

     Example 6:

          (%i1) load("graphs")$
          (%i2) t: tutte_graph();
          (%o2)                         GRAPH
          (%i3) draw_graph(t, redraw=true,
                              fixed_vertices=[1,2,3,4,5,6,7,8,9]);
          (%o3)                         done

 -- Option variable: draw_graph_program
     Default value: <spring_embedding>

     The default value for the program used to position vertices in
     ‘draw_graph’ program.

 -- draw_graph option: show_id
     Default value: <false>

     If <true> then ids of the vertices are displayed.

 -- draw_graph option: show_label
     Default value: <false>

     If <true> then labels of the vertices are displayed.

 -- draw_graph option: label_alignment
     Default value: <center>

     Determines how to align the labels/ids of the vertices.  Can be
     ‘left’, ‘center’ or ‘right’.

 -- draw_graph option: show_weight
     Default value: <false>

     If <true> then weights of the edges are displayed.

 -- draw_graph option: vertex_type
     Default value: <circle>

     Defines how vertices are displayed.  See the <point_type> option
     for the ‘draw’ package for possible values.

 -- draw_graph option: vertex_size
     The size of vertices.

 -- draw_graph option: vertex_color
     The color used for displaying vertices.

 -- draw_graph option: show_vertices
     Default value: []

     Display selected vertices in the using a different color.

 -- draw_graph option: show_vertex_type
     Defines how vertices specified in <show_vertices> are displayed.
     See the <point_type> option for the ‘draw’ package for possible
     values.

 -- draw_graph option: show_vertex_size
     The size of vertices in <show_vertices>.

 -- draw_graph option: show_vertex_color
     The color used for displaying vertices in the <show_vertices> list.

 -- draw_graph option: vertex_partition
     Default value: []

     A partition ‘[[v1,v2,...],...,[vk,...,vn]]’ of the vertices of the
     graph.  The vertices of each list in the partition will be drawn in
     a different color.

 -- draw_graph option: vertex_coloring
     Specifies coloring of the vertices.  The coloring <col> must be
     specified in the format as returned by <vertex_coloring>.

 -- draw_graph option: edge_color
     The color used for displaying edges.

 -- draw_graph option: edge_width
     The width of edges.

 -- draw_graph option: edge_type
     Defines how edges are displayed.  See the <line_type> option for
     the ‘draw’ package.

 -- draw_graph option: show_edges
     Display edges specified in the list <e_list> using a different
     color.

 -- draw_graph option: show_edge_color
     The color used for displaying edges in the <show_edges> list.

 -- draw_graph option: show_edge_width
     The width of edges in <show_edges>.

 -- draw_graph option: show_edge_type
     Defines how edges in <show_edges> are displayed.  See the
     <line_type> option for the ‘draw’ package.

 -- draw_graph option: edge_partition
     A partition ‘[[e1,e2,...],...,[ek,...,em]]’ of edges of the graph.
     The edges of each list in the partition will be drawn using a
     different color.

 -- draw_graph option: edge_coloring
     The coloring of edges.  The coloring must be specified in the
     format as returned by the function <edge_coloring>.

 -- draw_graph option: redraw
     Default value: <false>

     If ‘true’, vertex positions are recomputed even if the positions
     have been saved from a previous drawing of the graph.

 -- draw_graph option: head_angle
     Default value: 15

     The angle for the arrows displayed on arcs (in directed graphs).

 -- draw_graph option: head_length
     Default value: 0.1

     The length for the arrows displayed on arcs (in directed graphs).

 -- draw_graph option: spring_embedding_depth
     Default value: 50

     The number of iterations in the spring embedding graph drawing
     algorithm.

 -- draw_graph option: terminal
     The terminal used for drawing (see the <terminal> option in the
     ‘draw’ package).

 -- draw_graph option: file_name
     The filename of the drawing if terminal is not screen.

 -- draw_graph option: program
     Defines the program used for positioning vertices of the graph.
     Can be one of the graphviz programs (dot, neato, twopi, circ, fdp),
     <circular>, <spring_embedding> or <planar_embedding>.
     <planar_embedding> is only available for 2-connected planar graphs.
     When ‘program=spring_embedding’, a set of vertices with fixed
     position can be specified with the <fixed_vertices> option.

 -- draw_graph option: fixed_vertices
     Specifies a list of vertices which will have positions fixed along
     a regular polygon.  Can be used when ‘program=spring_embedding’.

 -- Function: vertices_to_path (<v_list>)
     Converts a list <v_list> of vertices to a list of edges of the path
     defined by <v_list>.

 -- Function: vertices_to_cycle (<v_list>)
     Converts a list <v_list> of vertices to a list of edges of the
     cycle defined by <v_list>.


File: maxima.info,  Node: grobner-pkg,  Next: hompack-pkg,  Prev: graphs-pkg,  Up: Top

64 grobner
**********

* Menu:

* Introduction to grobner ::
* Functions and Variables for grobner ::


File: maxima.info,  Node: Introduction to grobner,  Next: Functions and Variables for grobner,  Prev: Top,  Up: Top

64.1 Introduction to grobner
============================

‘grobner’ is a package for working with Groebner bases in Maxima.

To use the following functions you must load the ‘grobner.lisp’ package.

     load("grobner");

A demo can be started by
     demo("grobner.demo");

or
     batch("grobner.demo")

Some of the calculation in the demo will take a lot of time therefore
the output ‘grobner-demo.output’ of the demo can be found in the same
directory as the demo file.

64.1.1 Notes on the grobner package
-----------------------------------

The package was written by

Marek Rychlik

<http://alamos.math.arizona.edu>

and is released 2002-05-24 under the terms of the General Public
License(GPL) (see file ‘grobner.lisp’).  This documentation was
extracted from the files
‘README’, ‘grobner.lisp’, ‘grobner.demo’, ‘grobner-demo.output’

by Günter Nowak.  Suggestions for improvement of the documentation can
be discussed at the _maxima_-mailing-list <maxima@math.utexas.edu>.  The
code is a little bit out of date now.  Modern implementation use the
fast _F4_ algorithm described in
A new efficient algorithm for computing Gröbner bases (F4)
Jean-Charles Faugère
LIP6/CNRS Université Paris VI
January 20, 1999

64.1.2 Implementations of admissible monomial orders in grobner
---------------------------------------------------------------

   • ‘lex’

     pure lexicographic, default order for monomial comparisons
   • ‘grlex’

     total degree order, ties broken by lexicographic

   • ‘grevlex’

     total degree, ties broken by reverse lexicographic

   • ‘invlex’

     inverse lexicographic order


File: maxima.info,  Node: Functions and Variables for grobner,  Prev: Introduction to grobner,  Up: Top

64.2 Functions and Variables for grobner
========================================

64.2.1 Global switches for grobner
----------------------------------

 -- Option variable: poly_monomial_order
     Default value: ‘lex’

     This global switch controls which monomial order is used in
     polynomial and Groebner Bases calculations.  If not set, ‘lex’ will
     be used.

 -- Option variable: poly_coefficient_ring
     Default value: ‘expression_ring’

     This switch indicates the coefficient ring of the polynomials that
     will be used in grobner calculations.  If not set, _maxima’s_
     general expression ring will be used.  This variable may be set to
     ‘ring_of_integers’ if desired.

 -- Option variable: poly_primary_elimination_order
     Default value: ‘false’

     Name of the default order for eliminated variables in
     elimination-based functions.  If not set, ‘lex’ will be used.

 -- Option variable: poly_secondary_elimination_order
     Default value: ‘false’

     Name of the default order for kept variables in elimination-based
     functions.  If not set, ‘lex’ will be used.

 -- Option variable: poly_elimination_order
     Default value: ‘false’

     Name of the default elimination order used in elimination
     calculations.  If set, it overrides the settings in variables
     ‘poly_primary_elimination_order’ and
     ‘poly_secondary_elimination_order’.  The user must ensure that this
     is a true elimination order valid for the number of eliminated
     variables.

 -- Option variable: poly_return_term_list
     Default value: ‘false’

     If set to ‘true’, all functions in this package will return each
     polynomial as a list of terms in the current monomial order rather
     than a _maxima_ general expression.

 -- Option variable: poly_grobner_debug
     Default value: ‘false’

     If set to ‘true’, produce debugging and tracing output.

 -- Option variable: poly_grobner_algorithm
     Default value: ‘buchberger’

     Possible values:
        • ‘buchberger’
        • ‘parallel_buchberger’
        • ‘gebauer_moeller’

     The name of the algorithm used to find the Groebner Bases.

 -- Option variable: poly_top_reduction_only
     Default value: ‘false’

     If not ‘false’, use top reduction only whenever possible.  Top
     reduction means that division algorithm stops after the first
     reduction.

64.2.2 Simple operators in grobner
----------------------------------

‘poly_add’, ‘poly_subtract’, ‘poly_multiply’ and ‘poly_expt’ are the
arithmetical operations on polynomials.  These are performed using the
internal representation, but the results are converted back to the
_maxima_ general form.

 -- Function: poly_add (<poly1>, <poly2>, <varlist>)
     Adds two polynomials <poly1> and <poly2>.

          (%i1) poly_add(z+x^2*y,x-z,[x,y,z]);
                                              2
          (%o1)                              x  y + x

 -- Function: poly_subtract (<poly1>, <poly2>, <varlist>)
     Subtracts a polynomial <poly2> from <poly1>.

          (%i1) poly_subtract(z+x^2*y,x-z,[x,y,z]);
                                                2
          (%o1)                          2 z + x  y - x

 -- Function: poly_multiply (<poly1>, <poly2>, <varlist>)
     Returns the product of polynomials <poly1> and <poly2>.

          (%i2) poly_multiply(z+x^2*y,x-z,[x,y,z])-(z+x^2*y)*(x-z),expand;
          (%o1)                                  0

 -- Function: poly_s_polynomial (<poly1>, <poly2>, <varlist>)
     Returns the _syzygy polynomial_ (_S-polynomial_) of two polynomials
     <poly1> and <poly2>.

 -- Function: poly_primitive_part (<poly1>, <varlist>)
     Returns the polynomial <poly> divided by the GCD of its
     coefficients.

          (%i1) poly_primitive_part(35*y+21*x,[x,y]);
          (%o1)                              5 y + 3 x

 -- Function: poly_normalize (<poly>, <varlist>)
     Returns the polynomial <poly> divided by the leading coefficient.
     It assumes that the division is possible, which may not always be
     the case in rings which are not fields.

64.2.3 Other functions in grobner
---------------------------------

 -- Function: poly_expand (<poly>, <varlist>)
     This function parses polynomials to internal form and back.  It is
     equivalent to ‘expand(<poly>)’ if <poly> parses correctly to a
     polynomial.  If the representation is not compatible with a
     polynomial in variables <varlist>, the result is an error.  It can
     be used to test whether an expression correctly parses to the
     internal representation.  The following examples illustrate that
     indexed and transcendental function variables are allowed.

          (%i1) poly_expand((x-y)*(y+x),[x,y]);
                                               2    2
          (%o1)                               x  - y
          (%i2) poly_expand((y+x)^2,[x,y]);
                                          2            2
          (%o2)                          y  + 2 x y + x
          (%i3) poly_expand((y+x)^5,[x,y]);
                            5      4         2  3       3  2      4      5
          (%o3)            y  + 5 x y  + 10 x  y  + 10 x  y  + 5 x  y + x
          (%i4) poly_expand(-1-x*exp(y)+x^2/sqrt(y),[x]);
                                                    2
                                            y      x
          (%o4)                       - x %e  + ------- - 1
                                                 sqrt(y)

          (%i5) poly_expand(-1-sin(x)^2+sin(x),[sin(x)]);
                                          2
          (%o5)                      - sin (x) + sin(x) - 1


 -- Function: poly_expt (<poly>, <number>, <varlist>)
     exponentitates <poly> by a positive integer <number>.  If <number>
     is not a positive integer number an error will be raised.

          (%i1) poly_expt(x-y,3,[x,y])-(x-y)^3,expand;
          (%o1)                                  0

 -- Function: poly_content (<poly>. <varlist>)
     ‘poly_content’ extracts the GCD of its coefficients

          (%i1) poly_content(35*y+21*x,[x,y]);
          (%o1)                                  7

 -- Function: poly_pseudo_divide (<poly>, <polylist>, <varlist>)
     Pseudo-divide a polynomial <poly> by the list of n polynomials
     <polylist>.  Return multiple values.  The first value is a list of
     quotients a.  The second value is the remainder r.  The third
     argument is a scalar coefficient c, such that c*poly can be divided
     by <polylist> within the ring of coefficients, which is not
     necessarily a field.  Finally, the fourth value is an integer count
     of the number of reductions performed.  The resulting objects
     satisfy the equation:

     c*poly=sum(a[i]*polylist[i],i=1...n)+r.

 -- Function: poly_exact_divide (<poly1>, <poly2>, <varlist>)
     Divide a polynomial <poly1> by another polynomial <poly2>.  Assumes
     that exact division with no remainder is possible.  Returns the
     quotient.

 -- Function: poly_normal_form (<poly>, <polylist>, <varlist>)
     ‘poly_normal_form’ finds the normal form of a polynomial <poly>
     with respect to a set of polynomials <polylist>.

 -- Function: poly_buchberger_criterion (<polylist>, <varlist>)
     Returns ‘true’ if <polylist> is a Groebner basis with respect to
     the current term order, by using the Buchberger criterion: for
     every two polynomials h1 and h2 in <polylist> the S-polynomial
     S(h1,h2) reduces to 0 modulo <polylist>.

 -- Function: poly_buchberger (<polylist_fl> <varlist>)
     ‘poly_buchberger’ performs the Buchberger algorithm on a list of
     polynomials and returns the resulting Groebner basis.

64.2.4 Standard postprocessing of Groebner Bases
------------------------------------------------

The _k-th elimination Ideal_ I_k of an Ideal I over K[ x[1],...,x[n] ]
is the ideal intersect(I, K[ x[k+1],...,x[n] ]).
The _colon ideal_ I:J is the ideal {h|for all w in J: w*h in I}.
The ideal I:p^inf is the ideal {h| there is a n in N: p^n*h in I}.
The ideal I:J^inf is the ideal {h| there is a n in N and a p in J: p^n*h
in I}.
The _radical ideal_ sqrt(I) is the ideal {h| there is a n in N : h^n in
I }.

 -- Function: poly_reduction (<polylist>, <varlist>)
     ‘poly_reduction’ reduces a list of polynomials <polylist>, so that
     each polynomial is fully reduced with respect to the other
     polynomials.

 -- Function: poly_minimization (<polylist>, <varlist>)
     Returns a sublist of the polynomial list <polylist> spanning the
     same monomial ideal as <polylist> but minimal, i.e.  no leading
     monomial of a polynomial in the sublist divides the leading
     monomial of another polynomial.

 -- Function: poly_normalize_list (<polylist>, <varlist>)
     ‘poly_normalize_list’ applies ‘poly_normalize’ to each polynomial
     in the list.  That means it divides every polynomial in a list
     <polylist> by its leading coefficient.

 -- Function: poly_grobner (<polylist>, <varlist>)
     Returns a Groebner basis of the ideal span by the polynomials
     <polylist>.  Affected by the global flags.

 -- Function: poly_reduced_grobner (<polylist>, <varlist>)
     Returns a reduced Groebner basis of the ideal span by the
     polynomials <polylist>.  Affected by the global flags.

 -- Function: poly_depends_p (<poly>, <var>, <varlist>)
     ‘poly_depends’ tests whether a polynomial depends on a variable
     <var>.

 -- Function: poly_elimination_ideal (<polylist>, <number>, <varlist>)

     ‘poly_elimination_ideal’ returns the grobner basis of the number-th
     elimination ideal of an ideal specified as a list of generating
     polynomials (not necessarily Groebner basis).

 -- Function: poly_colon_ideal (<polylist1>, <polylist2>, <varlist>)

     Returns the reduced Groebner basis of the colon ideal

     I(polylist1):I(polylist2)

     where polylist1 and polylist2 are two lists of polynomials.

 -- Function: poly_ideal_intersection (<polylist1>, <polylist2>,
          <varlist>)

     ‘poly_ideal_intersection’ returns the intersection of two ideals.

 -- Function: poly_lcm (<poly1>, <poly2>, <varlist>)
     Returns the lowest common multiple of <poly1> and <poly2>.

 -- Function: poly_gcd (<poly1>, <poly2>, <varlist>)

     Returns the greatest common divisor of <poly1> and <poly2>.

     See also ‘ezgcd’, ‘gcd’, ‘gcdex’, and ‘gcdivide’.

     Example:

          (%i1) p1:6*x^3+19*x^2+19*x+6;
                                  3       2
          (%o1)                6 x  + 19 x  + 19 x + 6
          (%i2) p2:6*x^5+13*x^4+12*x^3+13*x^2+6*x;
                            5       4       3       2
          (%o2)          6 x  + 13 x  + 12 x  + 13 x  + 6 x
          (%i3) poly_gcd(p1, p2, [x]);
                                      2
          (%o3)                    6 x  + 13 x + 6

 -- Function: poly_grobner_equal (<polylist1>, <polylist2>, <varlist>)
     ‘poly_grobner_equal’ tests whether two Groebner Bases generate the
     same ideal.  Returns ‘true’ if two lists of polynomials <polylist1>
     and <polylist2>, assumed to be Groebner Bases, generate the same
     ideal, and ‘false’ otherwise.  This is equivalent to checking that
     every polynomial of the first basis reduces to 0 modulo the second
     basis and vice versa.  Note that in the example below the first
     list is not a Groebner basis, and thus the result is ‘false’.

          (%i1) poly_grobner_equal([y+x,x-y],[x,y],[x,y]);
          (%o1)                         false

 -- Function: poly_grobner_subsetp (<polylist1>, <polylist2>, <varlist>)

     ‘poly_grobner_subsetp’ tests whether an ideal generated by
     <polylist1> is contained in the ideal generated by <polylist2>.
     For this test to always succeed, <polylist2> must be a Groebner
     basis.

 -- Function: poly_grobner_member (<poly>, <polylist>, <varlist>)

     Returns ‘true’ if a polynomial <poly> belongs to the ideal
     generated by the polynomial list <polylist>, which is assumed to be
     a Groebner basis.  Returns ‘false’ otherwise.

     ‘poly_grobner_member’ tests whether a polynomial belongs to an
     ideal generated by a list of polynomials, which is assumed to be a
     Groebner basis.  Equivalent to ‘normal_form’ being 0.

 -- Function: poly_ideal_saturation1 (<polylist>, <poly>, <varlist>)
     Returns the reduced Groebner basis of the saturation of the ideal

     I(polylist):poly^inf

     Geometrically, over an algebraically closed field, this is the set
     of polynomials in the ideal generated by <polylist> which do not
     identically vanish on the variety of <poly>.

 -- Function: poly_ideal_saturation (<polylist1>, <polylist2>,
          <varlist>)
     Returns the reduced Groebner basis of the saturation of the ideal

     I(polylist1):I(polylist2)^inf

     Geometrically, over an algebraically closed field, this is the set
     of polynomials in the ideal generated by <polylist1> which do not
     identically vanish on the variety of <polylist2>.

 -- Function: poly_ideal_polysaturation1 (<polylist1>, <polylist2>,
          <varlist>)
     <polylist2> is a list of n polynomials ‘[poly1,...,polyn]’.
     Returns the reduced Groebner basis of the ideal

     I(polylist):poly1^inf:...:polyn^inf

     obtained by a sequence of successive saturations in the polynomials
     of the polynomial list <polylist2> of the ideal generated by the
     polynomial list <polylist1>.

 -- Function: poly_ideal_polysaturation (<polylist>, <polylistlist>,
          <varlist>)
     <polylistlist> is a list of n list of polynomials
     ‘[polylist1,...,polylistn]’.  Returns the reduced Groebner basis of
     the saturation of the ideal

     I(polylist):I(polylist_1)^inf:...:I(polylist_n)^inf

 -- Function: poly_saturation_extension (<poly>, <polylist>, <varlist1>,
          <varlist2>)

     ‘poly_saturation_extension’ implements the famous Rabinowitz trick.

 -- Function: poly_polysaturation_extension (<poly>, <polylist>,
          <varlist1>, <varlist2>)


File: maxima.info,  Node: hompack-pkg,  Next: impdiff-pkg,  Prev: grobner-pkg,  Up: Top

65 hompack
**********

* Menu:

* Introduction to hompack::
* Functions and Variables for hompack::


File: maxima.info,  Node: Introduction to hompack,  Next: Functions and Variables for hompack,  Up: hompack-pkg

65.1 Introduction to hompack
============================

‘Hompack’ is a Common Lisp translation (via ‘f2cl’) of the Fortran
library HOMPACK, as obtained from Netlib.


File: maxima.info,  Node: Functions and Variables for hompack,  Prev: Introduction to hompack,  Up: hompack-pkg

65.2 Functions and Variables for hompack
========================================

 -- Function: hompack_polsys (<eqnlist>, <varlist> [, <iflg1>, <epsbig>,
          <epssml>, <numrr>])
     Finds the roots of the system of polynomials in the variables
     <varlist> in the system of equations in <eqnlist>.  The number of
     equations must match number of variables.  Each equation must be a
     polynomial with variables in <varlist>.  The coefficients must be
     real numbers.

     The optional keyword arguments provide some control over the
     algorithm.

     ‘epsbig’
          is the local error tolerance allowed by the path tracker,
          defaulting to 1e-4.
     ‘epssml’
          is the accuracy desired for the final solution, defaulting to
          1d-14.
     ‘numrr’
          is the number of multiples of 1000 steps that will be tried
          before abandoning a path, defaulting to 10.
     ‘iflg1’
          defaulting to 0, controls the algorithm as follows:
          ‘0’
               If the problem is to be solved without calling ‘polsys’’
               scaling routine, ‘sclgnp’, and without using the
               projective transformation.
          ‘1’
               If scaling but no projective transformation is to be
               used.
          ‘10’
               If no scaling but projective transformation is to be
               used.
          ‘11’
               If both scaling and projective transformation are to be
               used.

     ‘hompack_polsys’ returns a list.  The elements of the list are:
     ‘retcode’
          Indicates whether the solution is valid or not.
          ‘0’
               Solution found without problems
          ‘1’
               Solution succeeded but ‘iflg2’ indicates some issues with
               a root.  (That is, ‘iflg2’ is not all ones.)
          ‘-1’
               ‘NN’, the declared dimension of the number of terms in
               the polynomials, is too small.  (This should not happen.)
          ‘-2’
               ‘MMAXT’, the declared dimension for the internal
               coefficient and degree arrays, is too small.  (This
               should not happen.)
          ‘-3’
               ‘TTOTDG’, the total degree of the equations, is too
               small.  (This should not happen.)
          ‘-4’
               ‘LENWK’, the length of the internal real work array, is
               too small.  (This should not happen.)
          ‘-5’
               ‘LENIWK’, the length of the internal integer work array,
               is too small.  (This should not happen.)
          ‘-6’
               <iflg1> is not 0 or 1, or 10 or 11.  (This should not
               happen; an error should be thrown before ‘polsys’ is
               called.)
     ‘roots’
          The roots of the system of equations.  This is in the same
          format as ‘solve’ would return.
     ‘iflg2’
          A list containing information on how the path for the m’th
          root terminated:
          ‘1’
               Normal return
          ‘2’
               Specified error tolerance cannot be met.  Increase
               <epsbig> and <epssml> and rerun.
          ‘3’
               Maximum number of steps exceeded.  To track the path
               further, increase <numrr> and rerun the path.  However,
               the path may be diverging, if the lambda value is near 1
               and the roots values are large.
          ‘4’
               Jacobian matrix does not have full rank.  The algorithm
               has failed (the zero curve of the homotopy map cannot be
               followed any further).
          ‘5’
               The tracking algorithm has lost the zero curve of the
               homotopy map and is not making progress.  The error
               tolerances <epsbig> and <epssml> were too lenient.  The
               problem should be restarted with smaller error
               tolerances.
          ‘6’
               The normal flow newton iteration in ‘stepnf’ or ‘rootnf’
               failed to converge.  The error tolerance <epsbig> may be
               too stringent.
          ‘7’
               Illegal input parameters, a fatal error.
     ‘lambda’
          A list of the final lambda value for the m-th root, where
          lambda is the continuation parameter.
     ‘arclen’
          A list of the arc length of the m-th root.
     ‘nfe’
          A list of the number of jacobian matrix evaluations required
          to track the m-th root.

     Here are some examples of using ‘hompack_polsys’.
          (%i1) load(hompack)$
          (%i2) hompack_polsys([x1^2-1, x2^2-2],[x1,x2]);
          (%o2) [0,
                 [[x1 = (-1.354505666901954e-16*%i)-0.9999999999999999,
                   x2 = 3.52147935979316e-16*%i-1.414213562373095],
                  [x1 = 1.0-5.536432658639868e-18*%i,
                   x2 = (-4.213674137126362e-17*%i)-1.414213562373095],
                  [x1 = (-9.475939894034927e-17*%i)-1.0,
                   x2 = 2.669654624736742e-16*%i+1.414213562373095],
                  [x1 = 9.921253413273088e-18*%i+1.0,
                   x2 = 1.414213562373095-5.305667769855424e-17*%i]],[1,1,1,1],
                 [1.0,1.0,0.9999999999999996,1.0],
                 [4.612623769341193,4.612623010859902,4.612623872939383,
                  4.612623114484402],[40,40,40,40]]

     The analytical solution can be obtained with solve:
          (%i1) solve([x1^2-1, x2^2-2],[x1,x2]);
          (%o1) [[x1 = 1,x2 = -sqrt(2)],[x1 = 1,x2 = sqrt(2)],[x1 = -1,x2 = -sqrt(2)],
                  [x1 = -1,x2 = sqrt(2)]]
     We see that ‘hompack_polsys’ returned the correct answer except
     that the roots are in a different order and there is a small
     imaginary part.

     Another example, with corresponding solution from solve:
          (%i1) hompack_polsys([x1^2 + 2*x2^2 + x1*x2 - 5, 2*x1^2 + x2^2 + x2-4],[x1,x2]);
          (%o1) [0,
                 [[x1 = 1.201557301700783-1.004786320788336e-15*%i,
                   x2 = (-4.376615092392437e-16*%i)-1.667270363480143],
                  [x1 = 1.871959754090949e-16*%i-1.428529189565313,
                   x2 = (-6.301586314393093e-17*%i)-0.9106199083334113],
                  [x1 = 0.5920619420732697-1.942890293094024e-16*%i,
                   x2 = 6.938893903907228e-17*%i+1.383859154368197],
                  [x1 = 7.363503717463654e-17*%i+0.08945540033671608,
                   x2 = 1.557667481081721-4.109128293931921e-17*%i]],[1,1,1,1],
                 [1.000000000000001,1.0,1.0,1.0],
                 [6.205795654034752,7.722213259390295,7.228287079174351,
                  5.611474283583368],[35,41,48,40]]
          (%i2) solve([x1^2+2*x2^2+x1*x2 - 5, 2*x1^2+x2^2+x2-4],[x1,x2]);
          (%o2) [[x1 = 0.08945540336850383,x2 = 1.557667386609071],
                 [x1 = 0.5920619554695062,x2 = 1.383859286083807],
                 [x1 = 1.201557352500749,x2 = -1.66727025803531],
                 [x1 = -1.428529150636283,x2 = -0.9106198942815954]]

     Note that ‘hompack_polsys’ can sometimes be very slow.  Perhaps
     ‘solve’ can be used.  Or perhaps ‘eliminate’ can be used to convert
     the system of polynomials into one polynomial for which ‘allroots’
     can find all the roots.


File: maxima.info,  Node: impdiff-pkg,  Next: interpol-pkg,  Prev: hompack-pkg,  Up: Top

66 impdiff
**********

* Menu:

* Functions and Variables for impdiff::


File: maxima.info,  Node: Functions and Variables for impdiff,  Prev: impdiff-pkg,  Up: impdiff-pkg

66.1 Functions and Variables for impdiff
========================================

 -- Function: implicit_derivative
          (<f>,<indvarlist>,<orderlist>,<depvar>)
     This subroutine computes implicit derivatives of multivariable
     functions.  <f> is an array function, the indexes are the
     derivative degree in the <indvarlist> order; <indvarlist> is the
     independent variable list; <orderlist> is the order desired; and
     <depvar> is the dependent variable.

     To use this function write first ‘load("impdiff")’.


File: maxima.info,  Node: interpol-pkg,  Next: lapack-pkg,  Prev: impdiff-pkg,  Up: Top

67 interpol
***********

* Menu:

* Introduction to interpol::
* Functions and Variables for interpol::


File: maxima.info,  Node: Introduction to interpol,  Next: Functions and Variables for interpol,  Prev: interpol-pkg,  Up: interpol-pkg

67.1 Introduction to interpol
=============================

Package ‘interpol’ defines the Lagrangian, the linear and the cubic
splines methods for polynomial interpolation.

   For comments, bugs or suggestions, please contact me at <’mario AT
edu DOT xunta DOT es’>.


File: maxima.info,  Node: Functions and Variables for interpol,  Prev: Introduction to interpol,  Up: interpol-pkg

67.2 Functions and Variables for interpol
=========================================

 -- Function: lagrange
          lagrange (<points>)
          lagrange (<points>, <option>)

     Computes the polynomial interpolation by the Lagrangian method.
     Argument <points> must be either:

        • a two column matrix, ‘p:matrix([2,4],[5,6],[9,3])’,
        • a list of pairs, ‘p: [[2,4],[5,6],[9,3]]’,
        • a list of numbers, ‘p: [4,6,3]’, in which case the abscissas
          will be assigned automatically to 1, 2, 3, etc.

     In the first two cases the pairs are ordered with respect to the
     first coordinate before making computations.

     With the <option> argument it is possible to select the name for
     the independent variable, which is ‘'x’ by default; to define
     another one, write something like ‘varname='z’.

     Note that when working with high degree polynomials, floating point
     evaluations are unstable.

     See also ‘linearinterpol’, ‘cspline’, and ‘ratinterpol’.

     Examples:

          (%i1) load("interpol")$
          (%i2) p:[[7,2],[8,2],[1,5],[3,2],[6,7]]$
          (%i3) lagrange(p);
                 (x - 7) (x - 6) (x - 3) (x - 1)
          (%o3)  -------------------------------
                               35
             (x - 8) (x - 6) (x - 3) (x - 1)
           - -------------------------------
                           12
             7 (x - 8) (x - 7) (x - 3) (x - 1)
           + ---------------------------------
                            30
             (x - 8) (x - 7) (x - 6) (x - 1)
           - -------------------------------
                           60
             (x - 8) (x - 7) (x - 6) (x - 3)
           + -------------------------------
                           84
          (%i4) f(x):=''%;
                         (x - 7) (x - 6) (x - 3) (x - 1)
          (%o4)  f(x) := -------------------------------
                                       35
             (x - 8) (x - 6) (x - 3) (x - 1)
           - -------------------------------
                           12
             7 (x - 8) (x - 7) (x - 3) (x - 1)
           + ---------------------------------
                            30
             (x - 8) (x - 7) (x - 6) (x - 1)
           - -------------------------------
                           60
             (x - 8) (x - 7) (x - 6) (x - 3)
           + -------------------------------
                           84
          (%i5) /* Evaluate the polynomial at some points */
                expand(map(f,[2.3,5/7,%pi]));
                                            4          3           2
                              919062  73 %pi    701 %pi    8957 %pi
          (%o5)  [- 1.567535, ------, ------- - -------- + ---------
                              84035     420       210         420
                                                       5288 %pi   186
                                                     - -------- + ---]
                                                         105       5
          (%i6) %,numer;
          (%o6) [- 1.567535, 10.9366573451538, 2.89319655125692]
          (%i7) load("draw")$  /* load draw package */
          (%i8) /* Plot the polynomial together with points */
                draw2d(
                  color      = red,
                  key        = "Lagrange polynomial",
                  explicit(f(x),x,0,10),
                  point_size = 3,
                  color      = blue,
                  key        = "Sample points",
                  points(p))$
          (%i9) /* Change variable name */
                lagrange(p, varname=w);
                 (w - 7) (w - 6) (w - 3) (w - 1)
          (%o9)  -------------------------------
                               35
             (w - 8) (w - 6) (w - 3) (w - 1)
           - -------------------------------
                           12
             7 (w - 8) (w - 7) (w - 3) (w - 1)
           + ---------------------------------
                            30
             (w - 8) (w - 7) (w - 6) (w - 1)
           - -------------------------------
                           60
             (w - 8) (w - 7) (w - 6) (w - 3)
           + -------------------------------
                           84

 -- Function: charfun2 (<x>, <a>, <b>)

     The characteristic or indicator function on the half-open interval
     [<a>, <b>), that is, including <a> and excluding <b>.

     When <x> >= <a> and <x> < <b> evaluates to ‘true’ or ‘false’,
     ‘charfun2’ returns 1 or 0, respectively.

     Otherwise, ‘charfun2’ returns a partially-evaluated result in terms
     of ‘charfun’.

     Package ‘interpol’ loads this function.

     See also ‘charfun’.

     Examples:

     When <x> >= <a> and <x> < <b> evaluates to ‘true’ or ‘false’,
     ‘charfun2’ returns 1 or 0, respectively.

          (%i1) load ("interpol") $
          (%i2) charfun2 (5, 0, 100);
          (%o2)                           1
          (%i3) charfun2 (-5, 0, 100);
          (%o3)                           0

     Otherwise, ‘charfun2’ returns a partially-evaluated result in terms
     of ‘charfun’.

          (%i1) load ("interpol") $
          (%i2) charfun2 (t, 0, 100);
          (%o2)            charfun((0 <= t) and (t < 100))
          (%i3) charfun2 (5, u, v);
          (%o3)             charfun((u <= 5) and (5 < v))
          (%i4) assume (v > u, u > 5);
          (%o4)                    [v > u, u > 5]
          (%i5) charfun2 (5, u, v);
          (%o5)                           0

 -- Function: linearinterpol
          linearinterpol (<points>)
          linearinterpol (<points>, <option>)

     Computes the polynomial interpolation by the linear method.
     Argument <points> must be either:

        • a two column matrix, ‘p:matrix([2,4],[5,6],[9,3])’,
        • a list of pairs, ‘p: [[2,4],[5,6],[9,3]]’,
        • a list of numbers, ‘p: [4,6,3]’, in which case the abscissas
          will be assigned automatically to 1, 2, 3, etc.

     In the first two cases the pairs are ordered with respect to the
     first coordinate before making computations.

     With the <option> argument it is possible to select the name for
     the independent variable, which is ‘'x’ by default; to define
     another one, write something like ‘varname='z’.

     See also ‘lagrange’, ‘cspline’, and ‘ratinterpol’.

     Examples:

          (%i1) load("interpol")$
          (%i2) p: matrix([7,2],[8,3],[1,5],[3,2],[6,7])$
          (%i3) linearinterpol(p);
                  13   3 x
          (%o3)  (-- - ---) charfun2(x, minf, 3)
                  2     2
           + (x - 5) charfun2(x, 7, inf) + (37 - 5 x) charfun2(x, 6, 7)
              5 x
           + (--- - 3) charfun2(x, 3, 6)
               3

          (%i4) f(x):=''%;
                          13   3 x
          (%o4)  f(x) := (-- - ---) charfun2(x, minf, 3)
                          2     2
           + (x - 5) charfun2(x, 7, inf) + (37 - 5 x) charfun2(x, 6, 7)
              5 x
           + (--- - 3) charfun2(x, 3, 6)
               3
          (%i5)  /* Evaluate the polynomial at some points */
                 map(f,[7.3,25/7,%pi]);
                                      62  5 %pi
          (%o5)                 [2.3, --, ----- - 3]
                                      21    3
          (%i6) %,numer;
          (%o6)  [2.3, 2.952380952380953, 2.235987755982989]
          (%i7) load("draw")$  /* load draw package */
          (%i8)  /* Plot the polynomial together with points */
                 draw2d(
                   color      = red,
                   key        = "Linear interpolator",
                   explicit(f(x),x,-5,20),
                   point_size = 3,
                   color      = blue,
                   key        = "Sample points",
                   points(args(p)))$
          (%i9)  /* Change variable name */
                 linearinterpol(p, varname='s);
                 13   3 s
          (%o9) (-- - ---) charfun2(s, minf, 3)
                 2     2
           + (s - 5) charfun2(s, 7, inf) + (37 - 5 s) charfun2(s, 6, 7)
              5 s
           + (--- - 3) charfun2(s, 3, 6)
               3

 -- Function: cspline
          cspline (<points>)
          cspline (<points>, <option1>, <option2>, ...)

     Computes the polynomial interpolation by the cubic splines method.
     Argument <points> must be either:

        • a two column matrix, ‘p:matrix([2,4],[5,6],[9,3])’,
        • a list of pairs, ‘p: [[2,4],[5,6],[9,3]]’,
        • a list of numbers, ‘p: [4,6,3]’, in which case the abscissas
          will be assigned automatically to 1, 2, 3, etc.

     In the first two cases the pairs are ordered with respect to the
     first coordinate before making computations.

     There are three options to fit specific needs:
        • ‘'d1’, default ‘'unknown’, is the first derivative at x_1; if
          it is ‘'unknown’, the second derivative at x_1 is made equal
          to 0 (natural cubic spline); if it is equal to a number, the
          second derivative is calculated based on this number.

        • ‘'dn’, default ‘'unknown’, is the first derivative at x_n; if
          it is ‘'unknown’, the second derivative at x_n is made equal
          to 0 (natural cubic spline); if it is equal to a number, the
          second derivative is calculated based on this number.

        • ‘'varname’, default ‘'x’, is the name of the independent
          variable.

     See also ‘lagrange’, ‘linearinterpol’, and ‘ratinterpol’.

     Examples:
          (%i1) load("interpol")$
          (%i2) p:[[7,2],[8,2],[1,5],[3,2],[6,7]]$
          (%i3) /* Unknown first derivatives at the extremes
                   is equivalent to natural cubic splines */
                cspline(p);
                        3         2
                  1159 x    1159 x    6091 x   8283
          (%o3)  (------- - ------- - ------ + ----) charfun2(x, minf, 3)
                   3288      1096      3288    1096
                      3         2
                2587 x    5174 x    494117 x   108928
           + (- ------- + ------- - -------- + ------) charfun2(x, 7, inf)
                 1644       137       1644      137
                    3          2
              4715 x    15209 x    579277 x   199575
           + (------- - -------- + -------- - ------) charfun2(x, 6, 7)
               1644       274        1644      274
                      3         2
                3287 x    2223 x    48275 x   9609
           + (- ------- + ------- - ------- + ----) charfun2(x, 3, 6)
                 4932       274      1644     274

          (%i4) f(x):=''%$
          (%i5) /* Some evaluations */
                map(f,[2.3,5/7,%pi]), numer;
          (%o5) [1.991460766423356, 5.823200187269903, 2.227405312429507]
          (%i6) load("draw")$  /* load draw package */
          (%i7) /* Plotting interpolating function */
                draw2d(
                  color      = red,
                  key        = "Cubic splines",
                  explicit(f(x),x,0,10),
                  point_size = 3,
                  color      = blue,
                  key        = "Sample points",
                  points(p))$
          (%i8) /* New call, but giving values at the derivatives */
                cspline(p,d1=0,dn=0);
                        3          2
                  1949 x    11437 x    17027 x   1247
          (%o8)  (------- - -------- + ------- + ----) charfun2(x, minf, 3)
                   2256       2256      2256     752
                      3          2
                1547 x    35581 x    68068 x   173546
           + (- ------- + -------- - ------- + ------) charfun2(x, 7, inf)
                  564       564        141      141
                   3          2
              607 x    35147 x    55706 x   38420
           + (------ - -------- + ------- - -----) charfun2(x, 6, 7)
               188       564        141      47
                      3         2
                3895 x    1807 x    5146 x   2148
           + (- ------- + ------- - ------ + ----) charfun2(x, 3, 6)
                 5076       188      141      47
          (%i8) /* Defining new interpolating function */
                g(x):=''%$
          (%i9) /* Plotting both functions together */
                draw2d(
                  color      = black,
                  key        = "Cubic splines (default)",
                  explicit(f(x),x,0,10),
                  color      = red,
                  key        = "Cubic splines (d1=0,dn=0)",
                  explicit(g(x),x,0,10),
                  point_size = 3,
                  color      = blue,
                  key        = "Sample points",
                  points(p))$

 -- Function: ratinterpol
          ratinterpol (<points>, <numdeg>)
          ratinterpol (<points>, <numdeg>, <option1>)

     Generates a rational interpolator for data given by <points> and
     the degree of the numerator being equal to <numdeg>; the degree of
     the denominator is calculated automatically.  Argument <points>
     must be either:

        • a two column matrix, ‘p:matrix([2,4],[5,6],[9,3])’,
        • a list of pairs, ‘p: [[2,4],[5,6],[9,3]]’,
        • a list of numbers, ‘p: [4,6,3]’, in which case the abscissas
          will be assigned automatically to 1, 2, 3, etc.

     In the first two cases the pairs are ordered with respect to the
     first coordinate before making computations.

     There is one option to fit specific needs:
        • ‘'varname’, default ‘'x’, is the name of the independent
          variable.

     See also ‘lagrange’, ‘linearinterpol’, ‘cspline’,
     ‘minpack_lsquares’, and *note lbfgs-pkg::

     Examples:

          (%i1) load("interpol")$
          (%i2) load("draw")$
          (%i3) p:[[7.2,2.5],[8.5,2.1],[1.6,5.1],[3.4,2.4],[6.7,7.9]]$
          (%i4) for k:0 thru length(p)-1 do
                  draw2d(
                    explicit(ratinterpol(p,k),x,0,9),
                    point_size = 3,
                    points(p),
                    title = concat("Degree of numerator = ",k),
                    yrange=[0,10])$


File: maxima.info,  Node: lapack-pkg,  Next: lbfgs-pkg,  Prev: interpol-pkg,  Up: Top

68 lapack
*********

* Menu:

* Introduction to lapack::
* Functions and Variables for lapack::


File: maxima.info,  Node: Introduction to lapack,  Next: Functions and Variables for lapack,  Prev: lapack-pkg,  Up: lapack-pkg

68.1 Introduction to lapack
===========================

‘lapack’ is a Common Lisp translation (via the program ‘f2cl’) of the
Fortran library LAPACK, as obtained from the SLATEC project.


File: maxima.info,  Node: Functions and Variables for lapack,  Prev: Introduction to lapack,  Up: lapack-pkg

68.2 Functions and Variables for lapack
=======================================

 -- Function: dgeev
          dgeev (<A>)
          dgeev (<A>, <right_p>, <left_p>)

     Computes the eigenvalues and, optionally, the eigenvectors of a
     matrix <A>.  All elements of <A> must be integer or floating point
     numbers.  <A> must be square (same number of rows and columns).
     <A> might or might not be symmetric.

     ‘dgeev(<A>)’ computes only the eigenvalues of <A>.  ‘dgeev(<A>,
     <right_p>, <left_p>)’ computes the eigenvalues of <A> and the right
     eigenvectors when <right_p> = ‘true’ and the left eigenvectors when
     <left_p> = ‘true’.

     A list of three items is returned.  The first item is a list of the
     eigenvalues.  The second item is ‘false’ or the matrix of right
     eigenvectors.  The third item is ‘false’ or the matrix of left
     eigenvectors.

     The right eigenvector v(j) (the j-th column of the right
     eigenvector matrix) satisfies

     A . v(j) = lambda(j) . v(j)

     where lambda(j) is the corresponding eigenvalue.  The left
     eigenvector u(j) (the j-th column of the left eigenvector matrix)
     satisfies

     u(j)**H . A = lambda(j) . u(j)**H

     where u(j)**H denotes the conjugate transpose of u(j).  The Maxima
     function ‘ctranspose’ computes the conjugate transpose.

     The computed eigenvectors are normalized to have Euclidean norm
     equal to 1, and largest component has imaginary part equal to zero.

     Example:

          (%i1) load ("lapack")$
          (%i2) fpprintprec : 6;
          (%o2)                           6
          (%i3) M : matrix ([9.5, 1.75], [3.25, 10.45]);
                                   [ 9.5   1.75  ]
          (%o3)                    [             ]
                                   [ 3.25  10.45 ]
          (%i4) dgeev (M);
          (%o4)          [[7.54331, 12.4067], false, false]
          (%i5) [L, v, u] : dgeev (M, true, true);
                                     [ - .666642  - .515792 ]
          (%o5) [[7.54331, 12.4067], [                      ],
                                     [  .745378   - .856714 ]
                                                  [ - .856714  - .745378 ]
                                                  [                      ]]
                                                  [  .515792   - .666642 ]
          (%i6) D : apply (diag_matrix, L);
                                [ 7.54331     0    ]
          (%o6)                 [                  ]
                                [    0     12.4067 ]
          (%i7) M . v - v . D;
                          [      0.0       - 8.88178E-16 ]
          (%o7)           [                              ]
                          [ - 8.88178E-16       0.0      ]
          (%i8) transpose (u) . M - D . transpose (u);
                               [ 0.0  - 4.44089E-16 ]
          (%o8)                [                    ]
                               [ 0.0       0.0      ]

 -- Function: dgeqrf (<A>)

     Computes the QR decomposition of the matrix <A>.  All elements of
     <A> must be integer or floating point numbers.  <A> may or may not
     have the same number of rows and columns.

     A list of two items is returned.  The first item is the matrix <Q>,
     which is a square, orthonormal matrix which has the same number of
     rows as <A>.  The second item is the matrix <R>, which is the same
     size as <A>, and which has all elements equal to zero below the
     diagonal.  The product ‘<Q> . <R>’, where "."  is the
     noncommutative multiplication operator, is equal to <A> (ignoring
     floating point round-off errors).

          (%i1) load ("lapack") $
          (%i2) fpprintprec : 6 $
          (%i3) M : matrix ([1, -3.2, 8], [-11, 2.7, 5.9]) $
          (%i4) [q, r] : dgeqrf (M);
                 [ - .0905357  .995893  ]
          (%o4) [[                      ],
                 [  .995893    .0905357 ]
                                         [ - 11.0454   2.97863   5.15148 ]
                                         [                               ]]
                                         [     0      - 2.94241  8.50131 ]
          (%i5) q . r - M;
                   [ - 7.77156E-16   1.77636E-15   - 8.88178E-16 ]
          (%o5)    [                                             ]
                   [      0.0       - 1.33227E-15   8.88178E-16  ]
          (%i6) mat_norm (%, 1);
          (%o6)                      3.10862E-15

 -- Function: dgesv (<A>, <b>)

     Computes the solution <x> of the linear equation <A> <x> = <b>,
     where <A> is a square matrix, and <b> is a matrix of the same
     number of rows as <A> and any number of columns.  The return value
     <x> is the same size as <b>.

     The elements of <A> and <b> must evaluate to real floating point
     numbers via ‘float’; thus elements may be any numeric type,
     symbolic numerical constants, or expressions which evaluate to
     floats.  The elements of <x> are always floating point numbers.
     All arithmetic is carried out as floating point operations.

     ‘dgesv’ computes the solution via the LU decomposition of <A>.

     Examples:

     ‘dgesv’ computes the solution of the linear equation <A> <x> = <b>.

          (%i1) A : matrix ([1, -2.5], [0.375, 5]);
                                         [   1    - 2.5 ]
          (%o1)                          [              ]
                                         [ 0.375    5   ]
          (%i2) b : matrix ([1.75], [-0.625]);
                                            [  1.75   ]
          (%o2)                             [         ]
                                            [ - 0.625 ]
          (%i3) x : dgesv (A, b);
                                      [  1.210526315789474  ]
          (%o3)                       [                     ]
                                      [ - 0.215789473684211 ]
          (%i4) dlange (inf_norm, b - A.x);
          (%o4)                                 0.0

     <b> is a matrix with the same number of rows as <A> and any number
     of columns.  <x> is the same size as <b>.

          (%i1) A : matrix ([1, -0.15], [1.82, 2]);
                                         [  1    - 0.15 ]
          (%o1)                          [              ]
                                         [ 1.82    2    ]
          (%i2) b : matrix ([3.7, 1, 8], [-2.3, 5, -3.9]);
                                        [  3.7   1    8   ]
          (%o2)                         [                 ]
                                        [ - 2.3  5  - 3.9 ]
          (%i3) x : dgesv (A, b);
                [  3.103827540695117  1.20985481742191    6.781786185657722 ]
          (%o3) [                                                           ]
                [ -3.974483062032557  1.399032116146062  -8.121425428948527 ]
          (%i4) dlange (inf_norm, b - A . x);
          (%o4)                       1.1102230246251565E-15

     The elements of <A> and <b> must evaluate to real floating point
     numbers.

          (%i1) A : matrix ([5, -%pi], [1b0, 11/17]);
                                         [   5    - %pi ]
                                         [              ]
          (%o1)                          [         11   ]
                                         [ 1.0b0   --   ]
                                         [         17   ]
          (%i2) b : matrix ([%e], [sin(1)]);
                                            [   %e   ]
          (%o2)                             [        ]
                                            [ sin(1) ]
          (%i3) x : dgesv (A, b);
                                       [ 0.690375643155986 ]
          (%o3)                        [                   ]
                                       [ 0.233510982552952 ]
          (%i4) dlange (inf_norm, b - A . x);
          (%o4)                        2.220446049250313E-16

 -- Function: dgesvd
          dgesvd (<A>)
          dgesvd (<A>, <left_p>, <right_p>)

     Computes the singular value decomposition (SVD) of a matrix <A>,
     comprising the singular values and, optionally, the left and right
     singular vectors.  All elements of <A> must be integer or floating
     point numbers.  <A> might or might not be square (same number of
     rows and columns).

     Let m be the number of rows, and n the number of columns of <A>.
     The singular value decomposition of <A> comprises three matrices,
     <U>, <Sigma>, and <V^T>, such that

     <A> = <U> . <Sigma> . <V>^T

     where <U> is an m-by-m unitary matrix, <Sigma> is an m-by-n
     diagonal matrix, and <V^T> is an n-by-n unitary matrix.

     Let sigma[i] be a diagonal element of Sigma, that is, <Sigma>[i, i]
     = <sigma>[i].  The elements sigma[i] are the so-called singular
     values of <A>; these are real and nonnegative, and returned in
     descending order.  The first min(m, n) columns of <U> and <V> are
     the left and right singular vectors of <A>.  Note that ‘dgesvd’
     returns the transpose of <V>, not <V> itself.

     ‘dgesvd(<A>)’ computes only the singular values of <A>.
     ‘dgesvd(<A>, <left_p>, <right_p>)’ computes the singular values of
     <A> and the left singular vectors when <left_p> = ‘true’ and the
     right singular vectors when <right_p> = ‘true’.

     A list of three items is returned.  The first item is a list of the
     singular values.  The second item is ‘false’ or the matrix of left
     singular vectors.  The third item is ‘false’ or the matrix of right
     singular vectors.

     Example:

          (%i1) load ("lapack")$
          (%i2) fpprintprec : 6;
          (%o2)                           6
          (%i3) M: matrix([1, 2, 3], [3.5, 0.5, 8], [-1, 2, -3], [4, 9, 7]);
                                  [  1    2    3  ]
                                  [               ]
                                  [ 3.5  0.5   8  ]
          (%o3)                   [               ]
                                  [ - 1   2   - 3 ]
                                  [               ]
                                  [  4    9    7  ]
          (%i4) dgesvd (M);
          (%o4)      [[14.4744, 6.38637, .452547], false, false]
          (%i5) [sigma, U, VT] : dgesvd (M, true, true);
          (%o5) [[14.4744, 6.38637, .452547],
          [ - .256731  .00816168   .959029    - .119523 ]
          [                                             ]
          [ - .526456   .672116   - .206236   - .478091 ]
          [                                             ],
          [  .107997   - .532278  - .0708315  - 0.83666 ]
          [                                             ]
          [ - .803287  - .514659  - .180867    .239046  ]
          [ - .374486  - .538209  - .755044 ]
          [                                 ]
          [  .130623   - .836799   0.5317   ]]
          [                                 ]
          [ - .917986   .100488    .383672  ]
          (%i6) m : length (U);
          (%o6)                           4
          (%i7) n : length (VT);
          (%o7)                           3
          (%i8) Sigma:
                  genmatrix(lambda ([i, j], if i=j then sigma[i] else 0),
                            m, n);
                            [ 14.4744     0        0    ]
                            [                           ]
                            [    0     6.38637     0    ]
          (%o8)             [                           ]
                            [    0        0     .452547 ]
                            [                           ]
                            [    0        0        0    ]
          (%i9) U . Sigma . VT - M;
                    [  1.11022E-15        0.0       1.77636E-15 ]
                    [                                           ]
                    [  1.33227E-15    1.66533E-15       0.0     ]
          (%o9)     [                                           ]
                    [ - 4.44089E-16  - 8.88178E-16  4.44089E-16 ]
                    [                                           ]
                    [  8.88178E-16    1.77636E-15   8.88178E-16 ]
          (%i10) transpose (U) . U;
                 [     1.0      5.55112E-17    2.498E-16     2.77556E-17  ]
                 [                                                        ]
                 [ 5.55112E-17      1.0       5.55112E-17    4.16334E-17  ]
          (%o10) [                                                        ]
                 [  2.498E-16   5.55112E-17       1.0       - 2.08167E-16 ]
                 [                                                        ]
                 [ 2.77556E-17  4.16334E-17  - 2.08167E-16       1.0      ]
          (%i11) VT . transpose (VT);
                    [      1.0           0.0      - 5.55112E-17 ]
                    [                                           ]
          (%o11)    [      0.0           1.0       5.55112E-17  ]
                    [                                           ]
                    [ - 5.55112E-17  5.55112E-17       1.0      ]

 -- Function: dlange (<norm>, <A>)
 -- Function: zlange (<norm>, <A>)

     Computes a norm or norm-like function of the matrix <A>.  If <A> is
     a real matrix, use ‘dlange’.  For a matrix with complex elements,
     use ‘zlange’.

     ‘norm’ specifies the kind of norm to be computed:
     ‘max’
          Compute max(abs(A(i, j))) where i and j range over the rows
          and columns, respectively, of <A>.  Note that this function is
          not a proper matrix norm.
     ‘one_norm’
          Compute the L[1] norm of <A>, that is, the maximum of the sum
          of the absolute value of elements in each column.
     ‘inf_norm’
          Compute the L[inf] norm of <A>, that is, the maximum of the
          sum of the absolute value of elements in each row.
     ‘frobenius’
          Compute the Frobenius norm of <A>, that is, the square root of
          the sum of squares of the matrix elements.

 -- Function: dgemm
          dgemm (<A>, <B>)
          dgemm (<A>, <B>, <options>)
     Compute the product of two matrices and optionally add the product
     to a third matrix.

     In the simplest form, ‘dgemm(<A>, <B>)’ computes the product of the
     two real matrices, <A> and <B>.

     In the second form, ‘dgemm’ computes the <alpha> * <A> * <B> +
     <beta> * <C> where <A>, <B>, <C> are real matrices of the
     appropriate sizes and <alpha> and <beta> are real numbers.
     Optionally, <A> and/or <B> can be transposed before computing the
     product.  The extra parameters are specified by optional keyword
     arguments: The keyword arguments are optional and may be specified
     in any order.  They all take the form ‘key=val’.  The keyword
     arguments are:

     ‘C’
          The matrix <C> that should be added.  The default is ‘false’,
          which means no matrix is added.
     ‘alpha’
          The product of <A> and <B> is multiplied by this value.  The
          default is 1.
     ‘beta’
          If a matrix <C> is given, this value multiplies <C> before it
          is added.  The default value is 0, which implies that <C> is
          not added, even if <C> is given.  Hence, be sure to specify a
          non-zero value for <beta>.
     ‘transpose_a’
          If ‘true’, the transpose of <A> is used instead of <A> for the
          product.  The default is ‘false’.
     ‘transpose_b’
          If ‘true’, the transpose of <B> is used instead of <B> for the
          product.  The default is ‘false’.

          (%i1) load ("lapack")$
          (%i2) A : matrix([1,2,3],[4,5,6],[7,8,9]);
                                            [ 1  2  3 ]
                                            [         ]
          (%o2)                             [ 4  5  6 ]
                                            [         ]
                                            [ 7  8  9 ]
          (%i3) B : matrix([-1,-2,-3],[-4,-5,-6],[-7,-8,-9]);
                                         [ - 1  - 2  - 3 ]
                                         [               ]
          (%o3)                          [ - 4  - 5  - 6 ]
                                         [               ]
                                         [ - 7  - 8  - 9 ]
          (%i4) C : matrix([3,2,1],[6,5,4],[9,8,7]);
                                            [ 3  2  1 ]
                                            [         ]
          (%o4)                             [ 6  5  4 ]
                                            [         ]
                                            [ 9  8  7 ]
          (%i5) dgemm(A,B);
                                   [ - 30.0   - 36.0   - 42.0  ]
                                   [                           ]
          (%o5)                    [ - 66.0   - 81.0   - 96.0  ]
                                   [                           ]
                                   [ - 102.0  - 126.0  - 150.0 ]
          (%i6) A . B;
                                      [ - 30   - 36   - 42  ]
                                      [                     ]
          (%o6)                       [ - 66   - 81   - 96  ]
                                      [                     ]
                                      [ - 102  - 126  - 150 ]
          (%i7) dgemm(A,B,transpose_a=true);
                                   [ - 66.0  - 78.0   - 90.0  ]
                                   [                          ]
          (%o7)                    [ - 78.0  - 93.0   - 108.0 ]
                                   [                          ]
                                   [ - 90.0  - 108.0  - 126.0 ]
          (%i8) transpose(A) . B;
                                     [ - 66  - 78   - 90  ]
                                     [                    ]
          (%o8)                      [ - 78  - 93   - 108 ]
                                     [                    ]
                                     [ - 90  - 108  - 126 ]
          (%i9) dgemm(A,B,c=C,beta=1);
                                   [ - 27.0  - 34.0   - 41.0  ]
                                   [                          ]
          (%o9)                    [ - 60.0  - 76.0   - 92.0  ]
                                   [                          ]
                                   [ - 93.0  - 118.0  - 143.0 ]
          (%i10) A . B + C;
                                      [ - 27  - 34   - 41  ]
                                      [                    ]
          (%o10)                      [ - 60  - 76   - 92  ]
                                      [                    ]
                                      [ - 93  - 118  - 143 ]
          (%i11) dgemm(A,B,c=C,beta=1, alpha=-1);
                                      [ 33.0   38.0   43.0  ]
                                      [                     ]
          (%o11)                      [ 72.0   86.0   100.0 ]
                                      [                     ]
                                      [ 111.0  134.0  157.0 ]
          (%i12) -A . B + C;
                                         [ 33   38   43  ]
                                         [               ]
          (%o12)                         [ 72   86   100 ]
                                         [               ]
                                         [ 111  134  157 ]


 -- Function: zgeev
          zgeev (<A>)
          zgeev (<A>, <right_p>, <left_p>)

     Like ‘dgeev’, but the matrix <A> is complex.

 -- Function: zheev
          zheev (<A>)
          zheev (<A>, <eigvec_p>)

     Like ‘dgeev’, but the matrix <A> is assumed to be a square complex
     Hermitian matrix.  If <eigvec_p> is ‘true’, then the eigenvectors
     of the matrix are also computed.

     No check is made that the matrix <A> is, in fact, Hermitian.

     A list of two items is returned, as in ‘dgeev’: a list of
     eigenvalues, and ‘false’ or the matrix of the eigenvectors.

     An example of computing the eigenvalues and then eigenvalues and
     eigenvectors of an Hermitian matrix.
          (%i1) load("lapack")$
          (%i2) A: matrix(
               [9.14 +%i*0.00 ,   -4.37 -%i*9.22 ,  -1.98 -%i*1.72 ,  -8.96 -%i*9.50],
               [-4.37 +%i*9.22 ,  -3.35 +%i*0.00 ,   2.25 -%i*9.51 ,   2.57 +%i*2.40],
               [-1.98 +%i*1.72 ,   2.25 +%i*9.51 ,  -4.82 +%i*0.00 ,  -3.24 +%i*2.04],
               [-8.96 +%i*9.50 ,   2.57 -%i*2.40 ,  -3.24 -%i*2.04 ,   8.44 +%i*0.00]);
          (%o2)
            [      9.14       (- 9.22 %i) - 4.37  (- 1.72 %i) - 1.98  (- 9.5 %i) - 8.96 ]
            [                                                                           ]
            [ 9.22 %i - 4.37        - 3.35          2.25 - 9.51 %i      2.4 %i + 2.57   ]
            [                                                                           ]
            [ 1.72 %i - 1.98    9.51 %i + 2.25          - 4.82         2.04 %i - 3.24   ]
            [                                                                           ]
            [ 9.5 %i - 8.96     2.57 - 2.4 %i     (- 2.04 %i) - 3.24        8.44        ]
          (%i3) zheev(A);
          (%o3) [[- 16.00474647209473, - 6.764970154793324, 6.665711453507098,
                                                               25.51400517338097], false]
          (%i4) E:zheev(A,true)$
          (%i5) E[1];
          (%o5) [- 16.00474647209474, - 6.764970154793325, 6.665711453507101,
                                                                       25.51400517338096]
          (%i6) E[2];
                         [   0.2674650533172745 %i + 0.2175453586665017    ]
                         [                                                 ]
                         [  0.002696730886619885 %i + 0.6968836773391712   ]
          (%o6)  Col 1 = [                                                 ]
                         [ (- 0.6082406376714117 %i) - 0.01210614292697931 ]
                         [                                                 ]
                         [               0.1593081858095037                ]
                   [   0.2644937470667444 %i + 0.4773693349937472   ]
                   [                                                ]
                   [ (- 0.2852389036031621 %i) - 0.1414362742011673 ]
           Col 2 = [                                                ]
                   [   0.2654607680986639 %i + 0.4467818117184174   ]
                   [                                                ]
                   [               0.5750762708542709               ]
                   [   0.2810649767305922 %i - 0.1335263928245182   ]
                   [                                                ]
                   [   0.2866310132869556 %i - 0.4536971347853274   ]
           Col 3 = [                                                ]
                   [ (- 0.2933684323754295 %i) - 0.4954972425541057 ]
                   [                                                ]
                   [               0.5325337537576771               ]
                   [ (- 0.5737316575503476 %i) - 0.3966146799427706 ]
                   [                                                ]
                   [  0.01826502619021457 %i + 0.3530557704387017   ]
           Col 4 = [                                                ]
                   [  0.1673700900085425 %i + 0.01476684746229564   ]
                   [                                                ]
                   [               0.6002632636961784               ]


File: maxima.info,  Node: lbfgs-pkg,  Next: lindstedt-pkg,  Prev: lapack-pkg,  Up: Top

69 lbfgs
********

* Menu:

* Introduction to lbfgs::
* Functions and Variables for lbfgs::


File: maxima.info,  Node: Introduction to lbfgs,  Next: Functions and Variables for lbfgs,  Up: lbfgs-pkg

69.1 Introduction to lbfgs
==========================

‘lbfgs’ is an implementation of the L-BFGS algorithm [1] to solve
unconstrained minimization problems via a limited-memory quasi-Newton
(BFGS) algorithm.  It is called a limited-memory method because a
low-rank approximation of the Hessian matrix inverse is stored instead
of the entire Hessian inverse.  The program was originally written in
Fortran [2] by Jorge Nocedal, incorporating some functions originally
written by Jorge J. Moré and David J. Thuente, and translated into Lisp
automatically via the program ‘f2cl’.  The Maxima package ‘lbfgs’
comprises the translated code plus an interface function which manages
some details.

   References:

   [1] D. Liu and J. Nocedal.  "On the limited memory BFGS method for
large scale optimization".  Mathematical Programming B 45:503–528 (1989)

   [2] <https://www.netlib.org/opt/lbfgs_um.shar>


File: maxima.info,  Node: Functions and Variables for lbfgs,  Prev: Introduction to lbfgs,  Up: lbfgs-pkg

69.2 Functions and Variables for lbfgs
======================================

 -- Function: lbfgs
          lbfgs (<FOM>, <X>, <X0>, <epsilon>, <iprint>)
          lbfgs ([<FOM>, <grad>] <X>, <X0>, <epsilon>, <iprint>)

     Finds an approximate solution of the unconstrained minimization of
     the figure of merit <FOM> over the list of variables <X>, starting
     from initial estimates <X0>, such that norm(grad(FOM)) <
     epsilon*max(1, norm(X)).

     <grad>, if present, is the gradient of <FOM> with respect to the
     variables <X>.  <grad> may be a list or a function that returns a
     list, with one element for each element of <X>.  If not present,
     the gradient is computed automatically by symbolic differentiation.
     If <FOM> is a function, the gradient <grad> must be supplied by the
     user.

     The algorithm applied is a limited-memory quasi-Newton (BFGS)
     algorithm [1].  It is called a limited-memory method because a
     low-rank approximation of the Hessian matrix inverse is stored
     instead of the entire Hessian inverse.  Each iteration of the
     algorithm is a line search, that is, a search along a ray in the
     variables <X>, with the search direction computed from the
     approximate Hessian inverse.  The FOM is always decreased by a
     successful line search.  Usually (but not always) the norm of the
     gradient of FOM also decreases.

     <iprint> controls progress messages printed by ‘lbfgs’.

     ‘iprint[1]’
          ‘<iprint>[1]’ controls the frequency of progress messages.
          ‘iprint[1] < 0’
               No progress messages.
          ‘iprint[1] = 0’
               Messages at the first and last iterations.
          ‘iprint[1] > 0’
               Print a message every ‘<iprint>[1]’ iterations.
     ‘iprint[2]’
          ‘<iprint>[2]’ controls the verbosity of progress messages.
          ‘iprint[2] = 0’
               Print out iteration count, number of evaluations of
               <FOM>, value of <FOM>, norm of the gradient of <FOM>, and
               step length.
          ‘iprint[2] = 1’
               Same as ‘<iprint>[2] = 0’, plus <X0> and the gradient of
               <FOM> evaluated at <X0>.
          ‘iprint[2] = 2’
               Same as ‘<iprint>[2] = 1’, plus values of <X> at each
               iteration.
          ‘iprint[2] = 3’
               Same as ‘<iprint>[2] = 2’, plus the gradient of <FOM> at
               each iteration.

     The columns printed by ‘lbfgs’ are the following.

     ‘I’
          Number of iterations.  It is incremented for each line search.
     ‘NFN’
          Number of evaluations of the figure of merit.
     ‘FUNC’
          Value of the figure of merit at the end of the most recent
          line search.
     ‘GNORM’
          Norm of the gradient of the figure of merit at the end of the
          most recent line search.
     ‘STEPLENGTH’
          An internal parameter of the search algorithm.

     Additional information concerning details of the algorithm are
     found in the comments of the original Fortran code [2].

     See also ‘lbfgs_nfeval_max’ and ‘lbfgs_ncorrections’.

     References:

     [1] D. Liu and J. Nocedal.  "On the limited memory BFGS method for
     large scale optimization".  Mathematical Programming B 45:503–528
     (1989)

     [2] <https://www.netlib.org/opt/lbfgs_um.shar>

     Examples:

     The same FOM as computed by FGCOMPUTE in the program sdrive.f in
     the LBFGS package from Netlib.  Note that the variables in question
     are subscripted variables.  The FOM has an exact minimum equal to
     zero at u[k] = 1 for k = 1, ..., 8.

          (%i1) load ("lbfgs")$
          (%i2) t1[j] := 1 - u[j];
          (%o2)                     t1  := 1 - u
                                      j         j
          (%i3) t2[j] := 10*(u[j + 1] - u[j]^2);
                                                    2
          (%o3)                t2  := 10 (u      - u )
                                 j         j + 1    j
          (%i4) n : 8;
          (%o4)                           8
          (%i5) FOM : sum (t1[2*j - 1]^2 + t2[2*j - 1]^2, j, 1, n/2);
                           2 2           2              2 2           2
          (%o5) 100 (u  - u )  + (1 - u )  + 100 (u  - u )  + (1 - u )
                      8    7           7           6    5           5
                               2 2           2              2 2           2
                  + 100 (u  - u )  + (1 - u )  + 100 (u  - u )  + (1 - u )
                          4    3           3           2    1           1
          (%i6) lbfgs (FOM, '[u[1],u[2],u[3],u[4],u[5],u[6],u[7],u[8]],
                 [-1.2, 1, -1.2, 1, -1.2, 1, -1.2, 1], 1e-3, [1, 0]);
          *************************************************
            N=    8   NUMBER OF CORRECTIONS=25
                 INITIAL VALUES
           F=  9.680000000000000D+01   GNORM=  4.657353755084533D+02
          *************************************************
           I NFN   FUNC                    GNORM                   STEPLENGTH

           1   3   1.651479526340304D+01   4.324359291335977D+00   7.926153934390631D-04
           2   4   1.650209316638371D+01   3.575788161060007D+00   1.000000000000000D+00
           3   5   1.645461701312851D+01   6.230869903601577D+00   1.000000000000000D+00
           4   6   1.636867301275588D+01   1.177589920974980D+01   1.000000000000000D+00
           5   7   1.612153014409201D+01   2.292797147151288D+01   1.000000000000000D+00
           6   8   1.569118407390628D+01   3.687447158775571D+01   1.000000000000000D+00
           7   9   1.510361958398942D+01   4.501931728123679D+01   1.000000000000000D+00
           8  10   1.391077875774293D+01   4.526061463810630D+01   1.000000000000000D+00
           9  11   1.165625686278198D+01   2.748348965356907D+01   1.000000000000000D+00
          10  12   9.859422687859144D+00   2.111494974231706D+01   1.000000000000000D+00
          11  13   7.815442521732282D+00   6.110762325764183D+00   1.000000000000000D+00
          12  15   7.346380905773044D+00   2.165281166715009D+01   1.285316401779678D-01
          13  16   6.330460634066464D+00   1.401220851761508D+01   1.000000000000000D+00
          14  17   5.238763939854303D+00   1.702473787619218D+01   1.000000000000000D+00
          15  18   3.754016790406625D+00   7.981845727632704D+00   1.000000000000000D+00
          16  20   3.001238402313225D+00   3.925482944745832D+00   2.333129631316462D-01
          17  22   2.794390709722064D+00   8.243329982586480D+00   2.503577283802312D-01
          18  23   2.563783562920545D+00   1.035413426522664D+01   1.000000000000000D+00
          19  24   2.019429976373283D+00   1.065187312340952D+01   1.000000000000000D+00
          20  25   1.428003167668592D+00   2.475962450735100D+00   1.000000000000000D+00
          21  27   1.197874264859232D+00   8.441707983339661D+00   4.303451060697367D-01
          22  28   9.023848942003913D-01   1.113189216665625D+01   1.000000000000000D+00
          23  29   5.508226405855795D-01   2.380830599637816D+00   1.000000000000000D+00
          24  31   3.902893258879521D-01   5.625595817143044D+00   4.834988416747262D-01
          25  32   3.207542206881058D-01   1.149444645298493D+01   1.000000000000000D+00
          26  33   1.874468266118200D-01   3.632482152347445D+00   1.000000000000000D+00
          27  34   9.575763380282112D-02   4.816497449000391D+00   1.000000000000000D+00
          28  35   4.085145106760390D-02   2.087009347116811D+00   1.000000000000000D+00
          29  36   1.931106005512628D-02   3.886818624052740D+00   1.000000000000000D+00
          30  37   6.894000636920714D-03   3.198505769992936D+00   1.000000000000000D+00
          31  38   1.443296008850287D-03   1.590265460381961D+00   1.000000000000000D+00
          32  39   1.571766574930155D-04   3.098257002223532D-01   1.000000000000000D+00
          33  40   1.288011779655132D-05   1.207784334505595D-02   1.000000000000000D+00
          34  41   1.806140190993455D-06   4.587890258846915D-02   1.000000000000000D+00
          35  42   1.769004612050548D-07   1.790537363138099D-02   1.000000000000000D+00
          36  43   3.312164244118216D-10   6.782068546986653D-04   1.000000000000000D+00

           THE MINIMIZATION TERMINATED WITHOUT DETECTING ERRORS.
           IFLAG = 0
          (%o6) [u  = 1.000005339816132, u  = 1.000009942840108,
                  1                       2
          u  = 1.000005339816132, u  = 1.000009942840108,
           3                       4
          u  = 1.000005339816132, u  = 1.000009942840108,
           5                       6
          u  = 1.000005339816132, u  = 1.000009942840108]
           7                       8

     A regression problem.  The FOM is the mean square difference
     between the predicted value F(X[i]) and the observed value Y[i].
     The function F is a bounded monotone function (a so-called
     "sigmoidal" function).  In this example, ‘lbfgs’ computes
     approximate values for the parameters of F and ‘plot2d’ displays a
     comparison of F with the observed data.

          (%i1) load ("lbfgs")$
          (%i2) FOM : '((1/length(X))*sum((F(X[i]) - Y[i])^2, i, 1,
                                                          length(X)));
                                         2
                         sum((F(X ) - Y ) , i, 1, length(X))
                                 i     i
          (%o2)          -----------------------------------
                                      length(X)
          (%i3) X : [1, 2, 3, 4, 5];
          (%o3)                    [1, 2, 3, 4, 5]
          (%i4) Y : [0, 0.5, 1, 1.25, 1.5];
          (%o4)                [0, 0.5, 1, 1.25, 1.5]
          (%i5) F(x) := A/(1 + exp(-B*(x - C)));
                                             A
          (%o5)            F(x) := ----------------------
                                   1 + exp((- B) (x - C))
          (%i6) ''FOM;
                          A               2            A                2
          (%o6) ((----------------- - 1.5)  + (----------------- - 1.25)
                    - B (5 - C)                  - B (4 - C)
                  %e            + 1            %e            + 1
                      A             2            A               2
           + (----------------- - 1)  + (----------------- - 0.5)
                - B (3 - C)                - B (2 - C)
              %e            + 1          %e            + 1
                       2
                      A
           + --------------------)/5
                - B (1 - C)     2
             (%e            + 1)
          (%i7) estimates : lbfgs (FOM, '[A, B, C], [1, 1, 1], 1e-4, [1, 0]);
          *************************************************
            N=    3   NUMBER OF CORRECTIONS=25
                 INITIAL VALUES
           F=  1.348738534246918D-01   GNORM=  2.000215531936760D-01
          *************************************************

          I  NFN  FUNC                    GNORM                   STEPLENGTH
          1    3  1.177820636622582D-01   9.893138394953992D-02   8.554435968992371D-01
          2    6  2.302653892214013D-02   1.180098521565904D-01   2.100000000000000D+01
          3    8  1.496348495303004D-02   9.611201567691624D-02   5.257340567840710D-01
          4    9  7.900460841091138D-03   1.325041647391314D-02   1.000000000000000D+00
          5   10  7.314495451266914D-03   1.510670810312226D-02   1.000000000000000D+00
          6   11  6.750147275936668D-03   1.914964958023037D-02   1.000000000000000D+00
          7   12  5.850716021108202D-03   1.028089194579382D-02   1.000000000000000D+00
          8   13  5.778664230657800D-03   3.676866074532179D-04   1.000000000000000D+00
          9   14  5.777818823650780D-03   3.010740179797108D-04   1.000000000000000D+00

           THE MINIMIZATION TERMINATED WITHOUT DETECTING ERRORS.
           IFLAG = 0
          (%o7) [A = 1.461933911464101, B = 1.601593973254801,
                                                     C = 2.528933072164855]
          (%i8) plot2d ([F(x), [discrete, X, Y]], [x, -1, 6]), ''estimates;
          (%o8)

     Gradient of FOM is specified (instead of computing it
     automatically).  Both the FOM and its gradient are passed as
     functions to ‘lbfgs’.

          (%i1) load ("lbfgs")$
          (%i2) F(a, b, c) := (a - 5)^2 + (b - 3)^4 + (c - 2)^6$
          (%i3) define(F_grad(a, b, c),
                       map (lambda ([x], diff (F(a, b, c), x)), [a, b, c]))$
          (%i4) estimates : lbfgs ([F, F_grad],
                             [a, b, c], [0, 0, 0], 1e-4, [1, 0]);
          *************************************************
            N=    3   NUMBER OF CORRECTIONS=25
                 INITIAL VALUES
           F=  1.700000000000000D+02   GNORM=  2.205175729958953D+02
          *************************************************

             I  NFN     FUNC                    GNORM                   STEPLENGTH

             1    2     6.632967565917637D+01   6.498411132518770D+01   4.534785987412505D-03
             2    3     4.368890936228036D+01   3.784147651974131D+01   1.000000000000000D+00
             3    4     2.685298972775191D+01   1.640262125898520D+01   1.000000000000000D+00
             4    5     1.909064767659852D+01   9.733664001790506D+00   1.000000000000000D+00
             5    6     1.006493272061515D+01   6.344808151880209D+00   1.000000000000000D+00
             6    7     1.215263596054292D+00   2.204727876126877D+00   1.000000000000000D+00
             7    8     1.080252896385329D-02   1.431637116951845D-01   1.000000000000000D+00
             8    9     8.407195124830860D-03   1.126344579730008D-01   1.000000000000000D+00
             9   10     5.022091686198525D-03   7.750731829225275D-02   1.000000000000000D+00
            10   11     2.277152808939775D-03   5.032810859286796D-02   1.000000000000000D+00
            11   12     6.489384688303218D-04   1.932007150271009D-02   1.000000000000000D+00
            12   13     2.075791943844547D-04   6.964319310814365D-03   1.000000000000000D+00
            13   14     7.349472666162258D-05   4.017449067849554D-03   1.000000000000000D+00
            14   15     2.293617477985238D-05   1.334590390856715D-03   1.000000000000000D+00
            15   16     7.683645404048675D-06   6.011057038099202D-04   1.000000000000000D+00

           THE MINIMIZATION TERMINATED WITHOUT DETECTING ERRORS.
           IFLAG = 0
          (%o4) [a = 5.000086823042934, b = 3.052395429705181,
                                                     c = 1.927980629919583]

 -- Variable: lbfgs_nfeval_max
     Default value: 100

     ‘lbfgs_nfeval_max’ is the maximum number of evaluations of the
     figure of merit (FOM) in ‘lbfgs’.  When ‘lbfgs_nfeval_max’ is
     reached, ‘lbfgs’ returns the result of the last successful line
     search.

 -- Variable: lbfgs_ncorrections
     Default value: 25

     ‘lbfgs_ncorrections’ is the number of corrections applied to the
     approximate inverse Hessian matrix which is maintained by ‘lbfgs’.


File: maxima.info,  Node: lindstedt-pkg,  Next: linearalgebra-pkg,  Prev: lbfgs-pkg,  Up: Top

70 lindstedt
************

* Menu:

* Functions and Variables for lindstedt::


File: maxima.info,  Node: Functions and Variables for lindstedt,  Prev: lindstedt-pkg,  Up: lindstedt-pkg

70.1 Functions and Variables for lindstedt
==========================================

 -- Function: Lindstedt (<eq>,<pvar>,<torder>,<ic>)
     This is a first pass at a Lindstedt code.  It can solve problems
     with initial conditions entered, which can be arbitrary constants,
     (just not <%k1> and <%k2>) where the initial conditions on the
     perturbation equations are z[i]=0, z'[i]=0 for i>0.  <ic> is the
     list of initial conditions.

     Problems occur when initial conditions are not given, as the
     constants in the perturbation equations are the same as the zero
     order equation solution.  Also, problems occur when the initial
     conditions for the perturbation equations are not z[i]=0, z'[i]=0
     for i>0, such as the Van der Pol equation.

     Example:
          (%i1) load("makeOrders")$

          (%i2) load("lindstedt")$

          (%i3) Lindstedt('diff(x,t,2)+x-(e*x^3)/6,e,2,[1,0]);
                    2
                   e  (cos(5 T) - 24 cos(3 T) + 23 cos(T))
          (%o3) [[[---------------------------------------
                                    36864
             e (cos(3 T) - cos(T))
           - --------------------- + cos(T)],
                      192
                    2
                 7 e    e
          T = (- ---- - -- + 1) t]]
                 3072   16

     To use this function write first ‘load("makeOrders")’ and
     ‘load("lindstedt")’.


File: maxima.info,  Node: linearalgebra-pkg,  Next: lsquares-pkg,  Prev: lindstedt-pkg,  Up: Top

71 linearalgebra
****************

* Menu:

* Introduction to linearalgebra::
* Functions and Variables for linearalgebra::


File: maxima.info,  Node: Introduction to linearalgebra,  Next: Functions and Variables for linearalgebra,  Up: linearalgebra-pkg

71.1 Introduction to linearalgebra
==================================

‘linearalgebra’ is a collection of functions for linear algebra.

   Example:

     (%i1) M : matrix ([1, 2], [1, 2]);
                                 [ 1  2 ]
     (%o1)                       [      ]
                                 [ 1  2 ]
     (%i2) nullspace (M);
                                    [  1  ]
                                    [     ]
     (%o2)                     span([   1 ])
                                    [ - - ]
                                    [   2 ]
     (%i3) columnspace (M);
                                     [ 1 ]
     (%o3)                      span([   ])
                                     [ 1 ]
     (%i4) ptriangularize (M - z*ident(2), z);
                              [ 1   2 - z   ]
     (%o4)                    [             ]
                              [           2 ]
                              [ 0  3 z - z  ]
     (%i5) M : matrix ([1, 2, 3], [4, 5, 6], [7, 8, 9]) - z*ident(3);
                          [ 1 - z    2      3   ]
                          [                     ]
     (%o5)                [   4    5 - z    6   ]
                          [                     ]
                          [   7      8    9 - z ]
     (%i6) MM : ptriangularize (M, z);
                   [ 4  5 - z            6            ]
                   [                                  ]
                   [                2                 ]
                   [     66        z    102 z   132   ]
                   [ 0   --      - -- + ----- + ---   ]
     (%o6)         [     49        7     49     49    ]
                   [                                  ]
                   [               3        2         ]
                   [           49 z    245 z    147 z ]
                   [ 0    0    ----- - ------ - ----- ]
                   [            264      88      44   ]
     (%i7) algebraic : true;
     (%o7)                         true
     (%i8) tellrat (MM [3, 3]);
                              3       2
     (%o8)                  [z  - 15 z  - 18 z]
     (%i9) MM : ratsimp (MM);
                    [ 4  5 - z           6           ]
                    [                                ]
                    [                2               ]
     (%o9)          [     66      7 z  - 102 z - 132 ]
                    [ 0   --    - ------------------ ]
                    [     49              49         ]
                    [                                ]
                    [ 0    0             0           ]
     (%i10) nullspace (MM);
                             [        1         ]
                             [                  ]
                             [   2              ]
                             [  z  - 14 z - 16  ]
                             [  --------------  ]
     (%o10)             span([        8         ])
                             [                  ]
                             [    2             ]
                             [   z  - 18 z - 12 ]
                             [ - -------------- ]
                             [         12       ]
     (%i11) M : matrix ([1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12],
                        [13, 14, 15, 16]);
                            [ 1   2   3   4  ]
                            [                ]
                            [ 5   6   7   8  ]
     (%o11)                 [                ]
                            [ 9   10  11  12 ]
                            [                ]
                            [ 13  14  15  16 ]
     (%i12) columnspace (M);
                                [ 1  ]  [ 2  ]
                                [    ]  [    ]
                                [ 5  ]  [ 6  ]
     (%o12)                span([    ], [    ])
                                [ 9  ]  [ 10 ]
                                [    ]  [    ]
                                [ 13 ]  [ 14 ]
     (%i13) apply ('orthogonal_complement, args (nullspace (transpose (M))));
                                [ 0 ]  [  1  ]
                                [   ]  [     ]
                                [ 1 ]  [  0  ]
     (%o13)                span([   ], [     ])
                                [ 2 ]  [ - 1 ]
                                [   ]  [     ]
                                [ 3 ]  [ - 2 ]


File: maxima.info,  Node: Functions and Variables for linearalgebra,  Prev: Introduction to linearalgebra,  Up: linearalgebra-pkg

71.2 Functions and Variables for linearalgebra
==============================================

 -- Function: addmatrices (<f>, <M_1>, ..., <M_n>)

     Using the function <f> as the addition function, return the sum of
     the matrices <M_1>, ..., <M_n>.  The function <f> must accept any
     number of arguments (a Maxima nary function).

     Examples:

          (%i1) m1 : matrix([1,2],[3,4])$
          (%i2) m2 : matrix([7,8],[9,10])$
          (%i3) addmatrices('max,m1,m2);
          (%o3) matrix([7,8],[9,10])
          (%i4) addmatrices('max,m1,m2,5*m1);
          (%o4) matrix([7,10],[15,20])

 -- Function: blockmatrixp (<M>)

     Return true if and only if <M> is a matrix and every entry of <M>
     is a matrix.

 -- Function: columnop (<M>, <i>, <j>, <theta>)

     If <M> is a matrix, return the matrix that results from doing the
     column operation ‘C_i <- C_i - <theta> * C_j’.  If <M> doesn’t have
     a row <i> or <j>, signal an error.

 -- Function: columnswap (<M>, <i>, <j>)

     If <M> is a matrix, swap columns <i> and <j>.  If <M> doesn’t have
     a column <i> or <j>, signal an error.

 -- Function: columnspace (<M>)

     If <M> is a matrix, return ‘span (v_1, ..., v_n)’, where the set
     ‘{v_1, ..., v_n}’ is a basis for the column space of <M>.  The span
     of the empty set is ‘{0}’.  Thus, when the column space has only
     one member, return ‘span ()’.

 -- Function: cholesky
          cholesky (<M>)
          cholesky (<M>, <field>)

     Return the Cholesky factorization of the matrix selfadjoint (or
     hermitian) matrix <M>.  The second argument defaults to
     ’generalring.’ For a description of the possible values for
     <field>, see ‘lu_factor’.

 -- Function: ctranspose (<M>)

     Return the complex conjugate transpose of the matrix <M>.  The
     function ‘ctranspose’ uses ‘matrix_element_transpose’ to transpose
     each matrix element.

 -- Function: diag_matrix (<d_1>, <d_2>, ..., <d_n>)

     Return a diagonal matrix with diagonal entries <d_1>, <d_2>, ...,
     <d_n>.  When the diagonal entries are matrices, the zero entries of
     the returned matrix are zero matrices of the appropriate size; for
     example:

          (%i1) diag_matrix(diag_matrix(1,2),diag_matrix(3,4));

                                      [ [ 1  0 ]  [ 0  0 ] ]
                                      [ [      ]  [      ] ]
                                      [ [ 0  2 ]  [ 0  0 ] ]
          (%o1)                       [                    ]
                                      [ [ 0  0 ]  [ 3  0 ] ]
                                      [ [      ]  [      ] ]
                                      [ [ 0  0 ]  [ 0  4 ] ]
          (%i2) diag_matrix(p,q);

                                             [ p  0 ]
          (%o2)                              [      ]
                                             [ 0  q ]

 -- Function: dotproduct (<u>, <v>)

     Return the dotproduct of vectors <u> and <v>.  This is the same as
     ‘conjugate (transpose (<u>)) . <v>’.  The arguments <u> and <v>
     must be column vectors.

 -- Function: eigens_by_jacobi
          eigens_by_jacobi (<A>)
          eigens_by_jacobi (<A>, <field_type>)

     Computes the eigenvalues and eigenvectors of <A> by the method of
     Jacobi rotations.  <A> must be a symmetric matrix (but it need not
     be positive definite nor positive semidefinite).  <field_type>
     indicates the computational field, either ‘floatfield’ or
     ‘bigfloatfield’.  If <field_type> is not specified, it defaults to
     ‘floatfield’.

     The elements of <A> must be numbers or expressions which evaluate
     to numbers via ‘float’ or ‘bfloat’ (depending on <field_type>).

     Examples:

          (%i1) S: matrix([1/sqrt(2), 1/sqrt(2)],[-1/sqrt(2), 1/sqrt(2)]);
                               [     1         1    ]
                               [  -------   ------- ]
                               [  sqrt(2)   sqrt(2) ]
          (%o1)                [                    ]
                               [      1        1    ]
                               [ - -------  ------- ]
                               [   sqrt(2)  sqrt(2) ]
          (%i2) L : matrix ([sqrt(3), 0], [0, sqrt(5)]);
                                [ sqrt(3)     0    ]
          (%o2)                 [                  ]
                                [    0     sqrt(5) ]
          (%i3) M : S . L . transpose (S);
                      [ sqrt(5)   sqrt(3)  sqrt(5)   sqrt(3) ]
                      [ ------- + -------  ------- - ------- ]
                      [    2         2        2         2    ]
          (%o3)       [                                      ]
                      [ sqrt(5)   sqrt(3)  sqrt(5)   sqrt(3) ]
                      [ ------- - -------  ------- + ------- ]
                      [    2         2        2         2    ]
          (%i4) eigens_by_jacobi (M);
          The largest percent change was 0.1454972243679
          The largest percent change was 0.0
          number of sweeps: 2
          number of rotations: 1
          (%o4) [[1.732050807568877, 2.23606797749979],
                                  [  0.70710678118655   0.70710678118655 ]
                                  [                                      ]]
                                  [ - 0.70710678118655  0.70710678118655 ]
          (%i5) float ([[sqrt(3), sqrt(5)], S]);
          (%o5) [[1.732050807568877, 2.23606797749979],
                                  [  0.70710678118655   0.70710678118655 ]
                                  [                                      ]]
                                  [ - 0.70710678118655  0.70710678118655 ]
          (%i6) eigens_by_jacobi (M, bigfloatfield);
          The largest percent change was 1.454972243679028b-1
          The largest percent change was 0.0b0
          number of sweeps: 2
          number of rotations: 1
          (%o6) [[1.732050807568877b0, 2.23606797749979b0],
                          [  7.071067811865475b-1   7.071067811865475b-1 ]
                          [                                              ]]
                          [ - 7.071067811865475b-1  7.071067811865475b-1 ]

 -- Function: get_lu_factors (<x>)

     When ‘<x> = lu_factor (<A>)’, then ‘get_lu_factors’ returns a list
     of the form ‘[P, L, U]’, where <P> is a permutation matrix, <L> is
     lower triangular with ones on the diagonal, and <U> is upper
     triangular, and ‘<A> = <P> <L> <U>’.

 -- Function: hankel
          hankel (<col>)
          hankel (<col>, <row>)

     Return a Hankel matrix <H>.  The first column of <H> is <col>;
     except for the first entry, the last row of <H> is <row>.  The
     default for <row> is the zero vector with the same length as <col>.

 -- Function: hessian (<f>, <x>)

     Returns the Hessian matrix of <f> with respect to the list of
     variables <x>.  The ‘(i, j)’-th element of the Hessian matrix is
     ‘diff(<f>, <x>[i], 1, <x>[j], 1)’.

     Examples:

          (%i1) hessian (x * sin (y), [x, y]);
                               [   0       cos(y)   ]
          (%o1)                [                    ]
                               [ cos(y)  - x sin(y) ]
          (%i2) depends (F, [a, b]);
          (%o2)                       [F(a, b)]
          (%i3) hessian (F, [a, b]);
                                  [   2      2   ]
                                  [  d F    d F  ]
                                  [  ---   ----- ]
                                  [    2   da db ]
                                  [  da          ]
          (%o3)                   [              ]
                                  [   2      2   ]
                                  [  d F    d F  ]
                                  [ -----   ---  ]
                                  [ da db     2  ]
                                  [         db   ]

 -- Function: hilbert_matrix (<n>)

     Return the <n> by <n> Hilbert matrix.  When <n> isn’t a positive
     integer, signal an error.

 -- Function: identfor
          identfor (<M>)
          identfor (<M>, <fld>)

     Return an identity matrix that has the same shape as the matrix
     <M>.  The diagonal entries of the identity matrix are the
     multiplicative identity of the field <fld>; the default for <fld>
     is <generalring>.

     The first argument <M> should be a square matrix or a non-matrix.
     When <M> is a matrix, each entry of <M> can be a square matrix –
     thus <M> can be a blocked Maxima matrix.  The matrix can be blocked
     to any (finite) depth.

     See also ‘zerofor’

 -- Function: invert_by_lu (<M>, <(rng generalring)>)

     Invert a matrix <M> by using the LU factorization.  The LU
     factorization is done using the ring <rng>.

 -- Function: jacobian (<f>, <x>)

     Returns the Jacobian matrix of the list of functions <f> with
     respect to the list of variables <x>.  The ‘(i, j)’-th element of
     the Jacobian matrix is ‘diff(<f>[i], <x>[j])’.

     Examples:

          (%i1) jacobian ([sin (u - v), sin (u * v)], [u, v]);
                            [ cos(v - u)  - cos(v - u) ]
          (%o1)             [                          ]
                            [ v cos(u v)   u cos(u v)  ]
          (%i2) depends ([F, G], [y, z]);
          (%o2)                  [F(y, z), G(y, z)]
          (%i3) jacobian ([F, G], [y, z]);
                                     [ dF  dF ]
                                     [ --  -- ]
                                     [ dy  dz ]
          (%o3)                      [        ]
                                     [ dG  dG ]
                                     [ --  -- ]
                                     [ dy  dz ]

 -- Function: kronecker_product (<A>, <B>)

     Return the Kronecker product of the matrices <A> and <B>.

 -- Function: listp
          listp (<e>, <p>)
          listp (<e>)

     Given an optional argument <p>, return ‘true’ if <e> is a Maxima
     list and <p> evaluates to ‘true’ for every list element.  When
     ‘listp’ is not given the optional argument, return ‘true’ if <e> is
     a Maxima list.  In all other cases, return ‘false’.

 -- Function: locate_matrix_entry (<M>, <r_1>, <c_1>, <r_2>, <c_2>, <f>,
          <rel>)

     The first argument must be a matrix; the arguments <r_1> through
     <c_2> determine a sub-matrix of <M> that consists of rows <r_1>
     through <r_2> and columns <c_1> through <c_2>.

     Find an entry in the sub-matrix <M> that satisfies some property.
     Three cases:

     (1) ‘<rel> = 'bool’ and <f> a predicate:

     Scan the sub-matrix from left to right then top to bottom, and
     return the index of the first entry that satisfies the predicate
     <f>.  If no matrix entry satisfies <f>, return ‘false’.

     (2) ‘<rel> = 'max’ and <f> real-valued:

     Scan the sub-matrix looking for an entry that maximizes <f>.
     Return the index of a maximizing entry.

     (3) ‘<rel> = 'min’ and <f> real-valued:

     Scan the sub-matrix looking for an entry that minimizes <f>.
     Return the index of a minimizing entry.

 -- Function: lu_backsub (<M>, <b>)

     When ‘<M> = lu_factor (<A>, <field>)’, then ‘lu_backsub (<M>, <b>)’
     solves the linear system ‘<A> <x> = <b>’.

     The <n> by <m> matrix ‘<b>’, with <n> the number of rows of the
     matrix ‘<A>’, contains one right hand side per column.  If there is
     only one right hand side then ‘<b>’ must be a <n> by 1 matrix.

     Each column of the matrix ‘<x>=lu_backsub (<M>, <b>)’ is the
     solution corresponding to the respective column of ‘<b>’.

     Examples:

          (%i1) A : matrix ([1 - z, 3], [3, 8 - z]);
                                         [ 1 - z    3   ]
          (%o1)                          [              ]
                                         [   3    8 - z ]
          (%i2) M : lu_factor (A,generalring);
                         [ 1 - z          3         ]
                         [                          ]
          (%o2)         [[   3              9       ], [1, 2], generalring]
                         [ -----  (- z) - ----- + 8 ]
                         [ 1 - z          1 - z     ]
          (%i3) b : matrix([a],[c]);
                                               [ a ]
          (%o3)                                [   ]
                                               [ c ]
          (%i4) x : lu_backsub(M,b);
                                     [               3 a     ]
                                     [       3 (c - -----)   ]
                                     [              1 - z    ]
                                     [ a - ----------------- ]
                                     [               9       ]
                                     [     (- z) - ----- + 8 ]
                                     [             1 - z     ]
                                     [ --------------------- ]
          (%o4)                      [         1 - z         ]
                                     [                       ]
                                     [            3 a        ]
                                     [       c - -----       ]
                                     [           1 - z       ]
                                     [   -----------------   ]
                                     [             9         ]
                                     [   (- z) - ----- + 8   ]
                                     [           1 - z       ]
          (%i5) ratsimp(A . x - b);
                                               [ 0 ]
          (%o5)                                [   ]
                                               [ 0 ]
          (%i6) B : matrix([a,d],[c,f]);
                                             [ a  d ]
          (%o6)                              [      ]
                                             [ c  f ]
          (%i7) x : lu_backsub(M,B);
                         [               3 a                    3 d     ]
                         [       3 (c - -----)          3 (f - -----)   ]
                         [              1 - z                  1 - z    ]
                         [ a - -----------------  d - ----------------- ]
                         [               9                      9       ]
                         [     (- z) - ----- + 8      (- z) - ----- + 8 ]
                         [             1 - z                  1 - z     ]
                         [ ---------------------  --------------------- ]
          (%o7)          [         1 - z                  1 - z         ]
                         [                                              ]
                         [            3 a                    3 d        ]
                         [       c - -----              f - -----       ]
                         [           1 - z                  1 - z       ]
                         [   -----------------      -----------------   ]
                         [             9                      9         ]
                         [   (- z) - ----- + 8      (- z) - ----- + 8   ]
                         [           1 - z                  1 - z       ]
          (%i8) ratsimp(A . x - B);
                                             [ 0  0 ]
          (%o8)                              [      ]
                                             [ 0  0 ]

 -- Function: lu_factor (<M>, <field>)

     Return a list of the form ‘[<LU>, <perm>, <fld>]’, or ‘[<LU>,
     <perm>, <fld>, <lower-cnd> <upper-cnd>]’, where

     (1) The matrix <LU> contains the factorization of <M> in a packed
     form.  Packed form means three things: First, the rows of <LU> are
     permuted according to the list <perm>.  If, for example, <perm> is
     the list ‘[3,2,1]’, the actual first row of the <LU> factorization
     is the third row of the matrix <LU>.  Second, the lower triangular
     factor of m is the lower triangular part of <LU> with the diagonal
     entries replaced by all ones.  Third, the upper triangular factor
     of <M> is the upper triangular part of <LU>.

     (2) When the field is either ‘floatfield’ or ‘complexfield’, the
     numbers <lower-cnd> and <upper-cnd> are lower and upper bounds for
     the infinity norm condition number of <M>.  For all fields, the
     condition number might not be estimated; for such fields,
     ‘lu_factor’ returns a two item list.  Both the lower and upper
     bounds can differ from their true values by arbitrarily large
     factors.  (See also ‘mat_cond’.)

     The argument <M> must be a square matrix.

     The optional argument <fld> must be a symbol that determines a ring
     or field.  The pre-defined fields and rings are:

     (a) ‘generalring’ – the ring of Maxima expressions,

     (b) ‘floatfield’ – the field of floating point numbers of the type
     double,

     (c) ‘complexfield’ – the field of complex floating point numbers of
     the type double,

     (d) ‘crering’ – the ring of Maxima CRE expressions,

     (e) ‘rationalfield’ – the field of rational numbers,

     (f) ‘runningerror’ – track the all floating point rounding errors,

     (g) ‘noncommutingring’ – the ring of Maxima expressions where
     multiplication is the non-commutative dot operator.

     When the field is ‘floatfield’, ‘complexfield’, or ‘runningerror’,
     the algorithm uses partial pivoting; for all other fields, rows are
     switched only when needed to avoid a zero pivot.

     Floating point addition arithmetic isn’t associative, so the
     meaning of ’field’ differs from the mathematical definition.

     A member of the field ‘runningerror’ is a two member Maxima list of
     the form ‘[x,n]’,where <x> is a floating point number and ‘n’ is an
     integer.  The relative difference between the ’true’ value of ‘x’
     and ‘x’ is approximately bounded by the machine epsilon times ‘n’.
     The running error bound drops some terms that of the order the
     square of the machine epsilon.

     There is no user-interface for defining a new field.  A user that
     is familiar with Common Lisp should be able to define a new field.
     To do this, a user must define functions for the arithmetic
     operations and functions for converting from the field
     representation to Maxima and back.  Additionally, for ordered
     fields (where partial pivoting will be used), a user must define
     functions for the magnitude and for comparing field members.  After
     that all that remains is to define a Common Lisp structure ‘mring’.
     The file ‘mring’ has many examples.

     To compute the factorization, the first task is to convert each
     matrix entry to a member of the indicated field.  When conversion
     isn’t possible, the factorization halts with an error message.
     Members of the field needn’t be Maxima expressions.  Members of the
     ‘complexfield’, for example, are Common Lisp complex numbers.  Thus
     after computing the factorization, the matrix entries must be
     converted to Maxima expressions.

     See also ‘get_lu_factors’.

     Examples:

          (%i1) w[i,j] := random (1.0) + %i * random (1.0);
          (%o1)          w     := random(1.) + %i random(1.)
                          i, j
          (%i2) showtime : true$
          Evaluation took 0.00 seconds (0.00 elapsed)
          (%i3) M : genmatrix (w, 100, 100)$
          Evaluation took 7.40 seconds (8.23 elapsed)
          (%i4) lu_factor (M, complexfield)$
          Evaluation took 28.71 seconds (35.00 elapsed)
          (%i5) lu_factor (M, generalring)$
          Evaluation took 109.24 seconds (152.10 elapsed)
          (%i6) showtime : false$

          (%i7) M : matrix ([1 - z, 3], [3, 8 - z]);
                                  [ 1 - z    3   ]
          (%o7)                   [              ]
                                  [   3    8 - z ]
          (%i8) lu_factor (M, generalring);
                    [ 1 - z         3        ]
                    [                        ]
          (%o8)    [[   3            9       ], [1, 2], generalring]
                    [ -----  - z - ----- + 8 ]
                    [ 1 - z        1 - z     ]
          (%i9) get_lu_factors (%);
                            [   1    0 ]  [ 1 - z         3        ]
                  [ 1  0 ]  [          ]  [                        ]
          (%o9)  [[      ], [   3      ], [                9       ]]
                  [ 0  1 ]  [ -----  1 ]  [   0    - z - ----- + 8 ]
                            [ 1 - z    ]  [              1 - z     ]
          (%i10) %[1] . %[2] . %[3];
                                  [ 1 - z    3   ]
          (%o10)                  [              ]
                                  [   3    8 - z ]

 -- Function: mat_cond
          mat_cond (<M>, 1)
          mat_cond (<M>, inf)

     Return the <p>-norm matrix condition number of the matrix <m>.  The
     allowed values for <p> are 1 and <inf>.  This function uses the LU
     factorization to invert the matrix <m>.  Thus the running time for
     ‘mat_cond’ is proportional to the cube of the matrix size;
     ‘lu_factor’ determines lower and upper bounds for the infinity norm
     condition number in time proportional to the square of the matrix
     size.

 -- Function: mat_norm
          mat_norm (<M>, 1)
          mat_norm (<M>, inf)
          mat_norm (<M>, frobenius)

     Return the matrix <p>-norm of the matrix <M>.  The allowed values
     for <p> are 1, ‘inf’, and ‘frobenius’ (the Frobenius matrix norm).
     The matrix <M> should be an unblocked matrix.

 -- Function: matrixp
          matrixp (<e>, <p>)
          matrixp (<e>)

     Given an optional argument <p>, return ‘true’ if <e> is a matrix
     and <p> evaluates to ‘true’ for every matrix element.  When
     ‘matrixp’ is not given an optional argument, return ‘true’ if ‘e’
     is a matrix.  In all other cases, return ‘false’.

     See also ‘blockmatrixp’

 -- Function: matrix_size (<M>)

     Return a two member list that gives the number of rows and columns,
     respectively of the matrix <M>.

 -- Function: mat_fullunblocker (<M>)

     If <M> is a block matrix, unblock the matrix to all levels.  If <M>
     is a matrix, return <M>; otherwise, signal an error.

 -- Function: mat_trace (<M>)

     Return the trace of the matrix <M>.  If <M> isn’t a matrix, return
     a noun form.  When <M> is a block matrix, ‘mat_trace(M)’ returns
     the same value as does ‘mat_trace(mat_unblocker(m))’.

 -- Function: mat_unblocker (<M>)

     If <M> is a block matrix, unblock <M> one level.  If <M> is a
     matrix, ‘mat_unblocker (M)’ returns <M>; otherwise, signal an
     error.

     Thus if each entry of <M> is matrix, ‘mat_unblocker (M)’ returns an
     unblocked matrix, but if each entry of <M> is a block matrix,
     ‘mat_unblocker (M)’ returns a block matrix with one less level of
     blocking.

     If you use block matrices, most likely you’ll want to set
     ‘matrix_element_mult’ to ‘"."’ and ‘matrix_element_transpose’ to
     ‘'transpose’.  See also ‘mat_fullunblocker’.

     Example:

          (%i1) A : matrix ([1, 2], [3, 4]);
                                      [ 1  2 ]
          (%o1)                       [      ]
                                      [ 3  4 ]
          (%i2) B : matrix ([7, 8], [9, 10]);
                                      [ 7  8  ]
          (%o2)                       [       ]
                                      [ 9  10 ]
          (%i3) matrix ([A, B]);
                               [ [ 1  2 ]  [ 7  8  ] ]
          (%o3)                [ [      ]  [       ] ]
                               [ [ 3  4 ]  [ 9  10 ] ]
          (%i4) mat_unblocker (%);
                                   [ 1  2  7  8  ]
          (%o4)                    [             ]
                                   [ 3  4  9  10 ]

 -- Function: nullspace (<M>)

     If <M> is a matrix, return ‘span (v_1, ..., v_n)’, where the set
     ‘{v_1, ..., v_n}’ is a basis for the nullspace of <M>.  The span of
     the empty set is ‘{0}’.  Thus, when the nullspace has only one
     member, return ‘span ()’.

 -- Function: nullity (<M>)

     If <M> is a matrix, return the dimension of the nullspace of <M>.

 -- Function: orthogonal_complement (<v_1>, ..., <v_n>)

     Return ‘span (u_1, ..., u_m)’, where the set ‘{u_1, ..., u_m}’ is a
     basis for the orthogonal complement of the set ‘(v_1, ..., v_n)’.

     Each vector <v_1> through <v_n> must be a column vector.

 -- Function: polytocompanion (<p>, <x>)

     If <p> is a polynomial in <x>, return the companion matrix of <p>.
     For a monic polynomial <p> of degree <n>, we have ‘<p> = (-1)^<n>
     charpoly (polytocompanion (<p>, <x>))’.

     When <p> isn’t a polynomial in <x>, signal an error.

 -- Function: ptriangularize (<M>, <v>)

     If <M> is a matrix with each entry a polynomial in <v>, return a
     matrix <M2> such that

     (1) <M2> is upper triangular,

     (2) ‘<M2> = <E_n> ... <E_1> <M>’, where <E_1> through <E_n> are
     elementary matrices whose entries are polynomials in <v>,

     (3) ‘|det (<M>)| = |det (<M2>)|’,

     Note: This function doesn’t check that every entry is a polynomial
     in <v>.

 -- Function: rowop (<M>, <i>, <j>, <theta>)

     If <M> is a matrix, return the matrix that results from doing the
     row operation ‘R_i <- R_i - theta * R_j’.  If <M> doesn’t have a
     row <i> or <j>, signal an error.

 -- Function: linalg_rank (<M>)

     Return the rank of the matrix <M>.  This function is equivalent to
     function ‘rank’, but it uses a different algorithm: it finds the
     ‘columnspace’ of the matrix and counts its elements, since the rank
     of a matrix is the dimension of its column space.

          (%i1) linalg_rank(matrix([1,2],[2,4]));
          (%o1)                           1
          (%i2) linalg_rank(matrix([1,b],[c,d]));
          (%o2)                           2

 -- Function: rowswap (<M>, <i>, <j>)

     If <M> is a matrix, swap rows <i> and <j>.  If <M> doesn’t have a
     row <i> or <j>, signal an error.

 -- Function: toeplitz
          toeplitz (<col>)
          toeplitz (<col>, <row>)

     Return a Toeplitz matrix <T>.  The first first column of <T> is
     <col>; except for the first entry, the first row of <T> is <row>.
     The default for <row> is complex conjugate of <col>.  Example:

          (%i1)  toeplitz([1,2,3],[x,y,z]);
                                            [ 1  y  z ]
                                            [         ]
          (%o1)                             [ 2  1  y ]
                                            [         ]
                                            [ 3  2  1 ]
          (%i2)  toeplitz([1,1+%i]);

                                        [   1     1 - %I ]
          (%o2)                         [                ]
                                        [ %I + 1    1    ]

 -- Function: vandermonde_matrix ([<x_1>, ..., <x_n>])

     Return a <n> by <n> matrix whose <i>-th row is ‘[1, <x_i>, <x_i>^2,
     ... <x_i>^(<n>-1)]’.

 -- Function: zerofor
          zerofor (<M>)
          zerofor (<M>, <fld>)

     Return a zero matrix that has the same shape as the matrix <M>.
     Every entry of the zero matrix is the additive identity of the
     field <fld>; the default for <fld> is <generalring>.

     The first argument <M> should be a square matrix or a non-matrix.
     When <M> is a matrix, each entry of <M> can be a square matrix –
     thus <M> can be a blocked Maxima matrix.  The matrix can be blocked
     to any (finite) depth.

     See also ‘identfor’

 -- Function: zeromatrixp (<M>)

     If <M> is not a block matrix, return ‘true’ if ‘is (equal (<e>,
     0))’ is true for each element <e> of the matrix <M>.  If <M> is a
     block matrix, return ‘true’ if ‘zeromatrixp’ evaluates to ‘true’
     for each element of <e>.


File: maxima.info,  Node: lsquares-pkg,  Next: minpack-pkg,  Prev: linearalgebra-pkg,  Up: Top

72 lsquares
***********

* Menu:

* Introduction to lsquares::
* Functions and Variables for lsquares::


File: maxima.info,  Node: Introduction to lsquares,  Next: Functions and Variables for lsquares,  Prev: lsquares-pkg,  Up: lsquares-pkg

72.1 Introduction to lsquares
=============================

‘lsquares’ is a collection of functions to implement the method of least
squares to estimate parameters for a model from numerical data.


File: maxima.info,  Node: Functions and Variables for lsquares,  Prev: Introduction to lsquares,  Up: lsquares-pkg

72.2 Functions and Variables for lsquares
=========================================

 -- Function: lsquares_estimates
          lsquares_estimates (<D>, <x>, <e>, <a>)
          lsquares_estimates (<D>, <x>, <e>, <a>, initial = <L>, tol =
          <t>)

     Estimate parameters <a> to best fit the equation <e> in the
     variables <x> and <a> to the data <D>, as determined by the method
     of least squares.  ‘lsquares_estimates’ first seeks an exact
     solution, and if that fails, then seeks an approximate solution.

     The return value is a list of lists of equations of the form ‘[a =
     ..., b = ..., c = ...]’.  Each element of the list is a distinct,
     equivalent minimum of the mean square error.

     The data <D> must be a matrix.  Each row is one datum (which may be
     called a ‘record’ or ‘case’ in some contexts), and each column
     contains the values of one variable across all data.  The list of
     variables <x> gives a name for each column of <D>, even the columns
     which do not enter the analysis.  The list of parameters <a> gives
     the names of the parameters for which estimates are sought.  The
     equation <e> is an expression or equation in the variables <x> and
     <a>; if <e> is not an equation, it is treated the same as ‘<e> =
     0’.

     Additional arguments to ‘lsquares_estimates’ are specified as
     equations and passed on verbatim to the function ‘lbfgs’ which is
     called to find estimates by a numerical method when an exact result
     is not found.

     If some exact solution can be found (via ‘solve’), the data <D> may
     contain non-numeric values.  However, if no exact solution is
     found, each element of <D> must have a numeric value.  This
     includes numeric constants such as ‘%pi’ and ‘%e’ as well as
     literal numbers (integers, rationals, ordinary floats, and
     bigfloats).  Numerical calculations are carried out with ordinary
     floating-point arithmetic, so all other kinds of numbers are
     converted to ordinary floats for calculations.

     If ‘lsquares_estimates’ needs excessive amounts of time or runs out
     of memory ‘lsquares_estimates_approximate’, which skips the attempt
     to find an exact solution, might still succeed.

     ‘load("lsquares")’ loads this function.

     See also ‘lsquares_estimates_exact’,
     ‘lsquares_estimates_approximate’,
     ‘lsquares_mse’, ‘lsquares_residuals’, and ‘lsquares_residual_mse’.

     Examples:

     A problem for which an exact solution is found.

          (%i1) load ("lsquares")$
          (%i2) M : matrix (
                  [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                     [ 1  1  1 ]
                                     [         ]
                                     [ 3       ]
                                     [ -  1  2 ]
                                     [ 2       ]
                                     [         ]
          (%o2)                      [ 9       ]
                                     [ -  2  1 ]
                                     [ 4       ]
                                     [         ]
                                     [ 3  2  2 ]
                                     [         ]
                                     [ 2  2  1 ]
          (%i3) lsquares_estimates (
                   M, [z,x,y], (z+D)^2 = A*x+B*y+C, [A,B,C,D]);
                            59        27      10921        107
          (%o3)     [[A = - --, B = - --, C = -----, D = - ---]]
                            16        16      1024         32

     A problem for which no exact solution is found, so
     ‘lsquares_estimates’ resorts to numerical approximation.

          (%i1) load ("lsquares")$
          (%i2) M : matrix ([1, 1], [2, 7/4], [3, 11/4], [4, 13/4]);
                                      [ 1  1  ]
                                      [       ]
                                      [    7  ]
                                      [ 2  -  ]
                                      [    4  ]
                                      [       ]
          (%o2)                       [    11 ]
                                      [ 3  -- ]
                                      [    4  ]
                                      [       ]
                                      [    13 ]
                                      [ 4  -- ]
                                      [    4  ]
          (%i3) lsquares_estimates (
            M, [x,y], y=a*x^b+c, [a,b,c], initial=[3,3,3], iprint=[-1,0]);
          (%o3) [[a = 1.375751433061394, b = 0.7148891534417651,
                                                 c = - 0.4020908910062951]]

     Exponential functions aren’t well-conditioned for least min square
     fitting.  In case that fitting to them fails it might be possible
     to get rid of the exponential function using an logarithm.

          (%i1) load ("lsquares")$
          (%i2) yvalues: [1,3,5,60,200,203,80]$
          (%i3) time: [1,2,4,5,6,8,10]$
          (%i4) f: y=a*exp(b*t);
                                             b t
          (%o4)                      y = a %e
          (%i5) yvalues_log: log(yvalues)$
          (%i6) f_log: log(subst(y=exp(y),f));
                                              b t
          (%o6)                   y = log(a %e   )
          (%i7) lsquares_estimates (transpose(matrix(yvalues_log,time)),
                                    [y,t], f_log, [a,b]);
          *************************************************
            N=    2   NUMBER OF CORRECTIONS=25
                 INITIAL VALUES
           F=  6.802906290754687D+00   GNORM=  2.851243373781393D+01
          *************************************************

          I NFN FUNC                  GNORM                 STEPLENGTH

          1   3 1.141838765593467D+00 1.067358003667488D-01 1.390943719972406D-02
          2   5 1.141118195694385D+00 1.237977833033414D-01 5.000000000000000D+00
          3   6 1.136945723147959D+00 3.806696991691383D-01 1.000000000000000D+00
          4   7 1.133958243220262D+00 3.865103550379243D-01 1.000000000000000D+00
          5   8 1.131725773805499D+00 2.292258231154026D-02 1.000000000000000D+00
          6   9 1.131625585698168D+00 2.664440547017370D-03 1.000000000000000D+00
          7  10 1.131620564856599D+00 2.519366958715444D-04 1.000000000000000D+00

           THE MINIMIZATION TERMINATED WITHOUT DETECTING ERRORS.
           IFLAG = 0
          (%o7)   [[a = 1.155904145765554, b = 0.5772666876959847]]

 -- Function: lsquares_estimates_exact (<MSE>, <a>)

     Estimate parameters <a> to minimize the mean square error <MSE>, by
     constructing a system of equations and attempting to solve them
     symbolically via ‘solve’.  The mean square error is an expression
     in the parameters <a>, such as that returned by ‘lsquares_mse’.

     The return value is a list of lists of equations of the form ‘[a =
     ..., b = ..., c = ...]’.  The return value may contain zero, one,
     or two or more elements.  If two or more elements are returned,
     each represents a distinct, equivalent minimum of the mean square
     error.

     See also ‘lsquares_estimates’, ‘lsquares_estimates_approximate’,
     ‘lsquares_mse’, ‘lsquares_residuals’, and ‘lsquares_residual_mse’.

     Example:

          (%i1) load ("lsquares")$
          (%i2) M : matrix (
                   [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                     [ 1  1  1 ]
                                     [         ]
                                     [ 3       ]
                                     [ -  1  2 ]
                                     [ 2       ]
                                     [         ]
          (%o2)                      [ 9       ]
                                     [ -  2  1 ]
                                     [ 4       ]
                                     [         ]
                                     [ 3  2  2 ]
                                     [         ]
                                     [ 2  2  1 ]
          (%i3) mse : lsquares_mse (M, [z, x, y], (z + D)^2 = A*x + B*y + C);
                   5
                  ====
                  \                                         2     2
                   >    ((- B M    ) - A M     + (M     + D)  - C)
                  /            i, 3       i, 2     i, 1
                  ====
                  i = 1
          (%o3)   -------------------------------------------------
                                          5
          (%i4) lsquares_estimates_exact (mse, [A, B, C, D]);
                            59        27      10921        107
          (%o4)     [[A = - --, B = - --, C = -----, D = - ---]]
                            16        16      1024         32

 -- Function: lsquares_estimates_approximate (<MSE>, <a>, initial = <L>,
          tol = <t>)

     Estimate parameters <a> to minimize the mean square error <MSE>,
     via the numerical minimization function ‘lbfgs’.  The mean square
     error is an expression in the parameters <a>, such as that returned
     by ‘lsquares_mse’.

     The solution returned by ‘lsquares_estimates_approximate’ is a
     local (perhaps global) minimum of the mean square error.  For
     consistency with ‘lsquares_estimates_exact’, the return value is a
     nested list which contains one element, namely a list of equations
     of the form ‘[a = ..., b = ..., c = ...]’.

     Additional arguments to ‘lsquares_estimates_approximate’ are
     specified as equations and passed on verbatim to the function
     ‘lbfgs’.

     <MSE> must evaluate to a number when the parameters are assigned
     numeric values.  This requires that the data from which <MSE> was
     constructed comprise only numeric constants such as ‘%pi’ and ‘%e’
     and literal numbers (integers, rationals, ordinary floats, and
     bigfloats).  Numerical calculations are carried out with ordinary
     floating-point arithmetic, so all other kinds of numbers are
     converted to ordinary floats for calculations.

     ‘load("lsquares")’ loads this function.

     See also ‘lsquares_estimates’, ‘lsquares_estimates_exact’,
     ‘lsquares_mse’,
     ‘lsquares_residuals’, and ‘lsquares_residual_mse’.

     Example:

          (%i1) load ("lsquares")$
          (%i2) M : matrix (
                   [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                     [ 1  1  1 ]
                                     [         ]
                                     [ 3       ]
                                     [ -  1  2 ]
                                     [ 2       ]
                                     [         ]
          (%o2)                      [ 9       ]
                                     [ -  2  1 ]
                                     [ 4       ]
                                     [         ]
                                     [ 3  2  2 ]
                                     [         ]
                                     [ 2  2  1 ]
          (%i3) mse : lsquares_mse (M, [z, x, y], (z + D)^2 = A*x + B*y + C);
                   5
                  ====
                  \                                         2     2
                   >    ((- B M    ) - A M     + (M     + D)  - C)
                  /            i, 3       i, 2     i, 1
                  ====
                  i = 1
          (%o3)   -------------------------------------------------
                                          5
          (%i4) lsquares_estimates_approximate (
                  mse, [A, B, C, D], iprint = [-1, 0]);
          (%o4) [[A = - 3.678504947401971, B = - 1.683070351177937,
                           C = 10.63469950148714, D = - 3.340357993175297]]

 -- Function: lsquares_mse (<D>, <x>, <e>)

     Returns the mean square error (MSE), a summation expression, for
     the equation <e> in the variables <x>, with data <D>.

     The MSE is defined as:

                              n
                             ====
                         1   \                        2
                         -    >    (lhs(e ) - rhs(e ))
                         n   /           i         i
                             ====
                             i = 1

     where <n> is the number of data and ‘<e>[i]’ is the equation <e>
     evaluated with the variables in <x> assigned values from the ‘i’-th
     datum, ‘<D>[i]’.

     ‘load("lsquares")’ loads this function.

     Example:

          (%i1) load ("lsquares")$
          (%i2) M : matrix (
                   [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                     [ 1  1  1 ]
                                     [         ]
                                     [ 3       ]
                                     [ -  1  2 ]
                                     [ 2       ]
                                     [         ]
          (%o2)                      [ 9       ]
                                     [ -  2  1 ]
                                     [ 4       ]
                                     [         ]
                                     [ 3  2  2 ]
                                     [         ]
                                     [ 2  2  1 ]
          (%i3) mse : lsquares_mse (M, [z, x, y], (z + D)^2 = A*x + B*y + C);
                   5
                  ====
                  \                                         2     2
                   >    ((- B M    ) - A M     + (M     + D)  - C)
                  /            i, 3       i, 2     i, 1
                  ====
                  i = 1
          (%o3)   -------------------------------------------------
                                          5
          (%i4) diff (mse, D);
          (%o4)
                5
               ====
               \                                                     2
             4  >    (M     + D) ((- B M    ) - A M     + (M     + D)  - C)
               /       i, 1             i, 3       i, 2     i, 1
               ====
               i = 1
             --------------------------------------------------------------
                                           5
          (%i5) ''mse, nouns;
                         2                 2         9 2               2
          (%o5) (((D + 3)  - C - 2 B - 2 A)  + ((D + -)  - C - B - 2 A)
                                                     4
                     2               2         3 2               2
           + ((D + 2)  - C - B - 2 A)  + ((D + -)  - C - 2 B - A)
                                               2
                     2             2
           + ((D + 1)  - C - B - A) )/5
          (%i3) mse : lsquares_mse (M, [z, x, y], (z + D)^2 = A*x + B*y + C);
                     5
                    ====
                    \                 2                         2
                     >    ((D + M    )  - C - M     B - M     A)
                    /            i, 1          i, 3      i, 2
                    ====
                    i = 1
          (%o3)     ---------------------------------------------
                                          5
          (%i4) diff (mse, D);
                   5
                  ====
                  \                             2
                4  >    (D + M    ) ((D + M    )  - C - M     B - M     A)
                  /           i, 1         i, 1          i, 3      i, 2
                  ====
                  i = 1
          (%o4) ----------------------------------------------------------
                                            5
          (%i5) ''mse, nouns;
                         2                 2         9 2               2
          (%o5) (((D + 3)  - C - 2 B - 2 A)  + ((D + -)  - C - B - 2 A)
                                                     4
                     2               2         3 2               2
           + ((D + 2)  - C - B - 2 A)  + ((D + -)  - C - 2 B - A)
                                               2
                     2             2
           + ((D + 1)  - C - B - A) )/5

 -- Function: lsquares_residuals (<D>, <x>, <e>, <a>)

     Returns the residuals for the equation <e> with specified
     parameters <a> and data <D>.

     <D> is a matrix, <x> is a list of variables, <e> is an equation or
     general expression; if not an equation, <e> is treated as if it
     were ‘<e> = 0’.  <a> is a list of equations which specify values
     for any free parameters in <e> aside from <x>.

     The residuals are defined as:

                                  lhs(e ) - rhs(e )
                                       i         i

     where ‘<e>[i]’ is the equation <e> evaluated with the variables in
     <x> assigned values from the ‘i’-th datum, ‘<D>[i]’, and assigning
     any remaining free variables from <a>.

     ‘load("lsquares")’ loads this function.

     Example:

          (%i1) load ("lsquares")$
          (%i2) M : matrix (
                   [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                     [ 1  1  1 ]
                                     [         ]
                                     [ 3       ]
                                     [ -  1  2 ]
                                     [ 2       ]
                                     [         ]
          (%o2)                      [ 9       ]
                                     [ -  2  1 ]
                                     [ 4       ]
                                     [         ]
                                     [ 3  2  2 ]
                                     [         ]
                                     [ 2  2  1 ]
          (%i3) a : lsquares_estimates (
                    M, [z,x,y], (z+D)^2 = A*x+B*y+C, [A,B,C,D]);
                            59        27      10921        107
          (%o3)     [[A = - --, B = - --, C = -----, D = - ---]]
                            16        16      1024         32
          (%i4) lsquares_residuals (
                    M, [z,x,y], (z+D)^2 = A*x+B*y+C, first(a));
                               13    13    13  13  13
          (%o4)               [--, - --, - --, --, --]
                               64    64    32  64  64

 -- Function: lsquares_residual_mse (<D>, <x>, <e>, <a>)

     Returns the residual mean square error (MSE) for the equation <e>
     with specified parameters <a> and data <D>.

     The residual MSE is defined as:

                              n
                             ====
                         1   \                        2
                         -    >    (lhs(e ) - rhs(e ))
                         n   /           i         i
                             ====
                             i = 1

     where ‘<e>[i]’ is the equation <e> evaluated with the variables in
     <x> assigned values from the ‘i’-th datum, ‘<D>[i]’, and assigning
     any remaining free variables from <a>.

     ‘load("lsquares")’ loads this function.

     Example:

          (%i1) load ("lsquares")$
          (%i2) M : matrix (
                   [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                     [ 1  1  1 ]
                                     [         ]
                                     [ 3       ]
                                     [ -  1  2 ]
                                     [ 2       ]
                                     [         ]
          (%o2)                      [ 9       ]
                                     [ -  2  1 ]
                                     [ 4       ]
                                     [         ]
                                     [ 3  2  2 ]
                                     [         ]
                                     [ 2  2  1 ]
          (%i3) a : lsquares_estimates (
                 M, [z,x,y], (z+D)^2 = A*x+B*y+C, [A,B,C,D]);
                            59        27      10921        107
          (%o3)     [[A = - --, B = - --, C = -----, D = - ---]]
                            16        16      1024         32
          (%i4) lsquares_residual_mse (
                 M, [z,x,y], (z + D)^2 = A*x + B*y + C, first (a));
                                        169
          (%o4)                         ----
                                        2560

 -- Function: plsquares
          plsquares (<Mat>,<VarList>,<depvars>)
          plsquares (<Mat>,<VarList>,<depvars>,<maxexpon>)
          plsquares (<Mat>,<VarList>,<depvars>,<maxexpon>,<maxdegree>)
     Multivariable polynomial adjustment of a data table by the "least
     squares" method.  <Mat> is a matrix containing the data, <VarList>
     is a list of variable names (one for each Mat column, but use "-"
     instead of varnames to ignore Mat columns), <depvars> is the name
     of a dependent variable or a list with one or more names of
     dependent variables (which names should be in <VarList>),
     <maxexpon> is the optional maximum exponent for each independent
     variable (1 by default), and <maxdegree> is the optional maximum
     polynomial degree (<maxexpon> by default); note that the sum of
     exponents of each term must be equal or smaller than <maxdegree>,
     and if ‘maxdgree = 0’ then no limit is applied.

     If <depvars> is the name of a dependent variable (not in a list),
     ‘plsquares’ returns the adjusted polynomial.  If <depvars> is a
     list of one or more dependent variables, ‘plsquares’ returns a list
     with the adjusted polynomial(s).  The Coefficients of Determination
     are displayed in order to inform about the goodness of fit, which
     ranges from 0 (no correlation) to 1 (exact correlation).  These
     values are also stored in the global variable <DETCOEF> (a list if
     <depvars> is a list).

     A simple example of multivariable linear adjustment:
          (%i1) load("plsquares")$

          (%i2) plsquares(matrix([1,2,0],[3,5,4],[4,7,9],[5,8,10]),
                          [x,y,z],z);
               Determination Coefficient for z = .9897039897039897
                                 11 y - 9 x - 14
          (%o2)              z = ---------------
                                        3

     The same example without degree restrictions:
          (%i3) plsquares(matrix([1,2,0],[3,5,4],[4,7,9],[5,8,10]),
                          [x,y,z],z,1,0);
               Determination Coefficient for z = 1.0
                              x y + 23 y - 29 x - 19
          (%o3)           z = ----------------------
                                        6

     How many diagonals does a N-sides polygon have?  What polynomial
     degree should be used?
          (%i4) plsquares(matrix([3,0],[4,2],[5,5],[6,9],[7,14],[8,20]),
                          [N,diagonals],diagonals,5);
               Determination Coefficient for diagonals = 1.0
                                          2
                                         N  - 3 N
          (%o4)              diagonals = --------
                                            2
          (%i5) ev(%, N=9);   /* Testing for a 9 sides polygon */
          (%o5)                 diagonals = 27

     How many ways do we have to put two queens without they are
     threatened into a n x n chessboard?
          (%i6) plsquares(matrix([0,0],[1,0],[2,0],[3,8],[4,44]),
                          [n,positions],[positions],4);
               Determination Coefficient for [positions] = [1.0]
                                   4       3      2
                                3 n  - 10 n  + 9 n  - 2 n
          (%o6)    [positions = -------------------------]
                                            6
          (%i7) ev(%[1], n=8); /* Testing for a (8 x 8) chessboard */
          (%o7)                positions = 1288

     An example with six dependent variables:
          (%i8) mtrx:matrix([0,0,0,0,0,1,1,1],[0,1,0,1,1,1,0,0],
                            [1,0,0,1,1,1,0,0],[1,1,1,1,0,0,0,1])$
          (%i8) plsquares(mtrx,[a,b,_And,_Or,_Xor,_Nand,_Nor,_Nxor],
                               [_And,_Or,_Xor,_Nand,_Nor,_Nxor],1,0);
                Determination Coefficient for
          [_And, _Or, _Xor, _Nand, _Nor, _Nxor] =
          [1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
          (%o2) [_And = a b, _Or = - a b + b + a,
          _Xor = - 2 a b + b + a, _Nand = 1 - a b,
          _Nor = a b - b - a + 1, _Nxor = 2 a b - b - a + 1]

     To use this function write first ‘load("lsquares")’.


File: maxima.info,  Node: minpack-pkg,  Next: makeOrders-pkg,  Prev: lsquares-pkg,  Up: Top

73 minpack
**********

* Menu:

* Introduction to minpack::
* Functions and Variables for minpack::


File: maxima.info,  Node: Introduction to minpack,  Next: Functions and Variables for minpack,  Prev: minpack-pkg,  Up: minpack-pkg

73.1 Introduction to minpack
============================

‘Minpack’ is a Common Lisp translation (via ‘f2cl’) of the Fortran
library MINPACK, as obtained from Netlib.


File: maxima.info,  Node: Functions and Variables for minpack,  Prev: Introduction to minpack,  Up: minpack-pkg

73.2 Functions and Variables for minpack
========================================

 -- Function: minpack_lsquares
          minpack_lsquares (<flist>, <varlist>, <guess>)
          minpack_lsquares (..., 'tolerance = <tolerance>)
          minpack_lsquares (..., 'jacobian = <jacobian>)

     Compute the point that minimizes the sum of the squares of the
     functions in the list <flist>.  The variables are in the list
     <varlist>.  An initial guess of the optimum point must be provided
     in <guess>.

     The optional keyword arguments, <tolerance> and <jacobian> provide
     some control over the algorithm.  <tolerance> is the estimated
     relative error desired in the sum of squares.  <jacobian> can be
     used to specify the Jacobian.  If <jacobian> is not given or is
     ‘true’ (the default), the Jacobian is computed from <flist>.  If
     <jacobian> is ‘false’, a numerical approximation is used.

     ‘minpack_lsquares’ returns a list.  The first item is the estimated
     solution; the second is the sum of squares, and the third indicates
     the success of the algorithm.  The possible values are

     ‘0’
          improper input parameters.
     ‘1’
          algorithm estimates that the relative error in the sum of
          squares is at most ‘tolerance’.
     ‘2’
          algorithm estimates that the relative error between x and the
          solution is at most ‘tolerance’.
     ‘3’
          conditions for info = 1 and info = 2 both hold.
     ‘4’
          fvec is orthogonal to the columns of the jacobian to machine
          precision.
     ‘5’
          number of calls to fcn with iflag = 1 has reached 100*(n+1).
     ‘6’
          tol is too small.  no further reduction in the sum of squares
          is possible.
     ‘7’
          tol is too small.  no further improvement in the approximate
          solution x is possible.

          /* Problem 6: Powell singular function */
          (%i1) powell(x1,x2,x3,x4) :=
                   [x1+10*x2, sqrt(5)*(x3-x4), (x2-2*x3)^2,
                        sqrt(10)*(x1-x4)^2]$
          (%i2) minpack_lsquares(powell(x1,x2,x3,x4), [x1,x2,x3,x4],
                                 [3,-1,0,1]);
          (%o2) [[1.652117596168394e-17, - 1.652117596168393e-18,
                  2.643388153869468e-18, 2.643388153869468e-18],
                 6.109327859207777e-34, 4]

          /* Same problem but use numerical approximation to Jacobian */
          (%i3) minpack_lsquares(powell(x1,x2,x3,x4), [x1,x2,x3,x4],
                                 [3,-1,0,1], jacobian = false);
          (%o3) [[5.060282149485331e-11, - 5.060282149491206e-12,
                  2.179447843547218e-11, 2.179447843547218e-11],
                 3.534491794847031e-21, 5]

 -- Function: minpack_solve
          minpack_solve (<flist>, <varlist>, <guess>)
          minpack_solve (..., 'tolerance = <tolerance>)
          minpack_solve (..., 'jacobian = <jacobian>)

     Solve a system of ‘n’ equations in ‘n’ unknowns.  The ‘n’ equations
     are given in the list <flist>, and the unknowns are in <varlist>.
     An initial guess of the solution must be provided in <guess>.

     The optional keyword arguments, <tolerance> and <jacobian> provide
     some control over the algorithm.  <tolerance> is the estimated
     relative error desired in the sum of squares.  <jacobian> can be
     used to specify the Jacobian.  If <jacobian> is not given or is
     ‘true’ (the default), the Jacobian is computed from <flist>.  If
     <jacobian> is ‘false’, a numerical approximation is used.

     ‘minpack_solve’ returns a list.  The first item is the estimated
     solution; the second is the sum of squares, and the third indicates
     the success of the algorithm.  The possible values are

     ‘0’
          improper input parameters.
     ‘1’
          algorithm estimates that the relative error in the solution is
          at most ‘tolerance’.
     ‘2’
          number of calls to fcn with iflag = 1 has reached 100*(n+1).
     ‘3’
          tol is too small.  no further reduction in the sum of squares
          is possible.
     ‘4’
          Iteration is not making good progress.

          /* Problem 6: Powell singular function */
          (%i1) powell(x1,x2,x3,x4) :=
                   [x1+10*x2, sqrt(5)*(x3-x4), (x2-2*x3)^2,
                        sqrt(10)*(x1-x4)^2]$
          (%i2) minpack_lsquares(powell(x1,x2,x3,x4), [x1,x2,x3,x4],
                                 [3,-1,0,1]);
          (%o2) [[8.586306796471285e-19, - 8.586306796471285e-20,
                 1.902656479186597e-18, 1.902656479186597e-18], 1.552862701642987e-35, 4]
     In this particular case, we can solve this analytically:
          (%i3) solve(powell(x1,x2,x3,x4),[x1,x2,x3,x4]);
          (%o3)       [[x1 = 0, x2 = 0, x3 = 0, x4 = 0]]
     and we see that the numerical solution is quite close the
     analytical one.


File: maxima.info,  Node: makeOrders-pkg,  Next: mnewton-pkg,  Prev: minpack-pkg,  Up: Top

74 makeOrders
*************

* Menu:

* Functions and Variables for makeOrders::


File: maxima.info,  Node: Functions and Variables for makeOrders,  Prev: makeOrders-pkg,  Up: makeOrders-pkg

74.1 Functions and Variables for makeOrders
===========================================

 -- Function: makeOrders (<indvarlist>,<orderlist>)
     Returns a list of all powers for a polynomial up to and including
     the arguments.

          (%i1) load("makeOrders")$

          (%i2) makeOrders([a,b],[2,3]);
          (%o2) [[0, 0], [0, 1], [0, 2], [0, 3], [1, 0], [1, 1],
                      [1, 2], [1, 3], [2, 0], [2, 1], [2, 2], [2, 3]]
          (%i3) expand((1+a+a^2)*(1+b+b^2+b^3));
                 2  3      3    3    2  2      2    2    2
          (%o3) a  b  + a b  + b  + a  b  + a b  + b  + a  b + a b
                                                            2
                                                     + b + a  + a + 1
     where ‘[0, 1]’ is associated with the term b and ‘[2, 3]’ with a^2
     b^3.

     To use this function write first ‘load("makeOrders")’.


File: maxima.info,  Node: mnewton-pkg,  Next: numericalio-pkg,  Prev: makeOrders-pkg,  Up: Top

75 mnewton
**********

* Menu:

* Introduction to mnewton::
* Functions and Variables for mnewton::


File: maxima.info,  Node: Introduction to mnewton,  Next: Functions and Variables for mnewton,  Prev: mnewton-pkg,  Up: mnewton-pkg

75.1 Introduction to mnewton
============================

‘mnewton’ is an implementation of Newton’s method for solving nonlinear
equations in one or more variables.


File: maxima.info,  Node: Functions and Variables for mnewton,  Prev: Introduction to mnewton,  Up: mnewton-pkg

75.2 Functions and Variables for mnewton
========================================

 -- Option variable: newtonepsilon
     Default value: ‘10.0^(-fpprec/2)’

     Precision to determine when the ‘mnewton’ function has converged
     towards the solution.

     When ‘newtonepsilon’ is a bigfloat, ‘mnewton’ computations are done
     with bigfloats; otherwise, ordinary floats are used.

     See also ‘mnewton’.

 -- Option variable: newtonmaxiter
     Default value: ‘50’

     Maximum number of iterations to stop the ‘mnewton’ function if it
     does not converge or if it converges too slowly.

     See also ‘mnewton’.

 -- Option variable: newtondebug
     Default value: ‘false’

     When ‘newtondebug’ is ‘true’, ‘mnewton’ prints out debugging
     information while solving a problem.

 -- Function: mnewton
          mnewton (<FuncList>, <VarList>, <GuessList>)
          mnewton (<FuncList>, <VarList>, <GuessList>, <DF>)

     Approximate solution of multiple nonlinear equations by Newton’s
     method.

     <FuncList> is a list of functions to solve, <VarList> is a list of
     variable names, and <GuessList> is a list of initial
     approximations.  The optional argument <DF> is the Jacobian matrix
     of the list of functions; if not supplied, it is calculated
     automatically from <FuncList>.

     <FuncList> may be specified as a list of equations, in which case
     the function to be solved is the left-hand side of each equation
     minus the right-hand side.

     If there is only a single function, variable, and initial point,
     they may be specified as a single expression, variable, and initial
     value; they need not be lists of one element.

     A variable may be a simple symbol or a subscripted symbol.

     The solution, if any, is returned as a list of one element, which
     is a list of equations, one for each variable, specifying an
     approximate solution; this is the same format as returned by
     ‘solve’.  If the solution is not found, ‘[]’ is returned.

     Functions and initial points may contain complex numbers, and
     solutions likewise may contain complex numbers.

     ‘mnewton’ is governed by global variables ‘newtonepsilon’ and
     ‘newtonmaxiter’, and the global flag ‘newtondebug’.

     ‘load("mnewton")’ loads this function.

     See also ‘realroots’, ‘allroots’, ‘find_root’ and ‘newton’.

     Examples:

          (%i1) load("mnewton")$

          (%i2) mnewton([x1+3*log(x1)-x2^2, 2*x1^2-x1*x2-5*x1+1],
                        [x1, x2], [5, 5]);
          (%o2) [[x1 = 3.756834008012769, x2 = 2.779849592817897]]
          (%i3) mnewton([2*a^a-5],[a],[1]);
          (%o3)             [[a = 1.70927556786144]]
          (%i4) mnewton([2*3^u-v/u-5, u+2^v-4], [u, v], [2, 2]);
          (%o4) [[u = 1.066618389595407, v = 1.552564766841786]]

     The variable ‘newtonepsilon’ controls the precision of the
     approximations.  It also controls if computations are performed
     with floats or bigfloats.

          (%i1) load("mnewton")$

          (%i2) (fpprec : 25, newtonepsilon : bfloat(10^(-fpprec+5)))$

          (%i3) mnewton([2*3^u-v/u-5, u+2^v-4], [u, v], [2, 2]);
          (%o3) [[u = 1.066618389595406772591173b0,
                                         v = 1.552564766841786450100418b0]]


File: maxima.info,  Node: numericalio-pkg,  Next: odepack-pkg,  Prev: mnewton-pkg,  Up: Top

76 numericalio
**************

* Menu:

* Introduction to numericalio::
* Functions and Variables for plain-text input and output::
* Functions and Variables for binary input and output::


File: maxima.info,  Node: Introduction to numericalio,  Next: Functions and Variables for plain-text input and output,  Prev: mnewton-pkg,  Up: numericalio-pkg

76.1 Introduction to numericalio
================================

‘numericalio’ is a collection of functions to read and write files and
streams.  Functions for plain-text input and output can read and write
numbers (integer, float, or bigfloat), symbols, and strings.  Functions
for binary input and output can read and write only floating-point
numbers.

   If there already exists a list, matrix, or array object to store
input data, ‘numericalio’ input functions can write data into that
object.  Otherwise, ‘numericalio’ can guess, to some degree, the
structure of an object to store the data, and return that object.

76.1.1 Plain-text input and output
----------------------------------

In plain-text input and output, it is assumed that each item to read or
write is an atom: an integer, float, bigfloat, string, or symbol, and
not a rational or complex number or any other kind of nonatomic
expression.  The ‘numericalio’ functions may attempt to do something
sensible faced with nonatomic expressions, but the results are not
specified here and subject to change.

   Atoms in both input and output files have the same format as in
Maxima batch files or the interactive console.  In particular, strings
are enclosed in double quotes, backslash ‘\’ prevents any special
interpretation of the next character, and the question mark ‘?’ is
recognized at the beginning of a symbol to mean a Lisp symbol (as
opposed to a Maxima symbol).  No continuation character (to join broken
lines) is recognized.

76.1.2 Separator flag values for input
--------------------------------------

The functions for plain-text input and output take an optional argument,
<separator_flag>, that tells what character separates data.

   For plain-text input, these values of <separator_flag> are
recognized: ‘comma’ for comma separated values, ‘pipe’ for values
separated by the vertical bar character ‘|’, ‘semicolon’ for values
separated by semicolon ‘;’, and ‘space’ for values separated by space or
tab characters.  Equivalently, the separator may be specified as a
string of one character: ‘","’ (comma), ‘"|"’ (pipe), ‘";"’ (semicolon),
‘" "’ (space), or ‘" "’ (tab).

   If the file name ends in ‘.csv’ and <separator_flag> is not
specified, ‘comma’ is assumed.  If the file name ends in something other
than ‘.csv’ and ‘separator_flag’ is not specified, ‘space’ is assumed.

   In plain-text input, multiple successive space and tab characters
count as a single separator.  However, multiple comma, pipe, or
semicolon characters are significant.  Successive comma, pipe, or
semicolon characters (with or without intervening spaces or tabs) are
considered to have ‘false’ between the separators.  For example,
‘1234,,Foo’ is treated the same as ‘1234,false,Foo’.

76.1.3 Separator flag values for output
---------------------------------------

For plain-text output, ‘tab’, for values separated by the tab character,
is recognized as a value of <separator_flag>, as well as ‘comma’,
‘pipe’, ‘semicolon’, and ‘space’.

   In plain-text output, ‘false’ atoms are written as such; a list
‘[1234, false, Foo]’ is written ‘1234,false,Foo’, and there is no
attempt to collapse the output to ‘1234,,Foo’.

76.1.4 Binary floating-point input and output
---------------------------------------------

‘numericalio’ functions can read and write 8-byte IEEE 754
floating-point numbers.  These numbers can be stored either least
significant byte first or most significant byte first, according to the
global flag set by ‘assume_external_byte_order’.  If not specified,
‘numericalio’ assumes the external byte order is most-significant byte
first.

   Other kinds of numbers are coerced to 8-byte floats; ‘numericalio’
cannot read or write binary non-numeric data.

   Some Lisp implementations do not recognize IEEE 754 special values
(positive and negative infinity, not-a-number values, denormalized
values).  The effect of reading such values with ‘numericalio’ is
undefined.

   ‘numericalio’ includes functions to open a stream for reading or
writing a stream of bytes.


File: maxima.info,  Node: Functions and Variables for plain-text input and output,  Next: Functions and Variables for binary input and output,  Prev: Introduction to numericalio,  Up: numericalio-pkg

76.2 Functions and Variables for plain-text input and output
============================================================

 -- Function: read_matrix
          read_matrix (<S>)
          read_matrix (<S>, <M>)
          read_matrix (<S>, <separator_flag>)
          read_matrix (<S>, <M>, <separator_flag>)

     ‘read_matrix(<S>)’ reads the source <S> and returns its entire
     content as a matrix.  The size of the matrix is inferred from the
     input data; each line of the file becomes one row of the matrix.
     If some lines have different lengths, ‘read_matrix’ complains.

     ‘read_matrix(<S>, <M>)’ read the source <S> into the matrix <M>,
     until <M> is full or the source is exhausted.  Input data are read
     into the matrix in row-major order; the input need not have the
     same number of rows and columns as <M>.

     The source <S> may be a file name or a stream which for example
     allows skipping the very first line of a file (that may be useful,
     if you read CSV data, where the first line often contains the
     description of the columns):
          s : openr("data.txt");
          readline(s);  /* skip the first line */
          M : read_matrix(s, 'comma);  /* read the following (comma-separated) lines into matrix M */
          close(s);

     The recognized values of <separator_flag> are ‘comma’, ‘pipe’,
     ‘semicolon’, and ‘space’.  Equivalently, the separator may be
     specified as a string of one character: ‘","’ (comma), ‘"|"’
     (pipe), ‘";"’ (semicolon), ‘" "’ (space), or ‘" "’ (tab).  If
     <separator_flag> is not specified, the file is assumed
     space-delimited.

     See also ‘openr’, ‘read_array’, ‘read_hashed_array’, ‘read_list’,
     ‘read_binary_matrix’, ‘write_data’ and ‘read_nested_list’.

 -- Function: read_array
          read_array (<S>, <A>)
          read_array (<S>, <A>, <separator_flag>)

     Reads the source <S> into the array <A>, until <A> is full or the
     source is exhausted.  Input data are read into the array in
     row-major order; the input need not conform to the dimensions of
     <A>.

     The source <S> may be a file name or a stream.

     The recognized values of <separator_flag> are ‘comma’, ‘pipe’,
     ‘semicolon’, and ‘space’.  Equivalently, the separator may be
     specified as a string of one character: ‘","’ (comma), ‘"|"’
     (pipe), ‘";"’ (semicolon), ‘" "’ (space), or ‘" "’ (tab).  If
     <separator_flag> is not specified, the file is assumed
     space-delimited.

     See also ‘openr’, ‘read_matrix’, ‘read_hashed_array’, ‘read_list’,
     ‘read_binary_array’ and ‘read_nested_list’.

 -- Function: read_hashed_array
          read_hashed_array (<S>, <A>)
          read_hashed_array (<S>, <A>, <separator_flag>)

     Reads the source <S> and returns its entire content as a ‘hashed
     array’.  The source <S> may be a file name or a stream.

     ‘read_hashed_array’ treats the first item on each line as a hash
     key, and associates the remainder of the line (as a list) with the
     key.  For example, the line ‘567 12 17 32 55’ is equivalent to
     ‘A[567]: [12, 17, 32, 55]$’.  Lines need not have the same numbers
     of elements.

     The recognized values of <separator_flag> are ‘comma’, ‘pipe’,
     ‘semicolon’, and ‘space’.  Equivalently, the separator may be
     specified as a string of one character: ‘","’ (comma), ‘"|"’
     (pipe), ‘";"’ (semicolon), ‘" "’ (space), or ‘" "’ (tab).  If
     <separator_flag> is not specified, the file is assumed
     space-delimited.

     See also ‘openr’, ‘read_matrix’, ‘read_array’, ‘read_list’ and
     ‘read_nested_list’.

 -- Function: read_nested_list
          read_nested_list (<S>)
          read_nested_list (<S>, <separator_flag>)

     Reads the source <S> and returns its entire content as a nested
     list.  The source <S> may be a file name or a stream.

     ‘read_nested_list’ returns a list which has a sublist for each line
     of input.  Lines need not have the same numbers of elements.  Empty
     lines are not ignored: an empty line yields an empty sublist.

     The recognized values of <separator_flag> are ‘comma’, ‘pipe’,
     ‘semicolon’, and ‘space’.  Equivalently, the separator may be
     specified as a string of one character: ‘","’ (comma), ‘"|"’
     (pipe), ‘";"’ (semicolon), ‘" "’ (space), or ‘" "’ (tab).  If
     <separator_flag> is not specified, the file is assumed
     space-delimited.

     See also ‘openr’, ‘read_matrix’, ‘read_array’, ‘read_list’ and
     ‘read_hashed_array’.

 -- Function: read_list
          read_list (<S>)
          read_list (<S>, <L>)
          read_list (<S>, <separator_flag>)
          read_list (<S>, <L>, <separator_flag>)

     ‘read_list(<S>)’ reads the source <S> and returns its entire
     content as a flat list.

     ‘read_list(<S>, <L>)’ reads the source <S> into the list <L>, until
     <L> is full or the source is exhausted.

     The source <S> may be a file name or a stream.

     The recognized values of <separator_flag> are ‘comma’, ‘pipe’,
     ‘semicolon’, and ‘space’.  Equivalently, the separator may be
     specified as a string of one character: ‘","’ (comma), ‘"|"’
     (pipe), ‘";"’ (semicolon), ‘" "’ (space), or ‘" "’ (tab).  If
     <separator_flag> is not specified, the file is assumed
     space-delimited.

     See also ‘openr’, ‘read_matrix’, ‘read_array’, ‘read_nested_list’,
     ‘read_binary_list’ and ‘read_hashed_array’.

 -- Function: write_data
          write_data (<X>, <D>)
          write_data (<X>, <D>, <separator_flag>)

     Writes the object <X> to the destination <D>.

     ‘write_data’ writes a matrix in row-major order, with one line per
     row.

     ‘write_data’ writes an array created by ‘array’ or ‘make_array’ in
     row-major order, with a new line at the end of every slab.
     Higher-dimensional slabs are separated by additional new lines.

     ‘write_data’ writes a hashed array with each key followed by its
     associated list on one line.

     ‘write_data’ writes a nested list with each sublist on one line.

     ‘write_data’ writes a flat list all on one line.

     The destination <D> may be a file name or a stream.  When the
     destination is a file name, the global variable
     ‘file_output_append’ governs whether the output file is appended or
     truncated.  When the destination is a stream, no special action is
     taken by ‘write_data’ after all the data are written; in
     particular, the stream remains open.

     The recognized values of <separator_flag> are ‘comma’, ‘pipe’,
     ‘semicolon’, ‘space’, and ‘tab’.  Equivalently, the separator may
     be specified as a string of one character: ‘","’ (comma), ‘"|"’
     (pipe), ‘";"’ (semicolon), ‘" "’ (space), or ‘" "’ (tab).  If
     <separator_flag> is not specified, the file is assumed
     space-delimited.

     See also ‘openw’ and ‘read_matrix’.


File: maxima.info,  Node: Functions and Variables for binary input and output,  Prev: Functions and Variables for plain-text input and output,  Up: numericalio-pkg

76.3 Functions and Variables for binary input and output
========================================================

 -- Function: assume_external_byte_order (<byte_order_flag>)
     Tells ‘numericalio’ the byte order for reading and writing binary
     data.  Two values of <byte_order_flag> are recognized: ‘lsb’ which
     indicates least-significant byte first, also called little-endian
     byte order; and ‘msb’ which indicates most-significant byte first,
     also called big-endian byte order.

     If not specified, ‘numericalio’ assumes the external byte order is
     most-significant byte first.

 -- Function: openr_binary (<file_name>)
     Returns an input stream of 8-bit unsigned bytes to read the file
     named by <file_name>.

     See also ‘openw_binary’ and ‘openr’.

 -- Function: openw_binary (<file_name>)
     Returns an output stream of 8-bit unsigned bytes to write the file
     named by <file_name>.

     See also ‘openr_binary’, ‘opena_binary’ and ‘openw’.

 -- Function: opena_binary (<file_name>)
     Returns an output stream of 8-bit unsigned bytes to append the file
     named by <file_name>.

 -- Function: read_binary_matrix (<S>, <M>)
     Reads binary 8-byte floating point numbers from the source <S> into
     the matrix <M> until <M> is full, or the source is exhausted.
     Elements of <M> are read in row-major order.

     The source <S> may be a file name or a stream.

     The byte order in elements of the source is specified by
     ‘assume_external_byte_order’.

     See also ‘read_matrix’.

 -- Function: read_binary_array (<S>, <A>)
     Reads binary 8-byte floating point numbers from the source <S> into
     the array <A> until <A> is full, or the source is exhausted.  <A>
     must be an array created by ‘array’ or ‘make_array’.  Elements of
     <A> are read in row-major order.

     The source <S> may be a file name or a stream.

     The byte order in elements of the source is specified by
     ‘assume_external_byte_order’.

     See also ‘read_array’.

 -- Function: read_binary_list
          read_binary_list (<S>)
          read_binary_list (<S>, <L>)

     ‘read_binary_list(<S>)’ reads the entire content of the source <S>
     as a sequence of binary 8-byte floating point numbers, and returns
     it as a list.  The source <S> may be a file name or a stream.

     ‘read_binary_list(<S>, <L>)’ reads 8-byte binary floating point
     numbers from the source <S> until the list <L> is full, or the
     source is exhausted.

     The byte order in elements of the source is specified by
     ‘assume_external_byte_order’.

     See also ‘read_list’.

 -- Function: write_binary_data (<X>, <D>)

     Writes the object <X>, comprising binary 8-byte IEEE 754
     floating-point numbers, to the destination <D>.  Other kinds of
     numbers are coerced to 8-byte floats.  ‘write_binary_data’ cannot
     write non-numeric data.

     The object <X> may be a list, a nested list, a matrix, or an array
     created by ‘array’ or ‘make_array’; <X> cannot be a hashed array or
     any other type of object.  ‘write_binary_data’ writes nested lists,
     matrices, and arrays in row-major order.

     The destination <D> may be a file name or a stream.  When the
     destination is a file name, the global variable
     ‘file_output_append’ governs whether the output file is appended or
     truncated.  When the destination is a stream, no special action is
     taken by ‘write_binary_data’ after all the data are written; in
     particular, the stream remains open.

     The byte order in elements of the destination is specified by
     ‘assume_external_byte_order’.

     See also ‘write_data’.


File: maxima.info,  Node: odepack-pkg,  Next: operatingsystem-pkg,  Prev: numericalio-pkg,  Up: Top

77 odepack
**********

* Menu:

* Introduction to ODEPACK::
* Getting Started with ODEPACK::
* Functions and Variables for odepack::


File: maxima.info,  Node: Introduction to ODEPACK,  Next: Getting Started with ODEPACK,  Prev: numericalio-pkg,  Up: odepack-pkg

77.1 Introduction to ODEPACK
============================

     ODEPACK is a collection of Fortran solvers for the initial value
     problem for ordinary differential equation systems.  It consists of
     nine solvers, namely a basic solver called LSODE and eight variants
     of it – LSODES, LSODA, LSODAR, LSODPK, LSODKR, LSODI, LSOIBT, and
     LSODIS. The collection is suitable for both stiff and nonstiff
     systems.  It includes solvers for systems given in explicit form,
     dy/dt = f(t,y), and also solvers for systems given in linearly
     implicit form, A(t,y) dy/dt = g(t,y).  Two of the solvers use
     general sparse matrix solvers for the linear systems that arise.
     Two others use iterative (preconditioned Krylov) methods instead of
     direct methods for these linear systems.  The most recent addition
     is LSODIS, which solves implicit problems with general sparse
     treatment of all matrices involved.
   (1)

   References: [1] Fortran Code is from
<https://www.netlib.org/odepack/>

   ---------- Footnotes ----------

   (1) From <https://www.netlib.org/odepack/opkd-sum>


File: maxima.info,  Node: Getting Started with ODEPACK,  Next: Functions and Variables for odepack,  Prev: Introduction to ODEPACK,  Up: odepack-pkg

77.1.1 Getting Started with ODEPACK
-----------------------------------

Of the eight variants of the solver, Maxima currently only has an
interface to ‘dlsode’.

   Let’s say we have this system of equations to solve:
       f1 = -.04d0*y1 + 1d4*y2*y3
       f3 = 3d7*y2*y2
       dy1/dt = f1
       dy2/dt = -f1 - f3
       dy3/dt = f3
   The independent variable is t; the dependent variables are y1, y2,
and y3,

   To start the solution, set up the differential equations to solved:
     load("dlsode");
     f1: -.04d0*y1 + 1d4*y2*y3$
     f3: 3d7*y2*y2$
     f2: -f1 - f3$
     fex: [f1, f2, f3];

   Initialize the solver, where we have selected method 21:
     (%i6) state : dlsode_init(fex, ['t,y1,y2,y3], 21);
     (%o6) [[f, #<Function "LAMBDA ($T $Y1 $Y2 $Y3)" {49DAC061}>],
     [vars, [t, y1, y2, y3]], [mf, 21], [neq, 3], [lrw, 58], [liw, 23], [rwork, {Li\
     sp Array: #(0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0
                    0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0
                    0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0
                    0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0)}],
     [iwork, {Lisp Array: #(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)}],
     [fjac, #<Function "LAMBDA ($T $Y1 $Y2 $Y3)" {49D52AC9}>]]
   The arrays rwork and iwork carry state between calls to
‘dlsode_step’, so they should not be modified by the user.  In fact,
this state should not be modified by the user at all.

   Now that the algorithm has been initialized we can compute solutions
to the differential equation, using the <state> returned above.

   For this example, we want to compute the solution at times ‘0.4*10^k’
for k from 0 to 11, with the initial values of 1, 0, 0 for the dependent
variables and with a relative tolerance of 1d-4 and absolute tolerances
of 1e-6, 1e-10, and 1d-6 for the dependent variables.

   Then
     y: [1d0, 0d0, 0d0];
     t: 0d0;
     rtol : 1d-4;
     atol: [1d-6, 1d-10, 1d-6];
     istate: 1;
     t:0d0;
     tout:.4d0;

     for k : 1 thru 12 do
       block([],
         result: dlsode_step(y, t, tout, rtol, atol, istate, state),
         printf(true, "At t = ~12,4,2e   y = ~{~14,6,2e~}~%", result[1], result[2]),
         istate : result[3],
         tout : tout * 10);

   This produces the output:
     At t =   4.0000e-01   y =   9.851726e-01  3.386406e-05  1.479357e-02
     At t =   4.0000e+00   y =   9.055142e-01  2.240418e-05  9.446344e-02
     At t =   4.0000e+01   y =   7.158050e-01  9.184616e-06  2.841858e-01
     At t =   4.0000e+02   y =   4.504846e-01  3.222434e-06  5.495122e-01
     At t =   4.0000e+03   y =   1.831701e-01  8.940379e-07  8.168290e-01
     At t =   4.0000e+04   y =   3.897016e-02  1.621193e-07  9.610297e-01
     At t =   4.0000e+05   y =   4.935213e-03  1.983756e-08  9.950648e-01
     At t =   4.0000e+06   y =   5.159269e-04  2.064759e-09  9.994841e-01
     At t =   4.0000e+07   y =   5.306413e-05  2.122677e-10  9.999469e-01
     At t =   4.0000e+08   y =   5.494530e-06  2.197824e-11  9.999945e-01
     At t =   4.0000e+09   y =   5.129458e-07  2.051784e-12  9.999995e-01
     At t =   4.0000e+10   y =  -7.170563e-08 -2.868225e-13  1.000000e+00


File: maxima.info,  Node: Functions and Variables for odepack,  Next: operatingsystem-pkg,  Prev: Getting Started with ODEPACK,  Up: odepack-pkg

77.2 Functions and Variables for odepack
========================================

 -- Function: dlsode_init (<fex>, <vars>, <method>)

     This must be called before running the solver.  This function
     returns a state object for use in the solver.  The user must not
     modify the state.

     The ODE to be solved is given in <fex>, which is a list of the
     equations.  <vars> is a list of independent variable and the
     dependent variables.  The list of dependent variables must be in
     the same order as the equations if <fex>.  Finally, <method>
     indicates the method to be used by the solver:

     ‘10’
          Nonstiff (Adams) method, no Jacobian used.
     ‘21’
          Stiff (BDF) method, user-supplied full Jacobian.
     ‘22’
          Stiff method, internally generated full Jacobian.

     The returned state object is a list of lists.  The sublist is a
     list of two elements:
     ‘f’
          The compiled function for the ODE.
     ‘vars’
          The list independent and dependent variables (<vars>).
     ‘mf’
          The method to be used (<method>).
     ‘neq’
          The number of equations.
     ‘lrw’
          Length of the work vector for real values.
     ‘liw’
          Length of the work vector for integer values.
     ‘rwork’
          Lisp array holding the real-valued work vector.
     ‘iwork’
          Lisp array holding the integer-valued work vector.
     ‘fjac’
          Compiled analytical Jacobian of the equations

     See also ‘dlsode_step’.  *Note Getting Started with ODEPACK:: for
     an example of usage.

 -- Function: dlsode_step (<inity>, <t>, <tout>, <rtol>, <atol>,
          <istate>, <state>)

     Performs one step of the solver, returning the values of the
     independent and dependent variables, a success or error code.

     ‘inity’
          For the first call (when istate = 1), the initial values
     ‘t’
          Current value of the independent value
     ‘tout’
          Next point where output is desired which must not be equal to
          <t>.
     ‘rtol’
          relative tolerance parameter
     ‘atol’
          Absolute tolerance parameter, scalar of vector.  If scalar, it
          applies to all dependent variables.  Otherwise it must be the
          tolerance for each dependent variable.

          Use <rtol> = 0 for pure absolute error and use <atol> = 0 for
          pure relative error.

     ‘istate’
          1 for the first call to dlsode, 2 for subsequent calls.
     ‘state’
          state returned by dlsode_init.

     The output is a list of the following items:
     ‘t’
          independent variable value
     ‘y’
          list of values of the dependent variables at time t.
     ‘istate’
          Integration status:
          ‘1’
               no work because tout = tt
          ‘2’
               successful result
          ‘-1’
               Excess work done on this call
          ‘-2’
               Excess accuracy requested
          ‘-3’
               Illegal input detected
          ‘-4’
               Repeated error test failures
          ‘-5’
               Repeated convergence failures (perhaps bad Jacobian or
               wrong choice of mf or tolerances)
          ‘-6’
               Error weight because zero during problem (solution
               component is vanished and atol(i) = 0.
     ‘info’
          association list of various bits of information:
          ‘n_steps’
               total steps taken thus far
          ‘n_f_eval’
               total number of function evals
          ‘n_j_eval’
               total number of Jacobian evals
          ‘method_order’
               method order
          ‘len_rwork’
               Actual length used for real work array
          ‘len_iwork’
               Actual length used for integer work array

     See also ‘dlsode_init’.  *Note Getting Started with ODEPACK:: for
     an example of usage.


File: maxima.info,  Node: operatingsystem-pkg,  Next: opsubst-pkg,  Prev: odepack-pkg,  Up: Top

78 operatingsystem
******************

* Menu:

* Introduction to operatingsystem::
* Directory operations::
* File operations::
* Environment operations::


File: maxima.info,  Node: Introduction to operatingsystem,  Next: Directory operations,  Prev: operatingsystem-pkg,  Up: operatingsystem-pkg

78.1 Introduction to operatingsystem
====================================

Package ‘operatingsystem’ contains functions for operatingsystem-tasks,
like file system operations.


File: maxima.info,  Node: Directory operations,  Next: File operations,  Prev: Introduction to operatingsystem,  Up: operatingsystem-pkg

78.2 Directory operations
=========================

 -- Function: chdir (<dir>)
     Change to directory <dir>

 -- Function: mkdir (<dir>)
     Create directory <dir>

 -- Function: rmdir (<dir>)
     remove directory <dir>

 -- Function: getcurrentdirectory ()
     returns the current working directory.

     See also ‘directory’.

   Examples:

     (%i1) load("operatingsystem")$
     (%i2) mkdir("testdirectory")$
     (%i3) chdir("testdirectory")$
     (%i4) chdir("..")$
     (%i5) rmdir("testdirectory")$


File: maxima.info,  Node: File operations,  Next: Environment operations,  Prev: Directory operations,  Up: operatingsystem-pkg

78.3 File operations
====================

 -- Function: copy_file (<file1>, <file2>)
     copies file <file1> to <file2>

 -- Function: rename_file (<file1>, <file2>)
     renames file <file1> to <file2>

 -- Function: delete_file (<file1>)
     deletes file <file1>


File: maxima.info,  Node: Environment operations,  Prev: File operations,  Up: operatingsystem-pkg

78.4 Environment operations
===========================

 -- Function: getenv (<env>)
     Get the value of the environment variable <env>

     Example:

          (%i1) load("operatingsystem")$
          (%i2) getenv("PATH");
          (%o2) /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin


File: maxima.info,  Node: opsubst-pkg,  Next: orthopoly-pkg,  Prev: operatingsystem-pkg,  Up: Top

79 opsubst
**********

* Menu:

* Functions and Variables for opsubst::


File: maxima.info,  Node: Functions and Variables for opsubst,  Prev: opsubst-pkg,  Up: opsubst-pkg

79.1 Functions and Variables for opsubst
========================================

 -- Function: opsubst
          opsubst (<f>,<g>,<e>)
          opsubst (<g>=<f>,<e>)
          opsubst ([<g1>=<f1>,<g2>=<f2>,..., <gn>=<fn>],<e>)
     The function ‘opsubst’ is similar to the function ‘subst’, except
     that ‘opsubst’ only makes substitutions for the operators in an
     expression.  In general, When <f> is an operator in the expression
     <e>, substitute <g> for <f> in the expression <e>.

     To determine the operator, ‘opsubst’ sets ‘inflag’ to true.  This
     means ‘opsubst’ substitutes for the internal, not the displayed,
     operator in the expression.

     Examples:
          (%i1) load ("opsubst")$

          (%i2) opsubst(f,g,g(g(x)));
          (%o2)                     f(f(x))
          (%i3) opsubst(f,g,g(g));
          (%o3)                       f(g)
          (%i4) opsubst(f,g[x],g[x](z));
          (%o4)                       f(z)
          (%i5) opsubst(g[x],f, f(z));
          (%o5)                      g (z)
                                      x
          (%i6) opsubst(tan, sin, sin(sin));
          (%o6)                     tan(sin)
          (%i7) opsubst([f=g,g=h],f(x));
          (%o7)                       h(x)

     Internally, Maxima does not use the unary negation, division, or
     the subtraction operators; thus:
          (%i8) opsubst("+","-",a-b);
          (%o8)                     a - b
          (%i9) opsubst("f","-",-a);
          (%o9)                      - a
          (%i10) opsubst("^^","/",a/b);
                                       a
          (%o10)                       -
                                       b

     The internal representation of -a*b is *(-1,a,b); thus
          (%i11) opsubst("[","*", -a*b);
          (%o11)                  [- 1, a, b]

     When either operator isn’t a Maxima symbol, generally some other
     function will signal an error:
          (%i12) opsubst(a+b,f, f(x));

          Improper name or value in functional position:
          b + a
           -- an error.  Quitting.  To debug this try debugmode(true);

     However, subscripted operators are allowed:
          (%i13) opsubst(g[5],f, f(x));
          (%o13)                     g (x)
                                      5

     To use this function write first ‘load("opsubst")’.


File: maxima.info,  Node: orthopoly-pkg,  Next: pslq-pkg,  Prev: opsubst-pkg,  Up: Top

80 orthopoly
************

* Menu:

* Introduction to orthogonal polynomials::
* Functions and Variables for orthogonal polynomials::


File: maxima.info,  Node: Introduction to orthogonal polynomials,  Next: Functions and Variables for orthogonal polynomials,  Prev: orthopoly-pkg,  Up: orthopoly-pkg

80.1 Introduction to orthogonal polynomials
===========================================

‘orthopoly’ is a package for symbolic and numerical evaluation of
several kinds of orthogonal polynomials, including Chebyshev, Laguerre,
Hermite, Jacobi, Legendre, and ultraspherical (Gegenbauer) polynomials.
Additionally, ‘orthopoly’ includes support for the spherical Bessel,
spherical Hankel, and spherical harmonic functions.

   For the most part, ‘orthopoly’ follows the conventions of Abramowitz
and Stegun Handbook of Mathematical Functions, Chapter 22 (10th
printing, December 1972); additionally, we use Gradshteyn and Ryzhik,
Table of Integrals, Series, and Products (1980 corrected and enlarged
edition), and Eugen Merzbacher Quantum Mechanics (2nd edition, 1970).

   Barton Willis of the University of Nebraska at Kearney (UNK) wrote
the ‘orthopoly’ package and its documentation.  The package is released
under the GNU General Public License (GPL).

80.1.1 Getting Started with orthopoly
-------------------------------------

‘load ("orthopoly")’ loads the ‘orthopoly’ package.

   To find the third-order Legendre polynomial,

     (%i1) legendre_p (3, x);
                           3             2
                  5 (1 - x)    15 (1 - x)
     (%o1)      - ---------- + ----------- - 6 (1 - x) + 1
                      2             2

   To express this as a sum of powers of <x>, apply <ratsimp> or <rat>
to the result.

     (%i2) [ratsimp (%), rat (%)];
                             3           3
                          5 x  - 3 x  5 x  - 3 x
     (%o2)/R/            [----------, ----------]
                              2           2

   Alternatively, make the second argument to ‘legendre_p’ (its “main”
variable) a canonical rational expression (CRE).

     (%i1) legendre_p (3, rat (x));
                                   3
                                5 x  - 3 x
     (%o1)/R/                   ----------
                                    2

   For floating point evaluation, ‘orthopoly’ uses a running error
analysis to estimate an upper bound for the error.  For example,

     (%i1) jacobi_p (150, 2, 3, 0.2);
     (%o1) interval(- 0.062017037936715, 1.533267919277521E-11)

   Intervals have the form ‘interval (<c>, <r>)’, where <c> is the
center and <r> is the radius of the interval.  Since Maxima does not
support arithmetic on intervals, in some situations, such as graphics,
you want to suppress the error and output only the center of the
interval.  To do this, set the option variable
‘orthopoly_returns_intervals’ to ‘false’.

     (%i1) orthopoly_returns_intervals : false;
     (%o1)                         false
     (%i2) jacobi_p (150, 2, 3, 0.2);
     (%o2)                  - 0.062017037936715

   Refer to the section *note Floating point Evaluation:: for more
information.

   Most functions in ‘orthopoly’ have a ‘gradef’ property; thus

     (%i1) diff (hermite (n, x), x);
     (%o1)                     2 n H     (x)
                                    n - 1
     (%i2) diff (gen_laguerre (n, a, x), x);
                   (a)               (a)
                n L   (x) - (n + a) L     (x) unit_step(n)
                   n                 n - 1
     (%o2)      ------------------------------------------
                                    x

   The unit step function in the second example prevents an error that
would otherwise arise by evaluating with <n> equal to 0.

     (%i3) ev (%, n = 0);
     (%o3)                           0

   The ‘gradef’ property only applies to the “main” variable;
derivatives with respect other arguments usually result in an error
message; for example

     (%i1) diff (hermite (n, x), x);
     (%o1)                     2 n H     (x)
                                    n - 1
     (%i2) diff (hermite (n, x), n);

     Maxima doesn't know the derivative of hermite with respect the first
     argument
      -- an error.  Quitting.  To debug this try debugmode(true);

   Generally, functions in ‘orthopoly’ map over lists and matrices.  For
the mapping to fully evaluate, the option variables ‘doallmxops’ and
‘listarith’ must both be ‘true’ (the defaults).  To illustrate the
mapping over matrices, consider

     (%i1) hermite (2, x);
                                          2
     (%o1)                    - 2 (1 - 2 x )
     (%i2) m : matrix ([0, x], [y, 0]);
                                 [ 0  x ]
     (%o2)                       [      ]
                                 [ y  0 ]
     (%i3) hermite (2, m);
                    [                             2  ]
                    [      - 2        - 2 (1 - 2 x ) ]
     (%o3)          [                                ]
                    [             2                  ]
                    [ - 2 (1 - 2 y )       - 2       ]

   In the second example, the ‘i, j’ element of the value is ‘hermite
(2, m[i,j])’; this is not the same as computing ‘-2 + 4 m . m’, as seen
in the next example.

     (%i4) -2 * matrix ([1, 0], [0, 1]) + 4 * m . m;
                         [ 4 x y - 2      0     ]
     (%o4)               [                      ]
                         [     0      4 x y - 2 ]

   If you evaluate a function at a point outside its domain, generally
‘orthopoly’ returns the function unevaluated.  For example,

     (%i1) legendre_p (2/3, x);
     (%o1)                        P   (x)
                                   2/3

   ‘orthopoly’ supports translation into TeX; it also does
two-dimensional output on a terminal.

     (%i1) spherical_harmonic (l, m, theta, phi);
                               m
     (%o1)                    Y (theta, phi)
                               l
     (%i2) tex (%);
     $$Y_{l}^{m}\left(\vartheta,\varphi\right)$$
     (%o2)                         false
     (%i3) jacobi_p (n, a, a - b, x/2);
                               (a, a - b) x
     (%o3)                    P          (-)
                               n          2
     (%i4) tex (%);
     $$P_{n}^{\left(a,a-b\right)}\left({{x}\over{2}}\right)$$
     (%o4)                         false

80.1.2 Limitations
------------------

When an expression involves several orthogonal polynomials with symbolic
orders, it’s possible that the expression actually vanishes, yet Maxima
is unable to simplify it to zero.  If you divide by such a quantity,
you’ll be in trouble.  For example, the following expression vanishes
for integers <n> greater than 1, yet Maxima is unable to simplify it to
zero.

     (%i1) (2*n - 1) * legendre_p (n - 1, x) * x - n * legendre_p (n, x)
           + (1 - n) * legendre_p (n - 2, x);
     (%o1)  (2 n - 1) P     (x) x - n P (x) + (1 - n) P     (x)
                       n - 1           n               n - 2

   For a specific <n>, we can reduce the expression to zero.

     (%i2) ev (% ,n = 10, ratsimp);
     (%o2)                           0

   Generally, the polynomial form of an orthogonal polynomial is
ill-suited for floating point evaluation.  Here’s an example.

     (%i1) p : jacobi_p (100, 2, 3, x)$

     (%i2) subst (0.2, x, p);
     (%o2)                3.4442767023833592E+35
     (%i3) jacobi_p (100, 2, 3, 0.2);
     (%o3)  interval(0.18413609135169, 6.8990300925815987E-12)
     (%i4) float(jacobi_p (100, 2, 3, 2/10));
     (%o4)                   0.18413609135169

   The true value is about 0.184; this calculation suffers from extreme
subtractive cancellation error.  Expanding the polynomial and then
evaluating, gives a better result.
     (%i5) p : expand(p)$
     (%i6) subst (0.2, x, p);
     (%o6) 0.18413609766122982

   This isn’t a general rule; expanding the polynomial does not always
result in an expression that is better suited for numerical evaluation.
By far, the best way to do numerical evaluation is to make one or more
of the function arguments floating point numbers.  By doing that,
specialized floating point algorithms are used for evaluation.

   Maxima’s ‘float’ function is somewhat indiscriminate; if you apply
‘float’ to an expression involving an orthogonal polynomial with a
symbolic degree or order parameter, these parameters may be converted
into floats; after that, the expression will not evaluate fully.
Consider

     (%i1) assoc_legendre_p (n, 1, x);
                                    1
     (%o1)                         P (x)
                                    n
     (%i2) float (%);
                                   1.0
     (%o2)                        P   (x)
                                   n
     (%i3) ev (%, n=2, x=0.9);
                                  1.0
     (%o3)                       P   (0.9)
                                  2

   The expression in (%o3) will not evaluate to a float; ‘orthopoly’
doesn’t recognize floating point values where it requires an integer.
Similarly, numerical evaluation of the ‘pochhammer’ function for orders
that exceed ‘pochhammer_max_index’ can be troublesome; consider

     (%i1) x :  pochhammer (1, 10), pochhammer_max_index : 5;
     (%o1)                         (1)
                                      10

   Applying ‘float’ doesn’t evaluate <x> to a float

     (%i2) float (x);
     (%o2)                       (1.0)
                                      10.0

   To evaluate <x> to a float, you’ll need to bind
‘pochhammer_max_index’ to 11 or greater and apply ‘float’ to <x>.

     (%i3) float (x), pochhammer_max_index : 11;
     (%o3)                       3628800.0

   The default value of ‘pochhammer_max_index’ is 100; change its value
after loading ‘orthopoly’.

   Finally, be aware that reference books vary on the definitions of the
orthogonal polynomials; we’ve generally used the conventions of
Abramowitz and Stegun.

   Before you suspect a bug in orthopoly, check some special cases to
determine if your definitions match those used by ‘orthopoly’.
Definitions often differ by a normalization; occasionally, authors use
“shifted” versions of the functions that makes the family orthogonal on
an interval other than (-1, 1).  To define, for example, a Legendre
polynomial that is orthogonal on (0, 1), define

     (%i1) shifted_legendre_p (n, x) := legendre_p (n, 2*x - 1)$

     (%i2) shifted_legendre_p (2, rat (x));
                                 2
     (%o2)/R/                 6 x  - 6 x + 1
     (%i3) legendre_p (2, rat (x));
                                    2
                                 3 x  - 1
     (%o3)/R/                    --------
                                    2

80.1.3 Floating point Evaluation
--------------------------------

Most functions in ‘orthopoly’ use a running error analysis to estimate
the error in floating point evaluation; the exceptions are the spherical
Bessel functions and the associated Legendre polynomials of the second
kind.  For numerical evaluation, the spherical Bessel functions call
SLATEC functions.  No specialized method is used for numerical
evaluation of the associated Legendre polynomials of the second kind.

   The running error analysis ignores errors that are second or higher
order in the machine epsilon (also known as unit roundoff).  It also
ignores a few other errors.  It’s possible (although unlikely) that the
actual error exceeds the estimate.

   Intervals have the form ‘interval (<c>, <r>)’, where <c> is the
center of the interval and <r> is its radius.  The center of an interval
can be a complex number, and the radius is always a positive real
number.

   Here is an example.

     (%i1) fpprec : 50$

     (%i2) y0 : jacobi_p (100, 2, 3, 0.2);
     (%o2) interval(0.1841360913516871, 6.8990300925815987E-12)
     (%i3) y1 : bfloat (jacobi_p (100, 2, 3, 1/5));
     (%o3) 1.8413609135168563091370224958913493690868904463668b-1

   Let’s test that the actual error is smaller than the error estimate

     (%i4) is (abs (part (y0, 1) - y1) < part (y0, 2));
     (%o4)                         true

   Indeed, for this example the error estimate is an upper bound for the
true error.

   Maxima does not support arithmetic on intervals.

     (%i1) legendre_p (7, 0.1) + legendre_p (8, 0.1);
     (%o1) interval(0.18032072148437508, 3.1477135311021797E-15)
             + interval(- 0.19949294375000004, 3.3769353084291579E-15)

   A user could define arithmetic operators that do interval math.  To
define interval addition, we can define

     (%i1) infix ("@+")$

     (%i2) "@+"(x,y) := interval (part (x, 1) + part (y, 1), part (x, 2)
           + part (y, 2))$

     (%i3) legendre_p (7, 0.1) @+ legendre_p (8, 0.1);
     (%o3) interval(- 0.019172222265624955, 6.5246488395313372E-15)

   The special floating point routines get called when the arguments are
complex.  For example,

     (%i1) legendre_p (10, 2 + 3.0*%i);
     (%o1) interval(- 3.876378825E+7 %i - 6.0787748E+7,
                                                1.2089173052721777E-6)

   Let’s compare this to the true value.

     (%i1) float (expand (legendre_p (10, 2 + 3*%i)));
     (%o1)          - 3.876378825E+7 %i - 6.0787748E+7

   Additionally, when the arguments are big floats, the special floating
point routines get called; however, the big floats are converted into
double floats and the final result is a double.

     (%i1) ultraspherical (150, 0.5b0, 0.9b0);
     (%o1) interval(- 0.043009481257265, 3.3750051301228864E-14)

80.1.4 Graphics and ‘orthopoly’
-------------------------------

To plot expressions that involve the orthogonal polynomials, you must do
two things:
  1. Set the option variable ‘orthopoly_returns_intervals’ to ‘false’,
  2. Quote any calls to ‘orthopoly’ functions.
   If function calls aren’t quoted, Maxima evaluates them to polynomials
before plotting; consequently, the specialized floating point code
doesn’t get called.  Here is an example of how to plot an expression
that involves a Legendre polynomial.

     (%i1) plot2d ('(legendre_p (5, x)), [x, 0, 1]),
                             orthopoly_returns_intervals : false;
     (%o1)

   The entire expression ‘legendre_p (5, x)’ is quoted; this is
different than just quoting the function name using ‘'legendre_p (5,
<x>)’.

80.1.5 Miscellaneous Functions
------------------------------

The ‘orthopoly’ package defines the Pochhammer symbol and a unit step
function.  ‘orthopoly’ uses the Kronecker delta function and the unit
step function in ‘gradef’ statements.

   To convert Pochhammer symbols into quotients of gamma functions, use
‘makegamma’.

     (%i1) makegamma (pochhammer (x, n));
                               gamma(x + n)
     (%o1)                     ------------
                                 gamma(x)
     (%i2) makegamma (pochhammer (1/2, 1/2));
                                     1
     (%o2)                       ---------
                                 sqrt(%pi)

   Derivatives of the Pochhammer symbol are given in terms of the ‘psi’
function.

     (%i1) diff (pochhammer (x, n), x);
     (%o1)             (x)  (psi (x + n) - psi (x))
                          n     0             0
     (%i2) diff (pochhammer (x, n), n);
     (%o2)                   (x)  psi (x + n)
                                n    0

   You need to be careful with the expression in (%o1); the difference
of the ‘psi’ functions has polynomials when ‘<x> = -1, -2, .., -<n>’.
These polynomials cancel with factors in ‘pochhammer (<x>, <n>)’ making
the derivative a degree ‘<n> - 1’ polynomial when <n> is a positive
integer.

   The Pochhammer symbol is defined for negative orders through its
representation as a quotient of gamma functions.  Consider

     (%i1) q : makegamma (pochhammer (x, n));
                               gamma(x + n)
     (%o1)                     ------------
                                 gamma(x)
     (%i2) sublis ([x=11/3, n= -6], q);
                                    729
     (%o2)                        - ----
                                    2240

   Alternatively, we can get this result directly.

     (%i1) pochhammer (11/3, -6);
                                    729
     (%o1)                        - ----
                                    2240

   The unit step function is left-continuous; thus

     (%i1) [unit_step (-1/10), unit_step (0), unit_step (1/10)];
     (%o1)                       [0, 0, 1]

   If you need a unit step function that is neither left or right
continuous at zero, define your own using ‘signum’; for example,

     (%i1) xunit_step (x) := (1 + signum (x))/2$

     (%i2) [xunit_step (-1/10), xunit_step (0), xunit_step (1/10)];
                                     1
     (%o2)                       [0, -, 1]
                                     2

   Do not redefine ‘unit_step’ itself; some code in ‘orthopoly’ requires
that the unit step function be left-continuous.

80.1.6 Algorithms
-----------------

Generally, ‘orthopoly’ does symbolic evaluation by using a hypergeometic
representation of the orthogonal polynomials.  The hypergeometic
functions are evaluated using the (undocumented) functions ‘hypergeo11’
and ‘hypergeo21’.  The exceptions are the half-integer Bessel functions
and the associated Legendre function of the second kind.  The
half-integer Bessel functions are evaluated using an explicit
representation, and the associated Legendre function of the second kind
is evaluated using recursion.

   For floating point evaluation, we again convert most functions into a
hypergeometic form; we evaluate the hypergeometic functions using
forward recursion.  Again, the exceptions are the half-integer Bessel
functions and the associated Legendre function of the second kind.
Numerically, the half-integer Bessel functions are evaluated using the
SLATEC code.


File: maxima.info,  Node: Functions and Variables for orthogonal polynomials,  Prev: Introduction to orthogonal polynomials,  Up: orthopoly-pkg

80.2 Functions and Variables for orthogonal polynomials
=======================================================

 -- Function: assoc_legendre_p (<n>, <m>, <x>)
     The associated Legendre function of the first kind of degree n and
     order m, assoc_legendre_p(n,m,z) , is a solution of the
     differential equation:

     (1-z^2)*diff(w,z,2) - 2*z*diff(w,z) + (n*(n+1)-m^2/(1-z^2))*w = 0

     This is related to the Legendre polynomial, legendre_p(n,x) via

     assoc_legendre_p(n,m,x) = (-1)^m*(1-x^2)^(m/2)
     diff(legendre_p(n,x),x,m)

     Reference: A&S eqn 22.5.37
     (https://personal.math.ubc.ca/~cbm/aands/page_779.htm), A&S eqn
     8.6.6 (https://personal.math.ubc.ca/~cbm/aands/page_334.htm), and
     A&S eqn 8.2.5
     (https://personal.math.ubc.ca/~cbm/aands/page_333.htm).

     Some examples:
          (%i1) assoc_legendre_p(2,0,x);
                                                           2
                                                  3 (1 - x)
          (%o1)                   (- 3 (1 - x)) + ---------- + 1
                                                      2
          (%i2) factor(%);
                                                2
                                             3 x  - 1
          (%o2)                              --------
                                                2
          (%i3) factor(assoc_legendre_p(2,1,x));
                                                        2
          (%o3)                         - 3 x sqrt(1 - x )

          (%i4) (-1)^1*(1-x^2)^(1/2)*diff(legendre_p(2,x),x);
                                                              2
          (%o4)                   - (3 - 3 (1 - x)) sqrt(1 - x )

          (%i5) factor(%);
                                                        2
          (%o5)                         - 3 x sqrt(1 - x )

 -- Function: assoc_legendre_q (<n>, <m>, <x>)
     The associated Legendre function of the second kind of degree n and
     order m, assoc_legendre_q(n,m,z) , is a solution of the
     differential equation:

     (1-z^2)*diff(w,z,2) - 2*z*diff(w,z) + (n*(n+1)-m^2/(1-z^2))*w = 0

     Reference: Abramowitz and Stegun, equation 8.5.3 and 8.1.8.

     Some examples:
          (%i1) assoc_legendre_q(0,0,x);
                                                 x + 1
                                           log(- -----)
                                                 x - 1
          (%o1)                            ------------
                                                2
          (%i2) assoc_legendre_q(1,0,x);
                                              x + 1
                                        log(- -----) x - 2
                                              x - 1
          (%o2)/R/                      ------------------
                                                2
          (%i3) assoc_legendre_q(1,1,x);
          (%o3)/R/
                    x + 1            2   2               2            x + 1            2
              log(- -----) sqrt(1 - x ) x  - 2 sqrt(1 - x ) x - log(- -----) sqrt(1 - x )
                    x - 1                                             x - 1
            - ---------------------------------------------------------------------------
                                                  2
                                               2 x  - 2

 -- Function: chebyshev_t (<n>, <x>)
     The Chebyshev polynomial of the first kind of degree n,
     chebyshev_t(n,x).

     Reference: A&S eqn 22.5.47
     (https://personal.math.ubc.ca/~cbm/aands/page_779.htm).

     The polynomials chebyshev_t(n,x) can be written in terms of a
     hypergeometric function:

     hypergeometric([-n,n],[1/2],(1-x)/2)

     The polynomials can also be defined in terms of the sum

     chebyshev_t(n,x) =
     n/2*sum((-1)^r/(n-r)*binomial(n-r,r)*(2*x)^(n-2*r), r, 0,
     floor(n/2))

     or the Rodrigues formula

     chebyshev_t(n,x) = 1/(k(n)*w(x))*diff(w(x)*(1-x^2)^n, x, n)

     where

     w(x) = 1/sqrt(1-x^2)

     k_n = (-2)^n*pochhammer(1/2,n)

     Some examples:
          (%i1) chebyshev_t(2,x);
                                                           2
          (%o1)                   (- 4 (1 - x)) + 2 (1 - x)  + 1
          (%i2) factor(%);
                                                2
          (%o2)                              2 x  - 1
          (%i3) factor(chebyshev_t(3,x));
                                                 2
          (%o3)                            x (4 x  - 3)
          (%i4) factor(hgfred([-3,3],[1/2],(1-x)/2));
                                                 2
          (%o4)                            x (4 x  - 3)

 -- Function: chebyshev_u (<n>, <x>)
     The Chebyshev polynomial of the second kind of degree n,
     chebyshev_u(n,x) .

     Reference: A&S eqn 22.5.48
     (https://personal.math.ubc.ca/~cbm/aands/page_779.htm).

     The polynomials chebyshev_u(n,x) can be written in terms of a
     hypergeometric function:

     chebyshev_u(n,x) = (n+1)*hypergeometric([-n,n+1],[3/2],(1-x)/2)

     The polynomials can also be defined in terms of the sum

     chebyshev_u(n,x) = sum((-1)^r*binomial(n-r,r)*(2*x)^(n-2*r), r, 0,
     floor(n/2))

     or the Rodrigues formula

     chebyshev_u(n,x) = 1/(k(n)*w(x))*diff(w(x)*(1-x^2)^n, x, n)

     where

     w(x) = sqrt(1-x^2)

     k(n) = (-2)^n*pochhammer(3/2,n)/(n+1) .

          (%i1) chebyshev_u(2,x);
                                                            2
                                      8 (1 - x)    4 (1 - x)
          (%o1)                 3 ((- ---------) + ---------- + 1)
                                          3            3
          (%i2) expand(%);
                                                2
          (%o2)                              4 x  - 1
          (%i3) expand(chebyshev_u(3,x));
                                               3
          (%o3)                             8 x  - 4 x
          (%i4) expand(4*hgfred([-3,5],[3/2],(1-x)/2));
                                               3
          (%o4)                             8 x  - 4 x

 -- Function: gen_laguerre (<n>, <a>, <x>)
     The generalized Laguerre polynomial of degree n,
     gen_laguerre(n,a,x) .

     These can be defined by

     gen_laguerre(n, a, x) = binomial(n+a,n)*hypergeometric([-n], [a+1],
     x)

     The polynomials can also be defined by the sum

     gen_laguerre(n, a, x) =
     sum(pochhammer(a+k+1,n-k)/((n-k)!*k!)*(-x)^k, k, 0, n)

     or the Rodrigues formula

     gen_laguerre(n, a, x) = 1/(k(n)*w(x))*diff(w(x)*x^n, x, n)

     where

     w(x) = %e^(-x)*x^a

     k(n) = n!

     Reference: A&S eqn 22.5.54
     (https://personal.math.ubc.ca/~cbm/aands/page_780.htm).

     Some examples:
          (%i1) gen_laguerre(1,k,x);
                                                       x
          (%o1)                         (k + 1) (1 - -----)
                                                     k + 1
          (%i2) gen_laguerre(2,k,x);
                                                   2
                                                  x            2 x
                           (k + 1) (k + 2) (--------------- - ----- + 1)
                                            (k + 1) (k + 2)   k + 1
          (%o2)            ---------------------------------------------
                                                 2
          (%i3) binomial(2+k,2)*hgfred([-2],[1+k],x);
                                                   2
                                                  x            2 x
                           (k + 1) (k + 2) (--------------- - ----- + 1)
                                            (k + 1) (k + 2)   k + 1
          (%o3)            ---------------------------------------------
                                                 2


 -- Function: hermite (<n>, <x>)
     The Hermite polynomial of degree n, hermite(n,x) .

     These polynomials may be defined by a hypergeometric function

     hermite(n,x) = (2*x)^n * hypergeometric([-n/2, -n/2+1/2],[],
     -1/x^2)

     or by the series

     hermite(n,x) = n!*sum((-1)^k*(2*x)^(n-2*k)/(k!*(n-2*k)!), k, 0,
     floor(n/2))

     or the Rodrigues formula

     hermite(n,x) = 1/(k(n)*w(x))*diff(w(x), x, n)

     where

     w(x) = %e(-x^2/2)

     k(n) = (-1)^n

     Reference: A&S eqn 22.5.55
     (https://personal.math.ubc.ca/~cbm/aands/page_780.htm).

     Some examples:
          (%i1) hermite(3,x);
                                                        2
                                                     2 x
          (%o1)                          - 12 x (1 - ----)
                                                      3
          (%i2) expand(%);
                                               3
          (%o2)                             8 x  - 12 x
          (%i3) expand(hermite(4,x));
                                            4       2
          (%o3)                         16 x  - 48 x  + 12
          (%i4) expand((2*x)^4*hgfred([-2,-2+1/2],[],-1/x^2));
                                            4       2
          (%o4)                         16 x  - 48 x  + 12
          (%i5) expand(4!*sum((-1)^k*(2*x)^(4-2*k)/(k!*(4-2*k)!),k,0,floor(4/2)));
                                            4       2
          (%o5)                         16 x  - 48 x  + 12

 -- Function: intervalp (<e>)
     Return ‘true’ if the input is an interval and return false if it
     isn’t.

 -- Function: jacobi_p (<n>, <a>, <b>, <x>)
     The Jacobi polynomial, jacobi_p(n,a,b,x) .

     The Jacobi polynomials are actually defined for all a and b;
     however, the Jacobi polynomial weight (1 - x)^a (1 + x)^b isn’t
     integrable for a <= -1 or b <= -1 .

     Reference: A&S eqn 22.5.42
     (https://personal.math.ubc.ca/~cbm/aands/page_779.htm).

     The polynomial may be defined in terms of hypergeometric functions:

     jacobi_p(n,a,b,x) =
     binomial(n+a,n)*hypergeometric([-n,n+a+b+1],[a+1],(1-x)/2)

     or the Rodrigues formula

     jacobi_p(n,a,b,x) = 1/(k(n)*w(x))*diff(w(x)*(1-x^2)^n, x, n)

     where

     w(x) = (1-x)^a*(1-x)^b

     k(n) = (-2)^n*n!

     Some examples:
          (%i1) jacobi_p(0,a,b,x);
          (%o1)                                  1
          (%i2) jacobi_p(1,a,b,x);
                                              (b + a + 2) (1 - x)
          (%o2)                  (a + 1) (1 - -------------------)
                                                   2 (a + 1)

 -- Function: laguerre (<n>, <x>)
     The Laguerre polynomial, laguerre(n,x) of degree n.

     Reference: A&S eqn 22.5.16
     (https://personal.math.ubc.ca/~cbm/aands/page_778.htm) and A&S eqn
     22.5.54 (https://personal.math.ubc.ca/~cbm/aands/page_780.htm).

     These are related to the generalized Laguerre polynomial by

     laguerre(n,x) = gen_laguerre(n,0,x)

     The polynomials are given by the sum

     laguerre(n,x) = sum((-1)^k/k!*binomial(n,k)*x^k,k,0,n)

     Some examples:
          (%i1) laguerre(1,x);
          (%o1)                                1 - x
          (%i2) laguerre(2,x);
                                            2
                                           x
          (%o2)                            -- - 2 x + 1
                                           2
          (%i3) gen_laguerre(2,0,x);
                                            2
                                           x
          (%o3)                            -- - 2 x + 1
                                           2
          (%i4) sum((-1)^k/k!*binomial(2,k)*x^k,k,0,2);
                                            2
                                           x
          (%o4)                            -- - 2 x + 1
                                           2

 -- Function: legendre_p (<n>, <x>)
     The Legendre polynomial of the first kind, legendre(n,x) , of
     degree n.

     Reference: A&S eqn 22.5.50
     (https://personal.math.ubc.ca/~cbm/aands/page_779.htm) and A&S eqn
     22.5.51 (https://personal.math.ubc.ca/~cbm/aands/page_779.htm).

     The Legendre polynomial is related to the Jacobi polynomials by

     legendre_p(n,x) = jacobi_p(n,0,0,x)

     or the Rodrigues formula

     legendre_p(n,x) = 1/(k(n)*w(x))*diff(w(x)*(1-x^2)^n, x, n)

     where

     w(x) = 1

     k(n) = (-2)^n*n!

     Some examples:
          (%i1) legendre_p(1,x);
          (%o1)                                  x
          (%i2) legendre_p(2,x);
                                                           2
                                                  3 (1 - x)
          (%o2)                   (- 3 (1 - x)) + ---------- + 1
                                                      2
          (%i3) expand(%);
                                                2
                                             3 x    1
          (%o3)                              ---- - -
                                              2     2
          (%i4) expand(legendre_p(3,x));
                                               3
                                            5 x    3 x
          (%o4)                             ---- - ---
                                             2      2
          (%i5) expand(jacobi_p(3,0,0,x));
                                               3
                                            5 x    3 x
          (%o5)                             ---- - ---
                                             2      2

 -- Function: legendre_q (<n>, <x>)
     The Legendre function of the second kind, legendre_q(n,x) of degree
     n.

     Reference: Abramowitz and Stegun, equations 8.5.3 and 8.1.8.

     These are related to assoc_legendre_q(n,m,x) by

     legendre_q(n,x) = assoc_legendre_q(n,0,x)

     Some examples:
          (%i1) legendre_q(0,x);
                                                 x + 1
                                           log(- -----)
                                                 x - 1
          (%o1)                            ------------
                                                2
          (%i2) legendre_q(1,x);
                                              x + 1
                                        log(- -----) x - 2
                                              x - 1
          (%o2)/R/                      ------------------
                                                2
          (%i3) assoc_legendre_q(1,0,x);
                                              x + 1
                                        log(- -----) x - 2
                                              x - 1
          (%o3)/R/                      ------------------
                                                2

 -- Function: orthopoly_recur (<f>, <args>)
     Returns a recursion relation for the orthogonal function family <f>
     with arguments <args>.  The recursion is with respect to the
     polynomial degree.

          (%i1) orthopoly_recur (legendre_p, [n, x]);
                              (2 n + 1) P (x) x - n P     (x)
                                         n           n - 1
          (%o1)   P     (x) = -------------------------------
                   n + 1                   n + 1

     The second argument to ‘orthopoly_recur’ must be a list with the
     correct number of arguments for the function <f>; if it isn’t,
     Maxima signals an error.

          (%i1) orthopoly_recur (jacobi_p, [n, x]);

          Function jacobi_p needs 4 arguments, instead it received 2
           -- an error.  Quitting.  To debug this try debugmode(true);

     Additionally, when <f> isn’t the name of one of the families of
     orthogonal polynomials, an error is signalled.

          (%i1) orthopoly_recur (foo, [n, x]);

          A recursion relation for foo isn't known to Maxima
           -- an error.  Quitting.  To debug this try debugmode(true);

 -- Variable: orthopoly_returns_intervals
     Default value: ‘true’

     When ‘orthopoly_returns_intervals’ is ‘true’, floating point
     results are returned in the form ‘interval (<c>, <r>)’, where <c>
     is the center of an interval and <r> is its radius.  The center can
     be a complex number; in that case, the interval is a disk in the
     complex plane.

 -- Function: orthopoly_weight (<f>, <args>)

     Returns a three element list; the first element is the formula of
     the weight for the orthogonal polynomial family <f> with arguments
     given by the list <args>; the second and third elements give the
     lower and upper endpoints of the interval of orthogonality.  For
     example,

          (%i1) w : orthopoly_weight (hermite, [n, x]);
                                      2
                                   - x
          (%o1)                 [%e    , - inf, inf]
          (%i2) integrate(w[1]*hermite(3, x)*hermite(2, x), x, w[2], w[3]);
          (%o2)                           0

     The main variable of <f> must be a symbol; if it isn’t, Maxima
     signals an error.

 -- Function: pochhammer (<x>, <n>)
     The Pochhammer symbol, pochhammer(x,n) .  (See A&S eqn 6.1.22
     (https://personal.math.ubc.ca/~cbm/aands/page_256.htm) and DLMF
     5.2.iii (https://dlmf.nist.gov/5.2.iii)).

     For nonnegative integers <n> with ‘<n> <= pochhammer_max_index’,
     the expression pochhammer(x, n) evaluates to the product x (x + 1)
     (x + 2) ... (x + n - 1) when n > 0 and to 1 when n = 0.  For
     negative n, pochhammer (x, n) is defined as (-1)^n / pochhammer (1
     - x, -n).

     Thus

          (%i1) pochhammer (x, 3);
          (%o1)                   x (x + 1) (x + 2)
          (%i2) pochhammer (x, -3);
                                           1
          (%o2)               - -----------------------
                                (1 - x) (2 - x) (3 - x)

     To convert a Pochhammer symbol into a quotient of gamma functions,
     (see A&S eqn 6.1.22
     (https://personal.math.ubc.ca/~cbm/aands/page_256.htm)) use
     ‘makegamma’; for example

          (%i1) makegamma (pochhammer (x, n));
                                    gamma(x + n)
          (%o1)                     ------------
                                      gamma(x)

     When <n> exceeds ‘pochhammer_max_index’ or when <n> is symbolic,
     ‘pochhammer’ returns a noun form.

          (%i1) pochhammer (x, n);
          (%o1)                         (x)
                                           n

 -- Variable: pochhammer_max_index
     Default value: 100

     ‘pochhammer (<n>, <x>)’ expands to a product if and only if ‘<n> <=
     pochhammer_max_index’.

     Examples:

          (%i1) pochhammer (x, 3), pochhammer_max_index : 3;
          (%o1)                   x (x + 1) (x + 2)
          (%i2) pochhammer (x, 4), pochhammer_max_index : 3;
          (%o2)                         (x)
                                           4

     Reference: A&S eqn 6.1.16
     (https://personal.math.ubc.ca/~cbm/aands/page_256.htm).

 -- Function: spherical_bessel_j (<n>, <x>)
     The spherical Bessel function of the first kind,
     spherical_bessel_j(n,x).

     Reference: A&S eqn 10.1.8
     (https://personal.math.ubc.ca/~cbm/aands/page_437.htm) and A&S eqn
     10.1.15 (https://personal.math.ubc.ca/~cbm/aands/page_439.htm).

     It is related to the Bessel function by

     spherical_bessel_j(n,x) = sqrt(%pi/(2*x))*bessel_j(n+1/2,x)

     Some examples:
          (%i1) spherical_bessel_j(1,x);
                                          sin(x)
                                          ------ - cos(x)
                                            x
          (%o1)                           ---------------
                                                 x
          (%i2) spherical_bessel_j(2,x);
                                          3             3 cos(x)
                                  (- (1 - --) sin(x)) - --------
                                           2               x
                                          x
          (%o2)                   ------------------------------
                                                x
          (%i3) expand(%);
                                    sin(x)    3 sin(x)   3 cos(x)
          (%o3)                  (- ------) + -------- - --------
                                      x           3          2
                                                 x          x
          (%i4) expand(sqrt(%pi/(2*x))*bessel_j(2+1/2,x)),besselexpand:true;
                                    sin(x)    3 sin(x)   3 cos(x)
          (%o4)                  (- ------) + -------- - --------
                                      x           3          2
                                                 x          x

 -- Function: spherical_bessel_y (<n>, <x>)
     The spherical Bessel function of the second kind,
     <spherical_bessel_y(n,x).

     Reference: A&S eqn 10.1.9
     (https://personal.math.ubc.ca/~cbm/aands/page_437.htm) and A&S eqn
     10.1.15 (https://personal.math.ubc.ca/~cbm/aands/page_439.htm).

     It is related to the Bessel function by

     spherical_bessel_y(n,x) = sqrt(%pi/(2*x))*bessel_y(n+1/2,x)

          (%i1) spherical_bessel_y(1,x);
                                                     cos(x)
                                        (- sin(x)) - ------
                                                       x
          (%o1)                         -------------------
                                                 x
          (%i2) spherical_bessel_y(2,x);
                                     3 sin(x)        3
                                     -------- - (1 - --) cos(x)
                                        x             2
                                                     x
          (%o2)                    - --------------------------
                                                 x
          (%i3) expand(%);
                                    3 sin(x)    cos(x)   3 cos(x)
          (%o3)                  (- --------) + ------ - --------
                                        2         x          3
                                       x                    x
          (%i4) expand(sqrt(%pi/(2*x))*bessel_y(2+1/2,x)),besselexpand:true;
                                    3 sin(x)    cos(x)   3 cos(x)
          (%o4)                  (- --------) + ------ - --------
                                        2         x          3
                                       x                    x

 -- Function: spherical_hankel1 (<n>, <x>)
     The spherical Hankel function of the first kind,
     spherical_hankel1(n,x).

     Reference: A&S eqn 10.1.36
     (https://personal.math.ubc.ca/~cbm/aands/page_439.htm).

     This is defined by

     spherical_hankel1(n,x) = spherical_bessel_j(n,x) +
     %i*spherical_bessel_y(n,x)

 -- Function: spherical_hankel2 (<n>, <x>)
     The spherical Hankel function of the second kind,
     spherical_hankel2(n,x).

     Reference: A&S eqn 10.1.17
     (https://personal.math.ubc.ca/~cbm/aands/page_439.htm).

     This is defined by

     spherical_hankel2(n,x) = spherical_bessel_j(n,x) -
     %i*spherical_bessel_y(n,x)

 -- Function: spherical_harmonic (<n>, <m>, <theta>, <phi>)
     The spherical harmonic function, spherical_harmonic(n,m,theta,phi)
     .

     Spherical harmonics satisfy the angular part of Laplace’s equation
     in spherical coordinates.

     For integers n and m such that n <= abs(m) and for theta in [0,
     %pi] , Maxima’s spherical harmonic function can be defined by

     spherical_harmonic(n, m, theta, phi) := (-1)^m *
     (((n-m)!*(2*n+1))/(4*%pi*(n+m)!))^(1/2)*
     exp(%i*m*phi)*assoc_legendre_p(n,m,cos(theta))

     Further, when n < abs(m) , the spherical harmonic function
     vanishes.

     The factor (-1)^m, frequently used in Quantum mechanics, is called
     the Condon-Shortely phase
     (https://en.wikipedia.org/wiki/Spherical_harmonics#Condon%E2%80%93Shortley_phase).
     Some references, including _NIST Digital Library of Mathematical
     Functions_ omit this factor; see <http://dlmf.nist.gov/14.30.E1>.

     Reference: Merzbacher 9.64.

     Some examples:
          (%i1) spherical_harmonic(1,0,theta,phi);
                                        sqrt(3) cos(theta)
          (%o1)                         ------------------
                                           2 sqrt(%pi)
          (%i2) spherical_harmonic(1,1,theta,phi);
                                              %i phi
                                    sqrt(3) %e       sin(theta)
          (%o2)                     ---------------------------
                                           3/2
                                          2    sqrt(%pi)
          (%i3) spherical_harmonic(1,-1,theta,phi);
                                              - %i phi
                                    sqrt(3) %e         sin(theta)
          (%o3)                   - -----------------------------
                                            3/2
                                           2    sqrt(%pi)
          (%i4) spherical_harmonic(2,0,theta,phi);
                                                                        2
                                                      3 (1 - cos(theta))
                    sqrt(5) ((- 3 (1 - cos(theta))) + ------------------- + 1)
                                                               2
          (%o4)     ----------------------------------------------------------
                                           2 sqrt(%pi)
          (%i5) factor(%);
                                                  2
                                    sqrt(5) (3 cos (theta) - 1)
          (%o5)                     ---------------------------
                                            4 sqrt(%pi)

 -- Function: unit_step (<x>)
     The left-continuous unit step function; thus ‘unit_step (<x>)’
     vanishes for ‘<x> <= 0’ and equals 1 for ‘<x> > 0’.

     If you want a unit step function that takes on the value 1/2 at
     zero, use ‘hstep’.

 -- Function: ultraspherical (<n>, <a>, <x>)
     The ultraspherical polynomial, ultraspherical(n,a,x) (also known as
     the Gegenbauer polynomial).

     Reference: A&S eqn 22.5.46
     (https://personal.math.ubc.ca/~cbm/aands/page_779.htm).

     These polynomials can be given in terms of Jacobi polynomials:

     ultraspherical(n,a,x) =
     gamma(a+1/2)/gamma(2*a)*gamma(n+2*a)/gamma(n+a+1/2)*jacobi_p(n,a-1/2,a-1/2,x)

     or the series

     ultraspherical(n,a,x) =
     sum((-1)^k*pochhammer(a,n-k)/k!/(n-2*k)!*(2*x)^(n-2*k),k, 0,
     floor(n/2))

     or the Rodrigues formula

     ultraspherical(n,x) = 1/(k(n)*w(x))*diff(w(x)*(1-x^2)^n, x, n)

     where

     w(x) = (1-x^2)^(a-1/2)

     k(n) = (-2)^n*pochhammer(a+1/2,n)*n!/pochhammer(2*a,n)

     Some examples:
          (%i1) ultraspherical(1,a,x);
                                             (2 a + 1) (1 - x)
          (%o1)                     2 a (1 - -----------------)
                                                        1
                                                 2 (a + -)
                                                        2
          (%i2) factor(%);
          (%o2)                                2 a x
          (%i3) factor(ultraspherical(2,a,x));
                                               2      2
          (%o3)                        a (2 a x  + 2 x  - 1)


File: maxima.info,  Node: pslq-pkg,  Next: pytranslate,  Prev: orthopoly-pkg,  Up: Top

81 pslq
*******

* Menu:

* Introduction to pslq::
* Functions and Variables for pslq::


File: maxima.info,  Node: Introduction to pslq,  Next: Functions and Variables for pslq,  Prev: pslq-pkg,  Up: pslq-pkg

81.1 Introduction to pslq
=========================

Package ‘pslq’ contains two functions.

   (1) ‘guess_exact_value’ tries to find an exact equivalent for an
inexact number (float or bigfloat).

   (2) ‘pslq_integer_relation’ tries to find integer coefficients such
that a linear combination of inexact numbers is approximately zero.


File: maxima.info,  Node: Functions and Variables for pslq,  Prev: Introduction to pslq,  Up: pslq-pkg

81.2 Functions and Variables for pslq
=====================================

 -- Function: guess_exact_value (<x>)

     When <x> is a floating point number or bigfloat,
     ‘guess_exact_value’ tries to find an exact expression (in terms of
     radicals, logarithms, exponentials, and the constant ‘%pi’) which
     is nearly equal to the given number.  If ‘guess_exact_value’ cannot
     find such an expression, <x> is returned unchanged.

     When <x> is rational number or other mapatom (other than a float or
     bigfloat), <x> is returned unchanged.

     Otherwise, <x> is a nonatomic expression, and ‘guess_exact_value’
     is applied to each of the arguments of <x>.

     Example:

          (%i1) load ("pslq.mac");
          (%o1)                       pslq.mac
          (%i2) root: float (sin (%pi/12));
          (%o2)                  0.2588190451025207
          (%i3) guess_exact_value (root);
                                  sqrt(2 - sqrt(3))
          (%o3)                   -----------------
                                          2
          (%i4) L: makelist (root^i, i, 0, 4);
          (%o4) [1.0, 0.2588190451025207, 0.06698729810778066,
                                 0.01733758853025369, 0.004487298107780675]
          (%i5) m: pslq_integer_relation(%);
          (%o5)                 [- 1, 0, 16, 0, - 16]
          (%i6) makelist (x^i, i, 0, 4) . m;
                                       4        2
          (%o6)                 (- 16 x ) + 16 x  - 1
          (%i7) solve(%);
                       sqrt(sqrt(3) + 2)      sqrt(sqrt(3) + 2)
          (%o7) [x = - -----------------, x = -----------------,
                               2                      2
                                  sqrt(2 - sqrt(3))      sqrt(2 - sqrt(3))
                            x = - -----------------, x = -----------------]
                                          2                      2

 -- Function: pslq_integer_relation (<L>)

     Implements the PSLQ algorithm [1] to find integer relations between
     bigfloat numbers.

     For a given list <L> of floating point numbers,
     ‘pslq_integer_relation’ returns a list of integers <m> such that
     ‘<m> . <L> = 0’ (with absolute residual error less than
     ‘pslq_threshold’).

     [1] D.H.Bailey: Integer Relation Detection and Lattice Reduction.

     Example:

          (%i1) load ("pslq.mac");
          (%o1)                       pslq.mac
          (%i2) root: float (sin (%pi/12));
          (%o2)                  0.2588190451025207
          (%i3) L: makelist (root^i, i, 0, 4);
          (%o3) [1.0, 0.2588190451025207, 0.06698729810778066,
                                 0.01733758853025369, 0.004487298107780675]
          (%i4) m: pslq_integer_relation(%);
          (%o4)                 [- 1, 0, 16, 0, - 16]
          (%i5) m . L;
          (%o5)                - 2.359223927328458E-16
          (%i6) float (10^(2 - fpprec));
          (%o6)                        1.0E-14
          (%i7) is (abs (m . L) < 10^(2 - fpprec));
          (%o7)                         true

 -- Variable: pslq_precision
     Default value: ‘10^(fpprec - 2)’

     Maximum magnitude of some intermediate results in
     ‘pslq_integer_relation’.  The search fails if one of the
     intermediate results has elements larger than ‘pslq_precision’.

 -- Variable: pslq_threshold
     Default value: ‘10^(2 - fpprec)’

     Threshold for absolute residual error of integer relation found by
     ‘pslq_integer_relation’.

 -- Variable: pslq_depth
     Default value: ‘20 * <n>’

     Number of iterations of the PSLQ algorithm.

     The default value is 20 times <n>, where <n> is the length of the
     list of numbers supplied to ‘pslq_integer_relation’.

 -- Variable: pslq_status

     Indicates success or failure for an integer relation search by
     ‘pslq_integer_relation’.

     When ‘pslq_status’ is 1, it indicates an integer relation was
     found, and the absolute residual error is less than
     ‘pslq_threshold’.

     When ‘pslq_status’ is 2, it indicates an integer relation was not
     found because some intermediate results are larger than
     ‘pslq_precision’.

     When ‘pslq_status’ is 3, it indicates an integer relation was not
     found because the number of iterations ‘pslq_depth’ was reached.


File: maxima.info,  Node: pytranslate,  Next: quantum_computing-pkg,  Prev: pslq-pkg,  Up: Top

82 pytranslate
**************

* Menu:

* Introduction to pytranslate::
* Functions in pytranslate::
* Extending pytranslate::


File: maxima.info,  Node: Introduction to pytranslate,  Next: Functions in pytranslate,  Up: pytranslate

82.1 Introduction to pytranslate
================================

‘pytranslate’ package provides Maxima to Python translation
functionality.  The package is experimental, and the specifications of
the functions in this package might change.  It was written as a Google
Summer of Code project by Lakshya A Agrawal (Undergraduate Student,
IIIT-Delhi) in 2019.  A detailed project report is available as a GitHub
Gist
(https://gist.github.com/LakshyAAAgrawal/33eee2d33c4788764087eef1fa67269e).

   The package needs to be loaded in a Maxima instance for use, by
executing ‘load("pytranslate");’
The statements are converted to python3 syntax.  The file pytranslate.py
must be imported for all translations to run, as shown in example.

   Example:
     (%i1) load ("pytranslate")$
     /* Define an example function to calculate factorial */
     (%i2) pytranslate(my_factorial(x) := if (x = 1 or x = 0) then 1
                       else x * my_factorial(x - 1));
     (%o2)
     def my_factorial(x, v = v):
         v = Stack({}, v)
         v.ins({"x" : x})
         return((1 if ((v["x"] == 1) or (v["x"] == 0)) \
                   else (v["x"] * my_factorial((v["x"] + (-1))))))
     m["my_factorial"] = my_factorial
     (%i3) my_factorial(5);
     (%o3)                          120
     >>> from pytranslate import *
     >>> def my_factorial(x, v = v):
     ...     v = Stack({}, v)
     ...     v.ins({"x" : x})
     ...     return((1 if ((v["x"] == 1) or (v["x"] == 0)) \
     ...     else (v["x"] * my_factorial((v["x"] + (-1))))))
     ...
     >>> my_factorial(5)
     120

   The Maxima to Python Translator works in two stages:
1.  Conversion of the internal Maxima representation to a defined
Intermediate Representation, henceforth referred as IR(mapping is
present in ‘share/pytranslate/maxima-to-ir.html’)
2.  The conversion of IR to Python.

   Supported Maxima forms:
1.  ‘Numbers’(including complex numbers)
2.  ‘Assignment operators’
3.  ‘Arithmetic operators’(+, -, *, ^, /, !)
4.  ‘Logical operators’(and, or, not)
5.  ‘Relational operators’(‘>’, ‘<’, ‘>=’, ‘<=’, ‘!=’, ‘==’)
6.  ‘Lists’
7.  ‘Arrays’
8.  ‘block’
9.  ‘Function’ and function calls
10.  ‘if’-else converted to Python conditionals
11.  ‘for’ loops
12.  ‘lambda’ form

82.1.1 Tests for pytranslate
----------------------------

The tests for ‘pytranslate’ are present at
‘share/pytranslate/rtest_pytranslate.mac’ and can be run by executing
‘batch(rtest_pytranslate, test);’


File: maxima.info,  Node: Functions in pytranslate,  Next: Extending pytranslate,  Prev: Introduction to pytranslate,  Up: pytranslate

82.2 Functions in pytranslate
=============================

 -- Function: pytranslate (<expr>, [print-ir])
     Translates the expression <expr> to equivalent python3 statements.
     Output is printed in the stdout.

     Example:
          (%i1) load ("pytranslate")$
          (%i2) pytranslate('(for i:8 step -1 unless i<3 do (print(i))));
          (%o2)
          v["i"] = 8
          while not((v["i"] < 3)):
              m["print"](v["i"])
              v["i"] = (v["i"] + -1)
          del v["i"]

     <expr> is evaluated, and the return value is used for translation.
     Hence, for statements like assignment, it might be useful to quote
     the statement:
          (%i1) load ("pytranslate")$
          (%i2) pytranslate(x:20);
          (%o2)
          20
          (%i3) pytranslate('(x:20));
          (%o3)
          v["x"] = 20

     Passing the optional parameter (<print-ir>) to ‘pytranslate’ as t,
     will print the internal IR representation of ‘expr’ and return the
     translated python3 code.

          (%i1) load("pytranslate");
          (%o1) pytranslate
          (%i2) pytranslate('(plot3d(lambda([x, y], x^2+y^(-1)), [x, 1, 10],
                             [y, 1, 10])), t);
          (body
           (funcall (element-array "m" (string "plot3d"))
                    (lambda
                        ((symbol "x") (symbol "y")
                         (op-no-bracket
                          =
                          (symbol "v")
                          (funcall (symbol "stack") (dictionary) (symbol "v"))))
                      (op +
                          (funcall (element-array (symbol "m") (string "pow"))
                                   (symbol "x") (num 2 0))
                          (funcall (element-array (symbol "m") (string "pow"))
                                   (symbol "y") (unary-op - (num 1 0)))))
                    (struct-list (string "x") (num 1 0) (num 10 0))
                    (struct-list (string "y") (num 1 0) (num 10 0))))
          (%o2)
          m["plot3d"](lambda x, y, v = Stack({}, v): (m["pow"](x, 2) + m["\
          pow"](y, (-1))), ["x", 1, 10], ["y", 1, 10])

 -- Function: show_form (<expr>)
     Displays the internal maxima form of ‘expr’
          (%i4) show_form(a^b);
          ((mexpt) $a $b)
          (%o4) a^b


File: maxima.info,  Node: Extending pytranslate,  Prev: Functions in pytranslate,  Up: pytranslate

82.3 Extending pytranslate
==========================

Working of pytranslate:
   • The entry point for pytranslate is the function ‘$pytranslate’
     defined in ‘share/pytranslate/pytranslate.lisp’.
   • ‘$pytranslate’ calls the function ‘maxima-to-ir’ with the Maxima
     expression as an argument(henceforth referred as ‘expr’).
   • ‘maxima-to-ir’ determines if ‘expr’ is atomic or non-atomic(lisp
     cons form).  If atomic, ‘atom-to-ir’ is called with ‘expr’ which
     returns the IR for the atomic expression.
     To define/modify translation for atomic expressions, make changes
     to the definition of ‘atom-to-ir’ in accordance with the IR.
   • If ‘expr’ is non-atomic, the function ‘cons-to-ir’ is called with
     ‘expr’ as an argument.
        • ‘cons-to-ir’ looks for ‘(caar expr)’ which specifies the type
          of ‘expr’, in hash-table <*maxima-direct-ir-map*> and if the
          type is found, then appends the retrieved IR with the result
          of lisp call ‘(mapcar #'maxima-to-ir (cdr expr))’, which
          applies maxima-to-ir function to all the elements present in
          the list.  Effectively, recursively generate IR for all the
          elements present in ‘expr’ and append them to the IR map for
          the type.
          Example:
               (%i9) show_form(a+b);
               ((MPLUS) $B $A)
               (%i10) pytranslate(a+b, t);
               (body (op + (element-array (symbol "v") (string "b")) \
               (element-array (symbol "v") (string "a"))))
               (%o10)
               (v["b"] + v["a"])
          Here, operator + with internal maxima representation,
          ‘(mplus)’ is present in <*maxima-direct-ir-map*> and mapped to
          ‘(op +)’ to which the result of generating IR for all other
          elements of the list (a b), i.e.  ‘(ELEMENT-ARRAY (SYMBOL "v")
          (STRING "b")) (ELEMENT-ARRAY (SYMBOL "v") (STRING "a"))’ is
          appended.

        • If ‘(caar expr)’ is not found in <*maxima-direct-ir-map*>,
          then ‘cons-to-ir’ looks for the type in
          <*maxima-special-ir-map*> which returns the function to handle
          the translation of the type of ‘expr’.  ‘cons-to-ir’ then
          calls the returned function with argument ‘expr’ as an
          argument.
          Example:
               (%i11) show_form(g(x) := x^2);
               ((mdefine simp) (($g) $x) ((mexpt) $x 2))
               (%i12) pytranslate(g(x):=x^2, t);
               (body
                (body
                 (func-def (symbol "g")
                           ((symbol "x") (op-no-bracket = (symbol "v") (symbol "v")))
                           (body-indented
                               (op-no-bracket = (symbol "v") (funcall (symbol "stack") \
                               (dictionary) (symbol "v")))
                               (obj-funcall (symbol "v") (symbol "ins") (dictionary \
                               ((string "x") (symbol "x"))))
                               (funcall (symbol "return")
                                   (funcall (element-array (symbol "f") (string "pow"))
                                        (element-array (symbol "v") (string "x"))
                                                 (num 2 0)))))
                 (op-no-bracket = (element-array (symbol "f") (string "g")) \
                 (symbol "g"))))
               (%o12)
               def g(x, v = v):
                   v = Stack({}, v)
                   v.ins({"x" : x})
                   return(f["pow"](v["x"], 2))
               f["g"] = g

          Here, ‘mdefine’, which is the type of ‘expr’ is present in
          <*maxima-special-ir-map*> which returns ‘func-def-to-ir’ as
          handler function, which is then called with ‘expr’ to generate
          the IR.
          To define/modify translation for a type, add an entry to
          <*maxima-direct-ir-map*> if only a part of the IR needs to be
          generated and the rest can be appended, otherwise, for
          complete handling of ‘expr’, add an entry to
          <*maxima-special-ir-map*> and define a function with the name
          defined in <*maxima-special-ir-map*> which returns the IR for
          the form.  The function naming convention for ir generators is
          (type)-to-ir, where type is the ‘(caar expr)’ for
          expression(‘mdefine -> func-def-to-ir’).  The function must
          return a valid IR for the specific type.
   • After the generation of IR, the function ‘ir-to-python’ is called
     with the generated ‘ir’ as an argument, which performs the codegen
     in a recursive manner.
        • ‘ir-to-python’ looks for lisp ‘(car ir)’ in the hash-table
          <*ir-python-direct-templates*>, which maps IR type to function
          handlers and calls the function returned with ‘ir’ as an
          argument.
   • To extend the IR of pytranslate, define a function with the naming
     convention (type)-to-python and add the name to
     <*ir-python-direct-templates*>.


File: maxima.info,  Node: quantum_computing-pkg,  Next: ratpow-pkg,  Prev: pytranslate,  Up: Top

83 quantum_computing-pkg
************************

* Menu:

* Package quantum_computing::
* Functions and Variables for Quantum_Computing::


File: maxima.info,  Node: Package quantum_computing,  Next: Functions and Variables for Quantum_Computing,  Prev: quantum_computing-pkg,  Up: quantum_computing-pkg

83.1 Package quantum_computing
==============================

The ‘quantum_computing’ package provides several functions to simulate
quantum computing circuits.  The state of a system of <n> qubits is
represented by a list of 2^<n> complex numbers and an operator acting on
<m> qubits is represented by a 2^<m> by 2^<m> matrix.  A hash array
<qmatrix> is defined with 6 common one-qubit matrices: the identity, the
Pauli matrices, the Hadamard matrix and the phase matrix.

   The major disadvantage compared to a real quantum computer is very
slow computing times even with a few qubits.  An advantage is that,
unlike a quantum computer, in this simulator a quantum state can be
cloned using ‘copylist’.

   This is an additional package that must be loaded with
‘load("quantum_computing")’ in order to use it.


File: maxima.info,  Node: Functions and Variables for Quantum_Computing,  Prev: Package quantum_computing,  Up: quantum_computing-pkg

83.2 Functions and Variables for Quantum_Computing
==================================================

 -- Function: binlist
          binlist (<k>)
          binlist (<k>, <n>)

     ‘binlist’(<k>), where <k> must be a natural number, returns a list
     of binary digits 0 or 1 corresponding to the digits of <k> in
     binary representation.  ‘binlist’(<k>, <n>) does the same but
     returns a list of length <n>, with leading zeros as necessary.
     Notice that for the result to represent a possible state of <m>
     qubits, <n> should be equal to 2^<m> and <k> should be between 0
     and 2^<m>-1.

 -- Function: binlist2dec (<lst>)

     Given a list <lst> with <n> binary digits, it returns the decimal
     number it represents.

 -- Function: CNOT (<q>, <i>, <j>)

     Changes the value of the <j>’th qubit, in a state <q> of <m>
     qubits, when the value of the <i>’th qubit equals 1.  It modifies
     the list <q> and returns its modified value.

 -- Function: controlled (<U>, <q>, <c>, <i>)

     Applies a matrix <U>, acting on <m> qubits, on qubits <i> through
     <i>+<m>-1 of the state <q> of <n> qubits (<n> > <m>), when the
     value of the <c>’th qubit in <q> equals 1.  <i> should be an
     integer between 1 and <n>+1-<m> and <c> should be an integer
     between 1 and <n>, excluding the qubits to be modified (<i> through
     <i>+<m>-1).

     <U> can be one of the indices of the array of common matrices
     <qmatrix> (see ‘qmatrix’).  The state <q> is modified and shown in
     the output.

 -- Function: gate
          gate (<U>, <q>)
          gate (<U>, <q>, <i>)
          gate (<U>, <q>, <i1>, ..., <im>)

     <U> must be a matrix acting on states of <m> qubits; <q> a list
     corresponding to a state of <n> qubits (<n> >= <m>); <i> and the
     <m> numbers <i1>, ..., <im> must be different integers between 1
     and <n>.

     ‘gate’(<U>, <q>) applies matrix <U> to each qubit of <q>, when <m>
     equals 1, or to the first <m> qubits of <q> when <m> is bigger than
     1.

     ‘gate’(<U>, <q>, <i>) applies matrix <U> to the qubits <i> through
     <i>+<m>-1 of <q>.

     ‘gate’(<U>, <q>, <i1>, ..., <in>) applies matrix <U> to the in the
     positions <i1>, ..., <im>.

     <U> can be one of the indices of the array of common matrices
     <qmatrix> (see ‘qmatrix’).  The state <q> is modified and shown in
     the output.

 -- Function: gate_matrix
          gate_matrix (<U>, <n>)
          gate_matrix (<U>, <n>, <i1>, ..., <im>)

     <U> must be a 2 by 2 matrix or one of the indices of the array of
     common matrices <qmatrix> (see ‘qmatrix’).  ‘gate_matrix’(<U>, <n>)
     returns the matrix corresponding to the action of <U> on each qubit
     in a state of <n> qubits.

     ‘gate_matrix’ (<U>, <n>, <i1>, ..., <im>) returns the matrix
     corresponding to the action of <U> on qubits <i1>, ..., <im> of a
     state of <n> qubits, where <i1>, ..., <im> are different integers
     between 1 and <n>.

 -- Function: linsert (<e>, <lst>, <p>)

     Inserts the expression or list <e> into the list <lst> at position
     <p>.  The list can be empty and <p> must be an integer between 1
     and the length of <lst> plus 1.

 -- Function: lreplace (<e>, <lst>, <p>)

     If <e> is a list of length <n>, the elements in the positions <p>,
     <p>+1, ..., <p>+<n>-1 of the list <lst> are replaced by <e>, or the
     first elements of <e> if the end of <lst> is reached.  If <e> is an
     expression, the element in position <p> of list <lst> is replaced
     by that expression.  <p> must be an integer between 1 and the
     length of <lst>.

 -- Function: normalize (<q>)

     Returns the normalized version of a quantum state given as a list
     <q>.

 -- Function: qdisplay (<q>)

     Represents the state <q> of a system of <n> qubits as a linear
     combination of the computational states with <n> binary digits.  It
     returns an expression including strings and symbols.

 -- System variable: qmatrix

     This variable is a predefined hash array of two by two matrices
     with the standard matrices: identity, Pauli matrices, Hadamard
     matrix and the phase matrix.  The six possible indices are I, X, Y,
     Z, H, S. <qmatrix>[I] is the identity matrix, <qmatrix>[X] the
     Pauli x matrix, <qmatrix>[Y] the Pauli y matrix, <qmatrix>[Z] the
     Pauli z matrix, <qmatrix>[H] the Hadamard matrix and <qmatrix>[S]
     the phase matrix.

 -- Function: qmeasure
          qmeasure (<q>)
          qmeasure (<q>, <i1>, ..., <im>)

     Measures the value of one or more qubits in a system of <n> qubits
     with state <q>.  The <m> positive integers <i1>, ..., <im> are the
     positions of the qubits to be measured It requires 1 or more
     arguments.  The first argument must be the state q.  If the only
     argument given is <q>, all the n qubits will be measured.

     It returns a list with the values of the qubits measured (either 0
     or 1), in the same order they were requested or in ascending order
     if the only argument given was <q>.  It modifies the list <q>,
     reflecting the collapse of the quantum state after the measurement.

 -- Function: qubits
          qubits (<n>)
          qubits (<i1>, ..., <in>)

     ‘qubits’(<n>) returns a list representing the ground state of a
     system of <n> qubits.

     ‘qubits’(<i1>, ..., <in>) returns a list with representing the
     state of <n> qubits with values <i1>, ..., <in>.

 -- Function: qswap (<q>, <i>, <j>)

     Interchanges the states of qubits <i> and <j> in the state <q> of a
     system of several qubits.  It modifies the list <q> and returns its
     modified value.

 -- Function: Rx (<a>)

     Returns the 2 by two matrix (acting on one qubit) corresponding to
     a rotation of with an angle of <a> radians around the x axis.

 -- Function: Ry (<a>)

     Returns the 2 by two matrix (acting on one qubit) corresponding to
     a rotation of with an angle of <a> radians around the y axis.

 -- Function: Rz (<a>)

     Returns the 2 by two matrix (acting on one qubit) corresponding to
     a rotation of with an angle of <a> radians around the z axis.

 -- Function: tprod (<o1>, ..., <on>)

     Returns the tensor product of the <n> matrices or lists <o1>, ...,
     <on>.

 -- Function: toffoli (<q>, (<i>, (<j>, (<k>)

     Changes the value of the <k>’th qubit, in the state <q> of <n>
     qubits, if the values of the <i>’th anf <j>’th qubits are equal to
     1.  It modifies the list <q> and returns its new value.


File: maxima.info,  Node: ratpow-pkg,  Next: romberg-pkg,  Prev: quantum_computing-pkg,  Up: Top

84 ratpow
*********

The package ‘ratpow’ provides functions that return the coefficients of
the numerator of a CRE polynomial in a given variable.

   For example,
   • ‘ratp_coeffs(5*x^7-3*x^2+4,x)’ returns ‘[[7,5],[2,-3],[0,4]]’,
     which omits zero terms;
   • ‘ratp_dense_coeffs(5*x^7-y*x^2+4,x)’ returns ‘[5,0,0,0,0,-y,0,4]’,
     which includes zero terms;
   • ‘ratp_dense_coeffs((x^4-y^4)/(x-y),x)’ returns ‘[1,y,y^2,y^3]’,
     because CRE simplifies the expression to ‘x^3+y*x^2+y^2*x+y^3’;
   • ‘ratp_dense_coeffs(x+sqrt(x),x)’ returns ‘[1,sqrt(x)]’ while
     ‘ratp_dense_coeffs(x+sqrt(x),sqrt(x))’ returns ‘[1,x]’: in CRE
     form, ‘x’ and ‘sqrt(x)’ are treated as independent variables.

   The returned coefficients are in CRE form except for numbers.

   For the list of vars of a CRE polynomial, use ‘showratvars’.  For the
denominator of a CRE polynomial, use ‘ratdenom’.

   For information about CREs see also ‘rat’, ‘ratdisrep’ and
‘showratvars’.
* Menu:

* Functions and Variables for ratpow::


File: maxima.info,  Node: Functions and Variables for ratpow,  Up: ratpow-pkg

84.1 Functions and Variables for ratpow
=======================================

 -- Function: ratp_hipow (<expr>, <x>)

     Returns the highest power of <x> in ‘ratnumer(expr)’

          (%i1) load("ratpow")$
          (%i2) ratp_hipow( x^(5/2) + x^2 , x);
          (%o2)                           2
          (%i3) ratp_hipow( x^(5/2) + x^2 , sqrt(x));
          (%o3)                           5

 -- Function: ratp_lopow (<expr>, <x>)

     Returns the lowest power of <x> in ‘ratnumer(expr)’

          (%i1) load("ratpow")$
          (%i2) ratp_lopow( x^5 + x^2 , x);
          (%o2)                           2

     The following example returns 0 since ‘1’ equals ‘x^0’:
          (%i1) load("ratpow")$
          (%i2) ratp_lopow( x^5 + x^2 + 1, x);
          (%o2)                           0

     The CRE form of the following equation contains ‘sqrt(x)’ and ‘x’.
     Since they are interpreted as independent variables, ‘ratp_lopow’
     returns ‘0’:
          (%i1) load("ratpow")$
          (%i2) g:sqrt(x)^5 + sqrt(x)^2;
                                       5/2
          (%o2)                       x    + x
          (%i3) showratvars(g);
                                        1/2
          (%o3)                       [x   , x]
          (%i4) ratp_lopow( g, x);
          (%o4)                           0
          (%i5) ratp_lopow( g, sqrt(x));
          (%o5)                           0

 -- Function: ratp_coeffs (<expr>, <x>)

     Returns the powers and coefficients of <x> in ‘ratnumer(expr)’ as a
     list of length-2 lists; returned coefficients are in CRE form
     except for numbers.

     ‘ratnumer(expr)’.
          (%i1) load("ratpow")$
          (%i2) ratp_coeffs( 4*x^3 + x + sqrt(x), x);
          (%o2)/R/         [[3, 4], [1, 1], [0, sqrt(x)]]

 -- Function: ratp_dense_coeffs (<expr>, <x>)

     Returns the coefficients of powers of <x> in ‘ratnumer(expr)’ from
     highest to lowest; returned coefficients are in CRE form except for
     numbers.

          (%i1) load("ratpow")$
          (%i2) ratp_dense_coeffs( 4*x^3 + x + sqrt(x), x);
          (%o2)/R/               [4, 0, 1, sqrt(x)]


File: maxima.info,  Node: romberg-pkg,  Next: simplex-pkg,  Prev: ratpow-pkg,  Up: Top

85 romberg
**********

* Menu:

* Functions and Variables for romberg::


File: maxima.info,  Node: Functions and Variables for romberg,  Up: romberg-pkg

85.1 Functions and Variables for romberg
========================================

 -- Function: romberg
          romberg (<expr>, <x>, <a>, <b>)
          romberg (<F>, <a>, <b>)

     Computes a numerical integration by Romberg’s method.

     ‘romberg(<expr>, <x>, <a>, <b>)’ returns an estimate of the
     integral ‘integrate(<expr>, <x>, <a>, <b>)’.  <expr> must be an
     expression which evaluates to a floating point value when <x> is
     bound to a floating point value.

     ‘romberg(<F>, <a>, <b>)’ returns an estimate of the integral
     ‘integrate(<F>(x), x, <a>, <b>)’ where ‘x’ represents the unnamed,
     sole argument of <F>; the actual argument is not named ‘x’.  <F>
     must be a Maxima or Lisp function which returns a floating point
     value when the argument is a floating point value.  <F> may name a
     translated or compiled Maxima function.

     The accuracy of ‘romberg’ is governed by the global variables
     ‘rombergabs’ and ‘rombergtol’.  ‘romberg’ terminates successfully
     when the absolute difference between successive approximations is
     less than ‘rombergabs’, or the relative difference in successive
     approximations is less than ‘rombergtol’.  Thus when ‘rombergabs’
     is 0.0 (the default) only the relative error test has any effect on
     ‘romberg’.

     ‘romberg’ halves the stepsize at most ‘rombergit’ times before it
     gives up; the maximum number of function evaluations is therefore
     ‘2^rombergit’.  If the error criterion established by ‘rombergabs’
     and ‘rombergtol’ is not satisfied, ‘romberg’ prints an error
     message.  ‘romberg’ always makes at least ‘rombergmin’ iterations;
     this is a heuristic intended to prevent spurious termination when
     the integrand is oscillatory.

     ‘romberg’ repeatedly evaluates the integrand after binding the
     variable of integration to a specific value (and not before).  This
     evaluation policy makes it possible to nest calls to ‘romberg’, to
     compute multidimensional integrals.  However, the error
     calculations do not take the errors of nested integrations into
     account, so errors may be underestimated.  Also, methods devised
     especially for multidimensional problems may yield the same
     accuracy with fewer function evaluations.

     See also ‘Introduction to QUADPACK’, a collection of numerical
     integration functions.

     Examples:

     A 1-dimensional integration.
          (%i1) f(x) := 1/((x - 1)^2 + 1/100) + 1/((x - 2)^2 + 1/1000)
                        + 1/((x - 3)^2 + 1/200);
                              1                 1                1
          (%o1) f(x) := -------------- + --------------- + --------------
                               2    1           2    1            2    1
                        (x - 1)  + ---   (x - 2)  + ----   (x - 3)  + ---
                                   100              1000              200
          (%i2) rombergtol : 1e-6;
          (%o2)                 9.999999999999999e-7
          (%i3) rombergit : 15;
          (%o3)                          15
          (%i4) estimate : romberg (f(x), x, -5, 5);
          (%o4)                   173.6730736617464
          (%i5) exact : integrate (f(x), x, -5, 5);
                  3/2          3/2      3/2          3/2
          (%o5) 10    atan(7 10   ) + 10    atan(3 10   )
                3/2         9/2       3/2         5/2
           + 5 2    atan(5 2   ) + 5 2    atan(5 2   ) + 10 atan(60)
           + 10 atan(40)
          (%i6) abs (estimate - exact) / exact, numer;
          (%o6)                 7.552722451569877e-11

     A 2-dimensional integration, implemented by nested calls to
     ‘romberg’.
          (%i1) g(x, y) := x*y / (x + y);
                                              x y
          (%o1)                   g(x, y) := -----
                                             x + y
          (%i2) rombergtol : 1e-6;
          (%o2)                 9.999999999999999e-7
          (%i3) estimate : romberg (romberg (g(x, y), y, 0, x/2), x, 1, 3);
          (%o3)                  0.8193023962835647
          (%i4) assume (x > 0);
          (%o4)                        [x > 0]
          (%i5) integrate (integrate (g(x, y), y, 0, x/2), x, 1, 3);
                                                     3
                                               2 log(-) - 1
                              9                      2        9
          (%o5)      (- 9 log(-)) + 9 log(3) + ------------ + -
                              2                     6         2
          (%i6) exact : radcan (%);
                              26 log(3) - 26 log(2) - 13
          (%o6)             - --------------------------
                                          3
          (%i7) abs (estimate - exact) / exact, numer;
          (%o7)                 1.371197987185102e-10

 -- Option variable: rombergabs
     Default value: 0.0

     The accuracy of ‘romberg’ is governed by the global variables
     ‘rombergabs’ and ‘rombergtol’.  ‘romberg’ terminates successfully
     when the absolute difference between successive approximations is
     less than ‘rombergabs’, or the relative difference in successive
     approximations is less than ‘rombergtol’.  Thus when ‘rombergabs’
     is 0.0 (the default) only the relative error test has any effect on
     ‘romberg’.

     See also ‘rombergit’ and ‘rombergmin’.

 -- Option variable: rombergit
     Default value: 11

     ‘romberg’ halves the stepsize at most ‘rombergit’ times before it
     gives up; the maximum number of function evaluations is therefore
     ‘2^rombergit’.  ‘romberg’ always makes at least ‘rombergmin’
     iterations; this is a heuristic intended to prevent spurious
     termination when the integrand is oscillatory.

     See also ‘rombergabs’ and ‘rombergtol’.

 -- Option variable: rombergmin
     Default value: 0

     ‘romberg’ always makes at least ‘rombergmin’ iterations; this is a
     heuristic intended to prevent spurious termination when the
     integrand is oscillatory.

     See also ‘rombergit’, ‘rombergabs’, and ‘rombergtol’.

 -- Option variable: rombergtol
     Default value: 1e-4

     The accuracy of ‘romberg’ is governed by the global variables
     ‘rombergabs’ and ‘rombergtol’.  ‘romberg’ terminates successfully
     when the absolute difference between successive approximations is
     less than ‘rombergabs’, or the relative difference in successive
     approximations is less than ‘rombergtol’.  Thus when ‘rombergabs’
     is 0.0 (the default) only the relative error test has any effect on
     ‘romberg’.

     See also ‘rombergit’ and ‘rombergmin’.


File: maxima.info,  Node: simplex-pkg,  Next: simplification-pkg,  Prev: romberg-pkg,  Up: Top

86 simplex
**********

* Menu:

* Introduction to simplex::
* Functions and Variables for simplex::


File: maxima.info,  Node: Introduction to simplex,  Next: Functions and Variables for simplex,  Prev: simplex-pkg,  Up: simplex-pkg

86.1 Introduction to simplex
============================

‘simplex’ is a package for linear optimization using the simplex
algorithm.

   Example:

     (%i1) load("simplex")$
     (%i2) minimize_lp(x+y, [3*x+2*y>2, x+4*y>3]);
                       9        7       1
     (%o2)            [--, [y = --, x = -]]
                       10       10      5

86.1.1 Tests for simplex
------------------------

There are some tests in the directory ‘share/simplex/Tests’.

86.1.1.1 klee_minty
...................

The function ‘klee_minty’ produces input for ‘linear_program’, for which
exponential time for solving is required without scaling.

   Example:

     load("klee_minty")$
     apply(linear_program, klee_minty(6));

   A better approach:

     epsilon_sx : 0$
     scale_sx : true$
     apply(linear_program, klee_minty(10));

86.1.1.2 NETLIB
...............

Some smaller problems from netlib (<https://www.netlib.org/lp/data/>)
test suite are converted to a format, readable by Maxima.  Problems are
‘adlittle’, ‘afiro’, ‘kb2’, ‘sc50a’ and ‘share2b’.  Each problem has
three input files in CSV format for matrix <A> and vectors <b> and <c>.

   Example:

     A : read_matrix("adlittle_A.csv", 'csv)$
     b : read_list("adlittle_b.csv", 'csv)$
     c : read_list("adlittle_c.csv", 'csv)$
     linear_program(A, b, c)$
     %[2];
     => 225494.9631623802

   Results:

     PROBLEM        MINIMUM                  SCALING
     adlittle       +2.2549496316E+05        false
     afiro          -4.6475314286E+02        false
     kb2            -1.7499001299E+03        true
     sc50a          -6.4575077059E+01        false
     share2b        -4.1573518187E+02        false

   The Netlib website <https://www.netlib.org/lp/data/readme> lists the
values as

     PROBLEM        MINIMUM
     adlittle       +2.2549496316E+05
     afiro          -4.6475314286E+02
     kb2            -1.7499001299E+03
     sc50a          -6.4575077059E+01
     share2b        -4.1573224074E+02


File: maxima.info,  Node: Functions and Variables for simplex,  Prev: Introduction to simplex,  Up: simplex-pkg

86.2 Functions and Variables for simplex
========================================

 -- Option variable: epsilon_lp
     Default value: ‘10^-8’

     Epsilon used for numerical computations in ‘linear_program’; it is
     set to 0 in ‘linear_program’ when all inputs are rational.

     Example:

          (%i1) load("simplex")$

          (%i2) minimize_lp(-x, [1e-9*x + y <= 1], [x,y]);
          Warning: linear_program(A,b,c): non-rat inputs found, epsilon_lp= 1.0e-8
          Warning: Solution may be incorrect.
          (%o2)                        Problem not bounded!
          (%i3) minimize_lp(-x, [10^-9*x + y <= 1], [x,y]);
          (%o3)               [- 1000000000, [y = 0, x = 1000000000]]
          (%i4) minimize_lp(-x, [1e-9*x + y <= 1], [x,y]), epsilon_lp=0;
          (%o4)     [- 9.999999999999999e+8, [y = 0, x = 9.999999999999999e+8]]

     See also: ‘linear_program’, ‘ratnump’.

 -- Function: linear_program (<A>, <b>, <c>)

     ‘linear_program’ is an implementation of the simplex algorithm.
     ‘linear_program(A, b, c)’ computes a vector <x> for which ‘c.x’ is
     minimum possible among vectors for which ‘A.x = b’ and ‘x >= 0’.
     Argument <A> is a matrix and arguments <b> and <c> are lists.

     ‘linear_program’ returns a list which contains the minimizing
     vector <x> and the minimum value ‘c.x’.  If the problem is not
     bounded, it returns "Problem not bounded!"  and if the problem is
     not feasible, it returns "Problem not feasible!".

     To use this function first load the ‘simplex’ package with
     ‘load("simplex");’.

     Example:

          (%i2) A: matrix([1,1,-1,0], [2,-3,0,-1], [4,-5,0,0])$
          (%i3) b: [1,1,6]$
          (%i4) c: [1,-2,0,0]$
          (%i5) linear_program(A, b, c);
                             13     19        3
          (%o5)            [[--, 4, --, 0], - -]
                             2      2         2

     See also: ‘minimize_lp’, ‘scale_lp’, and ‘epsilon_lp’.

 -- Function: maximize_lp (<obj>, <cond>, [<pos>])

     Maximizes linear objective function <obj> subject to some linear
     constraints <cond>.  See ‘minimize_lp’ for detailed description of
     arguments and return value.

     See also: ‘minimize_lp’.

 -- Function: minimize_lp (<obj>, <cond>, [<pos>])

     Minimizes a linear objective function <obj> subject to some linear
     constraints <cond>.  <cond> a list of linear equations or
     inequalities.  In strict inequalities ‘>’ is replaced by ‘>=’ and
     ‘<’ by ‘<=’.  The optional argument <pos> is a list of decision
     variables which are assumed to be positive.

     If the minimum exists, ‘minimize_lp’ returns a list which contains
     the minimum value of the objective function and a list of decision
     variable values for which the minimum is attained.  If the problem
     is not bounded, ‘minimize_lp’ returns "Problem not bounded!"  and
     if the problem is not feasible, it returns "Problem not feasible!".

     The decision variables are not assumed to be non-negative by
     default.  If all decision variables are non-negative, set
     ‘nonnegative_lp’ to ‘true’ or include ‘all’ in the optional
     argument <pos>.  If only some of decision variables are positive,
     list them in the optional argument <pos> (note that this is more
     efficient than adding constraints).

     ‘minimize_lp’ uses the simplex algorithm which is implemented in
     maxima ‘linear_program’ function.

     To use this function first load the ‘simplex’ package with
     ‘load("simplex");’.

     Examples:

          (%i1) minimize_lp(x+y, [3*x+y=0, x+2*y>2]);
                                4       6        2
          (%o1)                [-, [y = -, x = - -]]
                                5       5        5
          (%i2) minimize_lp(x+y, [3*x+y>0, x+2*y>2]), nonnegative_lp=true;
          (%o2)                [1, [y = 1, x = 0]]
          (%i3) minimize_lp(x+y, [3*x+y>0, x+2*y>2], all);
          (%o3)                         [1, [y = 1, x = 0]]
          (%i4) minimize_lp(x+y, [3*x+y=0, x+2*y>2]), nonnegative_lp=true;
          (%o4)                Problem not feasible!
          (%i5) minimize_lp(x+y, [3*x+y>0]);
          (%o5)                Problem not bounded!


     There is also a limited ability to solve linear programs with
     symbolic constants.

          (%i1) declare(c,constant)$
          (%i2) maximize_lp(x+y, [y<=-x/c+3, y<=-x+4], [x, y]), epsilon_lp=0;
          Is (c-1)*c positive, negative or zero?
          p;
          Is c*(2*c-1) positive, negative or zero?
          p;
          Is c positive or negative?
          p;
          Is c-1 positive, negative or zero?
          p;
          Is 2*c-1 positive, negative or zero?
          p;
          Is 3*c-4 positive, negative or zero?
          p;
                                           1                1
          (%o2)                 [4, [x = -----, y = 3 - ---------]]
                                             1               1
                                         1 - -          (1 - -) c
                                             c               c

          (%i1) (assume(c>4/3), declare(c,constant))$
          (%i2) maximize_lp(x+y, [y<=-x/c+3, y<=-x+4], [x, y]), epsilon_lp=0;
                                           1                1
          (%o2)                 [4, [x = -----, y = 3 - ---------]]
                                             1               1
                                         1 - -          (1 - -) c
                                             c               c

     See also: ‘maximize_lp’, ‘nonnegative_lp’, ‘epsilon_lp’.

 -- Option variable: nonnegative_lp
 -- Option variable: nonegative_lp
     Default value: ‘false’

     If ‘nonnegative_lp’ is true all decision variables to ‘minimize_lp’
     and ‘maximize_lp’ are assumed to be non-negative.  ‘nonegative_lp’
     is a deprecated alias.

     See also: ‘minimize_lp’.

 -- Option variable: scale_lp
     Default value: ‘false’

     When ‘scale_lp’ is ‘true’, ‘linear_program’ scales its input so
     that the maximum absolute value in each row or column is 1.

 -- Variable: pivot_count_sx

     After ‘linear_program’ returns, ‘pivot_count_sx’ is the number of
     pivots in last computation.

 -- Variable: pivot_max_sx

     ‘pivot_max_sx’ is the maximum number of pivots allowed by
     ‘linear_program’.


File: maxima.info,  Node: simplification-pkg,  Next: solve_rec-pkg,  Prev: simplex-pkg,  Up: Top

87 simplification
*****************

* Menu:

* Introduction to simplification::
* Package absimp::
* Package facexp::
* Package functs::
* Package ineq::
* Package rducon::
* Package scifac::


File: maxima.info,  Node: Introduction to simplification,  Next: Package absimp,  Prev: simplification-pkg,  Up: simplification-pkg

87.1 Introduction to simplification
===================================

The directory ‘maxima/share/simplification’ contains several scripts
which implement simplification rules and functions, and also some
functions not related to simplification.


File: maxima.info,  Node: Package absimp,  Next: Package facexp,  Prev: Introduction to simplification,  Up: simplification-pkg

87.2 Package absimp
===================

The ‘absimp’ package contains pattern-matching rules that extend the
built-in simplification rules for the ‘abs’ and ‘signum’ functions.
‘absimp’ respects relations established with the built-in ‘assume’
function and by declarations such as ‘mode_declare (m, even, n, odd)’
for even or odd integers.

   ‘absimp’ defines ‘unitramp’ and ‘unitstep’ functions in terms of
‘abs’ and ‘signum’.

   ‘load ("absimp")’ loads this package.  ‘demo ("absimp")’ shows a
demonstration of this package.

   Examples:

     (%i1) load ("absimp")$
     (%i2) (abs (x))^2;
                                     2
     (%o2)                          x
     (%i3) diff (abs (x), x);
                                    x
     (%o3)                        ------
                                  abs(x)
     (%i4) cosh (abs (x));
     (%o4)                        cosh(x)


File: maxima.info,  Node: Package facexp,  Next: Package functs,  Prev: Package absimp,  Up: simplification-pkg

87.3 Package facexp
===================

The ‘facexp’ package contains several related functions that provide the
user with the ability to structure expressions by controlled expansion.
This capability is especially useful when the expression contains
variables that have physical meaning, because it is often true that the
most economical form of such an expression can be obtained by fully
expanding the expression with respect to those variables, and then
factoring their coefficients.  While it is true that this procedure is
not difficult to carry out using standard Maxima functions, additional
fine-tuning may also be desirable, and these finishing touches can be
more difficult to apply.

   The function ‘facsum’ and its related forms provide a convenient
means for controlling the structure of expressions in this way.  Another
function, ‘collectterms’, can be used to add two or more expressions
that have already been simplified to this form, without resimplifying
the whole expression again.  This function may be useful when the
expressions are very large.

   ‘load ("facexp")’ loads this package.  ‘demo ("facexp")’ shows a
demonstration of this package.

 -- Function: facsum (<expr>, <arg_1>, ..., <arg_n>)
     Returns a form of <expr> which depends on the arguments <arg_1>,
     ..., <arg_n>.  The arguments can be any form suitable for
     ‘ratvars’, or they can be lists of such forms.  If the arguments
     are not lists, then the form returned is fully expanded with
     respect to the arguments, and the coefficients of the arguments are
     factored.  These coefficients are free of the arguments, except
     perhaps in a non-rational sense.

     If any of the arguments are lists, then all such lists are combined
     into a single list, and instead of calling ‘factor’ on the
     coefficients of the arguments, ‘facsum’ calls itself on these
     coefficients, using this newly constructed single list as the new
     argument list for this recursive call.  This process can be
     repeated to arbitrary depth by nesting the desired elements in
     lists.

     It is possible that one may wish to ‘facsum’ with respect to more
     complicated subexpressions, such as ‘log (x + y)’.  Such arguments
     are also permissible.

     Occasionally the user may wish to obtain any of the above forms for
     expressions which are specified only by their leading operators.
     For example, one may wish to ‘facsum’ with respect to all ‘log’’s.
     In this situation, one may include among the arguments either the
     specific ‘log’’s which are to be treated in this way, or
     alternatively, either the expression ‘operator (log)’ or ‘'operator
     (log)’.  If one wished to ‘facsum’ the expression <expr> with
     respect to the operators <op_1>, ..., <op_n>, one would evaluate
     ‘facsum (<expr>, operator (<op_1>, ..., <op_n>))’.  The ‘operator’
     form may also appear inside list arguments.

     In addition, the setting of the switches ‘facsum_combine’ and
     ‘nextlayerfactor’ may affect the result of ‘facsum’.

 -- Global variable: nextlayerfactor
     Default value: ‘false’

     When ‘nextlayerfactor’ is ‘true’, recursive calls of ‘facsum’ are
     applied to the factors of the factored form of the coefficients of
     the arguments.

     When ‘false’, ‘facsum’ is applied to each coefficient as a whole
     whenever recursive calls to ‘facsum’ occur.

     Inclusion of the atom ‘nextlayerfactor’ in the argument list of
     ‘facsum’ has the effect of ‘nextlayerfactor: true’, but for the
     next level of the expression only.  Since ‘nextlayerfactor’ is
     always bound to either ‘true’ or ‘false’, it must be presented
     single-quoted whenever it appears in the argument list of ‘facsum’.

 -- Global variable: facsum_combine
     Default value: ‘true’

     ‘facsum_combine’ controls the form of the final result returned by
     ‘facsum’ when its argument is a quotient of polynomials.  If
     ‘facsum_combine’ is ‘false’ then the form will be returned as a
     fully expanded sum as described above, but if ‘true’, then the
     expression returned is a ratio of polynomials, with each polynomial
     in the form described above.

     The ‘true’ setting of this switch is useful when one wants to
     ‘facsum’ both the numerator and denominator of a rational
     expression, but does not want the denominator to be multiplied
     through the terms of the numerator.

 -- Function: factorfacsum (<expr>, <arg_1>, ... <arg_n>)
     Returns a form of <expr> which is obtained by calling ‘facsum’ on
     the factors of <expr> with <arg_1>, ...  <arg_n> as arguments.  If
     any of the factors of <expr> is raised to a power, both the factor
     and the exponent will be processed in this way.

 -- Function: collectterms (<expr>, <arg_1>, ..., <arg_n>)

     Collects all terms that contain <arg_1> ...  <arg_n>.  If several
     expressions have been simplified with the following functions
     ‘facsum’, ‘factorfacsum’, ‘factenexpand’, ‘facexpten’ or
     ‘factorfacexpten’, and they are to be added together, it may be
     desirable to combine them using the function ‘collecterms’.
     ‘collecterms’ can take as arguments all of the arguments that can
     be given to these other associated functions with the exception of
     ‘nextlayerfactor’, which has no effect on ‘collectterms’.  The
     advantage of ‘collectterms’ is that it returns a form similar to
     ‘facsum’, but since it is adding forms that have already been
     processed by ‘facsum’, it does not need to repeat that effort.
     This capability is especially useful when the expressions to be
     summed are very large.

     See also ‘factor’.

     Example:

          (%i1) (exp(x)+2)*x+exp(x);
                                       x          x
          (%o1)                   x (%e  + 2) + %e
          (%i2) collectterms(expand(%),exp(x));
                                            x
          (%o2)                   (x + 1) %e  + 2 x


File: maxima.info,  Node: Package functs,  Next: Package ineq,  Prev: Package facexp,  Up: simplification-pkg

87.4 Package functs
===================

 -- Function: rempart (<expr>, <n>)
     Removes part <n> from the expression <expr>.

     If <n> is a list of the form ‘[<l>, <m>]’ then parts <l> thru <m>
     are removed.

     To use this function write first ‘load("functs")’.

 -- Function: wronskian ([<f_1>, ..., <f_n>], <x>)
     Returns the Wronskian matrix of the list of expressions [<f_1>,
     ..., <f_n>] in the variable <x>.  The determinant of the Wronskian
     matrix is the Wronskian determinant of the list of expressions.

     To use ‘wronskian’, first ‘load("functs")’.  Example:

          (%i1) load ("functs")$
          (%i2) wronskian([f(x), g(x)],x);
                              [   f(x)       g(x)    ]
                              [                      ]
          (%o2)               [ d          d         ]
                              [ -- (f(x))  -- (g(x)) ]
                              [ dx         dx        ]

 -- Function: tracematrix (<M>)
     Returns the trace (sum of the diagonal elements) of matrix <M>.

     To use this function write first ‘load("functs")’.

 -- Function: rational (<z>)
     Multiplies numerator and denominator of <z> by the complex
     conjugate of denominator, thus rationalizing the denominator.
     Returns canonical rational expression (CRE) form if given one, else
     returns general form.

     To use this function write first ‘load("functs")’.

 -- Function: nonzeroandfreeof (<x>, <expr>)
     Returns ‘true’ if <expr> is nonzero and ‘freeof (<x>, <expr>)’
     returns ‘true’.  Returns ‘false’ otherwise.

     To use this function write first ‘load("functs")’.

 -- Function: linear (<expr>, <x>)
     When <expr> is an expression of the form ‘<a>*<x> + <b>’ where <a>
     is nonzero, and <a> and <b> are free of <x>, ‘linear’ returns a
     list of three equations, one for each of the three formal variables
     <b>, <a>, and <x>.  Otherwise, ‘linear’ returns ‘false’.

     ‘load("antid")’ loads this function.

     Example:

          (%i1) load ("antid");
          (%o1)  /maxima/share/integration/antid.mac
          (%i2) linear ((1 - w)*(1 - x)*z, z);
          (%o2) [bargumentb = 0, aargumenta = (w - 1) x - w + 1,
                                                            xargumentx = z]
          (%i3) linear (cos(u - v) + cos(u + v), u);
          (%o3)                         false

 -- Function: gcdivide (<p>, <q>)

     When the option variable ‘takegcd’ is ‘true’ which is the default,
     ‘gcdivide’ divides the polynomials <p> and <q> by their greatest
     common divisor and returns the ratio of the results.  ‘gcdivde’
     calls the function ‘ezgcd’ to divide the polynomials by the
     greatest common divisor.

     When ‘takegcd’ is ‘false’, ‘gcdivide’ returns the ratio ‘<p>/<q>’.

     To use this function write first ‘load("functs")’.

     See also ‘ezgcd’, ‘gcd’, ‘gcdex’, and ‘poly_gcd’.

     Example:

          (%i1) load("functs")$

          (%i2) p1:6*x^3+19*x^2+19*x+6;
                                  3       2
          (%o2)                6 x  + 19 x  + 19 x + 6
          (%i3) p2:6*x^5+13*x^4+12*x^3+13*x^2+6*x;
                            5       4       3       2
          (%o3)          6 x  + 13 x  + 12 x  + 13 x  + 6 x
          (%i4) gcdivide(p1, p2);
                                       x + 1
          (%o4)                        ------
                                        3
                                       x  + x
          (%i5) takegcd:false;
          (%o5)                         false
          (%i6) gcdivide(p1, p2);
                                 3       2
                              6 x  + 19 x  + 19 x + 6
          (%o6)          ----------------------------------
                            5       4       3       2
                         6 x  + 13 x  + 12 x  + 13 x  + 6 x
          (%i7) ratsimp(%);
                                       x + 1
          (%o7)                        ------
                                        3
                                       x  + x

 -- Function: arithmetic (<a>, <d>, <n>)
     Returns the <n>-th term of the arithmetic series ‘<a>, <a> + <d>,
     <a> + 2*<d>, ..., <a> + (<n> - 1)*<d>’.

     To use this function write first ‘load("functs")’.

 -- Function: geometric (<a>, <r>, <n>)
     Returns the <n>-th term of the geometric series ‘<a>, <a>*<r>,
     <a>*<r>^2, ..., <a>*<r>^(<n> - 1)’.

     To use this function write first ‘load("functs")’.

 -- Function: harmonic (<a>, <b>, <c>, <n>)
     Returns the <n>-th term of the harmonic series ‘<a>/<b>, <a>/(<b> +
     <c>), <a>/(<b> + 2*<c>), ..., <a>/(<b> + (<n> - 1)*<c>)’.

     To use this function write first ‘load("functs")’.

 -- Function: arithsum (<a>, <d>, <n>)
     Returns the sum of the arithmetic series from 1 to <n>.

     To use this function write first ‘load("functs")’.

 -- Function: geosum (<a>, <r>, <n>)
     Returns the sum of the geometric series from 1 to <n>.  If <n> is
     infinity (‘inf’) then a sum is finite only if the absolute value of
     <r> is less than 1.

     To use this function write first ‘load("functs")’.

 -- Function: gaussprob (<x>)
     Returns the Gaussian probability function ‘%e^(-<x>^2/2) /
     sqrt(2*%pi)’.

     To use this function write first ‘load("functs")’.

 -- Function: gd (<x>)
     Returns the Gudermannian function ‘2*atan(%e^x)-%pi/2’.

     To use this function write first ‘load("functs")’.

 -- Function: agd (<x>)
     Returns the inverse Gudermannian function ‘log (tan (%pi/4 +
     x/2))’.

     To use this function write first ‘load("functs")’.

 -- Function: vers (<x>)
     Returns the versed sine ‘1 - cos (x)’.

     To use this function write first ‘load("functs")’.

 -- Function: covers (<x>)
     Returns the coversed sine ‘1 - sin (<x>)’.

     To use this function write first ‘load("functs")’.

 -- Function: exsec (<x>)
     Returns the exsecant ‘sec (<x>) - 1’.

     To use this function write first ‘load("functs")’.

 -- Function: hav (<x>)
     Returns the haversine ‘(1 - cos(x))/2’.

     To use this function write first ‘load("functs")’.

 -- Function: combination (<n>, <r>)
     Returns the number of combinations of <n> objects taken <r> at a
     time.

     To use this function write first ‘load("functs")’.

 -- Function: permutation (<n>, <r>)
     Returns the number of permutations of <r> objects selected from a
     set of <n> objects.

     To use this function write first ‘load("functs")’.


File: maxima.info,  Node: Package ineq,  Next: Package rducon,  Prev: Package functs,  Up: simplification-pkg

87.5 Package ineq
=================

The ‘ineq’ package contains simplification rules for inequalities.

   Example session:

     (%i1) load("ineq")$
     tellsimp: warning: rule will treat '+
                               ' as noncommutative and nonassociative.
     tellsimp: warning: rule will treat '+
                               ' as noncommutative and nonassociative.
     tellsimp: warning: rule will treat '+
                               ' as noncommutative and nonassociative.
     tellsimp: warning: rule will treat '+
                               ' as noncommutative and nonassociative.
     tellsimp: warning: rule will treat '+
                               ' as noncommutative and nonassociative.
     tellsimp: warning: rule will treat '+
                               ' as noncommutative and nonassociative.
     tellsimp: warning: rule will treat '+
                               ' as noncommutative and nonassociative.
     tellsimp: warning: rule will treat '+
                               ' as noncommutative and nonassociative.
     (%i2) a>=4;  /* a sample inequality */
     (%o2)                        a >= 4
     (%o3)                     b + a > c + 4
     (%o4)                       7 x < 7 y
     (%o5)                    - 2 x <= - 6 z
                                      2
     (%o6)                      1 <= a  + 1
     (%o8)                       2 x < 3 x
     (%o9)                        a >= b
     (%o10)                   a + 3 >= b + 3
     (%o11)                       a >= b
     (%o12)                     a >= c - b
     (%o13)                     b + a >= c
     (%o14)                 (- c) + b + a >= 0
     (%o15)                   c - b - a <= 0
                                    2
     (%o16)                  (z - 1)  > - 2 z
                                 2
     (%o17)                     z  + 1 > 0
     (%o18)                        true
     (%i19) (b>c)+%; /* add a second, strict inequality */

   Be careful about using parentheses around the inequalities: when the
user types in ‘(A > B) + (C = 5)’ the result is ‘A + C > B + 5’, but ‘A
> B + C = 5’ is a syntax error, and ‘(A > B + C) = 5’ is something else
entirely.

   Do ‘disprule (all)’ to see a complete listing of the rule
definitions.

   The user will be queried if Maxima is unable to decide the sign of a
quantity multiplying an inequality.

   The most common mis-feature is illustrated by:

     (%i1) eq: a > b;
     (%o1)                         a > b
     (%i2) 2*eq;
     (%o2)                       2 (a > b)
     (%i3) % - eq;
     (%o3)                         a > b

   Another problem is 0 times an inequality; the default to have this
turn into 0 has been left alone.  However, if you type
‘X*<some_inequality>’ and Maxima asks about the sign of ‘X’ and you
respond ‘zero’ (or ‘z’), the program returns ‘X*<some_inequality>’ and
not use the information that ‘X’ is 0.  You should do ‘ev (%, x: 0)’ in
such a case, as the database will only be used for comparison purposes
in decisions, and not for the purpose of evaluating ‘X’.

   The user may note a slower response when this package is loaded, as
the simplifier is forced to examine more rules than without the package,
so you might wish to remove the rules after making use of them.  Do
‘kill (rules)’ to eliminate all of the rules (including any that you
might have defined); or you may be more selective by killing only some
of them; or use ‘remrule’ on a specific rule.

   Note that if you load this package after defining your own rules you
will clobber your rules that have the same name.  The rules in this
package are: ‘*rule1’, ..., ‘*rule8’, ‘+rule1’, ..., ‘+rule18’, and you
must enclose the rulename in quotes to refer to it, as in ‘remrule ("+",
"+rule1")’ to specifically remove the first rule on ‘"+"’ or ‘disprule
("*rule2")’ to display the definition of the second multiplicative rule.


File: maxima.info,  Node: Package rducon,  Next: Package scifac,  Prev: Package ineq,  Up: simplification-pkg

87.6 Package rducon
===================

 -- Function: reduce_consts (<expr>)
     Replaces constant subexpressions of <expr> with constructed
     constant atoms, saving the definition of all these constructed
     constants in the list of equations ‘const_eqns’, and returning the
     modified <expr>.  Those parts of <expr> are constant which return
     ‘true’ when operated on by the function ‘constantp’.  Hence, before
     invoking ‘reduce_consts’, one should do

          declare ([<objects to be given the constant property>], constant)$

     to set up a database of the constant quantities occurring in your
     expressions.

     If you are planning to generate Fortran output after these symbolic
     calculations, one of the first code sections should be the
     calculation of all constants.  To generate this code segment, do

          map ('fortran, const_eqns)$

     Variables besides ‘const_eqns’ which affect ‘reduce_consts’ are:

     ‘const_prefix’ (default value: ‘xx’) is the string of characters
     used to prefix all symbols generated by ‘reduce_consts’ to
     represent constant subexpressions.

     ‘const_counter’ (default value: 1) is the integer index used to
     generate unique symbols to represent each constant subexpression
     found by ‘reduce_consts’.

     ‘load ("rducon")’ loads this function.  ‘demo ("rducon")’ shows a
     demonstration of this function.


File: maxima.info,  Node: Package scifac,  Prev: Package rducon,  Up: simplification-pkg

87.7 Package scifac
===================

 -- Function: gcfac (<expr>)
     ‘gcfac’ is a factoring function that attempts to apply the same
     heuristics which scientists apply in trying to make expressions
     simpler.  ‘gcfac’ is limited to monomial-type factoring.  For a
     sum, ‘gcfac’ does the following:

       1. Factors over the integers.
       2. Factors out the largest powers of terms occurring as
          coefficients, regardless of the complexity of the terms.
       3. Uses (1) and (2) in factoring adjacent pairs of terms.
       4. Repeatedly and recursively applies these techniques until the
          expression no longer changes.

     Item (3) does not necessarily do an optimal job of pairwise
     factoring because of the combinatorially-difficult nature of
     finding which of all possible rearrangements of the pairs yields
     the most compact pair-factored result.

     ‘load ("scifac")’ loads this function.  ‘demo ("scifac")’ shows a
     demonstration of this function.


File: maxima.info,  Node: solve_rec-pkg,  Next: stats-pkg,  Prev: simplification-pkg,  Up: Top

88 solve_rec
************

* Menu:

* Introduction to solve_rec::
* Functions and Variables for solve_rec::


File: maxima.info,  Node: Introduction to solve_rec,  Next: Functions and Variables for solve_rec,  Prev: solve_rec-pkg,  Up: solve_rec-pkg

88.1 Introduction to solve_rec
==============================

‘solve_rec’ is a package for solving linear recurrences with polynomial
coefficients.

   A demo is available with ‘demo("solve_rec");’.

   Example:

     (%i1) load("solve_rec")$
     (%i2) solve_rec((n+4)*s[n+2] + s[n+1] - (n+1)*s[n], s[n]);
                                         n
                      %k  (2 n + 3) (- 1)          %k
                        1                            2
     (%o2)       s  = -------------------- + ---------------
                  n     (n + 1) (n + 2)      (n + 1) (n + 2)


File: maxima.info,  Node: Functions and Variables for solve_rec,  Prev: Introduction to solve_rec,  Up: solve_rec-pkg

88.2 Functions and Variables for solve_rec
==========================================

 -- Function: harmonic_number (<x>)
     When <x> is positive integer n, ‘harmonic_number’ is the n’th
     harmonic number.  More generally, ‘harmonic_number(x) = psi[0](x+1)
     + %gamma’.  (See *note polygamma::).

          (%i1) load("simplify_sum")$
          (%i2) harmonic_number(5);
                                         137
          (%o2)                          ---
                                         60
          (%i3) sum(1/k, k, 1, 5);
                                         137
          (%o3)                          ---
                                         60
          (%i4) float(harmonic_number(sqrt(2)));
          (%o4)              %gamma + 0.6601971549171388
          (%i5) float(psi[0](1+sqrt(2)))+%gamma;
          (%o5)              %gamma + 0.6601971549171388

 -- Function: harmonic_to_psi (<x>)
     Converts expressions with ‘harmonic_number’ to the equivalent
     expression involving ‘psi[0]’ (see *note polygamma::).

          (%i1) load("simplify_sum")$
          (%i2) harmonic_to_psi(harmonic_number(sqrt(2)));
          (%o2)              psi (sqrt(2) + 1) + %gamma
                                0

 -- Function: reduce_order (<rec>, <sol>, <var>)

     Reduces the order of linear recurrence <rec> when a particular
     solution <sol> is known.  The reduced reccurence can be used to get
     other solutions.

     Example:

          (%i3) rec: x[n+2] = x[n+1] + x[n]/n;
                                                x
                                                 n
          (%o3)               x      = x      + --
                               n + 2    n + 1   n
          (%i4) solve_rec(rec, x[n]);
          WARNING: found some hypergeometrical solutions!
          (%o4)                    x  = %k  n
                                    n     1
          (%i5) reduce_order(rec, n, x[n]);
          (%t5)                    x  = n %z
                                    n       n

                                     n - 1
                                     ====
                                     \
          (%t6)                %z  =  >     %u
                                 n   /        %j
                                     ====
                                     %j = 0

          (%o6)             (- n - 2) %u     - %u
                                        n + 1     n
          (%i6) solve_rec((n+2)*%u[n+1] + %u[n], %u[n]);
                                               n
                                      %k  (- 1)
                                        1
          (%o6)                 %u  = ----------
                                  n    (n + 1)!

          So the general solution is

                       n - 1
                       ====        j
                       \      (- 1)
                 %k  n  >    -------- + %k  n
                   2   /     (j + 1)!     1
                       ====
                       j = 0

 -- Option variable: simplify_products
     Default value: ‘true’

     If ‘simplify_products’ is ‘true’, ‘solve_rec’ will try to simplify
     products in result.

     See also: ‘solve_rec’.

 -- Function: simplify_sum (<expr>)

     Tries to simplify all sums appearing in <expr> to a closed form.

     To use this function first load the ‘simplify_sum’ package with
     ‘load("simplify_sum")’.

     Example:

          (%i1) load("simplify_sum")$
          (%i2) sum(binomial(n+k,k)/2^k, k, 1, n) + sum(binomial(2*n, 2*k), k, 1,n);
                  n                          n
                 ====                       ====
                 \     binomial(n + k, k)   \
          (%o2)   >    ------------------ +  >    binomial(2 n, 2 k)
                 /              k           /
                 ====          2            ====
                 k = 1                      k = 1
          (%i3) simplify_sum(%);
                                   2 n - 1    n
          (%o3)                   2        + 2  - 2

 -- Function: solve_rec (<eqn>, <var>, [<init>])
     Solves for hypergeometrical solutions to linear recurrence <eqn>
     with polynomials coefficient in variable <var>.  Optional arguments
     <init> are initial conditions.

     ‘solve_rec’ can solve linear recurrences with constant
     coefficients, finds hypergeometrical solutions to homogeneous
     linear recurrences with polynomial coefficients, rational solutions
     to linear recurrences with polynomial coefficients and can solve
     Ricatti type recurrences.

     Note that the running time of the algorithm used to find
     hypergeometrical solutions is exponential in the degree of the
     leading and trailing coefficient.

     To use this function first load the ‘solve_rec’ package with
     ‘load("solve_rec");’.

     Example of linear recurrence with constant coefficients:

          (%i2) solve_rec(a[n]=a[n-1]+a[n-2]+n/2^n, a[n]);
                                  n          n
                     (sqrt(5) - 1)  %k  (- 1)
                                      1           n
          (%o2) a  = ------------------------- - ----
                 n               n                  n
                                2                5 2
                                                          n
                                             (sqrt(5) + 1)  %k
                                                              2    2
                                           + ------------------ - ----
                                                      n              n
                                                     2            5 2

     Example of linear recurrence with polynomial coefficients:

          (%i7) 2*x*(x+1)*y[x] - (x^2+3*x-2)*y[x+1] + (x-1)*y[x+2];
                                   2
          (%o7) (x - 1) y      - (x  + 3 x - 2) y      + 2 x (x + 1) y
                         x + 2                   x + 1                x
          (%i8) solve_rec(%, y[x], y[1]=1, y[3]=3);
                                        x
                                     3 2    x!
          (%o9)                 y  = ---- - --
                                 x    4     2

     Example of Ricatti type recurrence:

          (%i2) x*y[x+1]*y[x] - y[x+1]/(x+2) + y[x]/(x-1) = 0;
                                      y         y
                                       x + 1     x
          (%o2)         x y  y      - ------ + ----- = 0
                           x  x + 1   x + 2    x - 1
          (%i3) solve_rec(%, y[x], y[3]=5)$
          (%i4) ratsimp(minfactorial(factcomb(%)));
                                             3
                                         30 x  - 30 x
          (%o4) y  = - -------------------------------------------------
                 x        6      5       4       3       2
                       5 x  - 3 x  - 25 x  + 15 x  + 20 x  - 12 x - 1584

     See also: ‘solve_rec_rat’, ‘simplify_products’ and
     ‘product_use_gamma’.

 -- Function: solve_rec_rat (<eqn>, <var>, [<init>])

     Solves for rational solutions to linear recurrences.  See solve_rec
     for description of arguments.

     To use this function first load the ‘solve_rec’ package with
     ‘load("solve_rec");’.

     Example:

          (%i1) (x+4)*a[x+3] + (x+3)*a[x+2] - x*a[x+1] + (x^2-1)*a[x];
          (%o1)  (x + 4) a      + (x + 3) a      - x a
                          x + 3            x + 2      x + 1
                                                             2
                                                         + (x  - 1) a
                                                                      x
          (%i2) solve_rec_rat(% = (x+2)/(x+1), a[x]);
                                 1
          (%o2)      a  = ---------------
                      x   (x - 1) (x + 1)

     See also: ‘solve_rec’.

 -- Option variable: product_use_gamma
     Default value: ‘true’

     When simplifying products, ‘solve_rec’ introduces gamma function
     into the expression if ‘product_use_gamma’ is ‘true’.

     See also: ‘simplify_products’, ‘solve_rec’.

 -- Function: summand_to_rec
          summand_to_rec (<summand>, <k>, <n>)
          summand_to_rec (<summand>, [<k>, <lo>, <hi>], <n>)

     Returns the recurrence satisfied by the sum

               hi
              ====
              \
               >     summand
              /
              ====
            k = lo

     where summand is hypergeometrical in <k> and <n>.  If <lo> and <hi>
     are omitted, they are assumed to be ‘lo = -inf’ and ‘hi = inf’.

     To use this function first load the ‘simplify_sum’ package with
     ‘load("simplify_sum")’.

     Example:

          (%i1) load("simplify_sum")$
          (%i2) summand: binom(n,k);
          (%o2)                           binomial(n, k)
          (%i3) summand_to_rec(summand,k,n);
          (%o3)                      2 sm  - sm      = 0
                                         n     n + 1
          (%i7) summand: binom(n, k)/(k+1);
                                          binomial(n, k)
          (%o7)                           --------------
                                              k + 1
          (%i8) summand_to_rec(summand, [k, 0, n], n);
          (%o8)               2 (n + 1) sm  - (n + 2) sm      = - 1
                                          n             n + 1


File: maxima.info,  Node: stats-pkg,  Next: stirling-pkg,  Prev: solve_rec-pkg,  Up: Top

89 stats
********

* Menu:

* Introduction to stats::
* Functions and Variables for inference_result::
* Functions and Variables for stats::
* Functions and Variables for special distributions::


File: maxima.info,  Node: Introduction to stats,  Next: Functions and Variables for inference_result,  Up: stats-pkg

89.1 Introduction to stats
==========================

Package ‘stats’ contains a set of classical statistical inference and
hypothesis testing procedures.

   All these functions return an ‘inference_result’ Maxima object which
contains the necessary results for population inferences and decision
making.

   Global variable ‘stats_numer’ controls whether results are given in
floating point or symbolic and rational format; its default value is
‘true’ and results are returned in floating point format.

   Package ‘descriptive’ contains some utilities to manipulate data
structures (lists and matrices); for example, to extract subsamples.  It
also contains some examples on how to use package ‘numericalio’ to read
data from plain text files.  See ‘descriptive’ and ‘numericalio’ for
more details.

   Package ‘stats’ loads packages ‘descriptive’, ‘distrib’ and
‘inference_result’.

   For comments, bugs or suggestions, please contact the author at

   <’mario AT edu DOT xunta DOT es’>.


File: maxima.info,  Node: Functions and Variables for inference_result,  Next: Functions and Variables for stats,  Prev: Introduction to stats,  Up: stats-pkg

89.2 Functions and Variables for inference_result
=================================================

 -- Function: inference_result (<title>, <values>, <numbers>)

     Constructs an ‘inference_result’ object of the type returned by the
     stats functions.  Argument <title> is a string with the name of the
     procedure; <values> is a list with elements of the form ‘symbol =
     value’ and <numbers> is a list with positive integer numbers
     ranging from one to ‘length(<values>)’, indicating which values
     will be shown by default.

     Example:

     This is a simple example showing results concerning a rectangle.
     The title of this object is the string ‘"Rectangle"’, it stores
     five results, named ‘'base’, ‘'height’, ‘'diagonal’, ‘'area’, and
     ‘'perimeter’, but only the first, second, fifth, and fourth will be
     displayed.  The ‘'diagonal’ is stored in this object, but it is not
     displayed; to access its value, make use of function
     ‘take_inference’.

          (%i1) load("inference_result")$
          (%i2) b: 3$ h: 2$
          (%i3) inference_result("Rectangle",
                                  ['base=b,
                                   'height=h,
                                   'diagonal=sqrt(b^2+h^2),
                                   'area=b*h,
                                   'perimeter=2*(b+h)],
                                  [1,2,5,4] );
                                  |   Rectangle
                                  |
                                  |    base = 3
                                  |
          (%o3)                   |   height = 2
                                  |
                                  | perimeter = 10
                                  |
                                  |    area = 6
          (%i4) take_inference('diagonal,%);
          (%o4)                        sqrt(13)

     See also ‘take_inference’.

 -- Function: inferencep (<obj>)

     Returns ‘true’ or ‘false’, depending on whether <obj> is an
     ‘inference_result’ object or not.

 -- Function: items_inference (<obj>)

     Returns a list with the names of the items stored in <obj>, which
     must be an ‘inference_result’ object.

     Example:

     The ‘inference_result’ object stores two values, named ‘'pi’ and
     ‘'e’, but only the second is displayed.  The ‘items_inference’
     function returns the names of all items, no matter they are
     displayed or not.

          (%i1) load("inference_result")$
          (%i2) inference_result("Hi", ['pi=%pi,'e=%e],[2]);
                                      |   Hi
          (%o2)                       |
                                      | e = %e
          (%i3) items_inference(%);
          (%o3)                        [pi, e]

 -- Function: take_inference
          take_inference (<n>, <obj>)
          take_inference (<name>, <obj>)
          take_inference (<list>, <obj>)

     Returns the <n>-th value stored in <obj> if <n> is a positive
     integer, or the item named <name> if this is the name of an item.
     If the first argument is a list of numbers and/or symbols, function
     ‘take_inference’ returns a list with the corresponding results.

     Example:

     Given an ‘inference_result’ object, function ‘take_inference’ is
     called in order to extract some information stored in it.

          (%i1) load("inference_result")$
          (%i2) b: 3$ h: 2$
          (%i3) sol: inference_result("Rectangle",
                                      ['base=b,
                                       'height=h,
                                       'diagonal=sqrt(b^2+h^2),
                                       'area=b*h,
                                       'perimeter=2*(b+h)],
                                      [1,2,5,4] );
                                  |   Rectangle
                                  |
                                  |    base = 3
                                  |
          (%o3)                   |   height = 2
                                  |
                                  | perimeter = 10
                                  |
                                  |    area = 6
          (%i4) take_inference('base,sol);
          (%o4)                           3
          (%i5) take_inference(5,sol);
          (%o5)                          10
          (%i6) take_inference([1,'diagonal],sol);
          (%o6)                     [3, sqrt(13)]
          (%i7) take_inference(items_inference(sol),sol);
          (%o7)                [3, 2, sqrt(13), 6, 10]

     See also ‘inference_result’, and ‘take_inference’.


File: maxima.info,  Node: Functions and Variables for stats,  Next: Functions and Variables for special distributions,  Prev: Functions and Variables for inference_result,  Up: stats-pkg

89.3 Functions and Variables for stats
======================================

 -- Option variable: stats_numer
     Default value: ‘true’

     If ‘stats_numer’ is ‘true’, inference statistical functions return
     their results in floating point numbers.  If it is ‘false’, results
     are given in symbolic and rational format.

 -- Function: test_mean
          test_mean (<x>)
          test_mean (<x>, <options> ...)

     This is the mean <t>-test.  Argument <x> is a list or a column
     matrix containing an one dimensional sample.  It also performs an
     asymptotic test based on the Central Limit Theorem if option
     ‘'asymptotic’ is ‘true’.

     Options:

        • ‘'mean’, default ‘0’, is the mean value to be checked.

        • ‘'alternative’, default ‘'twosided’, is the alternative
          hypothesis; valid values are: ‘'twosided’, ‘'greater’ and
          ‘'less’.

        • ‘'dev’, default ‘'unknown’, this is the value of the standard
          deviation when it is known; valid values are: ‘'unknown’ or a
          positive expression.

        • ‘'conflevel’, default ‘95/100’, confidence level for the
          confidence interval; it must be an expression which takes a
          value in (0,1).

        • ‘'asymptotic’, default ‘false’, indicates whether it performs
          an exact <t>-test or an asymptotic one based on the Central
          Limit Theorem; valid values are ‘true’ and ‘false’.

     The output of function ‘test_mean’ is an ‘inference_result’ Maxima
     object showing the following results:

       1. ‘'mean_estimate’: the sample mean.

       2. ‘'conf_level’: confidence level selected by the user.

       3. ‘'conf_interval’: confidence interval for the population mean.

       4. ‘'method’: inference procedure.

       5. ‘'hypotheses’: null and alternative hypotheses to be tested.

       6. ‘'statistic’: value of the sample statistic used for testing
          the null hypothesis.

       7. ‘'distribution’: distribution of the sample statistic,
          together with its parameter(s).

       8. ‘'p_value’: p-value of the test.

     Examples:

     Performs an exact <t>-test with unknown variance.  The null
     hypothesis is H_0: mean=50 against the one sided alternative H_1:
     mean<50; according to the results, the p-value is too great, there
     are no evidence for rejecting H_0.

          (%i1) load("stats")$
          (%i2) data: [78,64,35,45,45,75,43,74,42,42]$
          (%i3) test_mean(data,'conflevel=0.9,'alternative='less,'mean=50);
                    |                 MEAN TEST
                    |
                    |            mean_estimate = 54.3
                    |
                    |              conf_level = 0.9
                    |
                    | conf_interval = [minf, 61.51314273502712]
                    |
          (%o3)     |  method = Exact t-test. Unknown variance.
                    |
                    | hypotheses = H0: mean = 50 , H1: mean < 50
                    |
                    |       statistic = .8244705235071678
                    |
                    |       distribution = [student_t, 9]
                    |
                    |        p_value = .7845100411786889

     This time Maxima performs an asymptotic test, based on the Central
     Limit Theorem.  The null hypothesis is H_0: equal(mean, 50) against
     the two sided alternative H_1: not equal(mean, 50); according to
     the results, the p-value is very small, H_0 should be rejected in
     favor of the alternative H_1.  Note that, as indicated by the
     ‘Method’ component, this procedure should be applied to large
     samples.

          (%i1) load("stats")$
          (%i2) test_mean([36,118,52,87,35,256,56,178,57,57,89,34,25,98,35,
                        98,41,45,198,54,79,63,35,45,44,75,42,75,45,45,
                        45,51,123,54,151],
                        'asymptotic=true,'mean=50);
                    |                       MEAN TEST
                    |
                    |           mean_estimate = 74.88571428571429
                    |
                    |                   conf_level = 0.95
                    |
                    | conf_interval = [57.72848600856194, 92.04294256286663]
                    |
          (%o2)     |    method = Large sample z-test. Unknown variance.
                    |
                    |       hypotheses = H0: mean = 50 , H1: mean # 50
                    |
                    |             statistic = 2.842831192874313
                    |
                    |             distribution = [normal, 0, 1]
                    |
                    |             p_value = .004471474652002261

 -- Function: test_means_difference
          test_means_difference (<x1>, <x2>)
          test_means_difference (<x1>, <x2>, <options> ...)

     This is the difference of means <t>-test for two samples.
     Arguments <x1> and <x2> are lists or column matrices containing two
     independent samples.  In case of different unknown variances (see
     options ‘'dev1’, ‘'dev2’ and ‘'varequal’ bellow), the degrees of
     freedom are computed by means of the Welch approximation.  It also
     performs an asymptotic test based on the Central Limit Theorem if
     option ‘'asymptotic’ is set to ‘true’.

     Options:

        • 
        • ‘'alternative’, default ‘'twosided’, is the alternative
          hypothesis; valid values are: ‘'twosided’, ‘'greater’ and
          ‘'less’.

        • ‘'dev1’, default ‘'unknown’, this is the value of the standard
          deviation of the <x1> sample when it is known; valid values
          are: ‘'unknown’ or a positive expression.

        • ‘'dev2’, default ‘'unknown’, this is the value of the standard
          deviation of the <x2> sample when it is known; valid values
          are: ‘'unknown’ or a positive expression.

        • ‘'varequal’, default ‘false’, whether variances should be
          considered to be equal or not; this option takes effect only
          when ‘'dev1’ and/or ‘'dev2’ are ‘'unknown’.

        • ‘'conflevel’, default ‘95/100’, confidence level for the
          confidence interval; it must be an expression which takes a
          value in (0,1).

        • ‘'asymptotic’, default ‘false’, indicates whether it performs
          an exact <t>-test or an asymptotic one based on the Central
          Limit Theorem; valid values are ‘true’ and ‘false’.

     The output of function ‘test_means_difference’ is an
     ‘inference_result’ Maxima object showing the following results:

       1. ‘'diff_estimate’: the difference of means estimate.

       2. ‘'conf_level’: confidence level selected by the user.

       3. ‘'conf_interval’: confidence interval for the difference of
          means.

       4. ‘'method’: inference procedure.

       5. ‘'hypotheses’: null and alternative hypotheses to be tested.

       6. ‘'statistic’: value of the sample statistic used for testing
          the null hypothesis.

       7. ‘'distribution’: distribution of the sample statistic,
          together with its parameter(s).

       8. ‘'p_value’: p-value of the test.

     Examples:

     The equality of means is tested with two small samples <x> and <y>,
     against the alternative H_1: m_1>m_2, being m_1 and m_2 the
     populations means; variances are unknown and supposed to be
     different.

          (%i1) load("stats")$
          (%i2) x: [20.4,62.5,61.3,44.2,11.1,23.7]$
          (%i3) y: [1.2,6.9,38.7,20.4,17.2]$
          (%i4) test_means_difference(x,y,'alternative='greater);
                      |              DIFFERENCE OF MEANS TEST
                      |
                      |         diff_estimate = 20.31999999999999
                      |
                      |                 conf_level = 0.95
                      |
                      |    conf_interval = [- .04597417812882298, inf]
                      |
          (%o4)       |        method = Exact t-test. Welch approx.
                      |
                      | hypotheses = H0: mean1 = mean2 , H1: mean1 > mean2
                      |
                      |           statistic = 1.838004300728477
                      |
                      |    distribution = [student_t, 8.62758740184604]
                      |
                      |            p_value = .05032746527991905

     The same test as before, but now variances are supposed to be
     equal.

          (%i1) load("stats")$
          (%i2) x: [20.4,62.5,61.3,44.2,11.1,23.7]$
          (%i3) y: matrix([1.2],[6.9],[38.7],[20.4],[17.2])$
          (%i4) test_means_difference(x,y,'alternative='greater,
                                                           'varequal=true);
                      |              DIFFERENCE OF MEANS TEST
                      |
                      |         diff_estimate = 20.31999999999999
                      |
                      |                 conf_level = 0.95
                      |
                      |     conf_interval = [- .7722627696897568, inf]
                      |
          (%o4)       |   method = Exact t-test. Unknown equal variances
                      |
                      | hypotheses = H0: mean1 = mean2 , H1: mean1 > mean2
                      |
                      |           statistic = 1.765996124515009
                      |
                      |           distribution = [student_t, 9]
                      |
                      |            p_value = .05560320992529344

 -- Function: test_variance
          test_variance (<x>)
          test_variance (<x>, <options>, ...)

     This is the variance <chi^2>-test.  Argument <x> is a list or a
     column matrix containing an one dimensional sample taken from a
     normal population.

     Options:

        • ‘'mean’, default ‘'unknown’, is the population’s mean, when it
          is known.

        • ‘'alternative’, default ‘'twosided’, is the alternative
          hypothesis; valid values are: ‘'twosided’, ‘'greater’ and
          ‘'less’.

        • ‘'variance’, default ‘1’, this is the variance value
          (positive) to be checked.

        • ‘'conflevel’, default ‘95/100’, confidence level for the
          confidence interval; it must be an expression which takes a
          value in (0,1).

     The output of function ‘test_variance’ is an ‘inference_result’
     Maxima object showing the following results:

       1. ‘'var_estimate’: the sample variance.

       2. ‘'conf_level’: confidence level selected by the user.

       3. ‘'conf_interval’: confidence interval for the population
          variance.

       4. ‘'method’: inference procedure.

       5. ‘'hypotheses’: null and alternative hypotheses to be tested.

       6. ‘'statistic’: value of the sample statistic used for testing
          the null hypothesis.

       7. ‘'distribution’: distribution of the sample statistic,
          together with its parameter.

       8. ‘'p_value’: p-value of the test.

     Examples:

     It is tested whether the variance of a population with unknown mean
     is equal to or greater than 200.

          (%i1) load("stats")$
          (%i2) x: [203,229,215,220,223,233,208,228,209]$
          (%i3) test_variance(x,'alternative='greater,'variance=200);
                       |                  VARIANCE TEST
                       |
                       |              var_estimate = 110.75
                       |
                       |                conf_level = 0.95
                       |
                       |     conf_interval = [57.13433376937479, inf]
                       |
          (%o3)        | method = Variance Chi-square test. Unknown mean.
                       |
                       |    hypotheses = H0: var = 200 , H1: var > 200
                       |
                       |                 statistic = 4.43
                       |
                       |             distribution = [chi2, 8]
                       |
                       |           p_value = .8163948512777689

 -- Function: test_variance_ratio
          test_variance_ratio (<x1>, <x2>)
          test_variance_ratio (<x1>, <x2>, <options> ...)

     This is the variance ratio <F>-test for two normal populations.
     Arguments <x1> and <x2> are lists or column matrices containing two
     independent samples.

     Options:

        • ‘'alternative’, default ‘'twosided’, is the alternative
          hypothesis; valid values are: ‘'twosided’, ‘'greater’ and
          ‘'less’.

        • ‘'mean1’, default ‘'unknown’, when it is known, this is the
          mean of the population from which <x1> was taken.

        • ‘'mean2’, default ‘'unknown’, when it is known, this is the
          mean of the population from which <x2> was taken.

        • ‘'conflevel’, default ‘95/100’, confidence level for the
          confidence interval of the ratio; it must be an expression
          which takes a value in (0,1).

     The output of function ‘test_variance_ratio’ is an
     ‘inference_result’ Maxima object showing the following results:

       1. ‘'ratio_estimate’: the sample variance ratio.

       2. ‘'conf_level’: confidence level selected by the user.

       3. ‘'conf_interval’: confidence interval for the variance ratio.

       4. ‘'method’: inference procedure.

       5. ‘'hypotheses’: null and alternative hypotheses to be tested.

       6. ‘'statistic’: value of the sample statistic used for testing
          the null hypothesis.

       7. ‘'distribution’: distribution of the sample statistic,
          together with its parameters.

       8. ‘'p_value’: p-value of the test.

     Examples:

     The equality of the variances of two normal populations is checked
     against the alternative that the first is greater than the second.

          (%i1) load("stats")$
          (%i2) x: [20.4,62.5,61.3,44.2,11.1,23.7]$
          (%i3) y: [1.2,6.9,38.7,20.4,17.2]$
          (%i4) test_variance_ratio(x,y,'alternative='greater);
                        |              VARIANCE RATIO TEST
                        |
                        |       ratio_estimate = 2.316933391522034
                        |
                        |               conf_level = 0.95
                        |
                        |    conf_interval = [.3703504689507268, inf]
                        |
          (%o4)         | method = Variance ratio F-test. Unknown means.
                        |
                        | hypotheses = H0: var1 = var2 , H1: var1 > var2
                        |
                        |         statistic = 2.316933391522034
                        |
                        |            distribution = [f, 5, 4]
                        |
                        |          p_value = .2179269692254457

 -- Function: test_proportion
          test_proportion (<x>, <n>)
          test_proportion (<x>, <n>, <options> ...)

     Inferences on a proportion.  Argument <x> is the number of
     successes in <n> trials in a Bernoulli experiment with unknown
     probability.

     Options:

        • ‘'proportion’, default ‘1/2’, is the value of the proportion
          to be checked.

        • ‘'alternative’, default ‘'twosided’, is the alternative
          hypothesis; valid values are: ‘'twosided’, ‘'greater’ and
          ‘'less’.

        • ‘'conflevel’, default ‘95/100’, confidence level for the
          confidence interval; it must be an expression which takes a
          value in (0,1).

        • ‘'asymptotic’, default ‘false’, indicates whether it performs
          an exact test based on the binomial distribution, or an
          asymptotic one based on the Central Limit Theorem; valid
          values are ‘true’ and ‘false’.

        • ‘'correct’, default ‘true’, indicates whether Yates correction
          is applied or not.

     The output of function ‘test_proportion’ is an ‘inference_result’
     Maxima object showing the following results:

       1. ‘'sample_proportion’: the sample proportion.

       2. ‘'conf_level’: confidence level selected by the user.

       3. ‘'conf_interval’: Wilson confidence interval for the
          proportion.

       4. ‘'method’: inference procedure.

       5. ‘'hypotheses’: null and alternative hypotheses to be tested.

       6. ‘'statistic’: value of the sample statistic used for testing
          the null hypothesis.

       7. ‘'distribution’: distribution of the sample statistic,
          together with its parameters.

       8. ‘'p_value’: p-value of the test.

     Examples:

     Performs an exact test.  The null hypothesis is H_0: p=1/2 against
     the one sided alternative H_1: p<1/2.

          (%i1) load("stats")$
          (%i2) test_proportion(45, 103, alternative = less);
                   |            PROPORTION TEST
                   |
                   | sample_proportion = .4368932038834951
                   |
                   |           conf_level = 0.95
                   |
                   | conf_interval = [0, 0.522714149150231]
                   |
          (%o2)    |     method = Exact binomial test.
                   |
                   | hypotheses = H0: p = 0.5 , H1: p < 0.5
                   |
                   |             statistic = 45
                   |
                   |  distribution = [binomial, 103, 0.5]
                   |
                   |      p_value = .1184509388901454

     A two sided asymptotic test.  Confidence level is 99/100.

          (%i1) load("stats")$
          (%i2) fpprintprec:7$
          (%i3) test_proportion(45, 103,
                            conflevel = 99/100, asymptotic=true);
                |                 PROPORTION TEST
                |
                |           sample_proportion = .43689
                |
                |                conf_level = 0.99
                |
                |        conf_interval = [.31422, .56749]
                |
          (%o3) | method = Asympthotic test with Yates correction.
                |
                |     hypotheses = H0: p = 0.5 , H1: p # 0.5
                |
                |               statistic = .43689
                |
                |      distribution = [normal, 0.5, .048872]
                |
                |                p_value = .19662

 -- Function: test_proportions_difference
          test_proportions_difference (<x1>, <n1>, <x2>, <n2>)
          test_proportions_difference (<x1>, <n1>, <x2>, <n2>, <options>
          ...)

     Inferences on the difference of two proportions.  Argument <x1> is
     the number of successes in <n1> trials in a Bernoulli experiment in
     the first population, and <x2> and <n2> are the corresponding
     values in the second population.  Samples are independent and the
     test is asymptotic.

     Options:

        • ‘'alternative’, default ‘'twosided’, is the alternative
          hypothesis; valid values are: ‘'twosided’ (‘p1 # p2’),
          ‘'greater’ (‘p1 > p2’) and ‘'less’ (‘p1 < p2’).

        • ‘'conflevel’, default ‘95/100’, confidence level for the
          confidence interval; it must be an expression which takes a
          value in (0,1).

        • ‘'correct’, default ‘true’, indicates whether Yates correction
          is applied or not.

     The output of function ‘test_proportions_difference’ is an
     ‘inference_result’ Maxima object showing the following results:

       1. ‘'proportions’: list with the two sample proportions.

       2. ‘'conf_level’: confidence level selected by the user.

       3. ‘'conf_interval’: Confidence interval for the difference of
          proportions ‘p1 - p2’.

       4. ‘'method’: inference procedure and warning message in case of
          any of the samples sizes is less than 10.

       5. ‘'hypotheses’: null and alternative hypotheses to be tested.

       6. ‘'statistic’: value of the sample statistic used for testing
          the null hypothesis.

       7. ‘'distribution’: distribution of the sample statistic,
          together with its parameters.

       8. ‘'p_value’: p-value of the test.

     Examples:

     A machine produced 10 defective articles in a batch of 250.  After
     some maintenance work, it produces 4 defective in a batch of 150.
     In order to know if the machine has improved, we test the null
     hypothesis ‘H0:p1=p2’, against the alternative ‘H0:p1>p2’, where
     ‘p1’ and ‘p2’ are the probabilities for one produced article to be
     defective before and after maintenance.  According to the p value,
     there is not enough evidence to accept the alternative.

          (%i1) load("stats")$
          (%i2) fpprintprec:7$
          (%i3) test_proportions_difference(10, 250, 4, 150,
                                          alternative = greater);
                |       DIFFERENCE OF PROPORTIONS TEST
                |
                |       proportions = [0.04, .02666667]
                |
                |              conf_level = 0.95
                |
                |      conf_interval = [- .02172761, 1]
                |
          (%o3) | method = Asymptotic test. Yates correction.
                |
                |   hypotheses = H0: p1 = p2 , H1: p1 > p2
                |
                |            statistic = .01333333
                |
                |    distribution = [normal, 0, .01898069]
                |
                |             p_value = .2411936

     Exact standard deviation of the asymptotic normal distribution when
     the data are unknown.

          (%i1) load("stats")$
          (%i2) stats_numer: false$
          (%i3) sol: test_proportions_difference(x1,n1,x2,n2)$
          (%i4) last(take_inference('distribution,sol));
                         1    1                  x2 + x1
                        (-- + --) (x2 + x1) (1 - -------)
                         n2   n1                 n2 + n1
          (%o4)    sqrt(---------------------------------)
                                     n2 + n1

 -- Function: test_sign
          test_sign (<x>)
          test_sign (<x>, <options> ...)

     This is the non parametric sign test for the median of a continuous
     population.  Argument <x> is a list or a column matrix containing
     an one dimensional sample.

     Options:

        • ‘'alternative’, default ‘'twosided’, is the alternative
          hypothesis; valid values are: ‘'twosided’, ‘'greater’ and
          ‘'less’.

        • ‘'median’, default ‘0’, is the median value to be checked.

     The output of function ‘test_sign’ is an ‘inference_result’ Maxima
     object showing the following results:

       1. ‘'med_estimate’: the sample median.

       2. ‘'method’: inference procedure.

       3. ‘'hypotheses’: null and alternative hypotheses to be tested.

       4. ‘'statistic’: value of the sample statistic used for testing
          the null hypothesis.

       5. ‘'distribution’: distribution of the sample statistic,
          together with its parameter(s).

       6. ‘'p_value’: p-value of the test.

     Examples:

     Checks whether the population from which the sample was taken has
     median 6, against the alternative H_1: median > 6.

          (%i1) load("stats")$
          (%i2) x: [2,0.1,7,1.8,4,2.3,5.6,7.4,5.1,6.1,6]$
          (%i3) test_sign(x,'median=6,'alternative='greater);
                         |                  SIGN TEST
                         |
                         |              med_estimate = 5.1
                         |
                         |      method = Non parametric sign test.
                         |
          (%o3)          | hypotheses = H0: median = 6 , H1: median > 6
                         |
                         |                statistic = 7
                         |
                         |      distribution = [binomial, 10, 0.5]
                         |
                         |         p_value = .05468749999999989

 -- Function: test_signed_rank
          test_signed_rank (<x>)
          test_signed_rank (<x>, <options> ...)

     This is the Wilcoxon signed rank test to make inferences about the
     median of a continuous population.  Argument <x> is a list or a
     column matrix containing an one dimensional sample.  Performs
     normal approximation if the sample size is greater than 20, or if
     there are zeroes or ties.

     See also ‘pdf_rank_test’ and ‘cdf_rank_test’

     Options:

        • ‘'median’, default ‘0’, is the median value to be checked.

        • ‘'alternative’, default ‘'twosided’, is the alternative
          hypothesis; valid values are: ‘'twosided’, ‘'greater’ and
          ‘'less’.

     The output of function ‘test_signed_rank’ is an ‘inference_result’
     Maxima object with the following results:

       1. ‘'med_estimate’: the sample median.

       2. ‘'method’: inference procedure.

       3. ‘'hypotheses’: null and alternative hypotheses to be tested.

       4. ‘'statistic’: value of the sample statistic used for testing
          the null hypothesis.

       5. ‘'distribution’: distribution of the sample statistic,
          together with its parameter(s).

       6. ‘'p_value’: p-value of the test.

     Examples:

     Checks the null hypothesis H_0: median = 15 against the alternative
     H_1: median > 15.  This is an exact test, since there are no ties.

          (%i1) load("stats")$
          (%i2) x: [17.1,15.9,13.7,13.4,15.5,17.6]$
          (%i3) test_signed_rank(x,median=15,alternative=greater);
                           |             SIGNED RANK TEST
                           |
                           |           med_estimate = 15.7
                           |
                           |           method = Exact test
                           |
          (%o3)            | hypotheses = H0: med = 15 , H1: med > 15
                           |
                           |              statistic = 14
                           |
                           |     distribution = [signed_rank, 6]
                           |
                           |            p_value = 0.28125

     Checks the null hypothesis H_0: equal(median, 2.5) against the
     alternative H_1: not equal(median, 2.5).  This is an approximated
     test, since there are ties.

          (%i1) load("stats")$
          (%i2) y:[1.9,2.3,2.6,1.9,1.6,3.3,4.2,4,2.4,2.9,1.5,3,2.9,4.2,3.1]$
          (%i3) test_signed_rank(y,median=2.5);
                       |                 SIGNED RANK TEST
                       |
                       |                med_estimate = 2.9
                       |
                       |          method = Asymptotic test. Ties
                       |
          (%o3)        |    hypotheses = H0: med = 2.5 , H1: med # 2.5
                       |
                       |                 statistic = 76.5
                       |
                       | distribution = [normal, 60.5, 17.58195097251724]
                       |
                       |           p_value = .3628097734643669

 -- Function: test_rank_sum
          test_rank_sum (<x1>, <x2>)
          test_rank_sum (<x1>, <x2>, <option>)

     This is the Wilcoxon-Mann-Whitney test for comparing the medians of
     two continuous populations.  The first two arguments <x1> and <x2>
     are lists or column matrices with the data of two independent
     samples.  Performs normal approximation if any of the sample sizes
     is greater than 10, or if there are ties.

     Option:

        • ‘'alternative’, default ‘'twosided’, is the alternative
          hypothesis; valid values are: ‘'twosided’, ‘'greater’ and
          ‘'less’.

     The output of function ‘test_rank_sum’ is an ‘inference_result’
     Maxima object with the following results:

       1. ‘'method’: inference procedure.

       2. ‘'hypotheses’: null and alternative hypotheses to be tested.

       3. ‘'statistic’: value of the sample statistic used for testing
          the null hypothesis.

       4. ‘'distribution’: distribution of the sample statistic,
          together with its parameters.

       5. ‘'p_value’: p-value of the test.

     Examples:

     Checks whether populations have similar medians.  Samples sizes are
     small and an exact test is made.

          (%i1) load("stats")$
          (%i2) x:[12,15,17,38,42,10,23,35,28]$
          (%i3) y:[21,18,25,14,52,65,40,43]$
          (%i4) test_rank_sum(x,y);
                        |                 RANK SUM TEST
                        |
                        |              method = Exact test
                        |
                        | hypotheses = H0: med1 = med2 , H1: med1 # med2
          (%o4)         |
                        |                 statistic = 22
                        |
                        |        distribution = [rank_sum, 9, 8]
                        |
                        |          p_value = .1995886466474702

     Now, with greater samples and ties, the procedure makes normal
     approximation.  The alternative hypothesis is H_1: median1 <
     median2.

          (%i1) load("stats")$
          (%i2) x: [39,42,35,13,10,23,15,20,17,27]$
          (%i3) y: [20,52,66,19,41,32,44,25,14,39,43,35,19,56,27,15]$
          (%i4) test_rank_sum(x,y,'alternative='less);
                       |                  RANK SUM TEST
                       |
                       |          method = Asymptotic test. Ties
                       |
                       |  hypotheses = H0: med1 = med2 , H1: med1 < med2
          (%o4)        |
                       |                 statistic = 48.5
                       |
                       | distribution = [normal, 79.5, 18.95419580097078]
                       |
                       |           p_value = .05096985666598441

 -- Function: test_normality (<x>)

     Shapiro-Wilk test for normality.  Argument <x> is a list of
     numbers, and sample size must be greater than 2 and less or equal
     than 5000, otherwise, function ‘test_normality’ signals an error
     message.

     Reference:

     [1] Algorithm AS R94, Applied Statistics (1995), vol.44, no.4,
     547-551

     The output of function ‘test_normality’ is an ‘inference_result’
     Maxima object with the following results:

       1. ‘'statistic’: value of the <W> statistic.

       2. ‘'p_value’: p-value under normal assumption.

     Examples:

     Checks for the normality of a population, based on a sample of size
     9.

          (%i1) load("stats")$
          (%i2) x:[12,15,17,38,42,10,23,35,28]$
          (%i3) test_normality(x);
                                 |      SHAPIRO - WILK TEST
                                 |
          (%o3)                  | statistic = .9251055695162436
                                 |
                                 |  p_value = .4361763918860381

 -- Function: linear_regression
          linear_regression (<x>)
          linear_regression (<x> <option>)

     Multivariate linear regression, y_i = b0 + b1*x_1i + b2*x_2i + ...
     + bk*x_ki + u_i, where u_i are N(0,sigma) independent random
     variables.  Argument <x> must be a matrix with more than one
     column.  The last column is considered as the responses (y_i).

     Option:

        • ‘'conflevel’, default ‘95/100’, confidence level for the
          confidence intervals; it must be an expression which takes a
          value in (0,1).

     The output of function ‘linear_regression’ is an ‘inference_result’
     Maxima object with the following results:

       1. ‘'b_estimation’: regression coefficients estimates.

       2. ‘'b_covariances’: covariance matrix of the regression
          coefficients estimates.

       3. ‘b_conf_int’: confidence intervals of the regression
          coefficients.

       4. ‘b_statistics’: statistics for testing coefficient.

       5. ‘b_p_values’: p-values for coefficient tests.

       6. ‘b_distribution’: probability distribution for coefficient
          tests.

       7. ‘v_estimation’: unbiased variance estimator.

       8. ‘v_conf_int’: variance confidence interval.

       9. ‘v_distribution’: probability distribution for variance test.

       10. ‘residuals’: residuals.

       11. ‘adc’: adjusted determination coefficient.

       12. ‘aic’: Akaike’s information criterion.

       13. ‘bic’: Bayes’s information criterion.

     Only items 1, 4, 5, 6, 7, 8, 9 and 11 above, in this order, are
     shown by default.  The rest remain hidden until the user makes use
     of functions ‘items_inference’ and ‘take_inference’.

     Example:

     Fitting a linear model to a trivariate sample.  The last column is
     considered as the responses (y_i).

          (%i2) load("stats")$
          (%i3) X:matrix(
              [58,111,64],[84,131,78],[78,158,83],
              [81,147,88],[82,121,89],[102,165,99],
              [85,174,101],[102,169,102])$
          (%i4) fpprintprec: 4$
          (%i5) res: linear_regression(X);
                       |       LINEAR REGRESSION MODEL
                       |
                       | b_estimation = [9.054, .5203, .2397]
                       |
                       | b_statistics = [.6051, 2.246, 1.74]
                       |
                       | b_p_values = [.5715, .07466, .1423]
                       |
          (%o5)        |   b_distribution = [student_t, 5]
                       |
                       |         v_estimation = 35.27
                       |
                       |     v_conf_int = [13.74, 212.2]
                       |
                       |      v_distribution = [chi2, 5]
                       |
                       |             adc = .7922
          (%i6) items_inference(res);
          (%o6) [b_estimation, b_covariances, b_conf_int, b_statistics,
          b_p_values, b_distribution, v_estimation, v_conf_int,
          v_distribution, residuals, adc, aic, bic]
          (%i7) take_inference('b_covariances, res);
                            [  223.9    - 1.12   - .8532  ]
                            [                             ]
          (%o7)             [ - 1.12    .05367   - .02305 ]
                            [                             ]
                            [ - .8532  - .02305   .01898  ]
          (%i8) take_inference('bic, res);
          (%o8)                          30.98
          (%i9) load("draw")$
          (%i10) draw2d(
              points_joined = true,
              grid = true,
              points(take_inference('residuals, res)) )$


File: maxima.info,  Node: Functions and Variables for special distributions,  Prev: Functions and Variables for stats,  Up: stats-pkg

89.4 Functions and Variables for special distributions
======================================================

 -- Function: pdf_signed_rank (<x>, <n>)
     Probability density function of the exact distribution of the
     signed rank statistic.  Argument <x> is a real number and <n> a
     positive integer.

     See also ‘test_signed_rank’.

 -- Function: cdf_signed_rank (<x>, <n>)
     Cumulative density function of the exact distribution of the signed
     rank statistic.  Argument <x> is a real number and <n> a positive
     integer.

     See also ‘test_signed_rank’.

 -- Function: pdf_rank_sum (<x>, <n>, <m>)
     Probability density function of the exact distribution of the rank
     sum statistic.  Argument <x> is a real number and <n> and <m> are
     both positive integers.

     See also ‘test_rank_sum’.

 -- Function: cdf_rank_sum (<x>, <n>, <m>)
     Cumulative density function of the exact distribution of the rank
     sum statistic.  Argument <x> is a real number and <n> and <m> are
     both positive integers.

     See also ‘test_rank_sum’.


File: maxima.info,  Node: stirling-pkg,  Next: stringproc-pkg,  Prev: stats-pkg,  Up: Top

90 stirling
***********

* Menu:

* Functions and Variables for stirling::


File: maxima.info,  Node: Functions and Variables for stirling,  Prev: stirling-pkg,  Up: stirling-pkg

90.1 Functions and Variables for stirling
=========================================

 -- Function: stirling
          stirling (<z>,<n>)
          stirling (<z>,<n>,<pred>)

     Replace ‘gamma(x)’ with the O(1/x^{2n-1}) Stirling formula.  when
     <n> isn’t a nonnegative integer, signal an error.  With the
     optional third argument ‘pred’, the Stirling formula is applied
     only when ‘pred’ is true.

     Reference: Abramowitz & Stegun, " Handbook of mathematical
     functions", 6.1.40.

     Examples:
          (%i1) load ("stirling")$

          (%i2) stirling(gamma(%alpha+x)/gamma(x),1);
                 1/2 - x             x + %alpha - 1/2
          (%o2) x        (x + %alpha)
                                             1           1
                                      --------------- - ---- - %alpha
                                      12 (x + %alpha)   12 x
                                    %e
          (%i3) taylor(%,x,inf,1);
                              %alpha       2    %alpha
                    %alpha   x       %alpha  - x       %alpha
          (%o3)/T/ x       + -------------------------------- + . . .
                                           2 x
          (%i4) map('factor,%);
                                                 %alpha - 1
                   %alpha   (%alpha - 1) %alpha x
          (%o4)   x       + -------------------------------
                                            2

     The function ‘stirling’ knows the difference between the variable
     ’gamma’ and the function gamma:

          (%i5) stirling(gamma + gamma(x),0);
                                              x - 1/2   - x
          (%o5)    gamma + sqrt(2) sqrt(%pi) x        %e
          (%i6) stirling(gamma(y) + gamma(x),0);
                                   y - 1/2   - y
          (%o6) sqrt(2) sqrt(%pi) y        %e
                                                        x - 1/2   - x
                                   + sqrt(2) sqrt(%pi) x        %e

     To apply the Stirling formula only to terms that involve the
     variable ‘k’, use an optional third argument; for example
          (%i7) makegamma(pochhammer(a,k)/pochhammer(b,k));
          (%o7) (gamma(b)*gamma(k+a))/(gamma(a)*gamma(k+b))
          (%i8) stirling(%,1, lambda([s], not(freeof(k,s))));
          (%o8) (%e^(b-a)*gamma(b)*(k+a)^(k+a-1/2)*(k+b)^(-k-b+1/2))/gamma(a)
     The terms ‘gamma(a)’ and ‘gamma(b)’ are free of ‘k’, so the
     Stirling formula was not applied to these two terms.

     To use this function write first ‘load("stirling")’.


File: maxima.info,  Node: stringproc-pkg,  Next: to_poly_solve-pkg,  Prev: stirling-pkg,  Up: Top

91 stringproc
*************

* Menu:

* Introduction to String Processing::
* String Input and Output::
* Characters::
* String Processing::
* Octets and Utilities for Cryptography::


File: maxima.info,  Node: Introduction to String Processing,  Next: String Input and Output,  Prev: stringproc-pkg,  Up: stringproc-pkg

91.1 Introduction to String Processing
======================================

The package ‘stringproc’ contains functions for processing strings and
characters including formatting, encoding and data streams.  This
package is completed by some tools for cryptography, e.g.  base64 and
hash functions.

   It can be directly loaded via ‘load("stringproc")’ or automatically
by using one of its functions.

   For questions and bug reports please contact the author.  The
following command prints his e-mail-address.

   ‘printf(true, "~{~a~}@gmail.com", split(sdowncase("Volker van
Nek")))$’

   A string is constructed by typing e.g.  ‘"Text"’.  When the option
variable ‘stringdisp’ is set to ‘false’, which is the default, the
double quotes won’t be printed.  *note stringp:: is a test, if an object
is a string.

     (%i1) str: "Text";
     (%o1)                         Text
     (%i2) stringp(str);
     (%o2)                         true

   Characters are represented by a string of length 1.  *note charp:: is
the corresponding test.

     (%i1) char: "e";
     (%o1)                           e
     (%i2) charp(char);
     (%o2)                         true

   In Maxima position indices in strings are like in list 1-indexed
which results to the following consistency.

     (%i1) is(charat("Lisp",1) = charlist("Lisp")[1]);
     (%o1)                         true

   A string may contain Maxima expressions.  These can be parsed with
*note parse_string::.

     (%i1) map(parse_string, ["42" ,"sqrt(2)", "%pi"]);
     (%o1)                   [42, sqrt(2), %pi]
     (%i2) map('float, %);
     (%o2)        [42.0, 1.414213562373095, 3.141592653589793]

   Strings can be processed as characters or in binary form as octets.
Functions for conversions are *note string_to_octets:: and *note
octets_to_string::.  Usable encodings depend on the platform, the
application and the underlying Lisp.  (The following shows Maxima in
GNU/Linux, compiled with SBCL.)

     (%i1) obase: 16.$
     (%i2) string_to_octets("$£€", "cp1252");
     (%o2)                     [24, 0A3, 80]
     (%i3) string_to_octets("$£€", "utf-8");
     (%o3)               [24, 0C2, 0A3, 0E2, 82, 0AC]

   Strings may be written to character streams or as octets to binary
streams.  The following example demonstrates file in and output of
characters.

   *note openw:: returns an output stream to a file, *note printf::
writes formatted to that file and by e.g.  *note close:: all characters
contained in the stream are written to the file.

     (%i1) s: openw("file.txt");
     (%o1)                #<output stream file.txt>
     (%i2) printf(s, "~%~d ~f ~a ~a ~f ~e ~a~%",
     42, 1.234, sqrt(2), %pi, 1.0e-2, 1.0e-2, 1.0b-2)$
     (%i3) close(s)$

   *note openr:: then returns an input stream from the previously used
file and *note readline:: returns the line read as a string.  The string
may be tokenized by e.g.  *note split:: or *note tokens:: and finally
parsed by *note parse_string::.

     (%i4) s: openr("file.txt");
     (%o4)                 #<input stream file.txt>
     (%i5) readline(s);
     (%o5)          42 1.234 sqrt(2) %pi 0.01 1.0E-2 1.0b-2
     (%i6) map(parse_string, split(%));
     (%o6)       [42, 1.234, sqrt(2), %pi, 0.01, 0.01, 1.0b-2]
     (%i7) close(s)$


File: maxima.info,  Node: String Input and Output,  Next: Characters,  Prev: Introduction to String Processing,  Up: stringproc-pkg

91.2 String Input and Output
============================

Example: Formatted printing to a file.

     (%i1) s: openw("file.txt");
     (%o1)                      #<output stream file.txt>
     (%i2) control:
     "~2tAn atom: ~20t~a~%~2tand a list: ~20t~{~r ~}~%~2t\
     and an integer: ~20t~d~%"$
     (%i3) printf( s,control, 'true,[1,2,3],42 )$
     (%o3)                                false
     (%i4) close(s);
     (%o4)                                true
     (%i5) s: openr("file.txt");
     (%o5)                      #<input stream file.txt>
     (%i6) while stringp( tmp:readline(s) ) do print(tmp)$
       An atom:          true
       and a list:       one two three
       and an integer:   42
     (%i7) close(s)$

 -- Function: close (<stream>)

     Closes <stream> and returns ‘true’ if <stream> had been open.

 -- Function: flength (<stream>)

     <stream> has to be an open stream from or to a file.  ‘flength’
     then returns the number of bytes which are currently present in
     this file.

     Example: See *note writebyte:: .

 -- Function: flush_output (<stream>)

     Flushes <stream> where <stream> has to be an output stream to a
     file.

     Example: See *note writebyte:: .

 -- Function: fposition
          fposition (<stream>)
          fposition (<stream>, <pos>)

     Returns the current position in <stream>, if <pos> is not used.  If
     <pos> is used, ‘fposition’ sets the position in <stream>.  <stream>
     has to be a stream from or to a file and <pos> has to be a positive
     number.

     Positions in data streams are like in strings or lists 1-indexed,
     i.e.  the first element in <stream> is in position 1.

 -- Function: freshline
          freshline ()
          freshline (<stream>)

     Writes a new line to the standard output stream if the position is
     not at the beginning of a line and returns ‘true’.  Using the
     optional argument <stream> the new line is written to that stream.
     There are some cases, where ‘freshline()’ does not work as
     expected.

     See also *note newline::.

 -- Function: get_output_stream_string (<stream>)

     Returns a string containing all the characters currently present in
     <stream> which must be an open string-output stream.  The returned
     characters are removed from <stream>.

     Example: See *note make_string_output_stream:: .

 -- Function: make_string_input_stream
          make_string_input_stream (<string>)
          make_string_input_stream (<string>, <start>)
          make_string_input_stream (<string>, <start>, <end>)

     Returns an input stream which contains parts of <string> and an end
     of file.  Without optional arguments the stream contains the entire
     string and is positioned in front of the first character.  <start>
     and <end> define the substring contained in the stream.  The first
     character is available at position 1.

          (%i1) istream : make_string_input_stream("text", 1, 4);
          (%o1)              #<string-input stream from "text">
          (%i2) (while (c : readchar(istream)) # false do sprint(c), newline())$
          t e x
          (%i3) close(istream)$

 -- Function: make_string_output_stream ()

     Returns an output stream that accepts characters.  Characters
     currently present in this stream can be retrieved by *note
     get_output_stream_string::.

          (%i1) ostream : make_string_output_stream();
          (%o1)               #<string-output stream 09622ea0>
          (%i2) printf(ostream, "foo")$

          (%i3) printf(ostream, "bar")$

          (%i4) string : get_output_stream_string(ostream);
          (%o4)                            foobar
          (%i5) printf(ostream, "baz")$

          (%i6) string : get_output_stream_string(ostream);
          (%o6)                              baz
          (%i7) close(ostream)$

 -- Function: newline
          newline ()
          newline (<stream>)

     Writes a new line to the standard output stream.  Using the
     optional argument <stream> the new line is written to that stream.
     There are some cases, where ‘newline()’ does not work as expected.

     See *note sprint:: for an example of using ‘newline()’.

 -- Function: opena (<file>)

     Returns a character output stream to <file>.  If an existing file
     is opened, ‘opena’ appends elements at the end of <file>.

     For binary output see *note opena_binary: Functions and Variables
     for binary input and output. .

 -- Function: openr
          openr (<file>)
          openr (<file>, <encoding>)

     Returns a character input stream to <file>.  ‘openr’ assumes that
     <file> already exists.  If reading the file results in a lisp error
     about its encoding passing the correct string as the argument
     <encoding> might help.  The available encodings and their names
     depend on the lisp being used.  For sbcl a list of suitable strings
     can be found at <http://www.sbcl.org/manual/#External-Formats>.

     For binary input see *note openr_binary: Functions and Variables
     for binary input and output. .  See also ‘close’ and ‘openw’.

          (%i1) istream : openr("data.txt","EUC-JP");
          (%o1)     #<FD-STREAM for "file /home/gunter/data.txt" {10099A3AE3}>
          (%i2) close(istream);
          (%o2)                                true

 -- Function: openw (<file>)

     Returns a character output stream to <file>.  If <file> does not
     exist, it will be created.  If an existing file is opened, ‘openw’
     destructively modifies <file>.

     For binary output see *note openw_binary: Functions and Variables
     for binary input and output. .

     See also ‘close’ and ‘openr’.

 -- Function: printf
          printf (<dest>, <string>)
          printf (<dest>, <string>, <expr_1>, ..., <expr_n>)

     Produces formatted output by outputting the characters of
     control-string <string> and observing that a tilde introduces a
     directive.  The character after the tilde, possibly preceded by
     prefix parameters and modifiers, specifies what kind of formatting
     is desired.  Most directives use one or more elements of the
     arguments <expr_1>, ..., <expr_n> to create their output.

     If <dest> is a stream or ‘true’, then ‘printf’ returns ‘false’.
     Otherwise, ‘printf’ returns a string containing the output.  By
     default the streams <stdin>, <stdout> and <stderr> are defined.  If
     Maxima is running as a network client (which is the normal case if
     Maxima is communicating with a graphical user interface, which must
     be the server) ‘setup-client’ will define <old_stdout> and
     <old_stderr>, too.

     ‘printf’ provides the Common Lisp function ‘format’ in Maxima.  The
     following example illustrates the general relation between these
     two functions.

          (%i1) printf(true, "R~dD~d~%", 2, 2);
          R2D2
          (%o1)                                false
          (%i2) :lisp (format t "R~dD~d~%" 2 2)
          R2D2
          NIL

     The following description is limited to a rough sketch of the
     possibilities of ‘printf’.  The Lisp function ‘format’ is described
     in detail in many reference books.  Of good help is e.g.  the free
     available online-manual "Common Lisp the Language" by Guy L.
     Steele.  See chapter 22.3.3 there.

     In addition, ‘printf’ recognizes two format directives which are
     not known to Lisp ‘format’.  The format directive ‘~m’ indicates
     Maxima pretty printer output.  The format directive ‘~h’ indicates
     a bigfloat number.

             ~%       new line
             ~&       fresh line
             ~t       tab
             ~$       monetary
             ~d       decimal integer
             ~b       binary integer
             ~o       octal integer
             ~x       hexadecimal integer
             ~br      base-b integer
             ~r       spell an integer
             ~p       plural
             ~f       floating point
             ~e       scientific notation
             ~g       ~f or ~e, depending upon magnitude
             ~h       bigfloat
             ~a       uses Maxima function string
             ~m       Maxima pretty printer output
             ~s       like ~a, but output enclosed in "double quotes"
             ~~       ~
             ~<       justification, ~> terminates
             ~(       case conversion, ~) terminates
             ~[       selection, ~] terminates
             ~{       iteration, ~} terminates

     Note that the directive ~* is not supported.

     If <dest> is a stream or ‘true’, then ‘printf’ returns ‘false’.
     Otherwise, ‘printf’ returns a string containing the output.

          (%i1) printf( false, "~a ~a ~4f ~a ~@r",
                        "String",sym,bound,sqrt(12),144), bound = 1.234;
          (%o1)                 String sym 1.23 2*sqrt(3) CXLIV
          (%i2) printf( false,"~{~a ~}",["one",2,"THREE"] );
          (%o2)                          one 2 THREE
          (%i3) printf(true,"~{~{~9,1f ~}~%~}",mat ),
                    mat = args(matrix([1.1,2,3.33],[4,5,6],[7,8.88,9]))$
                1.1       2.0       3.3
                4.0       5.0       6.0
                7.0       8.9       9.0
          (%i4) control: "~:(~r~) bird~p ~[is~;are~] singing."$
          (%i5) printf( false,control, n,n,if n=1 then 1 else 2 ), n=2;
          (%o5)                    Two birds are singing.

     The directive ~h has been introduced to handle bigfloats.

          ~w,d,e,x,o,p@H
           w : width
           d : decimal digits behind floating point
           e : minimal exponent digits
           x : preferred exponent
           o : overflow character
           p : padding character
           @ : display sign for positive numbers

          (%i1) fpprec : 1000$
          (%i2) printf(true, "|~h|~%", 2.b0^-64)$
          |0.0000000000000000000542101086242752217003726400434970855712890625|
          (%i3) fpprec : 26$
          (%i4) printf(true, "|~h|~%", sqrt(2))$
          |1.4142135623730950488016887|
          (%i5) fpprec : 24$
          (%i6) printf(true, "|~h|~%", sqrt(2))$
          |1.41421356237309504880169|
          (%i7) printf(true, "|~28h|~%", sqrt(2))$
          |   1.41421356237309504880169|
          (%i8) printf(true, "|~28,,,,,'*h|~%", sqrt(2))$
          |***1.41421356237309504880169|
          (%i9) printf(true, "|~,18h|~%", sqrt(2))$
          |1.414213562373095049|
          (%i10) printf(true, "|~,,,-3h|~%", sqrt(2))$
          |1414.21356237309504880169b-3|
          (%i11) printf(true, "|~,,2,-3h|~%", sqrt(2))$
          |1414.21356237309504880169b-03|
          (%i12) printf(true, "|~20h|~%", sqrt(2))$
          |1.41421356237309504880169|
          (%i13) printf(true, "|~20,,,,'+h|~%", sqrt(2))$
          |++++++++++++++++++++|

     For conversion of objects to strings also see ‘concat’, ‘sconcat’,
     ‘string’ and ‘simplode’.

 -- Function: readbyte (<stream>)

     Removes and returns the first byte in <stream> which must be a
     binary input stream.  If the end of file is encountered ‘readbyte’
     returns ‘false’.

     Example: Read the first 16 bytes from a file encrypted with AES in
     OpenSSL.

          (%i1) ibase: obase: 16.$

          (%i2) in: openr_binary("msg.bin");
          (%o2)                       #<input stream msg.bin>
          (%i3) (L:[],  thru 16. do push(readbyte(in), L),  L:reverse(L));
          (%o3) [53, 61, 6C, 74, 65, 64, 5F, 5F, 88, 56, 0DE, 8A, 74, 0FD,
                 0AD, 0F0]
          (%i4) close(in);
          (%o4)                                true
          (%i5) map(ascii, rest(L,-8));
          (%o5)                      [S, a, l, t, e, d, _, _]
          (%i6) salt: octets_to_number(rest(L,8));
          (%o6)                          8856de8a74fdadf0

 -- Function: readchar (<stream>)

     Removes and returns the first character in <stream>.  If the end of
     file is encountered ‘readchar’ returns ‘false’.

     Example: See *note make_string_input_stream::.

 -- Function: readline (<stream>)

     Returns a string containing all characters starting at the current
     position in <stream> up to the end of the line or ‘false’ if the
     end of the file is encountered.

 -- Function: sprint (<expr_1>, ..., <expr_n>)

     Evaluates and displays its arguments one after the other ‘on a
     line’ starting at the leftmost position.  The expressions are
     printed with a space character right next to the number, and it
     disregards line length.  ‘newline()’ might be used for line
     breaking.

     Example: Sequential printing with ‘sprint’.  Creating a new line
     with ‘newline()’.

          (%i1) for n:0 thru 19 do sprint(fib(n))$
          0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181
          (%i2) for n:0 thru 22 do (
                   sprint(fib(n)),
                   if mod(n,10) = 9 then newline() )$
          0 1 1 2 3 5 8 13 21 34
          55 89 144 233 377 610 987 1597 2584 4181
          6765 10946 17711

 -- Function: writebyte (<byte>, <stream>)

     Writes <byte> to <stream> which must be a binary output stream.
     ‘writebyte’ returns ‘byte’.

     Example: Write some bytes to a binary file output stream.  In this
     example all bytes correspond to printable characters and are
     printed by ‘printfile’.  The bytes remain in the stream until
     ‘flush_output’ or ‘close’ have been called.

          (%i1) ibase: obase: 16.$

          (%i2) bytes: map(cint, charlist("GNU/Linux"));
          (%o2)                [47, 4E, 55, 2F, 4C, 69, 6E, 75, 78]
          (%i3) out: openw_binary("test.bin");
          (%o3)                      #<output stream test.bin>
          (%i4) for i thru 3 do writebyte(bytes[i], out);
          (%o4)                                done
          (%i5) printfile("test.bin")$

          (%i6) flength(out);
          (%o6)                                  0
          (%i7) flush_output(out);
          (%o7)                                true
          (%i8) flength(out);
          (%o8)                                  3
          (%i9) printfile("test.bin")$
          GNU
          (%i0A) for b in rest(bytes,3) do writebyte(b, out);
          (%o0A)                               done
          (%i0B) close(out);
          (%o0B)                               true
          (%i0C) printfile("test.bin")$
          GNU/Linux


File: maxima.info,  Node: Characters,  Next: String Processing,  Prev: String Input and Output,  Up: stringproc-pkg

91.3 Characters
===============

Characters are strings of length 1.

 -- Function: adjust_external_format ()

     Prints information about the current external format of the Lisp
     reader and in case the external format encoding differs from the
     encoding of the application which runs Maxima
     ‘adjust_external_format’ tries to adjust the encoding or prints
     some help or instruction.  ‘adjust_external_format’ returns ‘true’
     when the external format has been changed and ‘false’ otherwise.

     Functions like *note cint::, *note unicode::, *note
     octets_to_string:: and *note string_to_octets:: need UTF-8 as the
     external format of the Lisp reader to work properly over the full
     range of Unicode characters.

     Examples (Maxima on Windows, March 2016): Using
     ‘adjust_external_format’ when the default external format is not
     equal to the encoding provided by the application.

     1.  Command line Maxima

     In case a terminal session is preferred it is recommended to use
     Maxima compiled with SBCL. Here Unicode support is provided by
     default and calls to ‘adjust_external_format’ are unnecessary.

     If Maxima is compiled with CLISP or GCL it is recommended to change
     the terminal encoding from CP850 to CP1252.
     ‘adjust_external_format’ prints some help.

     CCL reads UTF-8 while the terminal input is CP850 by default.
     CP1252 is not supported by CCL. ‘adjust_external_format’ prints
     instructions for changing the terminal encoding and external format
     both to iso-8859-1.

     2.  wxMaxima

     In wxMaxima SBCL reads CP1252 by default but the input from the
     application is UTF-8 encoded.  Adjustment is needed.

     Calling ‘adjust_external_format’ and restarting Maxima permanently
     changes the default external format to UTF-8.

          (%i1)adjust_external_format();
          The line
          (setf sb-impl::*default-external-format* :utf-8)
          has been appended to the init file
          C:/Users/Username/.sbclrc
          Please restart Maxima to set the external format to UTF-8.
          (%i1) false

     Restarting Maxima.

          (%i1) adjust_external_format();
          The external format is currently UTF-8
          and has not been changed.
          (%i1) false

 -- Function: alphacharp (<char>)

     Returns ‘true’ if <char> is an alphabetic character.

     To identify a non-US-ASCII character as an alphabetic character the
     underlying Lisp must provide full Unicode support.  E.g.  a German
     umlaut is detected as an alphabetic character with SBCL in
     GNU/Linux but not with GCL. (In Windows Maxima, when compiled with
     SBCL, must be set to UTF-8.  See *note adjust_external_format:: for
     more.)

     Example: Examination of non-US-ASCII characters.

     The underlying Lisp (SBCL, GNU/Linux) is able to convert the typed
     character into a Lisp character and to examine.

          (%i1) alphacharp("ü");
          (%o1)                          true

     In GCL this is not possible.  An error break occurs.

          (%i1) alphacharp("u");
          (%o1)                          true
          (%i2) alphacharp("ü");

          package stringproc: ü cannot be converted into a Lisp character.
           -- an error.

 -- Function: alphanumericp (<char>)

     Returns ‘true’ if <char> is an alphabetic character or a digit
     (only corresponding US-ASCII characters are regarded as digits).

     Note: See remarks on *note alphacharp::.

 -- Function: ascii (<int>)

     Returns the US-ASCII character corresponding to the integer <int>
     which has to be less than ‘128’.

     See *note unicode:: for converting code points larger than ‘127’.

     Examples:

          (%i1) for n from 0 thru 127 do (
                  ch: ascii(n),
                  if alphacharp(ch) then sprint(ch),
                  if n = 96 then newline() )$
          A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
          a b c d e f g h i j k l m n o p q r s t u v w x y z

 -- Function: cequal (<char_1>, <char_2>)

     Returns ‘true’ if <char_1> and <char_2> are the same character.

 -- Function: cequalignore (<char_1>, <char_2>)

     Like ‘cequal’ but ignores case which is only possible for
     non-US-ASCII characters when the underlying Lisp is able to
     recognize a character as an alphabetic character.  See remarks on
     *note alphacharp::.

 -- Function: cgreaterp (<char_1>, <char_2>)

     Returns ‘true’ if the code point of <char_1> is greater than the
     code point of <char_2>.

 -- Function: cgreaterpignore (<char_1>, <char_2>)

     Like ‘cgreaterp’ but ignores case which is only possible for
     non-US-ASCII characters when the underlying Lisp is able to
     recognize a character as an alphabetic character.  See remarks on
     *note alphacharp::.

 -- Function: charp (<obj>)

     Returns ‘true’ if <obj> is a Maxima-character.  See introduction
     for example.

 -- Function: cint (<char>)

     Returns the Unicode code point of <char> which must be a Maxima
     character, i.e.  a string of length ‘1’.

     Examples: The hexadecimal code point of some characters (Maxima
     with SBCL on GNU/Linux).

          (%i1) obase: 16.$
          (%i2) map(cint, ["$","£","€"]);
          (%o2)                           [24, 0A3, 20AC]

     Warning: It is not possible to enter characters corresponding to
     code points larger than 16 bit in wxMaxima with SBCL on Windows
     when the external format has not been set to UTF-8.  See *note
     adjust_external_format::.

     CMUCL doesn’t process these characters as one character.  ‘cint’
     then returns ‘false’.  Converting a character to a code point via
     UTF-8-octets may serve as a workaround:

     ‘utf8_to_unicode(string_to_octets(character));’

     See *note utf8_to_unicode::, *note string_to_octets::.

 -- Function: clessp (<char_1>, <char_2>)

     Returns ‘true’ if the code point of <char_1> is less than the code
     point of <char_2>.

 -- Function: clesspignore (<char_1>, <char_2>)

     Like ‘clessp’ but ignores case which is only possible for
     non-US-ASCII characters when the underlying Lisp is able to
     recognize a character as an alphabetic character.  See remarks on
     *note alphacharp::.

 -- Function: constituent (<char>)

     Returns ‘true’ if <char> is a graphic character but not a space
     character.  A graphic character is a character one can see, plus
     the space character.  (‘constituent’ is defined by Paul Graham.
     See Paul Graham, ANSI Common Lisp, 1996, page 67.)

          (%i1) for n from 0 thru 255 do (
          tmp: ascii(n), if constituent(tmp) then sprint(tmp) )$
          ! " #  %  ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @ A B
          C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c
          d e f g h i j k l m n o p q r s t u v w x y z { | } ~

 -- Function: digitcharp (<char>)

     Returns ‘true’ if <char> is a digit where only the corresponding
     US-ASCII-character is regarded as a digit.

 -- Function: lowercasep (<char>)

     Returns ‘true’ if <char> is a lowercase character.

     Note: See remarks on *note alphacharp::.

 -- Variable: newline

     The newline character (ASCII-character 10).

 -- Variable: space

     The space character.

 -- Variable: tab

     The tab character.

 -- Function: unicode (<arg>)

     Returns the character defined by <arg> which might be a Unicode
     code point or a name string if the underlying Lisp provides full
     Unicode support.

     Example: Characters defined by hexadecimal code points (Maxima with
     SBCL on GNU/Linux).

          (%i1) ibase: 16.$
          (%i2) map(unicode, [24, 0A3, 20AC]);
          (%o2)                            [$, £, €]

     Warning: In wxMaxima with SBCL on Windows it is not possible to
     convert code points larger than 16 bit to characters when the
     external format has not been set to UTF-8.  See *note
     adjust_external_format:: for more information.

     CMUCL doesn’t process code points larger than 16 bit.  In these
     cases ‘unicode’ returns ‘false’.  Converting a code point to a
     character via UTF-8 octets may serve as a workaround:

     ‘octets_to_string(unicode_to_utf8(code_point));’

     See *note octets_to_string::, *note unicode_to_utf8::.

     In case the underlying Lisp provides full Unicode support the
     character might be specified by its name.  The following is
     possible in ECL, CLISP and SBCL, where in SBCL on Windows the
     external format has to be set to UTF-8.  ‘unicode(name)’ is
     supported by CMUCL too but again limited to 16 bit characters.

     The string argument to ‘unicode’ is basically the same string
     returned by ‘printf’ using the "~@c" specifier.  But as shown below
     the prefix "#\" must be omitted.  Underlines might be replaced by
     spaces and uppercase letters by lowercase ones.

     Example (continued): Characters defined by names (Maxima with SBCL
     on GNU/Linux).

          (%i3) printf(false, "~@c", unicode(0DF));
          (%o3)                    #\LATIN_SMALL_LETTER_SHARP_S
          (%i4) unicode("LATIN_SMALL_LETTER_SHARP_S");
          (%o4)                                  ß
          (%i5) unicode("Latin small letter sharp s");
          (%o5)                                  ß

 -- Function: unicode_to_utf8 (<code_point>)

     Returns a list containing the UTF-8 code corresponding to the
     Unicode <code_point>.

     Examples: Converting Unicode code points to UTF-8 and vice versa.

          (%i1) ibase: obase: 16.$
          (%i2) map(cint, ["$","£","€"]);
          (%o2)                           [24, 0A3, 20AC]
          (%i3) map(unicode_to_utf8, %);
          (%o3)                 [[24], [0C2, 0A3], [0E2, 82, 0AC]]
          (%i4) map(utf8_to_unicode, %);
          (%o4)                           [24, 0A3, 20AC]

 -- Function: uppercasep (<char>)

     Returns ‘true’ if <char> is an uppercase character.

     Note: See remarks on *note alphacharp::.

 -- Variable: us_ascii_only

     This option variable affects Maxima when the character encoding
     provided by the application which runs Maxima is UTF-8 but the
     external format of the Lisp reader is not equal to UTF-8.

     On GNU/Linux this is true when Maxima is built with GCL and on
     Windows in wxMaxima with GCL- and SBCL-builds.  With SBCL it is
     recommended to change the external format to UTF-8.  Setting
     ‘us_ascii_only’ is unnecessary then.  See *note
     adjust_external_format:: for details.

     ‘us_ascii_only’ is ‘false’ by default.  Maxima itself then (i.e.
     in the above described situation) parses the UTF-8 encoding.

     When ‘us_ascii_only’ is set to ‘true’ it is assumed that all
     strings used as arguments to string processing functions do not
     contain Non-US-ASCII characters.  Given that promise, Maxima avoids
     parsing UTF-8 and strings can be processed more efficiently.

 -- Function: utf8_to_unicode (<list>)

     Returns a Unicode code point corresponding to the <list> which must
     contain the UTF-8 encoding of a single character.

     Examples: See *note unicode_to_utf8::.


File: maxima.info,  Node: String Processing,  Next: Octets and Utilities for Cryptography,  Prev: Characters,  Up: stringproc-pkg

91.4 String Processing
======================

Position indices in strings are 1-indexed like in Maxima lists.  See
example in *note charat::.

 -- Function: charat (<string>, <n>)

     Returns the <n>-th character of <string>.  The first character in
     <string> is returned with <n> = 1.

          (%i1) charat("Lisp",1);
          (%o1)                           L
          (%i2) charlist("Lisp")[1];
          (%o2)                           L

 -- Function: charlist (<string>)

     Returns the list of all characters in <string>.

          (%i1) charlist("Lisp");
          (%o1)                     [L, i, s, p]

 -- Function: eval_string (<str>)

     Parse the string <str> as a Maxima expression and evaluate it.  The
     string <str> may or may not have a terminator (dollar sign ‘$’ or
     semicolon ‘;’).  Only the first expression is parsed and evaluated,
     if there is more than one.

     Complain if <str> is not a string.

     Examples:

          (%i1) eval_string ("foo: 42; bar: foo^2 + baz");
          (%o1)                       42
          (%i2) eval_string ("(foo: 42, bar: foo^2 + baz)");
          (%o2)                   baz + 1764

     See also *note parse_string:: and *note eval_string_lisp::.

 -- Function: parse_string (<str>)

     Parse the string <str> as a Maxima expression (do not evaluate it).
     The string <str> may or may not have a terminator (dollar sign ‘$’
     or semicolon ‘;’).  Only the first expression is parsed, if there
     is more than one.

     Complain if <str> is not a string.

     Examples:

          (%i1) parse_string ("foo: 42; bar: foo^2 + baz");
          (%o1)                    foo : 42
          (%i2) parse_string ("(foo: 42, bar: foo^2 + baz)");
                                             2
          (%o2)          (foo : 42, bar : foo  + baz)

     See also *note eval_string::.

 -- Function: scopy (<string>)

     Returns a copy of <string> as a new string.

 -- Function: sdowncase
          sdowncase (<string>)
          sdowncase (<string>, <start>)
          sdowncase (<string>, <start>, <end>)

     Like *note supcase:: but uppercase characters are converted to
     lowercase.

 -- Function: sequal (<string_1>, <string_2>)

     Returns ‘true’ if <string_1> and <string_2> contain the same
     sequence of characters.

 -- Function: sequalignore (<string_1>, <string_2>)

     Like ‘sequal’ but ignores case which is only possible for
     non-US-ASCII characters when the underlying Lisp is able to
     recognize a character as an alphabetic character.  See remarks on
     *note alphacharp::.

 -- Function: sexplode (<string>)

     ‘sexplode’ is an alias for function ‘charlist’.

 -- Function: simplode
          simplode (<list>)
          simplode (<list>, <delim>)

     ‘simplode’ takes a list of expressions and concatenates them into a
     string.  If no delimiter <delim> is specified, ‘simplode’ uses no
     delimiter.  <delim> can be any string.

     See also ‘concat’, ‘sconcat’, ‘string’ and ‘printf’.

     Examples:

          (%i1) simplode(["xx[",3,"]:",expand((x+y)^3)]);
          (%o1)             xx[3]:y^3+3*x*y^2+3*x^2*y+x^3
          (%i2) simplode( sexplode("stars")," * " );
          (%o2)                   s * t * a * r * s
          (%i3) simplode( ["One","more","coffee."]," " );
          (%o3)                   One more coffee.

 -- Function: sinsert (<seq>, <string>, <pos>)
     Returns a string that is a concatenation of ‘substring(<string>, 1,
     <pos>-1)’, the string <seq> and ‘substring (<string>, <pos>)’.
     Note that the first character in <string> is in position 1.

     Examples:

          (%i1) s: "A submarine."$
          (%i2) concat( substring(s,1,3),"yellow ",substring(s,3) );
          (%o2)                  A yellow submarine.
          (%i3) sinsert("hollow ",s,3);
          (%o3)                  A hollow submarine.

 -- Function: sinvertcase
          sinvertcase (<string>)
          sinvertcase (<string>, <start>)
          sinvertcase (<string>, <start>, <end>)

     Returns <string> except that each character from position <start>
     to <end> is inverted.  If <end> is not given, all characters from
     <start> to the end of <string> are replaced.

     Examples:

          (%i1) sinvertcase("sInvertCase");
          (%o1)                      SiNVERTcASE

 -- Function: slength (<string>)

     Returns the number of characters in <string>.

 -- Function: smake (<num>, <char>)

     Returns a new string with a number of <num> characters <char>.

     Example:

          (%i1) smake(3,"w");
          (%o1)                          www

 -- Function: smismatch
          smismatch (<string_1>, <string_2>)
          smismatch (<string_1>, <string_2>, <test>)

     Returns the position of the first character of <string_1> at which
     <string_1> and <string_2> differ or ‘false’.  Default test function
     for matching is ‘sequal’.  If ‘smismatch’ should ignore case, use
     ‘sequalignore’ as test.

     Example:

          (%i1) smismatch("seven","seventh");
          (%o1)                           6

 -- Function: split
          split (<string>)
          split (<string>, <delim>)
          split (<string>, <delim>, <multiple>)

     Returns the list of all tokens in <string>.  Each token is an
     unparsed string.  ‘split’ uses <delim> as delimiter.  If <delim> is
     not given, the space character is the default delimiter.
     <multiple> is a boolean variable with ‘true’ by default.  Multiple
     delimiters are read as one.  This is useful if tabs are saved as
     multiple space characters.  If <multiple> is set to ‘false’, each
     delimiter is noted.

     Examples:

          (%i1) split("1.2   2.3   3.4   4.5");
          (%o1)                 [1.2, 2.3, 3.4, 4.5]
          (%i2) split("first;;third;fourth",";",false);
          (%o2)               [first, , third, fourth]

 -- Function: sposition (<char>, <string>)
     Returns the position of the first character in <string> which
     matches <char>.  The first character in <string> is in position 1.
     For matching characters ignoring case see *note ssearch::.

 -- Function: sremove
          sremove (<seq>, <string>)
          sremove (<seq>, <string>, <test>)
          sremove (<seq>, <string>, <test>, <start>)
          sremove (<seq>, <string>, <test>, <start>, <end>)

     Returns a string like <string> but without all substrings matching
     <seq>.  Default test function for matching is ‘sequal’.  If
     ‘sremove’ should ignore case while searching for <seq>, use
     ‘sequalignore’ as test.  Use <start> and <end> to limit searching.
     Note that the first character in <string> is in position 1.

     Examples:

          (%i1) sremove("n't","I don't like coffee.");
          (%o1)                   I do like coffee.
          (%i2) sremove ("DO ",%,'sequalignore);
          (%o2)                    I like coffee.

 -- Function: sremovefirst
          sremovefirst (<seq>, <string>)
          sremovefirst (<seq>, <string>, <test>)
          sremovefirst (<seq>, <string>, <test>, <start>)
          sremovefirst (<seq>, <string>, <test>, <start>, <end>)

     Like ‘sremove’ except that only the first substring that matches
     <seq> is removed.

 -- Function: sreverse (<string>)

     Returns a string with all the characters of <string> in reverse
     order.

     See also ‘reverse’.

 -- Function: ssearch
          ssearch (<seq>, <string>)
          ssearch (<seq>, <string>, <test>)
          ssearch (<seq>, <string>, <test>, <start>)
          ssearch (<seq>, <string>, <test>, <start>, <end>)

     Returns the position of the first substring of <string> that
     matches the string <seq>.  Default test function for matching is
     ‘sequal’.  If ‘ssearch’ should ignore case, use ‘sequalignore’ as
     test.  Use <start> and <end> to limit searching.  Note that the
     first character in <string> is in position 1.

     Example:

          (%i1) ssearch("~s","~{~S ~}~%",'sequalignore);
          (%o1)                                  4

 -- Function: ssort
          ssort (<string>)
          ssort (<string>, <test>)

     Returns a string that contains all characters from <string> in an
     order such there are no two successive characters <c> and <d> such
     that ‘test (<c>, <d>)’ is ‘false’ and ‘test (<d>, <c>)’ is ‘true’.
     Default test function for sorting is <clessp>.  The set of test
     functions is ‘{clessp, clesspignore, cgreaterp, cgreaterpignore,
     cequal, cequalignore}’.

     Examples:

          (%i1) ssort("I don't like Mondays.");
          (%o1)                    '.IMaddeiklnnoosty
          (%i2) ssort("I don't like Mondays.",'cgreaterpignore);
          (%o2)                 ytsoonnMlkIiedda.'

 -- Function: ssubst
          ssubst (<new>, <old>, <string>)
          ssubst (<new>, <old>, <string>, <test>)
          ssubst (<new>, <old>, <string>, <test>, <start>)
          ssubst (<new>, <old>, <string>, <test>, <start>, <end>)

     Returns a string like <string> except that all substrings matching
     <old> are replaced by <new>.  <old> and <new> need not to be of the
     same length.  Default test function for matching is ‘sequal’.  If
     ‘ssubst’ should ignore case while searching for old, use
     ‘sequalignore’ as test.  Use <start> and <end> to limit searching.
     Note that the first character in <string> is in position 1.

     Examples:

          (%i1) ssubst("like","hate","I hate Thai food. I hate green tea.");
          (%o1)          I like Thai food. I like green tea.
          (%i2) ssubst("Indian","thai",%,'sequalignore,8,12);
          (%o2)         I like Indian food. I like green tea.

 -- Function: ssubstfirst
          ssubstfirst (<new>, <old>, <string>)
          ssubstfirst (<new>, <old>, <string>, <test>)
          ssubstfirst (<new>, <old>, <string>, <test>, <start>)
          ssubstfirst (<new>, <old>, <string>, <test>, <start>, <end>)

     Like ‘subst’ except that only the first substring that matches
     <old> is replaced.

 -- Function: strim (<seq>,<string>)

     Returns a string like <string>, but with all characters that appear
     in <seq> removed from both ends.

     Examples:

          (%i1) "/* comment */"$
          (%i2) strim(" /*",%);
          (%o2)                        comment
          (%i3) slength(%);
          (%o3)                           7

 -- Function: striml (<seq>, <string>)

     Like ‘strim’ except that only the left end of <string> is trimmed.

 -- Function: strimr (<seq>, <string>)

     Like ‘strim’ except that only the right end of <string> is trimmed.

 -- Function: stringp (<obj>)

     Returns ‘true’ if <obj> is a string.  See introduction for example.

 -- Function: substring
          substring (<string>, <start>)
          substring (<string>, <start>, <end>)

     Returns the substring of <string> beginning at position <start> and
     ending at position <end>.  The character at position <end> is not
     included.  If <end> is not given, the substring contains the rest
     of the string.  Note that the first character in <string> is in
     position 1.

     Examples:

          (%i1) substring("substring",4);
          (%o1)                        string
          (%i2) substring(%,4,6);
          (%o2)                          in

 -- Function: supcase
          supcase (<string>)
          supcase (<string>, <start>)
          supcase (<string>, <start>, <end>)

     Returns <string> except that lowercase characters from position
     <start> to <end> are replaced by the corresponding uppercase ones.
     If <end> is not given, all lowercase characters from <start> to the
     end of <string> are replaced.

     Example:

          (%i1) supcase("english",1,2);
          (%o1)                        English

 -- Function: tokens
          tokens (<string>)
          tokens (<string>, <test>)

     Returns a list of tokens, which have been extracted from <string>.
     The tokens are substrings whose characters satisfy a certain test
     function.  If test is not given, <constituent> is used as the
     default test.  ‘{constituent, alphacharp, digitcharp, lowercasep,
     uppercasep, charp, characterp, alphanumericp}’ is the set of test
     functions.  (The Lisp-version of ‘tokens’ is written by Paul
     Graham.  ANSI Common Lisp, 1996, page 67.)

     Examples:

          (%i1) tokens("24 October 2005");
          (%o1)                  [24, October, 2005]
          (%i2) tokens("05-10-24",'digitcharp);
          (%o2)                     [05, 10, 24]
          (%i3) map(parse_string,%);
          (%o3)                      [5, 10, 24]


File: maxima.info,  Node: Octets and Utilities for Cryptography,  Prev: String Processing,  Up: stringproc-pkg

91.5 Octets and Utilities for Cryptography
==========================================

 -- Function: base64 (<arg>)

     Returns the base64-representation of <arg> as a string.  The
     argument <arg> may be a string, a non-negative integer or a list of
     octets.

     Examples:

          (%i1) base64: base64("foo bar baz");
          (%o1)                          Zm9vIGJhciBiYXo=
          (%i2) string: base64_decode(base64);
          (%o2)                            foo bar baz
          (%i3) obase: 16.$
          (%i4) integer: base64_decode(base64, 'number);
          (%o4)                       666f6f206261722062617a
          (%i5) octets: base64_decode(base64, 'list);
          (%o5)            [66, 6F, 6F, 20, 62, 61, 72, 20, 62, 61, 7A]
          (%i6) ibase: 16.$
          (%i7) base64(octets);
          (%o7)                          Zm9vIGJhciBiYXo=

     Note that if <arg> contains umlauts (resp.  octets larger than 127)
     the resulting base64-string is platform dependent.  However the
     decoded string will be equal to the original.

 -- Function: base64_decode
          base64_decode (<base64-string>)
          base64_decode (<base64-string>, <return-type>)

     By default ‘base64_decode’ decodes the <base64-string> back to the
     original string.

     The optional argument <return-type> allows ‘base64_decode’ to
     alternatively return the corresponding number or list of octets.
     <return-type> may be ‘string’, ‘number’ or ‘list’.

     Example: See *note base64::.

 -- Function: crc24sum
          crc24sum (<octets>)
          crc24sum (<octets>, <return-type>)

     By default ‘crc24sum’ returns the ‘CRC24’ checksum of an octet-list
     as a string.

     The optional argument <return-type> allows ‘crc24sum’ to
     alternatively return the corresponding number or list of octets.
     <return-type> may be ‘string’, ‘number’ or ‘list’.

     Example:

          -----BEGIN PGP SIGNATURE-----
          Version: GnuPG v2.0.22 (GNU/Linux)

          iQEcBAEBAgAGBQJVdCTzAAoJEG/1Mgf2DWAqCSYH/AhVFwhu1D89C3/QFcgVvZTM
          wnOYzBUURJAL/cT+IngkLEpp3hEbREcugWp+Tm6aw3R4CdJ7G3FLxExBH/5KnDHi
          rBQu+I7+3ySK2hpryQ6Wx5J9uZSa4YmfsNteR8up0zGkaulJeWkS4pjiRM+auWVe
          vajlKZCIK52P080DG7Q2dpshh4fgTeNwqCuCiBhQ73t8g1IaLdhDN6EzJVjGIzam
          /spqT/sTo6sw8yDOJjvU+Qvn6/mSMjC/YxjhRMaQt9EMrR1AZ4ukBF5uG1S7mXOH
          WdiwkSPZ3gnIBhM9SuC076gLWZUNs6NqTeE3UzMjDAFhH3jYk1T7mysCvdtIkms=
          =WmeC
          -----END PGP SIGNATURE-----

          (%i1) ibase : obase : 16.$
          (%i2) sig64 : sconcat(
           "iQEcBAEBAgAGBQJVdCTzAAoJEG/1Mgf2DWAqCSYH/AhVFwhu1D89C3/QFcgVvZTM",
           "wnOYzBUURJAL/cT+IngkLEpp3hEbREcugWp+Tm6aw3R4CdJ7G3FLxExBH/5KnDHi",
           "rBQu+I7+3ySK2hpryQ6Wx5J9uZSa4YmfsNteR8up0zGkaulJeWkS4pjiRM+auWVe",
           "vajlKZCIK52P080DG7Q2dpshh4fgTeNwqCuCiBhQ73t8g1IaLdhDN6EzJVjGIzam",
           "/spqT/sTo6sw8yDOJjvU+Qvn6/mSMjC/YxjhRMaQt9EMrR1AZ4ukBF5uG1S7mXOH",
           "WdiwkSPZ3gnIBhM9SuC076gLWZUNs6NqTeE3UzMjDAFhH3jYk1T7mysCvdtIkms=" )$
          (%i3) octets: base64_decode(sig64, 'list)$
          (%i4) crc24: crc24sum(octets, 'list);
          (%o4)                          [5A, 67, 82]
          (%i5) base64(crc24);
          (%o5)                              WmeC

 -- Function: md5sum
          md5sum (<arg>)
          md5sum (<arg>, <return-type>)

     Returns the ‘MD5’ checksum of a string, non-negative integer, list
     of octets, or binary (not character) input stream.  A file for
     which an input stream is opened may be an ordinary text file; it is
     the stream which needs to be binary, not the file itself.

     When the argument is an input stream, ‘md5sum’ reads the entire
     content of the stream, but does not close the stream.

     The default return value is a string containing 32 hex characters.
     The optional argument <return-type> allows ‘md5sum’ to
     alternatively return the corresponding number or list of octets.
     <return-type> may be ‘string’, ‘number’ or ‘list’.

     Note that in case <arg> contains German umlauts or other non-ASCII
     characters (resp.  octets larger than 127) the ‘MD5’ checksum is
     platform dependent.

     Examples:

          (%i1) ibase: obase: 16.$
          (%i2) msg: "foo bar baz"$
          (%i3) string: md5sum(msg);
          (%o3)                  ab07acbb1e496801937adfa772424bf7
          (%i4) integer: md5sum(msg, 'number);
          (%o4)                 0ab07acbb1e496801937adfa772424bf7
          (%i5) octets: md5sum(msg, 'list);
          (%o5)        [0AB,7,0AC,0BB,1E,49,68,1,93,7A,0DF,0A7,72,42,4B,0F7]
          (%i6) sdowncase( printf(false, "~{~2,'0x~^:~}", octets) );
          (%o6)           ab:07:ac:bb:1e:49:68:01:93:7a:df:a7:72:42:4b:f7

     The argument may be a binary input stream.

          (%i1) S: openr_binary (file_search ("md5.lisp"));
          (%o1) #<INPUT BUFFERED FILE-STREAM (UNSIGNED-BYTE 8)
            /home/robert/maxima/maxima-code/share/stringproc/md5.lisp>
          (%i2) md5sum (S);
          (%o2)           31a512ed53daf5b99495c9d05559355f
          (%i3) close (S);
          (%o3)                         true

 -- Function: mgf1_sha1
          mgf1_sha1 (<seed>, <len>)
          mgf1_sha1 (<seed>, <len>, <return-type>)

     Returns a pseudo random number of variable length.  By default the
     returned value is a number with a length of <len> octets.

     The optional argument <return-type> allows ‘mgf1_sha1’ to
     alternatively return the corresponding list of <len> octets.
     <return-type> may be ‘number’ or ‘list’.

     The computation of the returned value is described in ‘RFC 3447’,
     appendix ‘B.2.1 MGF1’.  ‘SHA1’ is used as hash function, i.e.  the
     randomness of the computed number relies on the randomness of
     ‘SHA1’ hashes.

     Example:

          (%i1) ibase: obase: 16.$
          (%i2) number: mgf1_sha1(4711., 8);
          (%o2)                        0e0252e5a2a42fea1
          (%i3) octets: mgf1_sha1(4711., 8, 'list);
          (%o3)                  [0E0,25,2E,5A,2A,42,0FE,0A1]

 -- Function: number_to_octets (<number>)

     Returns an octet-representation of <number> as a list of octets.
     The <number> must be a non-negative integer.

     Example:

          (%i1) ibase : obase : 16.$
          (%i2) octets: [0ca,0fe,0ba,0be]$
          (%i3) number: octets_to_number(octets);
          (%o3)                            0cafebabe
          (%i4) number_to_octets(number);
          (%o4)                      [0CA, 0FE, 0BA, 0BE]

 -- Function: octets_to_number (<octets>)

     Returns a number by concatenating the octets in the list of
     <octets>.

     Example: See *note number_to_octets::.

 -- Function: octets_to_oid (<octets>)

     Computes an object identifier (OID) from the list of <octets>.

     Example: RSA encryption OID

          (%i1) ibase : obase : 16.$
          (%i2) oid: octets_to_oid([2A,86,48,86,0F7,0D,1,1,1]);
          (%o2)                      1.2.840.113549.1.1.1
          (%i3) oid_to_octets(oid);
          (%o3)               [2A, 86, 48, 86, 0F7, 0D, 1, 1, 1]

 -- Function: octets_to_string
          octets_to_string (<octets>)
          octets_to_string (<octets>, <encoding>)

     Decodes the list of <octets> into a string according to current
     system defaults.  When decoding octets corresponding to
     Non-US-ASCII characters the result depends on the platform,
     application and underlying Lisp.

     Example: Using system defaults (Maxima compiled with GCL, which
     uses no format definition and simply passes through the
     UTF-8-octets encoded by the GNU/Linux terminal).

          (%i1) octets: string_to_octets("abc");
          (%o1)                            [61, 62, 63]
          (%i2) octets_to_string(octets);
          (%o2)                                 abc
          (%i3) ibase: obase: 16.$
          (%i4) unicode(20AC);
          (%o4)                                  €
          (%i5) octets: string_to_octets(%);
          (%o5)                           [0E2, 82, 0AC]
          (%i6) octets_to_string(octets);
          (%o6)                                  €
          (%i7) utf8_to_unicode(octets);
          (%o7)                                20AC

     In case the external format of the Lisp reader is equal to UTF-8
     the optional argument <encoding> allows to set the encoding for the
     octet to string conversion.  If necessary see *note
     adjust_external_format:: for changing the external format.

     Some names of supported encodings (see corresponding Lisp manual
     for more):
     CCL, CLISP, SBCL: ‘utf-8, ucs-2be, ucs-4be, iso-8859-1, cp1252,
     cp850’
     CMUCL: ‘utf-8, utf-16-be, utf-32-be, iso8859-1, cp1252’
     ECL: ‘utf-8, ucs-2be, ucs-4be, iso-8859-1, windows-cp1252,
     dos-cp850’

     Example (continued): Using the optional encoding argument (Maxima
     compiled with SBCL, GNU/Linux terminal).

          (%i8) string_to_octets("€", "ucs-2be");
          (%o8)                              [20, 0AC]

 -- Function: oid_to_octets (<oid-string>)

     Converts an object identifier (OID) to a list of <octets>.

     Example: See *note octets_to_oid::.

 -- Function: sha1sum
          sha1sum (<arg>)
          sha1sum (<arg>, <return-type>)

     Returns the ‘SHA1’ fingerprint of a string, a non-negative integer
     or a list of octets.  The default return value is a string
     containing 40 hex characters.

     The optional argument <return-type> allows ‘sha1sum’ to
     alternatively return the corresponding number or list of octets.
     <return-type> may be ‘string’, ‘number’ or ‘list’.

     Example:

          (%i1) ibase: obase: 16.$
          (%i2) msg: "foo bar baz"$
          (%i3) string: sha1sum(msg);
          (%o3)              c7567e8b39e2428e38bf9c9226ac68de4c67dc39
          (%i4) integer: sha1sum(msg, 'number);
          (%o4)             0c7567e8b39e2428e38bf9c9226ac68de4c67dc39
          (%i5) octets: sha1sum(msg, 'list);
          (%o5)  [0C7,56,7E,8B,39,0E2,42,8E,38,0BF,9C,92,26,0AC,68,0DE,4C,67,0DC,39]
          (%i6) sdowncase( printf(false, "~{~2,'0x~^:~}", octets) );
          (%o6)     c7:56:7e:8b:39:e2:42:8e:38:bf:9c:92:26:ac:68:de:4c:67:dc:39

     Note that in case <arg> contains German umlauts or other non-ASCII
     characters (resp.  octets larger than 127) the ‘SHA1’ fingerprint
     is platform dependent.

 -- Function: sha256sum
          sha256sum (<arg>)
          sha256sum (<arg>, <return-type>)

     Returns the ‘SHA256’ fingerprint of a string, a non-negative
     integer or a list of octets.  The default return value is a string
     containing 64 hex characters.

     The optional argument <return-type> allows ‘sha256sum’ to
     alternatively return the corresponding number or list of octets
     (see *note sha1sum::).

     Example:

          (%i1) string: sha256sum("foo bar baz");
          (%o1)  dbd318c1c462aee872f41109a4dfd3048871a03dedd0fe0e757ced57dad6f2d7

     Note that in case <arg> contains German umlauts or other non-ASCII
     characters (resp.  octets larger than 127) the ‘SHA256’ fingerprint
     is platform dependent.

 -- Function: string_to_octets
          string_to_octets (<string>)
          string_to_octets (<string>, <encoding>)

     Encodes a <string> into a list of octets according to current
     system defaults.  When encoding strings containing Non-US-ASCII
     characters the result depends on the platform, application and
     underlying Lisp.

     In case the external format of the Lisp reader is equal to UTF-8
     the optional argument <encoding> allows to set the encoding for the
     string to octet conversion.  If necessary see *note
     adjust_external_format:: for changing the external format.

     See *note octets_to_string:: for examples and some more
     information.


File: maxima.info,  Node: to_poly_solve-pkg,  Next: unit-pkg,  Prev: stringproc-pkg,  Up: Top

92 to_poly_solve
****************

* Menu:

* Functions and Variables for to_poly_solve::


File: maxima.info,  Node: Functions and Variables for to_poly_solve,  Prev: to_poly_solve-pkg,  Up: to_poly_solve-pkg

92.1 Functions and Variables for to_poly_solve
==============================================

The packages ‘to_poly’ and ‘to_poly_solve’ are experimental; the
specifications of the functions in these packages might change or the
some of the functions in these packages might be merged into other
Maxima functions.

   Barton Willis (Professor of Mathematics, University of Nebraska at
Kearney) wrote the ‘to_poly’ and ‘to_poly_solve’ packages and the
English language user documentation for these packages.

 -- Operator: %and

     The operator ‘%and’ is a simplifying nonshort-circuited logical
     conjunction.  Maxima simplifies an ‘%and’ expression to either
     true, false, or a logically equivalent, but simplified, expression.
     The operator ‘%and’ is associative, commutative, and idempotent.
     Thus when ‘%and’ returns a noun form, the arguments of ‘%and’ form
     a non-redundant sorted list; for example

          (%i1) a %and (a %and b);
          (%o1)                       a %and b

     If one argument to a conjunction is the explicit the negation of
     another argument, ‘%and’ returns false:

          (%i2) a %and (not a);
          (%o2)                         false

     If any member of the conjunction is false, the conjunction
     simplifies to false even if other members are manifestly
     non-boolean; for example

          (%i3) 42 %and false;
          (%o3)                         false

     Any argument of an ‘%and’ expression that is an inequation (that
     is, an inequality or equation), is simplified using the Fourier
     elimination package.  The Fourier elimination simplifier has a
     pre-processor that converts some, but not all, nonlinear
     inequations into linear inequations; for example the Fourier
     elimination code simplifies ‘abs(x) + 1 > 0’ to true, so

          (%i4) (x < 1) %and (abs(x) + 1 > 0);
          (%o4)                         x < 1

     Notes
        • The option variable ‘prederror’ does not alter the
          simplification ‘%and’ expressions.

        • To avoid operator precedence errors, compound expressions
          involving the operators ‘%and, %or’, and ‘not’ should be fully
          parenthesized.

        • The Maxima operators ‘and’ and ‘or’ are both short-circuited.
          Thus ‘and’ isn’t associative or commutative.

     Limitations The conjunction ‘%and’ simplifies inequations locally,
     not globally.  This means that conjunctions such as

          (%i5) (x < 1) %and (x > 1);
          (%o5)                 (x > 1) %and (x < 1)

     do not simplify to false.  Also, the Fourier elimination code
     ignores the fact database;

          (%i6) assume(x > 5);
          (%o6)                        [x > 5]
          (%i7) (x > 1) %and (x > 2);
          (%o7)                 (x > 1) %and (x > 2)

     Finally, nonlinear inequations that aren’t easily converted into an
     equivalent linear inequation aren’t simplified.

     There is no support for distributing ‘%and’ over ‘%or’; neither is
     there support for distributing a logical negation over ‘%and’.

     To use ‘load("to_poly_solve")’

     Related functions ‘%or, %if, and, or, not’

     Status The operator ‘%and’ is experimental; the specifications of
     this function might change and its functionality might be merged
     into other Maxima functions.

 -- Operator: %if (<bool>, <a>, <b>)

     The operator ‘%if’ is a simplifying conditional.  The conditional
     <bool> should be boolean-valued.  When the conditional is true,
     return the second argument; when the conditional is false, return
     the third; in all other cases, return a noun form.

     Maxima inequations (either an inequality or an equality) are not
     boolean-valued; for example, Maxima does not simplify 5 < 6 to
     true, and it does not simplify 5 = 6 to false; however, in the
     context of a conditional to an ‘%if’ statement, Maxima
     automatically attempts to determine the truth value of an
     inequation.  Examples:

          (%i1) f : %if(x # 1, 2, 8);
          (%o1)                 %if(x - 1 # 0, 2, 8)
          (%i2) [subst(x = -1,f), subst(x=1,f)];
          (%o2)                        [2, 8]

     If the conditional involves an inequation, Maxima simplifies it
     using the Fourier elimination package.

     Notes

        • If the conditional is manifestly non-boolean, Maxima returns a
          noun form:

          (%i3) %if(42,1,2);
          (%o3)                     %if(42, 1, 2)

        • The Maxima operator ‘if’ is nary, the operator ‘%if’ isn’t
          nary.

     Limitations The Fourier elimination code only simplifies nonlinear
     inequations that are readily convertible to an equivalent linear
     inequation.

     To use: ‘load("to_poly_solve")’

     Status: The operator ‘%if’ is experimental; its specifications
     might change and its functionality might be merged into other
     Maxima functions.

 -- Operator: %or

     The operator ‘%or’ is a simplifying nonshort-circuited logical
     disjunction.  Maxima simplifies an ‘%or’ expression to either true,
     false, or a logically equivalent, but simplified, expression.  The
     operator ‘%or’ is associative, commutative, and idempotent.  Thus
     when ‘%or’ returns a noun form, the arguments of ‘%or’ form a
     non-redundant sorted list; for example

          (%i1) a %or (a %or b);
          (%o1)                        a %or b

     If one member of the disjunction is the explicit the negation of
     another member, ‘%or’ returns true:

          (%i2) a %or (not a);
          (%o2)                         true

     If any member of the disjunction is true, the disjunction
     simplifies to true even if other members of the disjunction are
     manifestly non-boolean; for example

          (%i3) 42 %or true;
          (%o3)                         true

     Any argument of an ‘%or’ expression that is an inequation (that is,
     an inequality or equation), is simplified using the Fourier
     elimination package.  The Fourier elimination code simplifies
     ‘abs(x) + 1 > 0’ to true, so we have

          (%i4) (x < 1) %or (abs(x) + 1 > 0);
          (%o4)                         true

     Notes
        • The option variable ‘prederror’ does not alter the
          simplification of ‘%or’ expressions.

        • You should parenthesize compound expressions involving the
          operators ‘%and, %or’, and ‘not’; the binding powers of these
          operators might not match your expectations.

        • The Maxima operators ‘and’ and ‘or’ are both short-circuited.
          Thus ‘or’ isn’t associative or commutative.

     Limitations The conjunction ‘%or’ simplifies inequations locally,
     not globally.  This means that conjunctions such as

          (%i1) (x < 1) %or (x >= 1);
          (%o1) (x > 1) %or (x >= 1)

     do not simplify to true.  Further, the Fourier elimination code
     ignores the fact database;

          (%i2) assume(x > 5);
          (%o2)                        [x > 5]
          (%i3) (x > 1) %and (x > 2);
          (%o3)                 (x > 1) %and (x > 2)

     Finally, nonlinear inequations that aren’t easily converted into an
     equivalent linear inequation aren’t simplified.

     The algorithm that looks for terms that cannot both be false is
     weak; also there is no support for distributing ‘%or’ over ‘%and’;
     neither is there support for distributing a logical negation over
     ‘%or’.

     To use ‘load("to_poly_solve")’

     Related functions ‘%or, %if, and, or, not’

     Status The operator ‘%or’ is experimental; the specifications of
     this function might change and its functionality might be merged
     into other Maxima functions.

 -- Function: complex_number_p (<x>)

     The predicate ‘complex_number_p’ returns true if its argument is
     either ‘a + %i * b’, ‘a’, ‘%i b’, or ‘%i’, where ‘a’ and ‘b’ are
     either rational or floating point numbers (including big floating
     point); for all other inputs, ‘complex_number_p’ returns false; for
     example

          (%i1) map('complex_number_p,[2/3, 2 + 1.5 * %i, %i]);
          (%o1)                  [true, true, true]
          (%i2) complex_number_p((2+%i)/(5-%i));
          (%o2)                         false
          (%i3) complex_number_p(cos(5 - 2 * %i));
          (%o3)                         false

     Related functions ‘isreal_p’

     To use ‘load("to_poly_solve")’

     Status The operator ‘complex_number_p’ is experimental; its
     specifications might change and its functionality might be merged
     into other Maxima functions.

 -- Function: compose_functions (<l>)

     The function call ‘compose_functions(l)’ returns a lambda form that
     is the composition of the functions in the list <l>.  The functions
     are applied from right to left; for example

          (%i1) compose_functions([cos, exp]);
                                                  %g151
          (%o1)             lambda([%g151], cos(%e     ))
          (%i2) %(x);
                                            x
          (%o2)                       cos(%e )

     When the function list is empty, return the identity function:

          (%i3) compose_functions([]);
          (%o3)                lambda([%g152], %g152)
          (%i4)  %(x);
          (%o4)                           x

     Notes
        • When Maxima determines that a list member isn’t a symbol or a
          lambda form, ‘funmake’ (not ‘compose_functions’) signals an
          error:

          (%i5) compose_functions([a < b]);

          funmake: first argument must be a symbol, subscripted symbol,
          string, or lambda expression; found: a < b
          #0: compose_functions(l=[a < b])(to_poly_solve.mac line 40)
           -- an error. To debug this try: debugmode(true);

        • To avoid name conflicts, the independent variable is
          determined by the function ‘new_variable’.

               (%i6) compose_functions([%g0]);
               (%o6)              lambda([%g154], %g0(%g154))
               (%i7) compose_functions([%g0]);
               (%o7)              lambda([%g155], %g0(%g155))

          Although the independent variables are different, Maxima is
          able to to deduce that these lambda forms are semantically
          equal:

               (%i8) is(equal(%o6,%o7));
               (%o8)                         true

     To use ‘load("to_poly_solve")’

     Status The function ‘compose_functions’ is experimental; its
     specifications might change and its functionality might be merged
     into other Maxima functions.

 -- Function: dfloat (<x>)

     The function ‘dfloat’ is a similar to ‘float’, but the function
     ‘dfloat’ applies ‘rectform’ when ‘float’ fails to evaluate to an
     IEEE double floating point number; thus

          (%i1) float(4.5^(1 + %i));
                                         %i + 1
          (%o1)                       4.5
          (%i2) dfloat(4.5^(1 + %i));
          (%o2)        4.48998802962884 %i + .3000124893895671

     Notes

        • The rectangular form of an expression might be poorly suited
          for numerical evaluation–for example, the rectangular form
          might needlessly involve the difference of floating point
          numbers (subtractive cancellation).

        • The identifier ‘float’ is both an option variable (default
          value false) and a function name.

     Related functions ‘float, bfloat’

     To use ‘load("to_poly_solve")’

     Status The function ‘dfloat’ is experimental; its specifications
     might change and its functionality might be merged into other
     Maxima functions.

 -- Function: elim (<l>, <x>)

     The function ‘elim’ eliminates the variables in the set or list ‘x’
     from the equations in the set or list ‘l’.  Each member of ‘x’ must
     be a symbol; the members of ‘l’ can either be equations, or
     expressions that are assumed to equal zero.

     The function ‘elim’ returns a list of two lists; the first is the
     list of expressions with the variables eliminated; the second is
     the list of pivots; thus, the second list is a list of expressions
     that ‘elim’ used to eliminate the variables.

     Here is an example of eliminating between linear equations:

          (%i1) elim(set(x + y + z = 1, x - y  - z = 8, x - z = 1),
                     set(x,y));
          (%o1)            [[2 z - 7], [y + 7, z - x + 1]]

     Eliminating ‘x’ and ‘y’ yields the single equation ‘2 z - 7 = 0’;
     the equations ‘y + 7 = 0’ and ‘z - z + 1 = 1’ were used as pivots.
     Eliminating all three variables from these equations,
     triangularizes the linear system:

          (%i2) elim(set(x + y + z = 1, x - y  - z = 8, x - z = 1),
                     set(x,y,z));
          (%o2)           [[], [2 z - 7, y + 7, z - x + 1]]

     Of course, the equations needn’t be linear:

          (%i3) elim(set(x^2 - 2 * y^3 = 1,  x - y = 5), [x,y]);
                               3    2
          (%o3)       [[], [2 y  - y  - 10 y - 24, y - x + 5]]

     The user doesn’t control the order the variables are eliminated.
     Instead, the algorithm uses a heuristic to attempt to choose the
     best pivot and the best elimination order.

     Notes

        • Unlike the related function ‘eliminate’, the function ‘elim’
          does not invoke ‘solve’ when the number of equations equals
          the number of variables.

        • The function ‘elim’ works by applying resultants; the option
          variable ‘resultant’ determines which algorithm Maxima uses.
          Using ‘sqfr’, Maxima factors each resultant and suppresses
          multiple zeros.

        • The ‘elim’ will triangularize a nonlinear set of polynomial
          equations; the solution set of the triangularized set can be
          larger than that solution set of the untriangularized set.
          Thus, the triangularized equations can have spurious
          solutions.

     Related functions elim_allbut, eliminate_using, eliminate

     Option variables resultant

     To use ‘load("to_poly")’

     Status The function ‘elim’ is experimental; its specifications
     might change and its functionality might be merged into other
     Maxima functions.

 -- Function: elim_allbut (<l>, <x>)

     This function is similar to ‘elim’, except that it eliminates all
     the variables in the list of equations ‘l’ except for those
     variables that in in the list ‘x’

          (%i1) elim_allbut([x+y = 1, x - 5*y = 1],[]);
          (%o1)                 [[], [y, y + x - 1]]
          (%i2) elim_allbut([x+y = 1, x - 5*y = 1],[x]);
          (%o2)                [[x - 1], [y + x - 1]]

     To use ‘load("to_poly")’

     Option variables resultant

     Related functions elim, eliminate_using, eliminate

     Status The function ‘elim_allbut’ is experimental; its
     specifications might change and its functionality might be merged
     into other Maxima functions.

 -- Function: eliminate_using (<l>, <e>, <x>)

     Using ‘e’ as the pivot, eliminate the symbol ‘x’ from the list or
     set of equations in ‘l’.  The function ‘eliminate_using’ returns a
     set.

          (%i1) eq : [x^2 - y^2 - z^3 , x*y - z^2 - 5, x - y + z];
                         3    2    2     2
          (%o1)      [- z  - y  + x , - z  + x y - 5, z - y + x]
          (%i2) eliminate_using(eq,first(eq),z);
                  3              2      2      3    2
          (%o2) {y  + (1 - 3 x) y  + 3 x  y - x  - x ,
                                  4    3  3       2  2             4
                                 y  - x  y  + 13 x  y  - 75 x y + x  + 125}
          (%i3) eliminate_using(eq,second(eq),z);
                  2            2       4    3  3       2  2             4
          (%o3) {y  - 3 x y + x  + 5, y  - x  y  + 13 x  y  - 75 x y + x
                                                                     + 125}
          (%i4) eliminate_using(eq, third(eq),z);
                  2            2       3              2      2      3    2
          (%o4) {y  - 3 x y + x  + 5, y  + (1 - 3 x) y  + 3 x  y - x  - x }

     Option variables resultant

     Related functions elim, eliminate, elim_allbut

     To use ‘load("to_poly")’

     Status The function ‘eliminate_using’ is experimental; its
     specifications might change and its functionality might be merged
     into other Maxima functions.

 -- Function: fourier_elim ([<eq1>, <eq2>, ...], [<var1>, <var>, ...])

     Fourier elimination is the analog of Gauss elimination for linear
     inequations (equations or inequalities).  The function call
     ‘fourier_elim([eq1, eq2, ...], [var1, var2, ...])’ does Fourier
     elimination on a list of linear inequations ‘[eq1, eq2, ...]’ with
     respect to the variables ‘[var1, var2, ...]’; for example

          (%i1) fourier_elim([y-x < 5, x - y < 7, 10 < y],[x,y]);
          (%o1)            [y - 5 < x, x < y + 7, 10 < y]
          (%i2) fourier_elim([y-x < 5, x - y < 7, 10 < y],[y,x]);
          (%o2)        [max(10, x - 7) < y, y < x + 5, 5 < x]

     Eliminating first with respect to x and second with respect to y
     yields lower and upper bounds for x that depend on y, and lower and
     upper bounds for y that are numbers.  Eliminating in the other
     order gives x dependent lower and upper bounds for y, and numerical
     lower and upper bounds for x.

     When necessary, ‘fourier_elim’ returns a _disjunction_ of lists of
     inequations:

          (%i3) fourier_elim([x # 6],[x]);
          (%o3)                  [x < 6] or [6 < x]

     When the solution set is empty, ‘fourier_elim’ returns ‘emptyset’,
     and when the solution set is all reals, ‘fourier_elim’ returns
     ‘universalset’; for example

          (%i4) fourier_elim([x < 1, x > 1],[x]);
          (%o4)                       emptyset
          (%i5) fourier_elim([minf < x, x < inf],[x]);
          (%o5)                     universalset

     For nonlinear inequations, ‘fourier_elim’ returns a (somewhat)
     simplified list of inequations:

          (%i6) fourier_elim([x^3 - 1 > 0],[x]);
                         2                             2
          (%o6) [1 < x, x  + x + 1 > 0] or [x < 1, - (x  + x + 1) > 0]
          (%i7) fourier_elim([cos(x) < 1/2],[x]);
          (%o7)                  [1 - 2 cos(x) > 0]

     Instead of a list of inequations, the first argument to
     ‘fourier_elim’ may be a logical disjunction or conjunction:

          (%i8) fourier_elim((x + y < 5) and (x - y >8),[x,y]);
                                                        3
          (%o8)            [y + 8 < x, x < 5 - y, y < - -]
                                                        2
          (%i9) fourier_elim(((x + y < 5) and x < 1) or  (x - y >8),[x,y]);
          (%o9)          [y + 8 < x] or [x < min(1, 5 - y)]

     The function ‘fourier_elim’ supports the inequation operators ‘<,
     <=, >, >=, #’, and ‘=’.

     The Fourier elimination code has a preprocessor that converts some
     nonlinear inequations that involve the absolute value, minimum, and
     maximum functions into linear in equations.  Additionally, the
     preprocessor handles some expressions that are the product or
     quotient of linear terms:

          (%i10) fourier_elim([max(x,y) > 6, x # 8, abs(y-1) > 12],[x,y]);
          (%o10) [6 < x, x < 8, y < - 11] or [8 < x, y < - 11]
           or [x < 8, 13 < y] or [x = y, 13 < y] or [8 < x, x < y, 13 < y]
           or [y < x, 13 < y]
          (%i11) fourier_elim([(x+6)/(x-9) <= 6],[x]);
          (%o11)           [x = 12] or [12 < x] or [x < 9]
          (%i12) fourier_elim([x^2 - 1 # 0],[x]);
          (%o12)      [- 1 < x, x < 1] or [1 < x] or [x < - 1]

     To use ‘load("fourier_elim")’

 -- Function: isreal_p (<e>)

     The predicate ‘isreal_p’ returns true when Maxima is able to
     determine that ‘e’ is real-valued on the entire real line; it
     returns false when Maxima is able to determine that ‘e’ isn’t
     real-valued on some nonempty subset of the real line; and it
     returns a noun form for all other cases.

          (%i1) map('isreal_p, [-1, 0, %i, %pi]);
          (%o1)               [true, true, false, true]

     Maxima variables are assumed to be real; thus

          (%i2) isreal_p(x);
          (%o2)                         true

     The function ‘isreal_p’ examines the fact database:

          (%i3) declare(z,complex)$

          (%i4) isreal_p(z);
          (%o4)                      isreal_p(z)

     Limitations Too often, ‘isreal_p’ returns a noun form when it
     should be able to return false; a simple example: the logarithm
     function isn’t real-valued on the entire real line, so
     ‘isreal_p(log(x))’ should return false; however

          (%i5) isreal_p(log(x));
          (%o5)                   isreal_p(log(x))

     To use ‘load("to_poly_solve")’

     Related functions complex_number_p

     Status The function ‘isreal_p’ is experimental; its specifications
     might change and its functionality might be merged into other
     Maxima functions.

 -- Function: new_variable (type)

     Return a unique symbol of the form ‘%[z,n,r,c,g]k’, where ‘k’ is an
     integer.  The allowed values for type are integer, natural_number,
     real, complex, and general.  (By natural number, we mean the
     nonnegative integers; thus zero is a natural number.  Some, but not
     all, definitions of natural number exclude zero.)

     When type isn’t one of the allowed values, type defaults to
     general.  For integers, natural numbers, and complex numbers,
     Maxima automatically appends this information to the fact database.

          (%i1) map('new_variable,
                    ['integer, 'natural_number, 'real, 'complex, 'general]);
          (%o1)          [%z144, %n145, %r146, %c147, %g148]
          (%i2) nicedummies(%);
          (%o2)               [%z0, %n0, %r0, %c0, %g0]
          (%i3) featurep(%z0, 'integer);
          (%o3)                         true
          (%i4) featurep(%n0, 'integer);
          (%o4)                         true
          (%i5) is(%n0 >= 0);
          (%o5)                         true
          (%i6) featurep(%c0, 'complex);
          (%o6)                         true

     Note Generally, the argument to ‘new_variable’ should be quoted.
     The quote will protect against errors similar to

          (%i7) integer : 12$

          (%i8) new_variable(integer);
          (%o8)                         %g149
          (%i9) new_variable('integer);
          (%o9)                         %z150

     Related functions nicedummies

     To use ‘load("to_poly_solve")’

     Status The function ‘new_variable’ is experimental; its
     specifications might change and its functionality might be merged
     into other Maxima functions.

 -- Function: nicedummies

     Starting with zero, the function ‘nicedummies’ re-indexes the
     variables in an expression that were introduced by ‘new_variable’;

          (%i1) new_variable('integer) + 52 * new_variable('integer);
          (%o1)                   52 %z136 + %z135
          (%i2) new_variable('integer) - new_variable('integer);
          (%o2)                     %z137 - %z138
          (%i3) nicedummies(%);
          (%o3)                       %z0 - %z1

     Related functions new_variable

     To use ‘load("to_poly_solve")’

     Status The function ‘nicedummies’ is experimental; its
     specifications might change and its functionality might be merged
     into other Maxima functions.

 -- Function: parg (<x>)

     The function ‘parg’ is a simplifying version of the complex
     argument function ‘carg’; thus

          (%i1) map('parg,[1,1+%i,%i, -1 + %i, -1]);
                                  %pi  %pi  3 %pi
          (%o1)               [0, ---, ---, -----, %pi]
                                   4    2     4

     Generally, for a non-constant input, ‘parg’ returns a noun form;
     thus

          (%i2) parg(x + %i * sqrt(x));
          (%o2)                 parg(x + %i sqrt(x))

     When ‘sign’ can determine that the input is a positive or negative
     real number, ‘parg’ will return a non-noun form for a non-constant
     input.  Here are two examples:

          (%i3) parg(abs(x));
          (%o3) 0
          (%i4) parg(-x^2-1);
          (%o4)                          %pi

     Note The ‘sign’ function mostly ignores the variables that are
     declared to be complex (‘declare(x,complex)’); for variables that
     are declared to be complex, the ‘parg’ can return incorrect values;
     for example

          (%i1) declare(x,complex)$

          (%i2) parg(x^2 + 1);
          (%o2) 0

     Related function carg, isreal_p

     To use ‘load("to_poly_solve")’

     Status The function ‘parg’ is experimental; its specifications
     might change and its functionality might be merged into other
     Maxima functions.

 -- Function: real_imagpart_to_conjugate (<e>)

     The function ‘real_imagpart_to_conjugate’ replaces all occurrences
     of ‘realpart’ and ‘imagpart’ to algebraically equivalent
     expressions involving the ‘conjugate’.

          (%i1) declare(x, complex)$

          (%i2) real_imagpart_to_conjugate(realpart(x) +  imagpart(x) = 3);
                    conjugate(x) + x   %i (x - conjugate(x))
          (%o2)     ---------------- - --------------------- = 3
                           2                     2

     To use ‘load("to_poly_solve")’

     Status The function ‘real_imagpart_to_conjugate’ is experimental;
     its specifications might change and its functionality might be
     merged into other Maxima functions.

 -- Function: rectform_log_if_constant (<e>)

     The function ‘rectform_log_if_constant’ converts all terms of the
     form ‘ log(c)’ to ‘rectform(log(c))’, where ‘c’ is either a
     declared constant expression or explicitly declared constant

          (%i1) rectform_log_if_constant(log(1-%i) - log(x - %i));
                                           log(2)   %i %pi
          (%o1)            - log(x - %i) + ------ - ------
                                             2        4
          (%i2) declare(a,constant, b,constant)$

          (%i3) rectform_log_if_constant(log(a + %i*b));
                                 2    2
                            log(b  + a )
          (%o3)             ------------ + %i atan2(b, a)
                                 2

     To use ‘load("to_poly_solve")’

     Status The function ‘rectform_log_if_constant’ is experimental; the
     specifications of this function might change might change and its
     functionality might be merged into other Maxima functions.

 -- Function: simp_inequality (<e>)

     The function ‘simp_inequality’ applies basic simplifications to
     inequations, returning either a boolean value (true or false) or
     the original inequation.

     The simplification rules used by ‘simp_inequality’ include some
     facts about the ranges of the absolute value, power, and
     exponential functions along with some elementary algebra facts.

     For conjunctions or disjunctions of inequations, ‘simp_inequality’
     is applied to each individual inequation, but no effort is made to
     simplify the entire logical expression.

     Effectively, simp_inequality creates a new empty context, so
     database facts are not used to simplify inequations.

     ‘load("to_poly_solve")’ loads this function.

     Examples:

          (%i2) simp_inequality(1 # 0);
          (%o2) true

          (%i3) simp_inequality(1 < 0);
          (%o3) false

          (%i4) simp_inequality(a=a);
          (%o4) true

          (%i5) simp_inequality(a # a);
          (%o5) false

          (%i6) simp_inequality(a + 1 # a);
          (%o6) true

          (%i7) simp_inequality(a < a+1);
          (%o7) true

          (%i8) simp_inequality(abs(x) >= 0);
          (%o8) true

          (%i9) simp_inequality(exp(x)  > 0);
          (%o9) true

          (%i10) simp_inequality(x^2 >= 0);
          (%o10) true

          (%i11) simp_inequality(2^x  # 0);
          (%o11) true

          (%i12) simp_inequality(2^(x+1) > 2^x);
          (%o12) true

     The fact database is not consulted.  For example:

          (%i13) assume(xx > 0)$
          (%i14) simp_inequality(xx > 0);
          (%o14) xx>0

     And finally, for conjunctions or disjunctions of inequations, each
     inequation is simplified, but no effort is made to simplify the
     entire logical expression; for example:

          (%i15) simp_inequality((1 > 0) and (x < 0) and (x > 0));
          (%o15) x<0 and x>0

 -- Function: standardize_inverse_trig (<e>)

     This function applies the identities ‘cot(x) = atan(1/x), acsc(x) =
     asin(1/x),’ and similarly for ‘asec, acoth, acsch’ and ‘asech’ to
     an expression.  See Abramowitz and Stegun, Eqs.  4.4.6 through
     4.4.8 and 4.6.4 through 4.6.6.

     To use ‘load("to_poly_solve")’

     Status The function ‘standardize_inverse_trig’ is experimental; its
     specifications might change and its functionality might be merged
     into other Maxima functions.

 -- Function: subst_parallel (<l>, <e>)

     When ‘l’ is a single equation or a list of equations, substitute
     the right hand side of each equation for the left hand side.  The
     substitutions are made in parallel; for example

          (%i1) load("to_poly_solve")$

          (%i2) subst_parallel([x=y,y=x], [x,y]);
          (%o2)                        [y, x]

     Compare this to substitutions made serially:

          (%i3) subst([x=y,y=x],[x,y]);
          (%o3)                        [x, x]

     The function ‘subst_parallel’ is similar to ‘sublis’ except that
     ‘subst_parallel’ allows for substitution of nonatoms; for example

          (%i4) subst_parallel([x^2 = a, y = b], x^2 * y);
          (%o4)                          a b
          (%i5) sublis([x^2 = a, y = b], x^2 * y);

                                                                       2
          sublis: left-hand side of equation must be a symbol; found: x
           -- an error. To debug this try: debugmode(true);

     The substitutions made by ‘subst_parallel’ are literal, not
     semantic; thus ‘subst_parallel’ does not recognize that x * y is a
     subexpression of x^2 * y

          (%i6) subst_parallel([x * y = a], x^2 * y);
                                         2
          (%o6)                         x  y

     The function ‘subst_parallel’ completes all substitutions before
     simplifications.  This allows for substitutions into conditional
     expressions where errors might occur if the simplifications were
     made earlier:

          (%i7) subst_parallel([x = 0], %if(x < 1, 5, log(x)));
          (%o7)                           5
          (%i8) subst([x = 0], %if(x < 1, 5, log(x)));

          log: encountered log(0).
           -- an error. To debug this try: debugmode(true);

     Related functions subst, sublis, ratsubst

     To use ‘load("to_poly_solve_extra.lisp")’

     Status The function ‘subst_parallel’ is experimental; the
     specifications of this function might change might change and its
     functionality might be merged into other Maxima functions.

 -- Function: to_poly (<e>, <l>)

     The function ‘to_poly’ attempts to convert the equation ‘e’ into a
     polynomial system along with inequality constraints; the solutions
     to the polynomial system that satisfy the constraints are solutions
     to the equation ‘e’.  Informally, ‘to_poly’ attempts to
     polynomialize the equation <e>; an example might clarify:

          (%i1) load("to_poly_solve")$

          (%i2) to_poly(sqrt(x) = 3, [x]);
                                      2
          (%o2) [[%g130 - 3, x = %g130 ],
                                %pi                               %pi
                             [- --- < parg(%g130), parg(%g130) <= ---], []]
                                 2                                 2

     The conditions ‘-%pi/2<parg(%g130),parg(%g130)<=%pi/2’ tell us that
     ‘%g130’ is in the range of the square root function.  When this is
     true, the solution set to ‘sqrt(x) = 3’ is the same as the solution
     set to ‘%g130-3,x=%g130^2’.

     To polynomialize trigonometric expressions, it is necessary to
     introduce a non algebraic substitution; these non algebraic
     substitutions are returned in the third list returned by ‘to_poly’;
     for example

          (%i3) to_poly(cos(x),[x]);
                          2                                 %i x
          (%o3)    [[%g131  + 1], [2 %g131 # 0], [%g131 = %e    ]]

     Constant terms aren’t polynomializied unless the number one is a
     member of the variable list; for example

          (%i4) to_poly(x = sqrt(5),[x]);
          (%o4)                [[x - sqrt(5)], [], []]
          (%i5) to_poly(x = sqrt(5),[1,x]);
                                      2
          (%o5) [[x - %g132, 5 = %g132 ],
                                %pi                               %pi
                             [- --- < parg(%g132), parg(%g132) <= ---], []]
                                 2                                 2

     To generate a polynomial with sqrt(5) + sqrt(7) as one of its
     roots, use the commands

          (%i6) first(elim_allbut(first(to_poly(x = sqrt(5) + sqrt(7),
                                                [1,x])), [x]));
                                    4       2
          (%o6)                   [x  - 24 x  + 4]

     Related functions to_poly_solve

     To use ‘load("to_poly")’

     Status: The function ‘to_poly’ is experimental; its specifications
     might change and its functionality might be merged into other
     Maxima functions.

 -- Function: to_poly_solve (<e>, <l>, [options])

     The function ‘to_poly_solve’ tries to solve the equations e for the
     variables l.  The equation(s) e can either be a single expression
     or a set or list of expressions; similarly, l can either be a
     single symbol or a list of set of symbols.  When a member of e
     isn’t explicitly an equation, for example x^2 -1, the solver
     assumes that the expression vanishes.

     The basic strategy of ‘to_poly_solve’ is to convert the input into
     a polynomial form and to call ‘algsys’ on the polynomial system.
     Internally ‘to_poly_solve’ defaults ‘algexact’ to true.  To change
     the default for ‘algexact’, append ’algexact=false to the
     ‘to_poly_solve’ argument list.

     When ‘to_poly_solve’ is able to determine the solution set, each
     member of the solution set is a list in a ‘%union’ object:

          (%i1) load("to_poly_solve")$

          (%i2) to_poly_solve(x*(x-1) = 0, x);
          (%o2)               %union([x = 0], [x = 1])

     When ‘to_poly_solve’ is unable to determine the solution set, a
     ‘%solve’ nounform is returned (in this case, a warning is printed)

          (%i3) to_poly_solve(x^k + 2* x + 1 = 0, x);

          Nonalgebraic argument given to 'to_poly'
          unable to solve
                                    k
          (%o3)            %solve([x  + 2 x + 1 = 0], [x])

     Substitution into a ‘%solve’ nounform can sometimes result in the
     solution

          (%i4) subst(k = 2, %);
          (%o4)                   %union([x = - 1])

     Especially for trigonometric equations, the solver sometimes needs
     to introduce an arbitrary integer.  These arbitrary integers have
     the form ‘%zXXX’, where ‘XXX’ is an integer; for example

          (%i5) to_poly_solve(sin(x) = 0, x);
          (%o5)   %union([x = 2 %pi %z33 + %pi], [x = 2 %pi %z35])

     To re-index these variables to zero, use ‘nicedummies’:

          (%i6) nicedummies(%);
          (%o6)    %union([x = 2 %pi %z0 + %pi], [x = 2 %pi %z1])

     Occasionally, the solver introduces an arbitrary complex number of
     the form ‘%cXXX’ or an arbitrary real number of the form ‘%rXXX’.
     The function ‘nicedummies’ will re-index these identifiers to zero.

     The solution set sometimes involves simplifying versions of various
     of logical operators including ‘%and’, ‘%or’, or ‘%if’ for
     conjunction, disjunction, and implication, respectively; for
     example

          (%i7) sol : to_poly_solve(abs(x) = a, x);
          (%o7) %union(%if(isnonnegative_p(a), [x = - a], %union()),
                                %if(isnonnegative_p(a), [x = a], %union()))
          (%i8) subst(a = 42, sol);
          (%o8)             %union([x = - 42], [x = 42])
          (%i9) subst(a = -42, sol);
          (%o9)                       %union()

     The empty set is represented by ‘%union()’.

     The function ‘to_poly_solve’ is able to solve some, but not all,
     equations involving rational powers, some nonrational powers,
     absolute values, trigonometric functions, and minimum and maximum.
     Also, some it can solve some equations that are solvable in in
     terms of the Lambert W function; some examples:

          (%i1) load("to_poly_solve")$

          (%i2) to_poly_solve(set(max(x,y) = 5, x+y = 2), set(x,y));
          (%o2)      %union([x = - 3, y = 5], [x = 5, y = - 3])
          (%i3) to_poly_solve(abs(1-abs(1-x)) = 10,x);
          (%o3)             %union([x = - 10], [x = 12])
          (%i4) to_poly_solve(set(sqrt(x) + sqrt(y) = 5, x + y = 10),
                              set(x,y));
                               3/2               3/2
                              5    %i - 10      5    %i + 10
          (%o4) %union([x = - ------------, y = ------------],
                                   2                 2
                                          3/2                 3/2
                                         5    %i + 10        5    %i - 10
                                    [x = ------------, y = - ------------])
                                              2                   2
          (%i5) to_poly_solve(cos(x) * sin(x) = 1/2,x,
                              'simpfuncs = ['expand, 'nicedummies]);
                                                   %pi
          (%o5)              %union([x = %pi %z0 + ---])
                                                    4
          (%i6) to_poly_solve(x^(2*a) + x^a + 1,x);
                                                  2 %i %pi %z81
                                                  -------------
                                            1/a         a
                            (sqrt(3) %i - 1)    %e
          (%o6) %union([x = -----------------------------------],
                                            1/a
                                           2
                                                            2 %i %pi %z83
                                                            -------------
                                                      1/a         a
                                    (- sqrt(3) %i - 1)    %e
                               [x = -------------------------------------])
                                                     1/a
                                                    2
          (%i7) to_poly_solve(x * exp(x) = a, x);
          (%o7)              %union([x = lambert_w(a)])

     For linear inequalities, ‘to_poly_solve’ automatically does Fourier
     elimination:

          (%i8) to_poly_solve([x + y < 1, x - y >= 8], [x,y]);
                                         7
          (%o8) %union([x = y + 8, y < - -],
                                         2
                                                                        7
                                           [y + 8 < x, x < 1 - y, y < - -])
                                                                        2

     Each optional argument to ‘to_poly_solve’ must be an equation;
     generally, the order of these options does not matter.

        • ‘simpfuncs = l’, where ‘l’ is a list of functions.  Apply the
          composition of the members of l to each solution.

               (%i1) to_poly_solve(x^2=%i,x);
                                              1/4             1/4
               (%o1)       %union([x = - (- 1)   ], [x = (- 1)   ])
               (%i2) to_poly_solve(x^2= %i,x, 'simpfuncs = ['rectform]);
                                     %i         1             %i         1
               (%o2) %union([x = - ------- - -------], [x = ------- + -------])
                                   sqrt(2)   sqrt(2)        sqrt(2)   sqrt(2)

          Sometimes additional simplification can revert a
          simplification; for example

               (%i3) to_poly_solve(x^2=1,x);
               (%o3)              %union([x = - 1], [x = 1])
               (%i4) to_poly_solve(x^2= 1,x, 'simpfuncs = [polarform]);
                                                       %i %pi
               (%o4)            %union([x = 1], [x = %e      ]

          Maxima doesn’t try to check that each member of the function
          list ‘l’ is purely a simplification; thus

               (%i5) to_poly_solve(x^2 = %i,x, 'simpfuncs = [lambda([s],s^2)]);
               (%o5)                   %union([x = %i])

          To convert each solution to a double float, use ‘simpfunc =
          ['dfloat]’:

               (%i6) to_poly_solve(x^3 +x + 1 = 0,x,
                                   'simpfuncs = ['dfloat]), algexact : true;
               (%o6) %union([x = - .6823278038280178],
               [x = .3411639019140089 - 1.161541399997251 %i],
               [x = 1.161541399997251 %i + .3411639019140089])

        • ‘use_grobner = true’ With this option, the function
          ‘poly_reduced_grobner’ is applied to the equations before
          attempting their solution.  Primarily, this option provides a
          workaround for weakness in the function ‘algsys’.  Here is an
          example of such a workaround:

               (%i7) to_poly_solve([x^2+y^2=2^2,(x-1)^2+(y-1)^2=2^2],[x,y],
                                   'use_grobner = true);
                                   sqrt(7) - 1      sqrt(7) + 1
               (%o7) %union([x = - -----------, y = -----------],
                                        2                2
                                                sqrt(7) + 1        sqrt(7) - 1
                                           [x = -----------, y = - -----------])
                                                     2                  2
               (%i8) to_poly_solve([x^2+y^2=2^2,(x-1)^2+(y-1)^2=2^2],[x,y]);
               (%o8)                       %union()

        • ‘maxdepth = k’, where ‘k’ is a positive integer.  This
          function controls the maximum recursion depth for the solver.
          The default value for ‘maxdepth’ is five.  When the recursions
          depth is exceeded, the solver signals an error:

               (%i9) to_poly_solve(cos(x) = x,x, 'maxdepth = 2);

               Unable to solve
               Unable to solve
               (%o9)        %solve([cos(x) = x], [x], maxdepth = 2)

        • ‘parameters = l’, where ‘l’ is a list of symbols.  The solver
          attempts to return a solution that is valid for all members of
          the list ‘l’; for example:

               (%i10) to_poly_solve(a * x = x, x);
               (%o10)                   %union([x = 0])
               (%i11) to_poly_solve(a * x = x, x, 'parameters = [a]);
               (%o11) %union(%if(a - 1 = 0, [x = %c111], %union()),
                                              %if(a - 1 # 0, [x = 0], %union()))

          In ‘(%o2)’, the solver introduced a dummy variable; to
          re-index the these dummy variables, use the function
          ‘nicedummies’:

               (%i12) nicedummies(%);
               (%o12) %union(%if(a - 1 = 0, [x = %c0], %union()),
                                              %if(a - 1 # 0, [x = 0], %union()))

     The ‘to_poly_solve’ uses data stored in the hashed array
     ‘one_to_one_reduce’ to solve equations of the form f(a) = f(b).
     The assignment ‘one_to_one_reduce['f,'f] : lambda([a,b], a=b)’
     tells ‘to_poly_solve’ that the solution set of f(a) = f(b) equals
     the solution set of a=b; for example

          (%i13) one_to_one_reduce['f,'f] : lambda([a,b], a=b)$

          (%i14) to_poly_solve(f(x^2-1) = f(0),x);
          (%o14)             %union([x = - 1], [x = 1])

     More generally, the assignment ‘one_to_one_reduce['f,'g] :
     lambda([a,b], w(a, b) = 0’ tells ‘to_poly_solve’ that the solution
     set of f(a) = f(b) equals the solution set of w(a,b) = 0; for
     example

          (%i15) one_to_one_reduce['f,'g] : lambda([a,b], a = 1 + b/2)$

          (%i16) to_poly_solve(f(x) - g(x),x);
          (%o16)                   %union([x = 2])

     Additionally, the function ‘to_poly_solve’ uses data stored in the
     hashed array ‘function_inverse’ to solve equations of the form f(a)
     = b.  The assignment ‘function_inverse['f] : lambda([s], g(s))’
     informs ‘to_poly_solve’ that the solution set to ‘f(x) = b’ equals
     the solution set to ‘x = g(b)’; two examples:

          (%i17) function_inverse['Q] : lambda([s], P(s))$

          (%i18) to_poly_solve(Q(x-1) = 2009,x);
          (%o18)              %union([x = P(2009) + 1])
          (%i19) function_inverse['G] : lambda([s], s+new_variable(integer));
          (%o19)       lambda([s], s + new_variable(integer))
          (%i20) to_poly_solve(G(x - a) = b,x);
          (%o20)             %union([x = b + a + %z125])

     Notes

        • The solve variables needn’t be symbols; when ‘fullratsubst’ is
          able to appropriately make substitutions, the solve variables
          can be nonsymbols:

          (%i1) to_poly_solve([x^2 + y^2 + x * y = 5, x * y = 8],
                              [x^2 + y^2, x * y]);
                                            2    2
          (%o1)           %union([x y = 8, y  + x  = - 3])

        • For equations that involve complex conjugates, the solver
          automatically appends the conjugate equations; for example

          (%i1) declare(x,complex)$

          (%i2) to_poly_solve(x + (5 + %i) * conjugate(x) = 1, x);
                                             %i + 21
          (%o2)              %union([x = - -----------])
                                           25 %i - 125
          (%i3) declare(y,complex)$

          (%i4) to_poly_solve(set(conjugate(x) - y = 42 + %i,
                                  x + conjugate(y) = 0), set(x,y));
                                     %i - 42        %i + 42
          (%o4)        %union([x = - -------, y = - -------])
                                        2              2

        • For an equation that involves the absolute value function, the
          ‘to_poly_solve’ consults the fact database to decide if the
          argument to the absolute value is complex valued.  When

               (%i1) to_poly_solve(abs(x) = 6, x);
               (%o1)              %union([x = - 6], [x = 6])
               (%i2) declare(z,complex)$

               (%i3) to_poly_solve(abs(z) = 6, z);
               (%o3) %union(%if((%c11 # 0) %and (%c11 conjugate(%c11) - 36 =
                                                      0), [z = %c11], %union()))

          This is the only situation that the solver consults the fact
          database.  If a solve variable is declared to be an integer,
          for example, ‘to_poly_solve’ ignores this declaration.

     Relevant option variables algexact, resultant, algebraic

     Related functions to_poly

     To use ‘load("to_poly_solve")’

     Status: The function ‘to_poly_solve’ is experimental; its
     specifications might change and its functionality might be merged
     into other Maxima functions.

 -- Operator: %union (<soln_1>, <soln_2>, <soln_3>, ...)
 -- Operator: %union ()

     ‘%union(<soln_1>, <soln_2>, <soln_3>, ...)’ represents the union of
     its arguments, each of which represents a solution set, as
     determined by ‘to_poly_solve’.  ‘%union()’ represents the empty
     set.

     In many cases, a solution is a list of equations ‘[<x> = ..., <y> =
     ..., <z> = ...]’ where <x>, <y>, and <z> are one or more unknowns.
     In such cases, ‘to_poly_solve’ returns a ‘%union’ expression
     containing one or more such lists.

     The solution set sometimes involves simplifying versions of various
     of logical operators including ‘%and’, ‘%or’, or ‘%if’ for
     conjunction, disjunction, and implication, respectively.

     Examples:

     ‘%union(...)’ represents the union of its arguments, each of which
     represents a solution set, as determined by ‘to_poly_solve’.  In
     many cases, a solution is a list of equations.

          (%i1) load ("to_poly_solve") $
          (%i2) to_poly_solve ([sqrt(x^2 - y^2), x + y], [x, y]);
          (%o2)    %union([x = 0, y = 0], [x = %c13, y = - %c13])

     ‘%union()’ represents the empty set.

          (%i1) load ("to_poly_solve") $
          (%i2) to_poly_solve (abs(x) = -1, x);
          (%o2)                       %union()

     The solution set sometimes involves simplifying versions of various
     of logical operators.

          (%i1) load ("to_poly_solve") $
          (%i2) sol : to_poly_solve (abs(x) = a, x);
          (%o2) %union(%if(isnonnegative_p(a), [x = - a], %union()),
                                %if(isnonnegative_p(a), [x = a], %union()))
          (%i3) subst (a = 42, sol);
          (%o3)             %union([x = - 42], [x = 42])
          (%i4) subst (a = -42, sol);
          (%o4)                       %union()


File: maxima.info,  Node: unit-pkg,  Next: wrstcse-pkg,  Prev: to_poly_solve-pkg,  Up: Top

93 unit
*******

* Menu:

* Introduction to Units::
* Functions and Variables for Units::


File: maxima.info,  Node: Introduction to Units,  Next: Functions and Variables for Units,  Prev: unit-pkg,  Up: unit-pkg

93.1 Introduction to Units
==========================

The _unit_ package enables the user to convert between arbitrary units
and work with dimensions in equations.  The functioning of this package
is radically different from the original Maxima units package - whereas
the original was a basic list of definitions, this package uses rulesets
to allow the user to chose, on a per dimension basis, what unit final
answers should be rendered in.  It will separate units instead of
intermixing them in the display, allowing the user to readily identify
the units associated with a particular answer.  It will allow a user to
simplify an expression to its fundamental Base Units, as well as
providing fine control over simplifying to derived units.  Dimensional
analysis is possible, and a variety of tools are available to manage
conversion and simplification options.  In addition to customizable
automatic conversion, _units_ also provides a traditional manual
conversion option.

   Note - when unit conversions are inexact Maxima will make
approximations resulting in fractions.  This is a consequence of the
techniques used to simplify units.  The messages warning of this type of
substitution are disabled by default in the case of units (normally they
are on) since this situation occurs frequently and the warnings clutter
the output.  (The existing state of ratprint is restored after unit
conversions, so user changes to that setting will be preserved
otherwise.)  If the user needs this information for units, they can set
_unitverbose:on_ to reactivate the printing of warnings from the unit
conversion process.

   _unit_ is included in Maxima in the share/contrib/unit directory.  It
obeys normal Maxima package loading conventions:

     (%i1) load("unit")$
     *******************************************************************
     *                       Units version 0.50                        *
     *          Definitions based on the NIST Reference on             *
     *              Constants, Units, and Uncertainty                  *
     *       Conversion factors from various sources including         *
     *                   NIST and the GNU units package                *
     *******************************************************************

     Redefining necessary functions...
     WARNING: DEFUN/DEFMACRO: redefining function TOPLEVEL-MACSYMA-EVAL ...
     WARNING: DEFUN/DEFMACRO: redefining function MSETCHK ...
     WARNING: DEFUN/DEFMACRO: redefining function KILL1 ...
     WARNING: DEFUN/DEFMACRO: redefining function NFORMAT ...
     Initializing unit arrays...
     Done.

   The WARNING messages are expected and not a cause for concern - they
indicate the _unit_ package is redefining functions already defined in
Maxima proper.  This is necessary in order to properly handle units.
The user should be aware that if other changes have been made to these
functions by other packages those changes will be overwritten by this
loading process.

   The _unit.mac_ file also loads a lisp file _unit-functions.lisp_
which contains the lisp functions needed for the package.

   Clifford Yapp is the primary author.  He has received valuable
assistance from Barton Willis of the University of Nebraska at Kearney
(UNK), Robert Dodier, and other intrepid folk of the Maxima mailing
list.

   There are probably lots of bugs.  Let me know.  ‘float’ and ‘numer’
don’t do what is expected.

   TODO : dimension functionality, handling of temperature, showabbr and
friends.  Show examples with addition of quantities containing units.


File: maxima.info,  Node: Functions and Variables for Units,  Prev: Introduction to Units,  Up: unit-pkg

93.2 Functions and Variables for Units
======================================

 -- Function: setunits (<list>)
     By default, the _unit_ package does not use any derived dimensions,
     but will convert all units to the seven fundamental dimensions
     using MKS units.
          (%i2) N;
                                               kg m
          (%o2)                                ----
                                                 2
                                                s
          (%i3) dyn;
                                             1      kg m
          (%o3)                           (------) (----)
                                           100000     2
                                                     s
          (%i4) g;
                                              1
          (%o4)                             (----) (kg)
                                             1000
          (%i5) centigram*inch/minutes^2;
                                            127        kg m
          (%o5)                       (-------------) (----)
                                       1800000000000     2
                                                        s

     In some cases this is the desired behavior.  If the user wishes to
     use other units, this is achieved with the ‘setunits’ command:
          (%i6) setunits([centigram,inch,minute]);
          (%o6)                                done
          (%i7) N;
                                      1800000000000   %in cg
          (%o7)                      (-------------) (------)
                                           127            2
                                                      %min
          (%i8) dyn;
                                         18000000   %in cg
          (%o8)                         (--------) (------)
                                           127          2
                                                    %min
          (%i9) g;
          (%o9)                             (100) (cg)
          (%i10) centigram*inch/minutes^2;
                                              %in cg
          (%o10)                              ------
                                                  2
                                              %min

     The setting of units is quite flexible.  For example, if we want to
     get back to kilograms, meters, and seconds as defaults for those
     dimensions we can do:
          (%i11) setunits([kg,m,s]);
          (%o11)                               done
          (%i12) centigram*inch/minutes^2;
                                            127        kg m
          (%o12)                      (-------------) (----)
                                       1800000000000     2
                                                        s

     Derived units are also handled by this command:
          (%i17) setunits(N);
          (%o17)                               done
          (%i18) N;
          (%o18)                                 N
          (%i19) dyn;
                                              1
          (%o19)                           (------) (N)
                                            100000
          (%i20) kg*m/s^2;
          (%o20)                                 N
          (%i21) centigram*inch/minutes^2;
                                              127
          (%o21)                        (-------------) (N)
                                         1800000000000

     Notice that the _unit_ package recognized the non MKS combination
     of mass, length, and inverse time squared as a force, and converted
     it to Newtons.  This is how Maxima works in general.  If, for
     example, we prefer dyne to Newtons, we simply do the following:
          (%i22) setunits(dyn);
          (%o22)                               done
          (%i23) kg*m/s^2;
          (%o23)                          (100000) (dyn)
          (%i24) centigram*inch/minutes^2;
                                            127
          (%o24)                         (--------) (dyn)
                                          18000000

     To discontinue simplifying to any force, we use the uforget
     command:
          (%i26) uforget(dyn);
          (%o26)                               false
          (%i27) kg*m/s^2;
                                               kg m
          (%o27)                               ----
                                                 2
                                                s
          (%i28) centigram*inch/minutes^2;
                                            127        kg m
          (%o28)                      (-------------) (----)
                                       1800000000000     2
                                                        s
     This would have worked equally well with ‘uforget(N)’ or
     ‘uforget(%force)’.

     See also ‘uforget’.  To use this function write first
     ‘load("unit")’.

 -- Function: uforget (<list>)
     By default, the _unit_ package converts all units to the seven
     fundamental dimensions using MKS units.  This behavior can be
     changed with the ‘setunits’ command.  After that, the user can
     restore the default behavior for a particular dimension by means of
     the ‘uforget’ command:
          (%i13) setunits([centigram,inch,minute]);
          (%o13)                               done
          (%i14) centigram*inch/minutes^2;
                                              %in cg
          (%o14)                              ------
                                                  2
                                              %min
          (%i15) uforget([cg,%in,%min]);
          (%o15)                      [false, false, false]
          (%i16) centigram*inch/minutes^2;
                                            127        kg m
          (%o16)                      (-------------) (----)
                                       1800000000000     2
                                                        s

     ‘uforget’ operates on dimensions, not units, so any unit of a
     particular dimension will work.  The dimension itself is also a
     legal argument.

     See also ‘setunits’.  To use this function write first
     ‘load("unit")’.

 -- Function: convert (<expr>, <list>)
     When resetting the global environment is overkill, there is the
     ‘convert’ command, which allows one time conversions.  It can
     accept either a single argument or a list of units to use in
     conversion.  When a convert operation is done, the normal global
     evaluation system is bypassed, in order to avoid the desired result
     being converted again.  As a consequence, for inexact calculations
     "rat" warnings will be visible if the global environment
     controlling this behavior (‘ratprint’) is true.  This is also
     useful for spot-checking the accuracy of a global conversion.
     Another feature is ‘convert’ will allow a user to do Base Dimension
     conversions even if the global environment is set to simplify to a
     Derived Dimension.

          (%i2) kg*m/s^2;
                                               kg m
          (%o2)                                ----
                                                 2
                                                s
          (%i3) convert(kg*m/s^2,[g,km,s]);
                                               g km
          (%o3)                                ----
                                                 2
                                                s
          (%i4) convert(kg*m/s^2,[g,inch,minute]);

          `rat' replaced 39.37007874015748 by 5000/127 = 39.37007874015748
                                        18000000000   %in g
          (%o4)                        (-----------) (-----)
                                            127           2
                                                      %min
          (%i5) convert(kg*m/s^2,[N]);
          (%o5)                                  N
          (%i6) convert(kg*m^2/s^2,[N]);
          (%o6)                                 m N
          (%i7) setunits([N,J]);
          (%o7)                                done
          (%i8) convert(kg*m^2/s^2,[N]);
          (%o8)                                 m N
          (%i9) convert(kg*m^2/s^2,[N,inch]);

          `rat' replaced 39.37007874015748 by 5000/127 = 39.37007874015748
                                           5000
          (%o9)                           (----) (%in N)
                                           127
          (%i10) convert(kg*m^2/s^2,[J]);
          (%o10)                                 J
          (%i11) kg*m^2/s^2;
          (%o11)                                 J
          (%i12) setunits([g,inch,s]);
          (%o12)                               done
          (%i13) kg*m/s^2;
          (%o13)                                 N
          (%i14) uforget(N);
          (%o14)                               false
          (%i15) kg*m/s^2;
                                          5000000   %in g
          (%o15)                         (-------) (-----)
                                            127       2
                                                     s
          (%i16) convert(kg*m/s^2,[g,inch,s]);

          `rat' replaced 39.37007874015748 by 5000/127 = 39.37007874015748
                                          5000000   %in g
          (%o16)                         (-------) (-----)
                                            127       2
                                                     s

     See also ‘setunits’ and ‘uforget’.  To use this function write
     first ‘load("unit")’.

 -- Optional variable: usersetunits
     Default value: none

     If a user wishes to have a default unit behavior other than that
     described, they can make use of _maxima-init.mac_ and the
     _usersetunits_ variable.  The _unit_ package will check on startup
     to see if this variable has been assigned a list.  If it has, it
     will use setunits on that list and take the units from that list to
     be defaults.  ‘uforget’ will revert to the behavior defined by
     usersetunits over its own defaults.  For example, if we have a
     _maxima-init.mac_ file containing:
          usersetunits : [N,J];
     we would see the following behavior:
          (%i1) load("unit")$
          *******************************************************************
          *                       Units version 0.50                        *
          *          Definitions based on the NIST Reference on             *
          *              Constants, Units, and Uncertainty                  *
          *       Conversion factors from various sources including         *
          *                   NIST and the GNU units package                *
          *******************************************************************

          Redefining necessary functions...
          WARNING: DEFUN/DEFMACRO: redefining function
           TOPLEVEL-MACSYMA-EVAL ...
          WARNING: DEFUN/DEFMACRO: redefining function MSETCHK ...
          WARNING: DEFUN/DEFMACRO: redefining function KILL1 ...
          WARNING: DEFUN/DEFMACRO: redefining function NFORMAT ...
          Initializing unit arrays...
          Done.
          User defaults found...
          User defaults initialized.
          (%i2) kg*m/s^2;
          (%o2)                                  N
          (%i3) kg*m^2/s^2;
          (%o3)                                  J
          (%i4) kg*m^3/s^2;
          (%o4)                                 J m
          (%i5) kg*m*km/s^2;
          (%o5)                             (1000) (J)
          (%i6) setunits([dyn,eV]);
          (%o6)                                done
          (%i7) kg*m/s^2;
          (%o7)                           (100000) (dyn)
          (%i8) kg*m^2/s^2;
          (%o8)                     (6241509596477042688) (eV)
          (%i9) kg*m^3/s^2;
          (%o9)                    (6241509596477042688) (eV m)
          (%i10) kg*m*km/s^2;
          (%o10)                   (6241509596477042688000) (eV)
          (%i11) uforget([dyn,eV]);
          (%o11)                           [false, false]
          (%i12) kg*m/s^2;
          (%o12)                                 N
          (%i13) kg*m^2/s^2;
          (%o13)                                 J
          (%i14) kg*m^3/s^2;
          (%o14)                                J m
          (%i15) kg*m*km/s^2;
          (%o15)                            (1000) (J)
     Without ‘usersetunits’, the initial inputs would have been
     converted to MKS, and uforget would have resulted in a return to
     MKS rules.  Instead, the user preferences are respected in both
     cases.  Notice these can still be overridden if desired.  To
     completely eliminate this simplification - i.e.  to have the user
     defaults reset to factory defaults - the ‘dontusedimension’ command
     can be used.  ‘uforget’ can restore user settings again, but only
     if ‘usedimension’ frees it for use.  Alternately,
     ‘kill(usersetunits)’ will completely remove all knowledge of the
     user defaults from the session.  Here are some examples of how
     these various options work.
          (%i2) kg*m/s^2;
          (%o2)                                  N
          (%i3) kg*m^2/s^2;
          (%o3)                                  J
          (%i4) setunits([dyn,eV]);
          (%o4)                                done
          (%i5) kg*m/s^2;
          (%o5)                           (100000) (dyn)
          (%i6) kg*m^2/s^2;
          (%o6)                     (6241509596477042688) (eV)
          (%i7) uforget([dyn,eV]);
          (%o7)                          [false, false]
          (%i8) kg*m/s^2;
          (%o8)                                  N
          (%i9) kg*m^2/s^2;
          (%o9)                                  J
          (%i10) dontusedimension(N);
          (%o10)                             [%force]
          (%i11) dontusedimension(J);
          (%o11)                         [%energy, %force]
          (%i12) kg*m/s^2;
                                               kg m
          (%o12)                               ----
                                                 2
                                                s
          (%i13) kg*m^2/s^2;
                                                   2
                                               kg m
          (%o13)                               -----
                                                 2
                                                s
          (%i14) setunits([dyn,eV]);
          (%o14)                               done
          (%i15) kg*m/s^2;
                                               kg m
          (%o15)                               ----
                                                 2
                                                s
          (%i16) kg*m^2/s^2;
                                                   2
                                               kg m
          (%o16)                               -----
                                                 2
                                                s
          (%i17) uforget([dyn,eV]);
          (%o17)                         [false, false]
          (%i18) kg*m/s^2;
                                               kg m
          (%o18)                               ----
                                                 2
                                                s
          (%i19) kg*m^2/s^2;
                                                   2
                                               kg m
          (%o19)                               -----
                                                 2
                                                s
          (%i20) usedimension(N);
          Done.  To have Maxima simplify to this dimension, use
          setunits([unit]) to select a unit.
          (%o20)                               true
          (%i21) usedimension(J);
          Done.  To have Maxima simplify to this dimension, use
          setunits([unit]) to select a unit.
          (%o21)                               true
          (%i22) kg*m/s^2;
                                               kg m
          (%o22)                               ----
                                                 2
                                                s
          (%i23) kg*m^2/s^2;
                                                   2
                                               kg m
          (%o23)                               -----
                                                 2
                                                s
          (%i24) setunits([dyn,eV]);
          (%o24)                               done
          (%i25) kg*m/s^2;
          (%o25)                          (100000) (dyn)
          (%i26) kg*m^2/s^2;
          (%o26)                    (6241509596477042688) (eV)
          (%i27) uforget([dyn,eV]);
          (%o27)                           [false, false]
          (%i28) kg*m/s^2;
          (%o28)                                 N
          (%i29) kg*m^2/s^2;
          (%o29)                                 J
          (%i30) kill(usersetunits);
          (%o30)                               done
          (%i31) uforget([dyn,eV]);
          (%o31)                          [false, false]
          (%i32) kg*m/s^2;
                                               kg m
          (%o32)                               ----
                                                 2
                                                s
          (%i33) kg*m^2/s^2;
                                                   2
                                               kg m
          (%o33)                               -----
                                                 2
                                                s
     Unfortunately this wide variety of options is a little confusing at
     first, but once the user grows used to them they should find they
     have very full control over their working environment.

 -- Function: metricexpandall (<x>)
     Rebuilds global unit lists automatically creating all desired
     metric units.  <x> is a numerical argument which is used to specify
     how many metric prefixes the user wishes defined.  The arguments
     are as follows, with each higher number defining all lower numbers’
     units:
                     0 - none. Only base units
                     1 - kilo, centi, milli
          (default)  2 - giga, mega, kilo, hecto, deka, deci, centi, milli,
                         micro, nano
                     3 - peta, tera, giga, mega, kilo, hecto, deka, deci,
                         centi, milli, micro, nano, pico, femto
                     4 - all
     Normally, Maxima will not define the full expansion since this
     results in a very large number of units, but ‘metricexpandall’ can
     be used to rebuild the list in a more or less complete fashion.
     The relevant variable in the _unit.mac_ file is <%unitexpand>.

 -- Variable: %unitexpand
     Default value: ‘2’

     This is the value supplied to ‘metricexpandall’ during the initial
     loading of _unit_.


File: maxima.info,  Node: wrstcse-pkg,  Next: zeilberger-pkg,  Prev: unit-pkg,  Up: Top

94 wrstcse
**********

* Menu:

* Introduction to wrstcse::
* Functions and Variables for wrstcse::


File: maxima.info,  Node: Introduction to wrstcse,  Next: Functions and Variables for wrstcse,  Prev: wrstcse-pkg,  Up: wrstcse-pkg

94.1 Introduction to wrstcse
============================

‘wrstcse’ is a naive go at interval arithmetics is powerful enough to
perform worst case calculations that appear in engineering by applying
all combinations of tolerances to all parameters.

   This approach isn’t guaranteed to find the exact combination of
parameters that results in the worst-case.  But it avoids the problems
that make a true interval arithmetics affected by the halting problem as
an equation can have an infinite number of local minima and maxima and
it might be impossible to algorithmically determine which one is the
global one.

   Tolerances are applied to parameters by providing the parameter with
a <tol[n]> that wrstcase will vary between -1 and 1.  Using the same <n>
for two parameters will make both parameters tolerate in the same way.

   ‘load ("wrstcse")’ loads this package.


File: maxima.info,  Node: Functions and Variables for wrstcse,  Prev: Introduction to wrstcse,  Up: wrstcse-pkg

94.2 Functions and Variables for wrstcse
========================================

 -- Function: wc_typicalvalues (<expression>, [<num>])

     Returns what happens if all tolerances (that are represented by tol
     [n] that can vary from 0 to 1) happen to be 0.

     Example:
          (%i1) load("wrstcse")$
          (%i2) vals: [
             R_1= 1000.0*(1+tol[1]*.01),
             R_2= 2000.0*(1+tol[2]*.01)
           ];
          (%o2) [R_1 = 1000.0 (0.01 tol  + 1),
                                       1
                                              R_2 = 2000.0 (0.01 tol  + 1)]
                                                                    2
          (%i3) divider:U_Out=U_In*R_1/(R_1+R_2);
                                          R_1 U_In
          (%o3)                   U_Out = ---------
                                          R_2 + R_1
          (%i4) wc_typicalvalues(vals);
          (%o4)             [R_1 = 1000.0, R_2 = 2000.0]
          (%i5) wc_typicalvalues(subst(vals,divider));
          (%o5)            U_Out = 0.3333333333333333 U_In

 -- Function: wc_inputvalueranges (<expression>, [<num>])

     Convenience function: Displays a list which parameter can vary
     between which values.

     Example:
          (%i1) load("wrstcse")$
          (%i2) vals: [
             R_1= 1000.0*(1+tol[1]*.01),
             R_2= 2000.0*(1+tol[2]*.01)
           ];
          (%o2) [R_1 = 1000.0 (0.01 tol  + 1),
                                       1
                                              R_2 = 2000.0 (0.01 tol  + 1)]
                                                                    2
          (%i3) wc_inputvalueranges(vals);
                  [ R_1  min = 990.0   typ = 1000.0  max = 1010.0 ]
          (%o3)   [                                               ]
                  [ R_2  min = 1980.0  typ = 2000.0  max = 2020.0 ]

 -- Function: wc_systematic (<expression>, [<num>])

     Systematically introduces <num> values per parameter into
     <expression> and returns a list of the result.  If no <num> is
     given, <num> defaults to 3.

     See also ‘wc_montecarlo’.

     Example:
          (%i1) load("wrstcse")$
          (%i2) vals: [
             R_1= 1000.0*(1+tol[1]*.01),
             R_2= 2000.0*(1+tol[2]*.01)
           ];
          (%o2) [R_1 = 1000.0 (0.01 tol  + 1),
                                       1
                                              R_2 = 2000.0 (0.01 tol  + 1)]
                                                                    2
          (%i3) divider: U_Out=U_In*(R_1)/(R_1+R_2);
                                          R_1 U_In
          (%o3)                   U_Out = ---------
                                          R_2 + R_1
          (%i4) wc_systematic(subst(vals,rhs(divider)));
          (%o4) [0.3333333333333334 U_In, 0.3311036789297659 U_In,
          0.3289036544850498 U_In, 0.3355704697986577 U_In,
          0.3333333333333333 U_In, 0.3311258278145696 U_In,
          0.3377926421404682 U_In, 0.3355481727574751 U_In,
          0.3333333333333333 U_In]

 -- Function: wc_montecarlo (<expression>, <num>)

     Introduces <num> random values per parameter into <expression> and
     returns a list of the result.

     See also ‘wc_systematic’.

     Example:
          (%i1) load("wrstcse")$
          (%i2) vals: [
             R_1= 1000.0*(1+tol[1]*.01),
             R_2= 2000.0*(1+tol[2]*.01)
           ];
          (%o2) [R_1 = 1000.0 (0.01 tol  + 1),
                                       1
                                              R_2 = 2000.0 (0.01 tol  + 1)]
                                                                    2
          (%i3) divider: U_Out=U_In*(R_1)/(R_1+R_2);
                                          R_1 U_In
          (%o3)                   U_Out = ---------
                                          R_2 + R_1
          (%i4) wc_montecarlo(subst(vals,rhs(divider)),10);
          (%o4) [0.3365488313167528 U_In, 0.3339089445851889 U_In,
          0.314651402884122 U_In, 0.3447359711624277 U_In,
          0.3294005710066001 U_In, 0.3330897542463686 U_In,
          0.3397591863729343 U_In, 0.3227030530673181 U_In,
          0.3385512773502185 U_In, 0.314764470912582 U_In]

 -- Function: wc_mintypmax (<expr>, [<n>])

     Prints the minimum, maximum and typical value of <expr>.  If <n> is
     positive, <n> values for each parameter will be tried
     systematically.  If <n> is negative, <-n> random values are used
     instead.  If no <n> is given, 3 is assumed.

     Example:
          (%i1) load("wrstcse")$
          (%i2) ratprint:false$
          (%i3) vals: [
             R_1= 1000.0*(1+tol[1]*.01),
             R_2= 1000.0*(1+tol[2]*.01)
           ];
          (%o3) [R_1 = 1000.0 (0.01 tol  + 1),
                                       1
                                              R_2 = 1000.0 (0.01 tol  + 1)]
                                                                    2
          (%i4) assume(U_In>0);
          (%o4)                      [U_In > 0]
          (%i5) divider:U_Out=U_In*R_1/(R_1+R_2);
                                          R_1 U_In
          (%o5)                   U_Out = ---------
                                          R_2 + R_1
          (%i6) lhs(divider)=wc_mintypmax(subst(vals,rhs(divider)));
          (%o6) U_Out = [min = 0.495 U_In, typ = 0.5 U_In,
                                                          max = 0.505 U_In]

 -- Function: wc_tolappend (<list>)

     Appends two list of parameters with tolerances renumbering the
     tolerances of both lists so they don’t coincide.

     Example:
          (%i1) load("wrstcse")$
          (%i2) val_a: [
             R_1= 1000.0*(1+tol[1]*.01),
             R_2= 1000.0*(1+tol[2]*.01)
           ];
          (%o2) [R_1 = 1000.0 (0.01 tol  + 1),
                                       1
                                              R_2 = 1000.0 (0.01 tol  + 1)]
                                                                    2
          (%i3) val_b: [
             R_3= 1000.0*(1+tol[1]*.01),
             R_4= 1000.0*(1+tol[2]*.01)
           ];
          (%o3) [R_3 = 1000.0 (0.01 tol  + 1),
                                       1
                                              R_4 = 1000.0 (0.01 tol  + 1)]
                                                                    2
          (%i4) wc_tolappend(val_a,val_b);
          (%o4) [R_1 = 1000.0 (0.01 tol  + 1),
                                       2
          R_2 = 1000.0 (0.01 tol  + 1), R_3 = 1000.0 (0.01 tol  + 1),
                                1                             4
          R_4 = 1000.0 (0.01 tol  + 1)]
                                3

 -- Function: wc_mintypmax2tol (<tolname>, <minval>, <typval>, <maxval>)

     Generates a parameter that uses the tolerance <tolname> that
     tolerates between the given values.

     Example:
          (%i1) load("wrstcse")$
          (%i2) V_F: U_Diode=wc_mintypmax2tol(tol[1],.5,.75,.82);
                                                    2
          (%o2) U_Diode = (- 0.09000000000000002 tol ) + 0.16 tol  + 0.75
                                                    1            1
          (%i3) lhs(V_F)=wc_mintypmax(rhs(V_F));
          (%o3) U_Diode = [min = 0.5, typ = 0.75, max = 0.8199999999999998]


File: maxima.info,  Node: zeilberger-pkg,  Next: Error and warning messages,  Prev: wrstcse-pkg,  Up: Top

95 zeilberger
*************

* Menu:

* Introduction to zeilberger::
* Functions and Variables for zeilberger::


File: maxima.info,  Node: Introduction to zeilberger,  Next: Functions and Variables for zeilberger,  Prev: zeilberger-pkg,  Up: zeilberger-pkg

95.1 Introduction to zeilberger
===============================

‘zeilberger’ is an implementation of Zeilberger’s algorithm for definite
hypergeometric summation, and also Gosper’s algorithm for indefinite
hypergeometric summation.

   ‘zeilberger’ makes use of the "filtering" optimization method
developed by Axel Riese.

   ‘zeilberger’ was developed by Fabrizio Caruso.

   ‘load ("zeilberger")’ loads this package.

95.1.1 The indefinite summation problem
---------------------------------------

‘zeilberger’ implements Gosper’s algorithm for indefinite hypergeometric
summation.  Given a hypergeometric term F_k in k we want to find its
hypergeometric anti-difference, that is, a hypergeometric term f_k such
that

   F_k = f_(k+1) - f_k.

95.1.2 The definite summation problem
-------------------------------------

‘zeilberger’ implements Zeilberger’s algorithm for definite
hypergeometric summation.  Given a proper hypergeometric term (in n and
k) F_(n,k) and a positive integer d we want to find a d-th order linear
recurrence with polynomial coefficients (in n) for F_(n,k) and a
rational function R in n and k such that

   a_0 F_(n,k) + ... + a_d F_(n+d,k) = Delta_k(R(n,k) F_(n,k)),

   where Delta_k is the k-forward difference operator, i.e.,
Delta_k(t_k) := t_(k+1) - t_k.

95.1.3 Verbosity levels
-----------------------

There are also verbose versions of the commands which are called by
adding one of the following prefixes:

‘Summary’
     Just a summary at the end is shown
‘Verbose’
     Some information in the intermediate steps
‘VeryVerbose’
     More information
‘Extra’
     Even more information including information on the linear system in
     Zeilberger’s algorithm

   For example:
‘GosperVerbose’, ‘parGosperVeryVerbose’, ‘ZeilbergerExtra’,
‘AntiDifferenceSummary’.


File: maxima.info,  Node: Functions and Variables for zeilberger,  Prev: Introduction to zeilberger,  Up: zeilberger-pkg

95.2 Functions and Variables for zeilberger
===========================================

 -- Function: AntiDifference (F_k, <k>)

     Returns the hypergeometric anti-difference of F_k, if it exists.
     Otherwise ‘AntiDifference’ returns ‘no_hyp_antidifference’.

 -- Function: Gosper (F_k, <k>)
     Returns the rational certificate R(k) for F_k, that is, a rational
     function such that F_k = R(k+1) F_(k+1) - R(k) F_k, if it exists.
     Otherwise, ‘Gosper’ returns ‘no_hyp_sol’.

 -- Function: GosperSum (F_k, <k>, <a>, <b>)

     Returns the summation of F_k from <k> = <a> to <k> = <b> if F_k has
     a hypergeometric anti-difference.  Otherwise, ‘GosperSum’ returns
     ‘nongosper_summable’.

     Examples:

          (%i1) load ("zeilberger")$
          (%i2) GosperSum ((-1)^k*k / (4*k^2 - 1), k, 1, n);
          Dependent equations eliminated:  (1)
                                     3       n + 1
                                (n + -) (- 1)
                                     2               1
          (%o2)               - ------------------ - -
                                            2        4
                                2 (4 (n + 1)  - 1)
          (%i3) GosperSum (1 / (4*k^2 - 1), k, 1, n);
                                          3
                                    - n - -
                                          2       1
          (%o3)                  -------------- + -
                                          2       2
                                 4 (n + 1)  - 1
          (%i4) GosperSum (x^k, k, 1, n);
                                    n + 1
                                   x          x
          (%o4)                    ------ - -----
                                   x - 1    x - 1
          (%i5) GosperSum ((-1)^k*a! / (k!*(a - k)!), k, 1, n);
                                          n + 1
                          a! (n + 1) (- 1)              a!
          (%o5)       - ------------------------- - ----------
                        a (- n + a - 1)! (n + 1)!   a (a - 1)!
          (%i6) GosperSum (k*k!, k, 1, n);
          Dependent equations eliminated:  (1)
          (%o6)                     (n + 1)! - 1
          (%i7) GosperSum ((k + 1)*k! / (k + 1)!, k, 1, n);
                            (n + 1) (n + 2) (n + 1)!
          (%o7)             ------------------------ - 1
                                    (n + 2)!
          (%i8) GosperSum (1 / ((a - k)!*k!), k, 1, n);
          (%o8)                  NON_GOSPER_SUMMABLE

 -- Function: parGosper (F_(n,k), <k>, <n>, <d>)

     Attempts to find a <d>-th order recurrence for F_(n,k).

     The algorithm yields a sequence [s_1, s_2, ..., s_m] of solutions.
     Each solution has the form

     [R(n, k), [a_0, a_1, ..., a_d]].

     ‘parGosper’ returns ‘[]’ if it fails to find a recurrence.

 -- Function: Zeilberger (F_(n,k), <k>, <n>)

     Attempts to compute the indefinite hypergeometric summation of
     F_(n,k).

     ‘Zeilberger’ first invokes ‘Gosper’, and if that fails to find a
     solution, then invokes ‘parGosper’ with order 1, 2, 3, ..., up to
     ‘MAX_ORD’.  If Zeilberger finds a solution before reaching
     ‘MAX_ORD’, it stops and returns the solution.

     The algorithms yields a sequence [s_1, s_2, ..., s_m] of solutions.
     Each solution has the form

     [R(n,k), [a_0, a_1, ..., a_d]].

     ‘Zeilberger’ returns ‘[]’ if it fails to find a solution.

     ‘Zeilberger’ invokes ‘Gosper’ only if ‘Gosper_in_Zeilberger’ is
     ‘true’.

95.3 General global variables
=============================

 -- Global variable: MAX_ORD
     Default value: 5

     ‘MAX_ORD’ is the maximum recurrence order attempted by
     ‘Zeilberger’.

 -- Global variable: simplified_output
     Default value: ‘false’

     When ‘simplified_output’ is ‘true’, functions in the ‘zeilberger’
     package attempt further simplification of the solution.

 -- Global variable: linear_solver
     Default value: ‘linsolve’

     ‘linear_solver’ names the solver which is used to solve the system
     of equations in Zeilberger’s algorithm.

 -- Global variable: warnings
     Default value: ‘true’

     When ‘warnings’ is ‘true’, functions in the ‘zeilberger’ package
     print warning messages during execution.

 -- Global variable: Gosper_in_Zeilberger
     Default value: ‘true’

     When ‘Gosper_in_Zeilberger’ is ‘true’, the ‘Zeilberger’ function
     calls ‘Gosper’ before calling ‘parGosper’.  Otherwise, ‘Zeilberger’
     goes immediately to ‘parGosper’.

 -- Global variable: trivial_solutions
     Default value: ‘true’

     When ‘trivial_solutions’ is ‘true’, ‘Zeilberger’ returns solutions
     which have certificate equal to zero, or all coefficients equal to
     zero.

95.4 Variables related to the modular test
==========================================

 -- Global variable: mod_test
     Default value: ‘false’

     When ‘mod_test’ is ‘true’, ‘parGosper’ executes a modular test for
     discarding systems with no solutions.

 -- Global variable: modular_linear_solver
     Default value: ‘linsolve’

     ‘modular_linear_solver’ names the linear solver used by the modular
     test in ‘parGosper’.

 -- Global variable: ev_point
     Default value: ‘big_primes[10]’

     ‘ev_point’ is the value at which the variable <n> is evaluated when
     executing the modular test in ‘parGosper’.

 -- Global variable: mod_big_prime
     Default value: ‘big_primes[1]’

     ‘mod_big_prime’ is the modulus used by the modular test in
     ‘parGosper’.

 -- Global variable: mod_threshold
     Default value: 4

     ‘mod_threshold’ is the greatest order for which the modular test in
     ‘parGosper’ is attempted.


File: maxima.info,  Node: trigtools-pkg,  Next: Error and warning messages,  Prev: zeilberger-pkg,  Up: Top

96 trigtools
************

* Menu:

* Introduction to trigtools::
* Functions and Variables for trigtools::
* References::


File: maxima.info,  Node: Introduction to trigtools,  Next: Functions and Variables for trigtools,  Prev: trigtools-pkg,  Up: trigtools-pkg

                           Trigtools Package
                           *****************


                           Aleksas Dormarkas
                        <aleksasd873@gmail.com>
                     <aleksas.domarkas@mif.vu.lt>
                           December 1, 2013

96.1 Introduction to trigtools
==============================

We use open-source computer algebra system(CAS) maxima 5.31.2.  The
trigtools package(1) contains commands that help you work with
trigonometric expessions.  List of functions in trigtools package:

   • ‘c2sin’
   • ‘c2cos’
   • ‘c2trig’
   • ‘c2hyp’
   • ‘trigfactor’
   • ‘trigsolve’
   • ‘trigvalue’
   • ‘trigeval’
   • ‘atan_contract’

   ---------- Footnotes ----------

   (1) This is a conversion by hand of the original “trigtools-doc.pdf”
file in “share/contrib/trigtools”, by Raymond Toy.  See the pdf for the
definitive version.


File: maxima.info,  Node: Functions and Variables for trigtools,  Next: References,  Prev: Introduction to trigtools,  Up: trigtools-pkg

96.2 Functions and Variables for trigtools
==========================================

* Menu:

* Convert to sin and cos::
* Convert to Trignometric Functions::
* Convert to Hyperbolic Functions::
* Factor Sums of sin and cos Functions::
* Solve Trignometric Equations::
* Evaluation of Trignometric Functions::
* Contract atan Functions::


File: maxima.info,  Node: Convert to sin and cos,  Next: Convert to Trignometric Functions,  Prev: Functions and Variables for trigtools,  Up: Functions and Variables for trigtools

96.2.1 Convert to sin and cos
-----------------------------

 -- Function: c2sin (<x>)
 -- Function: c2cos (<x>)
     The function c2sin converts the expression a*cos(x)+b*sin(x) to 
     r*sin(x+phi).

     The function c2cos converts the expression a*cos(x)+b*sin(x) to 
     r*cos(x-phi).

     Examples:
          (%i1) load("trigtools")$
          (%i2) c2sin(3*sin(x)+4*cos(x));
                                                      4
          (%o2)                        5 sin(x + atan(-))
                                                      3
          (%i3) trigexpand(%),expand;
          (%o3)                        3 sin(x) + 4 cos(x)

          (%i4) c2cos(3*sin(x)-4*cos(x));
                                                       3
          (%o4)                       - 5 cos(x + atan(-))
                                                       4
          (%i5) trigexpand(%),expand;
          (%o5)                        3 sin(x) - 4 cos(x)
          (%i6) c2sin(sin(x)+cos(x));
                                                      %pi
          (%o6)                       sqrt(2) sin(x + ---)
                                                       4
          (%i7) trigexpand(%),expand;
          (%o7)                          sin(x) + cos(x)
          (%i8) c2cos(sin(x)+cos(x));
                                                      %pi
          (%o8)                       sqrt(2) cos(x - ---)
                                                       4
          (%i9) trigexpand(%),expand;
          (%o9)                          sin(x) + cos(x)

     Example.  Solve trigonometric equation

          (%i10) eq:3*sin(x)+4*cos(x)=2;
          (%o10)                      3 sin(x) + 4 cos(x) = 2

          (%i11) plot2d([3*sin(x)+4*cos(x),2],[x,-%pi,%pi]);

            [image src="figures/trigtools-1.png" alt="plot1" ]

          (%i12) eq1:c2sin(lhs(eq))=2;
                                                     4
          (%o35)                      5 sin(x + atan(-)) = 2
                                                     3
          (%i13) solvetrigwarn:false$
          (%i14) solve(eq1)[1]$ x1:rhs(%);
                                              2         4
          (%o15)                         asin(-) - atan(-)
                                              5         3
          (%i16) float(%), numer;
          (%o39)                       - 0.5157783719341241
          (%i17) eq2:c2cos(lhs(eq))=2;
                                                     3
          (%o17)                      5 cos(x - atan(-)) = 2
          (%i18) solve(eq2,x)[1]$ x2:rhs(%);
                                              3         2
          (%o19)                         atan(-) + acos(-)
                                              4         5
          (%i20) float(%), numer;
          (%o20)                         1.802780589520693

          (%i21) sol:[x1,x2];
                                    2         4        3         2
          (%o44)              [asin(-) - atan(-), atan(-) + acos(-)]
                                    5         3        4         5

     Answ.: x = x1 + 2*%pi*k,  x1 = asin(2/5)-atan(4/3), or  x1 =
     atan(3/4)+acos(2/5), for k any integer.


File: maxima.info,  Node: Convert to Trignometric Functions,  Next: Convert to Hyperbolic Functions,  Prev: Convert to sin and cos,  Up: Functions and Variables for trigtools

96.2.2 Convert to Trignometric Functions
----------------------------------------

 -- Function: c2trig (<x>)
     The function c2trig (convert to trigonometric) reduce expression
     with hyperbolic functions sinh, cosh, tanh, coth to trigonometric
     expression with sin, cos, tan, cot.

     Examples:

       1.  
               (%i1) load(trigtools)$
               (%i2) sinh(x)=c2trig(sinh(x));
               cosh(x)=c2trig(cosh(x));
               tanh(x)=c2trig(tanh(x));
               coth(x)=c2trig(coth(x));
               (%o2)                     sinh(x) = - %i sin(%i x)
               (%o3)                        cosh(x) = cos(%i x)
               (%o4)                     tanh(x) = - %i tan(%i x)
               (%o5)                      coth(x) = %i cot(%i x)

       2. see
          <http://www.math.utexas.edu/pipermail/maxima/2013/034585.html>
               (%i6) cos(p+q*%i);
               (%o6)                           cos(%i q + p)
               (%i7) trigexpand(%);
               (%o7)                cos(p) cosh(q) - %i sin(p) sinh(q)
               (%i8) c2trig(%);
               (%o8)                           cos(%i q + p)

       3.  
               (%i9) sin(a+b*%i);
               (%o9)                           sin(%i b + a)
               (%i10) trigexpand(%);
               (%o10)                %i cos(a) sinh(b) + sin(a) cosh(b)
               (%i11) c2trig(%);
               (%o11)                           sin(%i b + a)

       4.  
               (%i12) cos(a*%i+b*%i);
               (%o12)                         cos(%i b + %i a)
               (%i13) trigexpand(%);
               (%o13)                 sinh(a) sinh(b) + cosh(a) cosh(b)
               (%i14) c2trig(%);
               (%o14)                         cos(%i b + %i a)

       5.  
               (%i15) tan(a+%i*b);
               (%o15)                           tan(%i b + a)
               (%i16) trigexpand(%);
                                             %i tanh(b) + tan(a)
               (%o16)                       ---------------------
                                            1 - %i tan(a) tanh(b)
               (%i17) c2trig(%);
               (%o217)                           tan(%i b + a)

       6.  

               (%i18) cot(x+%i*y);
               (%o18)                           cot(%i y + x)
               (%i19) trigexpand(%);
                                          (- %i cot(x) coth(y)) - 1
               (%o19)                     -------------------------
                                             cot(x) - %i coth(y)
               (%i20) c2trig(%);
               (%o20)                           cot(%i y + x)


File: maxima.info,  Node: Convert to Hyperbolic Functions,  Next: Factor Sums of sin and cos Functions,  Prev: Convert to Trignometric Functions,  Up: Functions and Variables for trigtools

96.2.3 Convert to Hyperbolic Functions
--------------------------------------

 -- Function: c2hyp (<x>)
     The function c2hyp (convert to hyperbolic) convert expression with
     exp function to expression with hyperbolic functions sinh, cosh.

     Examples:

          (%i6) c2hyp(exp(x));
          (%o6)                         sinh(x) + cosh(x)
          (%i7) c2hyp(exp(x)+exp(x^2)+1);
                                 2          2
          (%o7)            sinh(x ) + cosh(x ) + sinh(x) + cosh(x) + 1
          (%i8) c2hyp(exp(x)/(2*exp(y)-3*exp(z)));
                                        sinh(x) + cosh(x)
          (%o8)           ---------------------------------------------
                          2 (sinh(y) + cosh(y)) - 3 (sinh(z) + cosh(z))


File: maxima.info,  Node: Factor Sums of sin and cos Functions,  Next: Solve Trignometric Equations,  Prev: Convert to Hyperbolic Functions,  Up: Functions and Variables for trigtools

96.2.4 Factor Sums of sin and cos Functions
-------------------------------------------

 -- Function: trigfactor (<x>)
     The function trigfactor factors expresions of form
     +-sin(x)+-cos(y).

     Examples:

       1.  
               (%i2) trigfactor(sin(x)+cos(x));
                                                           %pi
               (%o2)                       sqrt(2) cos(x - ---)
                                                            4
               (%i3) trigrat(%);
               (%o3)                          sin(x) + cos(x)

       2.  
               (%i4) trigfactor(sin(x)+cos(y));
                                          y   x   %pi      y   x   %pi
               (%o4)                2 cos(- - - + ---) cos(- + - - ---)
                                          2   2    4       2   2    4
               (%i5) trigrat(%);
               (%o5)                          cos(y) + sin(x)

       3.  
               (%i6) trigfactor(sin(x)-cos(3*y));
                                        3 y   x   %pi      3 y   x   %pi
               (%o6)              2 sin(--- - - + ---) sin(--- + - - ---)
                                         2    2    4        2    2    4
               (%i7) trigrat(%);
               (%o7)                         sin(x) - cos(3 y)

       4.  
               (%i8) trigfactor(-sin(5*x)-cos(3*y));
                                       3 y   5 x   %pi      3 y   5 x   %pi
               (%o8)           - 2 cos(--- - --- + ---) cos(--- + --- - ---)
                                        2     2     4        2     2     4
               (%i9) trigrat(%);
               (%o9)                      (- cos(3 y)) - sin(5 x)

       5.  
               (%i10) sin(alpha)+sin(beta)=trigfactor(sin(alpha)+sin(beta));
                                                      beta   alpha      beta   alpha
               (%o10)  sin(beta) + sin(alpha) = 2 cos(---- - -----) sin(---- + -----)
                                                       2       2         2       2
               (%i11) trigrat(%);
               (%o78)          sin(beta) + sin(alpha) = sin(beta) + sin(alpha)

       6.  
               (%i12) sin(alpha)-sin(beta)=trigfactor(sin(alpha)-sin(beta));
                                                       beta   alpha      beta   alpha
               (%o12) sin(alpha) - sin(beta) = - 2 sin(---- - -----) cos(---- + -----)
                                                        2       2         2       2

       7.  
               (%i13) cos(alpha)+cos(beta)=trigfactor(cos(alpha)+cos(beta));
                                                      beta   alpha      beta   alpha
               (%o80)  cos(beta) + cos(alpha) = 2 cos(---- - -----) cos(---- + -----)
                                                       2       2         2       2

       8.  
               (%i14) cos(alpha)-cos(beta)=trigfactor(cos(alpha)-cos(beta));
                                                      beta   alpha      beta   alpha
               (%o14)  cos(alpha) - cos(beta) = 2 sin(---- - -----) sin(---- + -----)
                                                       2       2         2       2

       9.  
               (%i15) trigfactor(3*sin(x)+7*cos(x));
               (%o15)                        3 sin(x) + 7 cos(x)
               (%i16) c2sin(%);
                                                                7
               (%o16)                     sqrt(58) sin(x + atan(-))
                                                                3
               (%i17) trigexpand(%),expand;
               (%o17)                        3 sin(x) + 7 cos(x)

          10.
               (%i18) trigfactor(sin(2*x));
               (%o18)                             sin(2 x)
               (%i19) trigexpand(%);
               (%o19)                          2 cos(x) sin(x)


File: maxima.info,  Node: Solve Trignometric Equations,  Next: Evaluation of Trignometric Functions,  Prev: Factor Sums of sin and cos Functions,  Up: Functions and Variables for trigtools

96.2.5 Solve Trignometric Equations
-----------------------------------

 -- Function: trigsolve (<x>)
     The function trigsolve find solutions of trigonometric equation
     from interval [a, b) .

     Examples:
       1.  
               (%i38) eq:eq:3*sin(x)+4*cos(x)=2;
               (%o38)                      3 sin(x) + 4 cos(x) = 2

               (%i39) plot2d([3*sin(x)+4*cos(x),2],[x,-%pi,%pi]);

            [image src="figures/trigtools-2.png" alt="plot2" ]

               (%o39)
               (%i40) sol:trigsolve(eq,-%pi,%pi);
                                 2 sqrt(21)   12              2 sqrt(21)   12
               (%o40)      {atan(---------- - --), %pi - atan(---------- + --)}
                                     5        5                   5        5
               (%i41) float(%), numer;
               (%o41)            {- 0.5157783719341241, 1.802780589520693}

          Answ.  : x = atan((2*sqrt(21))/5-12/5)+2*%pi*k ; 
          x=%pi-atan((2*sqrt(21))/5+12/5)+2*%pi*k, k – any integer.

       2.  
               (%i6) eq:cos(3*x)-sin(x)=sqrt(3)*(cos(x)-sin(3*x));
               (%o6)         cos(3 x) - sin(x) = sqrt(3) (cos(x) - sin(3 x))
               (%i7) plot2d([lhs(eq)-rhs(eq)], [x,0,2*%pi])$

            [image src="figures/trigtools-3.png" alt="plot3" ]


          We have 6 solutions from [0, 2*pi].
               (%i8) plot2d([lhs(eq)-rhs(eq)], [x,0.2,0.5]);

            [image src="figures/trigtools-4.png" alt="plot4" ]

               (%i9) plot2d([lhs(eq)-rhs(eq)], [x,3.3,3.6]);

            [image src="figures/trigtools-5.png" alt="plot4" ]

               (%i10) trigfactor(lhs(eq))=map(trigfactor,rhs(eq));
                                  %pi            %pi                      %pi            %pi
               (%o15) - 2 sin(x + ---) sin(2 x - ---) = 2 sqrt(3) sin(x - ---) sin(2 x - ---)
                                   4              4                        4              4
               (%i11) factor(lhs(%)-rhs(%));
                                4 x + %pi                4 x - %pi       8 x - %pi
               (%o11)  - 2 (sin(---------) + sqrt(3) sin(---------)) sin(---------)
                                    4                        4               4

          Equation is equivalent to
               (%i12) L:factor(rhs(%)-lhs(%));
                               4 x + %pi                4 x - %pi       8 x - %pi
               (%o12)   2 (sin(---------) + sqrt(3) sin(---------)) sin(---------)
                                   4                        4               4
               (%i13) eq1:part(L,2)=0;
                                    4 x + %pi                4 x - %pi
               (%o13)           sin(---------) + sqrt(3) sin(---------) = 0
                                        4                        4
               (%i14) eq2:part(L,3)=0;
                                                8 x - %pi
               (%o14)                       sin(---------) = 0
                                                    4
               (%i15) S1:trigsolve(eq1,0,2*%pi);
                                                %pi  13 %pi
               (%o15)                         {---, ------}
                                                12     12
               (%i16) S2:trigsolve(eq2,0,2*%pi);
                                          %pi  5 %pi  9 %pi  13 %pi
               (%o16)                   {---, -----, -----, ------}
                                           8     8      8      8
               (%i17) S:listify(union(S1,S2));
                                  %pi  %pi  5 %pi  13 %pi  9 %pi  13 %pi
               (%o17)            [---, ---, -----, ------, -----, ------]
                                  12    8     8      12      8      8
               (%i18) float(%), numer;
               (%o18) [0.2617993877991494, 0.3926990816987241, 1.963495408493621,
                                     3.403392041388942, 3.534291735288517, 5.105088062083414]

          Answer: x = a+2*%pi*k, where a any from S, k any integer.

       3.  
               (%i19) eq:8*cos(x)*cos(4*x)*cos(5*x)-1=0;
               (%o19)               8 cos(x) cos(4 x) cos(5 x) - 1 = 0

               (%i20) trigrat(%);
               (%o20)          2 cos(10 x) + 2 cos(8 x) + 2 cos(2 x) + 1 = 0

          Left side is periodic with period T=%pi .

          We have 10 solutions from [0, pi].
               (%i21) plot2d([lhs(eq),rhs(eq)],[x,0,%pi]);

            [image src="figures/trigtools-6.png" alt="plot6" ]

               (%i22) x4:find_root(eq, x, 1.3, 1.32);
               (%o22)                        1.308996938995747
               (%i23) x5:find_root(eq, x, 1.32, 1.35);
               (%o23)                        1.346396851538483
               (%i24) plot2d([lhs(eq),0], [x,1.3,1.35], [gnuplot_preamble, "set grid;"]);

            [image src="figures/trigtools-7.png" alt="plot7" ]


          Equation we multiply by 2*sin(x)*cos(2*x) :

               (%i25) eq*2*sin(x)*cos(2*x);
               (%o25)     2 sin(x) cos(2 x) (8 cos(x) cos(4 x) cos(5 x) - 1) = 0
               (%i26) eq1:trigreduce(%),expand;
               (%o26)                     sin(13 x) + sin(x) = 0
               (%i27) trigfactor(lhs(eq1))=0;
               (%o27)                     2 cos(6 x) sin(7 x) = 0
               (%i28) S1:trigsolve(cos(6*x),0,%pi);
                                   %pi  %pi  5 %pi  7 %pi  3 %pi  11 %pi
               (%o28)             {---, ---, -----, -----, -----, ------}
                                   12    4    12     12      4      12
               (%i29) S2:trigsolve(sin(7*x),0,%pi);
                                    %pi  2 %pi  3 %pi  4 %pi  5 %pi  6 %pi
               (%o29)           {0, ---, -----, -----, -----, -----, -----}
                                     7     7      7      7      7      7

          We remove solutions of sin(x)=0 and  cos(2*x) = 0.

               (%i30) S3:trigsolve(sin(x),0,%pi);
               (%o30)                               {0}
               (%i31) S4:trigsolve(cos(2*x),0,%pi);
                                                %pi  3 %pi
               (%o31)                          {---, -----}
                                                 4     4

          We find 10 solutions from [0, %pi] :
               (%i32) union(S1,S2)$ setdifference(%,S3)$ setdifference(%,S4);
                        %pi  %pi  2 %pi  5 %pi  3 %pi  4 %pi  7 %pi  5 %pi  6 %pi  11 %pi
               (%o34) {---, ---, -----, -----, -----, -----, -----, -----, -----, ------}
                        12    7     7     12      7      7     12      7      7      12
               (%i35) S:listify(%);
                       %pi  %pi  2 %pi  5 %pi  3 %pi  4 %pi  7 %pi  5 %pi  6 %pi  11 %pi
               (%o35) [---, ---, -----, -----, -----, -----, -----, -----, -----, ------]
                       12    7     7     12      7      7     12      7      7      12
               (%i36) length(S);
               (%o36)                               10
               (%i37) float(S), numer;
               (%o37) [0.2617993877991494, 0.4487989505128276, 0.8975979010256552,
               1.308996938995747, 1.346396851538483, 1.79519580205131, 1.832595714594046,
               2.243994752564138, 2.692793703076966, 2.879793265790644]
          Answer: x = a+2*%pi*k, where a any from S, k any integer.


File: maxima.info,  Node: Evaluation of Trignometric Functions,  Next: Contract atan Functions,  Prev: Solve Trignometric Equations,  Up: Functions and Variables for trigtools

96.2.6 Evaluation of Trignometric Functions
-------------------------------------------

 -- Function: trigvalue (<x>)
     The function trigvalue compute values of sin(m*%pi/n), 
     cos(m*%pi/n),  tan(m*%pi/n),  and cot(m*%pi/n) in radicals.

 -- Function: trigeval (<x>)
     The function trigeval compute values of expressions with
     sin(m*%pi/n),  cos(m*%pi/n),  tan(m*%pi/n),  and cot(m*%pi/n) in
     radicals.

   Examples:
  1. Values of trignometric functions
          (%i1) load(trigtools)$
          (%i2) trigvalue(sin(%pi/10));
                                            sqrt(5) - 1
          (%o2)                             -----------
                                                 4
          (%i3) trigvalue(cos(%pi/10));
                                         sqrt(sqrt(5) + 5)
          (%o3)                          -----------------
                                                3/2
                                               2
          (%i4) trigvalue(tan(%pi/10));
                                        sqrt(5 - 2 sqrt(5))
          (%o4)                         -------------------
                                              sqrt(5)
          (%i5) float(%), numer;
          (%o5)                         0.3249196962329063
          (%i6) float(tan(%pi/10)), numer;
          (%o6)                         0.3249196962329063
          (%i7) trigvalue(cot(%pi/10));
          (%o7)                         sqrt(2 sqrt(5) + 5)
          (%i8) float(%), numer;
          (%o8)                          3.077683537175254
          (%i9) float(cot(%pi/10)), numer;
          (%o9)                          3.077683537175254
          (%i10) trigvalue(sin(%pi/32));
                               sqrt(2 - sqrt(sqrt(sqrt(2) + 2) + 2))
          (%o10)               -------------------------------------
                                                 2
          (%i11) trigvalue(cos(%pi/32));
                               sqrt(sqrt(sqrt(sqrt(2) + 2) + 2) + 2)
          (%o11)               -------------------------------------
                                                 2
          (%i12) trigvalue(cos(%pi/256));
                 sqrt(sqrt(sqrt(sqrt(sqrt(sqrt(sqrt(2) + 2) + 2) + 2) + 2) + 2) + 2)
          (%o12) -------------------------------------------------------------------
                                                  2
          (%i13) trigvalue(cos(%pi/60));
                  sqrt(sqrt(sqrt(2) sqrt(3) sqrt(sqrt(5) + 5) + sqrt(5) + 7) + 4)
          (%o13)  ---------------------------------------------------------------
                                                3/2
                                               2
          (%i14) trigvalue(sin(%pi/60));
                  sqrt(4 - sqrt(sqrt(2) sqrt(3) sqrt(sqrt(5) + 5) + sqrt(5) + 7))
          (%o14)  ---------------------------------------------------------------
                                                3/2
                                               2
          (%i15) trigvalue(sin(%pi/18));
                                                 %pi
          (%o15)                             sin(---)
                                                 18
          (%i16) trigvalue(sin(%pi/20));
                                sqrt(4 - sqrt(2) sqrt(sqrt(5) + 5))
          (%o16)                -----------------------------------
                                                3/2
                                               2

  2. ode example
          (%i17) load(odes)$
          (%i18) eq:'diff(y,x,5)+2*y=0;
                                            5
                                           d y
          (%o18)                           --- + 2 y = 0
                                             5
                                           dx
          (%i19) odeL(eq,y,x);
                             1/5     4 %pi
                          - 2    cos(-----) x
                                       5           1/5     4 %pi
          (%o19) y = C5 %e                    sin(2    sin(-----) x)
                                                             5
                     1/5     4 %pi
                  - 2    cos(-----) x
                               5           1/5     4 %pi
           + C4 %e                    cos(2    sin(-----) x)
                                                     5
                     1/5     2 %pi
                  - 2    cos(-----) x
                               5           1/5     2 %pi
           + C3 %e                    sin(2    sin(-----) x)
                                                     5
                     1/5     2 %pi
                  - 2    cos(-----) x                                  1/5
                               5           1/5     2 %pi            - 2    x
           + C2 %e                    cos(2    sin(-----) x) + C1 %e
                                                     5
          (%i20) sol:trigeval(%);
                            (sqrt(5) - 1) x
                          - ---------------
                                  9/5
                                 2              sqrt(sqrt(5) + 5) x
          (%o20) y = C3 %e                  sin(-------------------)
                                                       13/10
                                                      2
                    (sqrt(5) - 1) x
                  - ---------------
                          9/5
                         2              sqrt(sqrt(5) + 5) x
           + C2 %e                  cos(-------------------)
                                               13/10
                                              2
                  (sqrt(5) + 1) x
                  ---------------
                        9/5
                       2              sqrt(5 - sqrt(5)) x
           + C5 %e                sin(-------------------)
                                             13/10
                                            2
                  (sqrt(5) + 1) x
                  ---------------
                        9/5                                          1/5
                       2              sqrt(5 - sqrt(5)) x         - 2    x
           + C4 %e                cos(-------------------) + C1 %e
                                             13/10
                                            2
          (%i21) subst(sol,eq)$
          (%i22) ev(%, nouns)$
          (%i23) radcan(%);
          (%o23)                               0 = 0

  3. n-th root of complex number

     Example.  Find the 4-th roots of %i
          (%i24) solve(x^4=%i,x);
                           1/8                1/8             1/8              1/8
          (%o24) [x = (- 1)    %i, x = - (- 1)   , x = - (- 1)    %i, x = (- 1)   ]
          (%i25) rectform(%);
                             %pi        %pi                 %pi         %pi
          (%o25) [x = %i cos(---) - sin(---), x = (- %i sin(---)) - cos(---),
                              8          8                   8           8
                                          %pi           %pi              %pi        %pi
                                  x = sin(---) - %i cos(---), x = %i sin(---) + cos(---)]
                                           8             8                8          8
          (%i26) trigeval(%);
                      sqrt(sqrt(2) + 2) %i   sqrt(2 - sqrt(2))
          (%o26) [x = -------------------- - -----------------,
                               2                     2
                 sqrt(2 - sqrt(2)) %i    sqrt(sqrt(2) + 2)
          x = (- --------------------) - -----------------,
                          2                      2
              sqrt(2 - sqrt(2))   sqrt(sqrt(2) + 2) %i
          x = ----------------- - --------------------,
                      2                    2
              sqrt(2 - sqrt(2)) %i   sqrt(sqrt(2) + 2)
          x = -------------------- + -----------------]
                       2                     2


File: maxima.info,  Node: Contract atan Functions,  Prev: Evaluation of Trignometric Functions,  Up: Functions and Variables for trigtools

96.2.7 Contract atan Functions
------------------------------

 -- Function: atan_contract (<r>)
     The function atan_contract(r) contracts atan functions.  We assume:
     abs(r)<%pi/2.

     Examples:
          (%i1) load(trigtools)$

       1.  
               (%i2) atan_contract(atan(x)+atan(y));
               (%o2)                          atan(y) + atan(x)
               (%i3) assume(abs(atan(x)+atan(y))<%pi/2)$
               (%i4) atan(x)+atan(y)=atan_contract(atan(x)+atan(y));
                                                                y + x
               (%o4)                  atan(y) + atan(x) = atan(-------)
                                                               1 - x y

       2.  
               (%i5) atan(1/3)+atan(1/5)+atan(1/7)+atan(1/8)$ %=atan_contract(%);
                                      1         1         1         1    %pi
               (%o6)             atan(-) + atan(-) + atan(-) + atan(-) = ---
                                      3         5         7         8     4

       3. Machin’s formulae
               (%i7) 4*atan(1/5)-atan(1/239)=atan_contract(4*atan(1/5)-atan(1/239));
                                                1          1     %pi
               (%o7)                     4 atan(-) - atan(---) = ---
                                                5         239     4

       4. see <http://en.wikipedia.org/wiki/Machin-like_formula>
               (%i8) 12*atan(1/49)+32*atan(1/57)-5*atan(1/239)+12*atan(1/110443)$
               %=atan_contract(%);
                               1             1             1               1       %pi
               (%o9)   12 atan(--) + 32 atan(--) - 5 atan(---) + 12 atan(------) = ---
                               49            57           239            110443     4


File: maxima.info,  Node: References,  Prev: Functions and Variables for trigtools

96.3 References
===============

  1. <http://maxima.sourceforge.net>


File: maxima.info,  Node: Error and warning messages,  Next: Command-line options,  Prev: zeilberger-pkg,  Up: Top

97 Error and warning messages
*****************************

* Menu:

* Error Messages::
* Warning Messages::

This chapter provides detailed information about the meaning of some
error messages or on how to recover from errors.


File: maxima.info,  Node: Error Messages,  Next: Warning Messages,  Up: Error and warning messages

97.1 Error Messages
===================

* Menu:

* No such list element::
* argument must be a non-atomic expression::
* cannot assign to function::
* 0 to a negative exponent::
* Comma is not a prefix operator::
* Illegal use of delimiter::
* loadfile failed to load::
* makelist second argument must evaluate to a number::
* Only symbols can be bound::
* Operators of arguments must all be the same::
* out of memory::
* part fell off the end::
* undefined variable during plotting::
* VTK is not installed::


File: maxima.info,  Node: No such list element,  Next: argument must be a non-atomic expression,  Prev: Error Messages,  Up: Error Messages

97.1.1 apply: no such "list" element
------------------------------------

One common cause for this error message is that square brackets operator
(‘[ ]’) was used trying to access a list element that whose element
number was ‘< 1’ or ‘> length(list)’.


File: maxima.info,  Node: argument must be a non-atomic expression,  Next: cannot assign to function,  Prev: No such list element,  Up: Error Messages

97.1.2 argument must be a non-atomic expression
-----------------------------------------------

This normally means that a list, a set or something else that consists
of more than one element was expected.  One possible cause for this
error message is a construct of the following type:
     (%i1) l:[1,2,3];
     (%o1)                       [1, 2, 3]
     (%i2) append(l,4);
     append: argument must be a non-atomic expression; found 4
      -- an error. To debug this try: debugmode(true);
   The correct way to append variables or numbers to a list is to wrap
them in a single-element list first:
     (%i1) l:[1,2,3];
     (%o1)                       [1, 2, 3]
     (%i2) append(l,[4]);
     (%o2)                     [1, 2, 3, 4]


File: maxima.info,  Node: cannot assign to function,  Next: 0 to a negative exponent,  Prev: argument must be a non-atomic expression,  Up: Error Messages

97.1.3 assignment: cannot assign to ‘<function name>’
-----------------------------------------------------

Maxima supports several assignment operators.  When trying to define a
function ‘:=’ has to be used.


File: maxima.info,  Node: 0 to a negative exponent,  Next: Comma is not a prefix operator,  Prev: cannot assign to function,  Up: Error Messages

97.1.4 expt: undefined: 0 to a negative exponent.
-------------------------------------------------

This message notifies about a classical division by zero error.


File: maxima.info,  Node: Comma is not a prefix operator,  Next: Illegal use of delimiter,  Prev: 0 to a negative exponent,  Up: Error Messages

97.1.5 incorrect syntax: , is not a prefix operator
---------------------------------------------------

This might be caused by a command starting with a comma (‘,’) or by one
comma being directly followed by another one..


File: maxima.info,  Node: Illegal use of delimiter,  Next: loadfile failed to load,  Prev: Comma is not a prefix operator,  Up: Error Messages

97.1.6 incorrect syntax: Illegal use of delimiter )
---------------------------------------------------

Common reasons for this error appearing are a closing parenthesis
without an opening one or a closing parenthesis directly preceded by a
comma.


File: maxima.info,  Node: loadfile failed to load,  Next: makelist second argument must evaluate to a number,  Prev: Illegal use of delimiter,  Up: Error Messages

97.1.7 loadfile: failed to load ‘<filename>’
--------------------------------------------

This error message normally indicates that the file exists, but can not
be read.  If the file is present and readable there is another possible
for this error message: Maxima can compile packages to native binary
files in order to make them run faster.  If after compiling the file
something in the system has changed in a way that makes it incompatible
with the binary the binary the file cannot be loaded any more.  Maxima
normally puts binary files it creates from its own packages in a folder
named ‘binary’ within the folder whose name it is printed after typing:
     (%i1) maxima_userdir;
     (%o1)                 /home/gunter/.maxima
   If this directory is missing maxima will recreate it again as soon as
it has to compile a package.


File: maxima.info,  Node: makelist second argument must evaluate to a number,  Next: Only symbols can be bound,  Prev: loadfile failed to load,  Up: Error Messages

97.1.8 makelist: second argument must evaluate to a number
----------------------------------------------------------

‘makelist’ expects the second argument to be the name of the variable
whose value is to be stepped.  This time instead of the name of a
still-undefined variable maxima has found something else, possibly a
list or the name of a list.


File: maxima.info,  Node: Only symbols can be bound,  Next: Operators of arguments must all be the same,  Prev: makelist second argument must evaluate to a number,  Up: Error Messages

97.1.9 Only symbols can be bound
--------------------------------

The most probable cause for this error is that there was an attempt to
either use a number or a variable whose numerical value is known as a
loop counter.


File: maxima.info,  Node: Operators of arguments must all be the same,  Next: out of memory,  Prev: Only symbols can be bound,  Up: Error Messages

97.1.10 operators of arguments must all be the same
---------------------------------------------------

One possible reason for this error message to appear is a try to use
‘append’ in order to add an equation to a list:
     (%i1) l:[a=1,b=2,c=3];
     (%o1)                 [a = 1, b = 2, c = 3]
     (%i2) append(l,d=5);
     append: operators of arguments must all be the same.
      -- an error. To debug this try: debugmode(true);
   In order to add an equation to a list it has to be wrapped in a
single-element list first:
     (%i1) l:[a=1,b=2,c=3];
     (%o1)                 [a = 1, b = 2, c = 3]
     (%i2) append(l,[d=5]);
     (%o2)             [a = 1, b = 2, c = 3, d = 5]


File: maxima.info,  Node: out of memory,  Next: part fell off the end,  Prev: Operators of arguments must all be the same,  Up: Error Messages

97.1.11 Out of memory
---------------------

Lisp typically handles several types of memory containing at least one
stack and a heap that contains user objects.  To avoid running out of
memory several approaches might be useful:
   • If possible, the best solution normally is to use an algorithm that
     is more memory-efficient.
   • Compiling a function might drastically reduce the amount of memory
     it needs.
   • Arrays of a fixed type might be more memory-efficient than lists.
   • If maxima is run by sbcl sbcl’s memory limit might be set to a
     value that is too low to solve the current problem.  In this case
     the command-line option ‘--dynamic-space-size <n>’ allows to tell
     sbcl to reserve ‘n’ megabytes for the heap.  It is to note, though,
     that sbcl has to handle several distinct types of memory and
     therefore might be able to only reserve about half of the available
     physical memory.  Also note that 32-bit processes might only be
     able to access 2GB of physical memory.


File: maxima.info,  Node: part fell off the end,  Next: undefined variable during plotting,  Prev: out of memory,  Up: Error Messages

97.1.12 part: fell off the end
------------------------------

‘part()’ was used to access the ‘n’th item in something that has less
than ‘n’ items.


File: maxima.info,  Node: undefined variable during plotting,  Next: VTK is not installed,  Prev: part fell off the end,  Up: Error Messages

97.1.13 undefined variable (draw or plot)
-----------------------------------------

A function could not be plotted since it still contained a variable
maxima doesn’t know the value of.

   In order to find out which variable this could be it is sometimes
helpful to temporarily replace the name of the drawing command
(‘draw2d’, ‘plot2d’ or similar) by a random name (for example ‘ddraw2d’)
that doesn’t coincide with the name of an existing function to make
maxima print out what parameters the drawing command sees.

     (%i1) load("draw")$
     (%i2) f(x):=sin(omega*t);
     (%o2) f(x) := sin(omega t)
     (%i3) draw2d(
             explicit(
               f(x),
               x,1,10
             )
           );
     draw2d (explicit): non defined variable
      -- an error. To debug this try: debugmode(true);
     (%i4) ddraw2d(
             explicit(
               f(x),
               x,1,10
             )
           );
     (%o4) ddraw2d(explicit(sin(omega t), x, 1, 10))


File: maxima.info,  Node: VTK is not installed,  Prev: undefined variable during plotting,  Up: Error Messages

97.1.14 VTK is not installed, which is required for Scene
---------------------------------------------------------

This might either mean that VTK is actually not installed - or cannot be
found by maxima - or that Maxima has no write access to the temporary
directory whose name is output if the following maxima command is
entered:
     (%i1) maxima_tempdir;
     (%o1)                         /tmp

   Note: The ‘scene()’ command requrires VTK with TCL/TK bindings.


File: maxima.info,  Node: Warning Messages,  Prev: Error Messages,  Up: Error and warning messages

97.2 Warning Messages
=====================

* Menu:

* undefined variable during translation::
* replaced x by y::


File: maxima.info,  Node: undefined variable during translation,  Next: replaced x by y,  Prev: Warning Messages,  Up: Warning Messages

97.2.1 Encountered undefined variable ‘<x>’ in translation
----------------------------------------------------------

A function was compiled but the type of the variable ‘x’ was not known.
This means that the compiled command contains additional code that makes
it retain all the flexibility maxima provides in respect to this
variable.  If ‘x’ isn’t meant as a variable name but just a named option
to a command prepending the named option by a single quote (‘'’) should
resolve this issue.


File: maxima.info,  Node: replaced x by y,  Prev: undefined variable during translation,  Up: Warning Messages

97.2.2 Rat: replaced ‘<x>’ by ‘<y> = <z>’
-----------------------------------------

‘rat’ was called on an expression containing floating point numbers
(including big floats) and ‘keepfloat’ was false.  This means the number
was replaced by a rational number approximating the floating-point
number.

   See also ‘ratprint’, ‘ratepsilon’, ‘bftorat’, ‘fpprintprec’ and
‘rationalize’.


File: maxima.info,  Node: Command-line options,  Next: Function and Variable Index,  Prev: Error and warning messages,  Up: Top

98 Command-line options
***********************

* Menu:

* Command line options::


File: maxima.info,  Node: Command line options,  Up: Command-line options

98.1 Command line options
=========================

The following command line options are available for Maxima:

‘-f file, --batch=<file>’
     Process file in noninteractive mode.

‘--batch-lisp=<file>’
     Process Lisp file file in noninteractive mode.

‘--batch-string=<string>’
     Process string in noninteractive mode.

‘-d, --directories’
     Display Maxima directory information.

‘--disable-readline’
     Disable readline support.
‘-g, --enable-lisp-debugger’
     Enable Lisp debugger.
‘-h, --help’
     Display a brief usage summary.
‘--init=string’
     Load the Maxima and Lisp initialization files ‘string.mac’ and
     ‘string.lisp’ at startup.
‘--init-mac=<file>’
     Load the Maxima initialization file file at startup.

‘--init-lisp=<file>’
     Load the Lisp initialization file file at startup.

‘-l <lisp>, --lisp=<lisp>’
     Use Lisp implementation lisp.  Use ‘--list-avail’ to see the list
     of possible values.

‘--list-avail’
     List the available Lisp and Maxima versions.
‘-p <lisp_file>, --preload-lisp=<lisp_file>’
     Preload ‘lisp_file’.

‘-q, --quiet’
     Suppress Maxima start-up message.

‘-r <string>, --run-string=<string>’
     Process string in interactive mode.

‘-s <port>, --server=<port>’
     Connect Maxima to server on port.  Note that this does not create a
     Maxima server; Maxima is the client.

‘-u <version>, --use-version=<version>’
     Launch Maxima version version.  Use ‘--list-avail’ to see the list
     of possible values.

‘--userdir=<directory>’
     Use directory for user directory (default is ‘%USERPROFILE%/maxima’
     for Windows, ‘$HOME/.maxima’ for others)

‘-v, --verbose’
     Print extra information from the Maxima wrapper script.
‘--version’
     Print the (default) installed version.

‘--very-quiet’
     Suppress expression labels and the Maxima start-up message.

‘-X <Lisp options>, --lisp-options=<Lisp options>’
     Options to be given to the underlying Lisp.

‘--no-init, --norc’
     Do not load the init file(s) on startup.


File: maxima.info,  Node: Function and Variable Index,  Prev: Command-line options,  Up: Top

Appendix A Function and Variable Index
**************************************

 [index ]
* Menu:

* !:                                     Combinatorial Functions.
                                                             (line   74)
* !!:                                    Combinatorial Functions.
                                                             (line    6)
* #:                                     Operators for Equations.
                                                             (line    6)
* $:                                     Functions and Variables for Command Line.
                                                             (line  203)
* %:                                     Functions and Variables for Command Line.
                                                             (line   91)
* %%:                                    Functions and Variables for Command Line.
                                                             (line  105)
* %and:                                  Functions and Variables for to_poly_solve.
                                                             (line   15)
* %c:                                    Functions and Variables for Differential Equations.
                                                             (line  173)
* %e:                                    Functions and Variables for Constants.
                                                             (line    6)
* %edispflag:                            Functions and Variables for Display.
                                                             (line    6)
* %emode:                                Root Exponential and Logarithmic Functions.
                                                             (line   15)
* %enumer:                               Root Exponential and Logarithmic Functions.
                                                             (line   55)
* %e_to_numlog:                          Root Exponential and Logarithmic Functions.
                                                             (line    6)
* %f:                                    Hypergeometric Functions.
                                                             (line   36)
* %gamma:                                Functions and Variables for Constants.
                                                             (line   23)
* %i:                                    Functions and Variables for Constants.
                                                             (line   14)
* %iargs:                                Options Controlling Simplification.
                                                             (line   52)
* %if:                                   Functions and Variables for to_poly_solve.
                                                             (line   89)
* %k1:                                   Functions and Variables for Differential Equations.
                                                             (line  178)
* %k2:                                   Functions and Variables for Differential Equations.
                                                             (line  183)
* %m:                                    Hypergeometric Functions.
                                                             (line   14)
* %or:                                   Functions and Variables for to_poly_solve.
                                                             (line  132)
* %phi:                                  Functions and Variables for Constants.
                                                             (line   95)
* %pi:                                   Functions and Variables for Constants.
                                                             (line  150)
* %piargs:                               Options Controlling Simplification.
                                                             (line    6)
* %rnum:                                 Functions and Variables for Equations.
                                                             (line    6)
* %rnum_list:                            Functions and Variables for Equations.
                                                             (line   15)
* %s:                                    Bessel Functions.   (line  225)
* %th:                                   Functions and Variables for Command Line.
                                                             (line  152)
* %union:                                Functions and Variables for to_poly_solve.
                                                             (line 1185)
* %union <1>:                            Functions and Variables for to_poly_solve.
                                                             (line 1186)
* %unitexpand:                           Functions and Variables for Units.
                                                             (line  407)
* %w:                                    Hypergeometric Functions.
                                                             (line   28)
* ':                                     Functions and Variables for Evaluation.
                                                             (line    6)
* '':                                    Functions and Variables for Evaluation.
                                                             (line  132)
* *:                                     Arithmetic operators.
                                                             (line    8)
* **:                                    Arithmetic operators.
                                                             (line  165)
* +:                                     Arithmetic operators.
                                                             (line    6)
* -:                                     Arithmetic operators.
                                                             (line    7)
* .:                                     Arithmetic operators.
                                                             (line  207)
* /:                                     Arithmetic operators.
                                                             (line    9)
* ::                                     Assignment operators.
                                                             (line    6)
* :::                                    Assignment operators.
                                                             (line   90)
* ::=:                                   Assignment operators.
                                                             (line  116)
* :=:                                    Assignment operators.
                                                             (line  189)
* ;:                                     Functions and Variables for Command Line.
                                                             (line  218)
* <:                                     Relational operators.
                                                             (line    6)
* <=:                                    Relational operators.
                                                             (line    7)
* =:                                     Operators for Equations.
                                                             (line   30)
* >:                                     Relational operators.
                                                             (line    9)
* >=:                                    Relational operators.
                                                             (line    8)
* ?:                                     Functions and Variables for Command Line.
                                                             (line  182)
* ??:                                    Functions and Variables for Command Line.
                                                             (line  195)
* @:                                     Functions and Variables for Structures.
                                                             (line   72)
* [:                                     Functions and Variables for Lists.
                                                             (line    6)
* ]:                                     Functions and Variables for Lists.
                                                             (line    7)
* ^:                                     Arithmetic operators.
                                                             (line   10)
* ^^:                                    Arithmetic operators.
                                                             (line  188)
* _:                                     Functions and Variables for Command Line.
                                                             (line   46)
* __:                                    Functions and Variables for Command Line.
                                                             (line    6)
* `:                                     Functions and Variables for ezunits.
                                                             (line    6)
* ``:                                    Functions and Variables for ezunits.
                                                             (line   92)
* |:                                     Functions and Variables for itensor.
                                                             (line 1442)
* ~:                                     Functions and Variables for itensor.
                                                             (line 1408)
* abasep:                                Functions and Variables for atensor.
                                                             (line  132)
* abs:                                   Functions for Numbers.
                                                             (line    6)
* absboxchar:                            Functions and Variables for Display.
                                                             (line   25)
* absint:                                Functions and Variables for Fourier series.
                                                             (line   33)
* absolute_real_time:                    Functions and Variables for Runtime Environment.
                                                             (line  354)
* acos:                                  Trigonometric and Hyperbolic Functions.
                                                             (line    6)
* acosh:                                 Trigonometric and Hyperbolic Functions.
                                                             (line   10)
* acot:                                  Trigonometric and Hyperbolic Functions.
                                                             (line   14)
* acoth:                                 Trigonometric and Hyperbolic Functions.
                                                             (line   18)
* acsc:                                  Trigonometric and Hyperbolic Functions.
                                                             (line   22)
* acsch:                                 Trigonometric and Hyperbolic Functions.
                                                             (line   26)
* activate:                              Functions and Variables for Facts.
                                                             (line    6)
* activecontexts:                        Functions and Variables for Facts.
                                                             (line   16)
* adapt_depth:                           Plotting Options.   (line   24)
* adapt_depth <1>:                       Functions and Variables for draw.
                                                             (line  209)
* addcol:                                Functions and Variables for Matrices and Linear Algebra.
                                                             (line    6)
* Addition:                              Arithmetic operators.
                                                             (line    6)
* additive:                              Functions and Variables for Simplification.
                                                             (line    6)
* addmatrices:                           Functions and Variables for linearalgebra.
                                                             (line    6)
* addrow:                                Functions and Variables for Matrices and Linear Algebra.
                                                             (line   13)
* add_edge:                              Functions and Variables for graphs.
                                                             (line 1181)
* add_edges:                             Functions and Variables for graphs.
                                                             (line 1194)
* add_vertex:                            Functions and Variables for graphs.
                                                             (line 1208)
* add_vertices:                          Functions and Variables for graphs.
                                                             (line 1222)
* adim:                                  Functions and Variables for atensor.
                                                             (line   75)
* adjacency_matrix:                      Functions and Variables for graphs.
                                                             (line  322)
* adjoin:                                Functions and Variables for Sets.
                                                             (line    6)
* adjoint:                               Functions and Variables for Matrices and Linear Algebra.
                                                             (line   20)
* adjust_external_format:                Characters.         (line    8)
* af:                                    Functions and Variables for atensor.
                                                             (line  100)
* aform:                                 Functions and Variables for atensor.
                                                             (line   82)
* agd:                                   Package functs.     (line  150)
* airy_ai:                               Airy Functions.     (line   27)
* airy_bi:                               Airy Functions.     (line   41)
* airy_dai:                              Airy Functions.     (line   34)
* airy_dbi:                              Airy Functions.     (line   48)
* algebraic:                             Functions and Variables for Polynomials.
                                                             (line    6)
* algepsilon:                            Functions and Variables for Equations.
                                                             (line   42)
* algexact:                              Functions and Variables for Equations.
                                                             (line   47)
* algfac:                                Functions and Variables for algebraic extensions.
                                                             (line    6)
* algnorm:                               Functions and Variables for algebraic extensions.
                                                             (line   23)
* algsys:                                Functions and Variables for Equations.
                                                             (line   62)
* algtrace:                              Functions and Variables for algebraic extensions.
                                                             (line   38)
* alg_type:                              Functions and Variables for atensor.
                                                             (line   71)
* alias:                                 Functions and Variables for Expressions.
                                                             (line    6)
* aliases:                               Functions and Variables for Expressions.
                                                             (line   12)
* allbut:                                Functions and Variables for Expressions.
                                                             (line   19)
* allocation:                            Functions and Variables for draw.
                                                             (line  219)
* allroots:                              Functions and Variables for Equations.
                                                             (line  164)
* allsym:                                Functions and Variables for itensor.
                                                             (line  520)
* all_dotsimp_denoms:                    Functions and Variables for Affine.
                                                             (line  132)
* alphabetic:                            Functions and Variables for Properties.
                                                             (line    6)
* alphacharp:                            Characters.         (line   64)
* alphanumericp:                         Characters.         (line   92)
* alt_display_output_type:               Functions and Variables for alt-display.
                                                             (line    6)
* amortization:                          Functions and Variables for finance.
                                                             (line  105)
* and:                                   Logical operators.  (line    6)
* animation:                             Visualization with VTK.
                                                             (line  169)
* annuity_fv:                            Functions and Variables for finance.
                                                             (line   66)
* annuity_pv:                            Functions and Variables for finance.
                                                             (line   53)
* antid:                                 Functions and Variables for Differentiation.
                                                             (line    6)
* antidiff:                              Functions and Variables for Differentiation.
                                                             (line   60)
* AntiDifference:                        Functions and Variables for zeilberger.
                                                             (line    6)
* antisymmetric:                         Functions and Variables for Simplification.
                                                             (line   30)
* append:                                Functions and Variables for Lists.
                                                             (line   47)
* appendfile:                            Functions and Variables for File Input and Output.
                                                             (line    6)
* apply:                                 Functions and Variables for Function Definition.
                                                             (line    6)
* apply1:                                Functions and Variables for Rules and Patterns.
                                                             (line    6)
* apply2:                                Functions and Variables for Rules and Patterns.
                                                             (line   21)
* applyb1:                               Functions and Variables for Rules and Patterns.
                                                             (line   34)
* apply_cycles:                          Functions and Variables for Combinatorics.
                                                             (line    6)
* apropos:                               Functions and Variables for Help.
                                                             (line    6)
* args:                                  Functions and Variables for Expressions.
                                                             (line   48)
* arithmetic:                            Package functs.     (line  109)
* arithsum:                              Package functs.     (line  127)
* arit_amortization:                     Functions and Variables for finance.
                                                             (line  130)
* array:                                 Functions and Variables for Arrays.
                                                             (line    6)
* arrayapply:                            Functions and Variables for Arrays.
                                                             (line   26)
* arrayinfo:                             Functions and Variables for Arrays.
                                                             (line   34)
* arraymake:                             Functions and Variables for Arrays.
                                                             (line  143)
* arrays:                                Functions and Variables for Arrays.
                                                             (line  188)
* arraysetapply:                         Functions and Variables for Arrays.
                                                             (line  217)
* ascii:                                 Characters.         (line   99)
* asec:                                  Trigonometric and Hyperbolic Functions.
                                                             (line   30)
* asech:                                 Trigonometric and Hyperbolic Functions.
                                                             (line   34)
* asin:                                  Trigonometric and Hyperbolic Functions.
                                                             (line   38)
* asinh:                                 Trigonometric and Hyperbolic Functions.
                                                             (line   42)
* askequal:                              Functions and Variables for Facts.
                                                             (line   23)
* askexp:                                Functions and Variables for Miscellaneous Options.
                                                             (line    6)
* askinteger:                            Functions and Variables for Facts.
                                                             (line   40)
* asksign:                               Functions and Variables for Facts.
                                                             (line   56)
* Assignment operator:                   Assignment operators.
                                                             (line    7)
* Assignment operator (evaluates left-hand side): Assignment operators.
                                                             (line   91)
* assoc:                                 Functions and Variables for Lists.
                                                             (line   58)
* assoc_legendre_p:                      Functions and Variables for orthogonal polynomials.
                                                             (line    6)
* assoc_legendre_q:                      Functions and Variables for orthogonal polynomials.
                                                             (line   47)
* assume:                                Functions and Variables for Facts.
                                                             (line   65)
* assumescalar:                          Functions and Variables for Facts.
                                                             (line  123)
* assume_external_byte_order:            Functions and Variables for binary input and output.
                                                             (line    6)
* assume_pos:                            Functions and Variables for Facts.
                                                             (line  145)
* assume_pos_pred:                       Functions and Variables for Facts.
                                                             (line  168)
* asymbol:                               Functions and Variables for atensor.
                                                             (line   88)
* asympa:                                Introduction to asympa.
                                                             (line    6)
* at:                                    Functions and Variables for Differentiation.
                                                             (line  110)
* atan:                                  Trigonometric and Hyperbolic Functions.
                                                             (line   46)
* atan2:                                 Trigonometric and Hyperbolic Functions.
                                                             (line   52)
* atanh:                                 Trigonometric and Hyperbolic Functions.
                                                             (line   59)
* atan_contract:                         Contract atan Functions.
                                                             (line    6)
* atensimp:                              Functions and Variables for atensor.
                                                             (line   62)
* atom:                                  Functions and Variables for Expressions.
                                                             (line   79)
* atomgrad:                              Functions and Variables for Differentiation.
                                                             (line  183)
* atrig1:                                Additional Functions.
                                                             (line    6)
* atvalue:                               Functions and Variables for Differentiation.
                                                             (line  188)
* augcoefmatrix:                         Functions and Variables for Matrices and Linear Algebra.
                                                             (line   25)
* augmented_lagrangian_method:           Functions and Variables for augmented_lagrangian.
                                                             (line    6)
* av:                                    Functions and Variables for atensor.
                                                             (line  107)
* average_degree:                        Functions and Variables for graphs.
                                                             (line  337)
* axes:                                  Plotting Options.   (line   35)
* axis_3d:                               Functions and Variables for draw.
                                                             (line  259)
* axis_bottom:                           Functions and Variables for draw.
                                                             (line  277)
* axis_left:                             Functions and Variables for draw.
                                                             (line  293)
* axis_right:                            Functions and Variables for draw.
                                                             (line  308)
* axis_top:                              Functions and Variables for draw.
                                                             (line  323)
* azimuth:                               Plotting Options.   (line   48)
* azimuth <1>:                           Visualization with VTK.
                                                             (line   62)
* background:                            Visualization with VTK.
                                                             (line   70)
* background_color:                      Functions and Variables for draw.
                                                             (line  338)
* backslash:                             Introduction to Strings.
                                                             (line    6)
* backsubst:                             Functions and Variables for Equations.
                                                             (line  235)
* backtrace:                             Functions and Variables for Program Flow.
                                                             (line    6)
* bars:                                  Functions and Variables for draw.
                                                             (line 2829)
* barsplot:                              Functions and Variables for statistical graphs.
                                                             (line    6)
* barsplot_description:                  Functions and Variables for statistical graphs.
                                                             (line  119)
* Base of natural logarithm:             Functions and Variables for Constants.
                                                             (line    7)
* base64:                                Octets and Utilities for Cryptography.
                                                             (line    6)
* base64_decode:                         Octets and Utilities for Cryptography.
                                                             (line   31)
* bashindices:                           Functions and Variables for Sums and Products.
                                                             (line    6)
* batch:                                 Functions and Variables for File Input and Output.
                                                             (line   15)
* batchload:                             Functions and Variables for File Input and Output.
                                                             (line   84)
* bc2:                                   Functions and Variables for Differential Equations.
                                                             (line    6)
* bdiscr:                                Functions and Variables for algebraic extensions.
                                                             (line   49)
* bdvac:                                 Functions and Variables for ctensor.
                                                             (line  790)
* belln:                                 Functions and Variables for Sets.
                                                             (line   24)
* benefit_cost:                          Functions and Variables for finance.
                                                             (line  239)
* berlefact:                             Functions and Variables for Polynomials.
                                                             (line   12)
* bern:                                  Functions and Variables for Number Theory.
                                                             (line    6)
* bernpoly:                              Functions and Variables for Number Theory.
                                                             (line   24)
* bernstein_approx:                      Functions and Variables for Bernstein.
                                                             (line   74)
* bernstein_expand:                      Functions and Variables for Bernstein.
                                                             (line  101)
* bernstein_explicit:                    Functions and Variables for Bernstein.
                                                             (line   49)
* bernstein_poly:                        Functions and Variables for Bernstein.
                                                             (line    6)
* besselexpand:                          Bessel Functions.   (line  161)
* bessel_i:                              Bessel Functions.   (line   48)
* bessel_j:                              Bessel Functions.   (line    6)
* bessel_k:                              Bessel Functions.   (line   70)
* bessel_simplify:                       Functions and Variables for contrib_ode.
                                                             (line  102)
* bessel_y:                              Bessel Functions.   (line   29)
* beta:                                  Gamma and Factorial Functions.
                                                             (line  280)
* beta_args_sum_to_integer:              Gamma and Factorial Functions.
                                                             (line  781)
* beta_expand:                           Gamma and Factorial Functions.
                                                             (line  773)
* beta_incomplete:                       Gamma and Factorial Functions.
                                                             (line  399)
* beta_incomplete_generalized:           Gamma and Factorial Functions.
                                                             (line  651)
* beta_incomplete_regularized:           Gamma and Factorial Functions.
                                                             (line  550)
* bezout:                                Functions and Variables for Polynomials.
                                                             (line   19)
* bfallroots:                            Functions and Variables for Equations.
                                                             (line  224)
* bffac:                                 Gamma and Factorial Functions.
                                                             (line   10)
* bfhzeta:                               Functions and Variables for Number Theory.
                                                             (line   34)
* bfloat:                                Functions and Variables for Numbers.
                                                             (line    6)
* bfloatp:                               Functions and Variables for Numbers.
                                                             (line   56)
* bfpsi:                                 Gamma and Factorial Functions.
                                                             (line   23)
* bfpsi0:                                Gamma and Factorial Functions.
                                                             (line   24)
* bftorat:                               Functions and Variables for Numbers.
                                                             (line   60)
* bftrunc:                               Functions and Variables for Numbers.
                                                             (line   87)
* bfzeta:                                Functions and Variables for Number Theory.
                                                             (line   28)
* bf_fft:                                Functions and Variables for fast Fourier transform.
                                                             (line  253)
* bf_find_root:                          Functions for numerical solution of equations.
                                                             (line   36)
* bf_find_root <1>:                      Functions for numerical solution of equations.
                                                             (line   37)
* bf_fmin_cobyla:                        Functions and Variables for cobyla.
                                                             (line   68)
* bf_inverse_fft:                        Functions and Variables for fast Fourier transform.
                                                             (line  247)
* bf_inverse_real_fft:                   Functions and Variables for fast Fourier transform.
                                                             (line  265)
* bf_real_fft:                           Functions and Variables for fast Fourier transform.
                                                             (line  259)
* biconnected_components:                Functions and Variables for graphs.
                                                             (line  347)
* bigfloat_bits:                         Functions and Variables for Numbers.
                                                             (line   95)
* bigfloat_eps:                          Functions and Variables for Numbers.
                                                             (line  108)
* bimetric:                              Functions and Variables for ctensor.
                                                             (line  814)
* bindtest:                              Functions and Variables for Properties.
                                                             (line   25)
* binlist:                               Functions and Variables for Quantum_Computing.
                                                             (line    6)
* binlist2dec:                           Functions and Variables for Quantum_Computing.
                                                             (line   18)
* binomial:                              Combinatorial Functions.
                                                             (line   23)
* bipartition:                           Functions and Variables for graphs.
                                                             (line  362)
* bit_and:                               Functions and Variables for bitwise.
                                                             (line   23)
* bit_length:                            Functions and Variables for bitwise.
                                                             (line  141)
* bit_lsh:                               Functions and Variables for bitwise.
                                                             (line   98)
* bit_not:                               Functions and Variables for bitwise.
                                                             (line    6)
* bit_onep:                              Functions and Variables for bitwise.
                                                             (line  157)
* bit_or:                                Functions and Variables for bitwise.
                                                             (line   48)
* bit_rsh:                               Functions and Variables for bitwise.
                                                             (line  119)
* bit_xor:                               Functions and Variables for bitwise.
                                                             (line   73)
* block:                                 Functions and Variables for Function Definition.
                                                             (line   76)
* blockmatrixp:                          Functions and Variables for linearalgebra.
                                                             (line   21)
* bode_gain:                             Functions and Variables for bode.
                                                             (line    6)
* bode_phase:                            Functions and Variables for bode.
                                                             (line   51)
* border:                                Functions and Variables for draw.
                                                             (line  352)
* bothcoef:                              Functions and Variables for Polynomials.
                                                             (line   37)
* boundaries_array:                      Functions and Variables for worldmap.
                                                             (line    9)
* box:                                   Functions and Variables for Expressions.
                                                             (line   85)
* box <1>:                               Plotting Options.   (line   61)
* boxchar:                               Functions and Variables for Expressions.
                                                             (line  138)
* boxplot:                               Functions and Variables for statistical graphs.
                                                             (line  145)
* boxplot_description:                   Functions and Variables for statistical graphs.
                                                             (line  234)
* break:                                 Functions and Variables for Function Definition.
                                                             (line  137)
* breakup:                               Functions and Variables for Equations.
                                                             (line  253)
* browser:                               Functions and Variables for Help.
                                                             (line  170)
* Bugs:                                  Functions and Variables for Bug Detection and Reporting.
                                                             (line   75)
* bug_report:                            Functions and Variables for Bug Detection and Reporting.
                                                             (line   74)
* buildq:                                Macros.             (line    6)
* build_info:                            Functions and Variables for Bug Detection and Reporting.
                                                             (line   85)
* build_sample:                          Functions and Variables for data manipulation.
                                                             (line    6)
* burn:                                  Functions and Variables for Number Theory.
                                                             (line   52)
* c:                                     Gentran Mode Switches.
                                                             (line    8)
* c2cos:                                 Convert to sin and cos.
                                                             (line    7)
* c2hyp:                                 Convert to Hyperbolic Functions.
                                                             (line    6)
* c2sin:                                 Convert to sin and cos.
                                                             (line    6)
* c2trig:                                Convert to Trignometric Functions.
                                                             (line    6)
* cabs:                                  Functions for Complex Numbers.
                                                             (line    6)
* canform:                               Functions and Variables for itensor.
                                                             (line  589)
* canten:                                Functions and Variables for itensor.
                                                             (line  502)
* capping:                               Functions and Variables for draw.
                                                             (line  372)
* capping <1>:                           Visualization with VTK.
                                                             (line  182)
* cardinality:                           Functions and Variables for Sets.
                                                             (line   51)
* carg:                                  Functions for Complex Numbers.
                                                             (line   98)
* carlson_rc:                            Functions and Variables for Elliptic Integrals.
                                                             (line   55)
* carlson_rd:                            Functions and Variables for Elliptic Integrals.
                                                             (line   91)
* carlson_rf:                            Functions and Variables for Elliptic Integrals.
                                                             (line  109)
* carlson_rj:                            Functions and Variables for Elliptic Integrals.
                                                             (line  125)
* cartan:                                Functions and Variables for Differentiation.
                                                             (line  248)
* cartesian_product:                     Functions and Variables for Sets.
                                                             (line   69)
* cartesian_product_list:                Functions and Variables for Sets.
                                                             (line   89)
* catch:                                 Functions and Variables for Function Definition.
                                                             (line  143)
* cauchysum:                             Functions and Variables for Series.
                                                             (line    6)
* cauchy_matrix:                         Functions and Variables for Matrices and Linear Algebra.
                                                             (line   40)
* cbffac:                                Gamma and Factorial Functions.
                                                             (line   47)
* cbrange:                               Functions and Variables for draw.
                                                             (line  391)
* cbtics:                                Functions and Variables for draw.
                                                             (line  418)
* ccurind:                               Gentran Option Variables.
                                                             (line   50)
* cdf_bernoulli:                         Bernoulli Random Variable.
                                                             (line   29)
* cdf_beta:                              Beta Random Variable.
                                                             (line   23)
* cdf_binomial:                          Binomial Random Variable.
                                                             (line   26)
* cdf_cauchy:                            Cauchy Random Variable.
                                                             (line   26)
* cdf_chi2:                              Chi-squared Random Variable.
                                                             (line   37)
* cdf_continuous_uniform:                Continuous Uniform Random Variable.
                                                             (line   22)
* cdf_discrete_uniform:                  Discrete Uniform Random Variable.
                                                             (line   25)
* cdf_empirical:                         Functions and Variables for descriptive statistics.
                                                             (line  561)
* cdf_exp:                               Exponential Random Variable.
                                                             (line   28)
* cdf_f:                                 F Random Variable.  (line   29)
* cdf_gamma:                             Gamma Random Variable.
                                                             (line   25)
* cdf_general_finite_discrete:           General Finite Discrete Random Variable.
                                                             (line   24)
* cdf_geometric:                         Geometric Random Variable.
                                                             (line   28)
* cdf_gumbel:                            Gumbel Random Variable.
                                                             (line   22)
* cdf_hypergeometric:                    Hypergeometric Random Variable.
                                                             (line   32)
* cdf_laplace:                           Laplace Random Variable.
                                                             (line   28)
* cdf_logistic:                          Logistic Random Variable.
                                                             (line   28)
* cdf_lognormal:                         Lognormal Random Variable.
                                                             (line   27)
* cdf_negative_binomial:                 Negative Binomial Random Variable.
                                                             (line   27)
* cdf_noncentral_chi2:                   Noncentral Chi-squared Random Variable.
                                                             (line   33)
* cdf_noncentral_student_t:              Noncentral Student's t Random Variable.
                                                             (line   84)
* cdf_normal:                            Normal Random Variable.
                                                             (line   25)
* cdf_pareto:                            Pareto Random Variable.
                                                             (line   17)
* cdf_poisson:                           Poisson Random Variable.
                                                             (line   23)
* cdf_rank_sum:                          Functions and Variables for special distributions.
                                                             (line   27)
* cdf_rayleigh:                          Rayleigh Random Variable.
                                                             (line   28)
* cdf_signed_rank:                       Functions and Variables for special distributions.
                                                             (line   13)
* cdf_student_t:                         Student's t Random Variable.
                                                             (line   32)
* cdf_weibull:                           Weibull Random Variable.
                                                             (line   22)
* cdisplay:                              Functions and Variables for ctensor.
                                                             (line  845)
* ceiling:                               Functions for Numbers.
                                                             (line   96)
* center:                                Visualization with VTK.
                                                             (line  189)
* central_moment:                        Functions and Variables for descriptive statistics.
                                                             (line  147)
* cequal:                                Characters.         (line  115)
* cequalignore:                          Characters.         (line  119)
* cf:                                    Functions and Variables for Number Theory.
                                                             (line   94)
* cfdisrep:                              Functions and Variables for Number Theory.
                                                             (line  162)
* cfexpand:                              Functions and Variables for Number Theory.
                                                             (line  179)
* cflength:                              Functions and Variables for Number Theory.
                                                             (line  196)
* cframe_flag:                           Functions and Variables for ctensor.
                                                             (line 1091)
* cgeodesic:                             Functions and Variables for ctensor.
                                                             (line  784)
* cgreaterp:                             Characters.         (line  126)
* cgreaterpignore:                       Characters.         (line  131)
* changename:                            Functions and Variables for itensor.
                                                             (line   24)
* changevar:                             Functions and Variables for Integration.
                                                             (line    6)
* chaosgame:                             Graphical analysis of discrete dynamical systems.
                                                             (line    6)
* charat:                                String Processing.  (line    9)
* charfun:                               Functions and Variables for Predicates.
                                                             (line    6)
* charfun2:                              Functions and Variables for interpol.
                                                             (line  105)
* charlist:                              String Processing.  (line   19)
* charp:                                 Characters.         (line  138)
* charpoly:                              Functions and Variables for Matrices and Linear Algebra.
                                                             (line   73)
* chdir:                                 Directory operations.
                                                             (line    6)
* chebyshev_t:                           Functions and Variables for orthogonal polynomials.
                                                             (line   78)
* chebyshev_u:                           Functions and Variables for orthogonal polynomials.
                                                             (line  120)
* checkdiv:                              Functions and Variables for ctensor.
                                                             (line  775)
* check_overlaps:                        Functions and Variables for Affine.
                                                             (line   88)
* chinese:                               Functions and Variables for Number Theory.
                                                             (line   73)
* cholesky:                              Functions and Variables for linearalgebra.
                                                             (line   44)
* christof:                              Functions and Variables for ctensor.
                                                             (line  199)
* chromatic_index:                       Functions and Variables for graphs.
                                                             (line  374)
* chromatic_number:                      Functions and Variables for graphs.
                                                             (line  383)
* cint:                                  Characters.         (line  143)
* circulant_graph:                       Functions and Variables for graphs.
                                                             (line   72)
* clear_edge_weight:                     Functions and Variables for graphs.
                                                             (line  393)
* clear_rules:                           Functions and Variables for Rules and Patterns.
                                                             (line  876)
* clear_vertex_label:                    Functions and Variables for graphs.
                                                             (line  406)
* clebsch_gordan:                        Functions and Variables for clebsch_gordan.
                                                             (line    6)
* clebsch_graph:                         Functions and Variables for graphs.
                                                             (line   92)
* clessp:                                Characters.         (line  168)
* clesspignore:                          Characters.         (line  173)
* clinelen:                              Gentran Option Variables.
                                                             (line   38)
* close:                                 String Input and Output.
                                                             (line   25)
* closefile:                             Functions and Variables for File Input and Output.
                                                             (line  107)
* cmetric:                               Functions and Variables for ctensor.
                                                             (line   14)
* cnonmet_flag:                          Functions and Variables for ctensor.
                                                             (line 1106)
* CNOT:                                  Functions and Variables for Quantum_Computing.
                                                             (line   23)
* coeff:                                 Functions and Variables for Polynomials.
                                                             (line   52)
* coefmatrix:                            Functions and Variables for Matrices and Linear Algebra.
                                                             (line  110)
* cograd:                                Functions and Variables for ctensor.
                                                             (line  723)
* col:                                   Functions and Variables for Matrices and Linear Algebra.
                                                             (line  120)
* collapse:                              Functions and Variables for Expressions.
                                                             (line  148)
* collectterms:                          Package facexp.     (line   99)
* color:                                 Plotting Options.   (line   70)
* color <1>:                             Functions and Variables for draw.
                                                             (line  441)
* color <2>:                             Visualization with VTK.
                                                             (line  197)
* colorbox:                              Functions and Variables for draw.
                                                             (line  536)
* color_bar:                             Plotting Options.   (line   84)
* color_bar_tics:                        Plotting Options.   (line   95)
* columnop:                              Functions and Variables for linearalgebra.
                                                             (line   26)
* columns:                               Functions and Variables for draw.
                                                             (line  567)
* columnspace:                           Functions and Variables for linearalgebra.
                                                             (line   37)
* columnswap:                            Functions and Variables for linearalgebra.
                                                             (line   32)
* columnvector:                          Functions and Variables for Matrices and Linear Algebra.
                                                             (line  125)
* combination:                           Package functs.     (line  176)
* combine:                               Functions and Variables for Simplification.
                                                             (line   57)
* commutative:                           Functions and Variables for Simplification.
                                                             (line   75)
* comp2pui:                              Functions and Variables for Symmetries.
                                                             (line    9)
* compare:                               Functions and Variables for Predicates.
                                                             (line   23)
* compfile:                              Functions and Variables for Function Definition.
                                                             (line  167)
* compile:                               Functions and Variables for Function Definition.
                                                             (line  186)
* compile_file:                          Functions and Variables for Function Definition.
                                                             (line 1411)
* complement_graph:                      Functions and Variables for graphs.
                                                             (line   95)
* complete_bipartite_graph:              Functions and Variables for graphs.
                                                             (line   98)
* complete_graph:                        Functions and Variables for graphs.
                                                             (line  101)
* complex:                               Functions and Variables for Properties.
                                                             (line  540)
* Complex infinity:                      Functions and Variables for Constants.
                                                             (line   54)
* complex_number_p:                      Functions and Variables for to_poly_solve.
                                                             (line  206)
* components:                            Functions and Variables for itensor.
                                                             (line  196)
* compose_functions:                     Functions and Variables for to_poly_solve.
                                                             (line  229)
* concan:                                Functions and Variables for itensor.
                                                             (line  514)
* concat:                                Functions and Variables for Strings.
                                                             (line    6)
* conditional evaluation:                Functions and Variables for to_poly_solve.
                                                             (line   90)
* cone:                                  Visualization with VTK.
                                                             (line  126)
* conjugate:                             Functions for Complex Numbers.
                                                             (line  148)
* conmetderiv:                           Functions and Variables for itensor.
                                                             (line  786)
* connected_components:                  Functions and Variables for graphs.
                                                             (line  419)
* connect_vertices:                      Functions and Variables for graphs.
                                                             (line 1226)
* cons:                                  Functions and Variables for Lists.
                                                             (line   99)
* constant:                              Functions and Variables for Properties.
                                                             (line   42)
* constantp:                             Functions and Variables for Properties.
                                                             (line   61)
* constituent:                           Characters.         (line  180)
* constvalue:                            Functions and Variables for ezunits.
                                                             (line  253)
* cont2part:                             Functions and Variables for Symmetries.
                                                             (line  209)
* content:                               Functions and Variables for Polynomials.
                                                             (line  146)
* context:                               Functions and Variables for Facts.
                                                             (line  237)
* contexts:                              Functions and Variables for Facts.
                                                             (line  251)
* continuous_freq:                       Functions and Variables for data manipulation.
                                                             (line   62)
* contortion:                            Functions and Variables for ctensor.
                                                             (line  655)
* contour:                               Functions and Variables for draw.
                                                             (line  586)
* contour_levels:                        Functions and Variables for draw.
                                                             (line  621)
* contract:                              Functions and Variables for itensor.
                                                             (line  180)
* contract <1>:                          Functions and Variables for Symmetries.
                                                             (line  220)
* Contraction with a vector:             Functions and Variables for itensor.
                                                             (line 1443)
* contract_edge:                         Functions and Variables for graphs.
                                                             (line 1244)
* contragrad:                            Functions and Variables for ctensor.
                                                             (line  728)
* contrib_ode:                           Functions and Variables for contrib_ode.
                                                             (line    6)
* controlled:                            Functions and Variables for Quantum_Computing.
                                                             (line   29)
* convert:                               Functions and Variables for Units.
                                                             (line  140)
* coord:                                 Functions and Variables for itensor.
                                                             (line  764)
* copy:                                  Functions and Variables for Expressions.
                                                             (line  159)
* copylist:                              Functions and Variables for Lists.
                                                             (line  134)
* copymatrix:                            Functions and Variables for Matrices and Linear Algebra.
                                                             (line  152)
* copy_file:                             File operations.    (line    6)
* copy_graph:                            Functions and Variables for graphs.
                                                             (line   69)
* cor:                                   Functions and Variables for descriptive statistics.
                                                             (line  694)
* cos:                                   Trigonometric and Hyperbolic Functions.
                                                             (line   63)
* cosh:                                  Trigonometric and Hyperbolic Functions.
                                                             (line   67)
* cosnpiflag:                            Functions and Variables for Fourier series.
                                                             (line   64)
* cot:                                   Trigonometric and Hyperbolic Functions.
                                                             (line   71)
* coth:                                  Trigonometric and Hyperbolic Functions.
                                                             (line   75)
* cov:                                   Functions and Variables for descriptive statistics.
                                                             (line  592)
* cov1:                                  Functions and Variables for descriptive statistics.
                                                             (line  621)
* covdiff:                               Functions and Variables for itensor.
                                                             (line  936)
* covect:                                Functions and Variables for Matrices and Linear Algebra.
                                                             (line  126)
* covers:                                Package functs.     (line  161)
* crc24sum:                              Octets and Utilities for Cryptography.
                                                             (line   44)
* create_graph:                          Functions and Variables for graphs.
                                                             (line    9)
* create_list:                           Functions and Variables for Lists.
                                                             (line  138)
* csc:                                   Trigonometric and Hyperbolic Functions.
                                                             (line   79)
* csch:                                  Trigonometric and Hyperbolic Functions.
                                                             (line   83)
* csetup:                                Functions and Variables for ctensor.
                                                             (line    9)
* cspline:                               Functions and Variables for interpol.
                                                             (line  213)
* ctaylor:                               Functions and Variables for ctensor.
                                                             (line  331)
* ctaypov:                               Functions and Variables for ctensor.
                                                             (line 1125)
* ctaypt:                                Functions and Variables for ctensor.
                                                             (line 1130)
* ctayswitch:                            Functions and Variables for ctensor.
                                                             (line 1113)
* ctayvar:                               Functions and Variables for ctensor.
                                                             (line 1120)
* ctorsion_flag:                         Functions and Variables for ctensor.
                                                             (line 1100)
* ctransform:                            Functions and Variables for ctensor.
                                                             (line  668)
* ctranspose:                            Functions and Variables for linearalgebra.
                                                             (line   53)
* ctrgsimp:                              Functions and Variables for ctensor.
                                                             (line 1085)
* ct_coords:                             Functions and Variables for ctensor.
                                                             (line 1262)
* ct_coordsys:                           Functions and Variables for ctensor.
                                                             (line   35)
* cube:                                  Visualization with VTK.
                                                             (line  143)
* cube_graph:                            Functions and Variables for graphs.
                                                             (line  113)
* cuboctahedron_graph:                   Functions and Variables for graphs.
                                                             (line  110)
* Current input expression:              Functions and Variables for Command Line.
                                                             (line    7)
* current_let_rule_package:              Functions and Variables for Rules and Patterns.
                                                             (line   51)
* cv:                                    Functions and Variables for descriptive statistics.
                                                             (line  173)
* cyclep:                                Functions and Variables for Combinatorics.
                                                             (line   26)
* cycle_digraph:                         Functions and Variables for graphs.
                                                             (line  104)
* cycle_graph:                           Functions and Variables for graphs.
                                                             (line  107)
* cylinder:                              Visualization with VTK.
                                                             (line  150)
* cylindrical:                           Functions and Variables for draw.
                                                             (line 2856)
* data_file_name:                        Functions and Variables for draw.
                                                             (line  669)
* days360:                               Functions and Variables for finance.
                                                             (line    6)
* dblfloat:                              Gentran Option Variables.
                                                             (line   73)
* dblint:                                Functions and Variables for Integration.
                                                             (line   61)
* deactivate:                            Functions and Variables for Facts.
                                                             (line  280)
* debugmode:                             Functions and Variables for Debugging.
                                                             (line    6)
* declare:                               Functions and Variables for Properties.
                                                             (line   94)
* declare_constvalue:                    Functions and Variables for ezunits.
                                                             (line  276)
* declare_dimensions:                    Functions and Variables for ezunits.
                                                             (line  487)
* declare_fundamental_dimensions:        Functions and Variables for ezunits.
                                                             (line  519)
* declare_fundamental_units:             Functions and Variables for ezunits.
                                                             (line  550)
* declare_index_properties:              Functions and Variables for Display.
                                                             (line   37)
* declare_index_properties <1>:          Functions and Variables for Display.
                                                             (line   38)
* declare_qty:                           Functions and Variables for ezunits.
                                                             (line  386)
* declare_translated:                    Functions and Variables for Function Definition.
                                                             (line 1441)
* declare_units:                         Functions and Variables for ezunits.
                                                             (line  336)
* declare_unit_conversion:               Functions and Variables for ezunits.
                                                             (line  444)
* declare_weights:                       Functions and Variables for Affine.
                                                             (line   57)
* decode_float:                          Functions and Variables for Numbers.
                                                             (line  121)
* decode_time:                           Functions and Variables for Runtime Environment.
                                                             (line  313)
* decreasing:                            Functions and Variables for Properties.
                                                             (line  234)
* decsym:                                Functions and Variables for itensor.
                                                             (line  529)
* default_let_rule_package:              Functions and Variables for Rules and Patterns.
                                                             (line   63)
* defcon:                                Functions and Variables for itensor.
                                                             (line  154)
* define:                                Functions and Variables for Function Definition.
                                                             (line  219)
* define_alt_display:                    Functions and Variables for alt-display.
                                                             (line   54)
* define_opproperty:                     Functions and Variables for Simplification.
                                                             (line  591)
* define_variable:                       Functions and Variables for Function Definition.
                                                             (line  313)
* defint:                                Functions and Variables for Integration.
                                                             (line  106)
* defmatch:                              Functions and Variables for Rules and Patterns.
                                                             (line   70)
* defrule:                               Functions and Variables for Rules and Patterns.
                                                             (line  172)
* defstruct:                             Functions and Variables for Structures.
                                                             (line   11)
* deftaylor:                             Functions and Variables for Series.
                                                             (line   38)
* degree_sequence:                       Functions and Variables for graphs.
                                                             (line  456)
* del:                                   Functions and Variables for Differentiation.
                                                             (line  278)
* delay:                                 Functions and Variables for draw.
                                                             (line  681)
* delete:                                Functions and Variables for Lists.
                                                             (line  168)
* deleten:                               Functions and Variables for ctensor.
                                                             (line 1061)
* delete_file:                           File operations.    (line   12)
* delta:                                 Functions and Variables for Differentiation.
                                                             (line  300)
* demo:                                  Functions and Variables for Help.
                                                             (line   43)
* demoivre:                              Functions and Variables for Simplification.
                                                             (line   96)
* demoivre <1>:                          Functions and Variables for Simplification.
                                                             (line   97)
* denom:                                 Functions and Variables for Polynomials.
                                                             (line  159)
* dependencies:                          Functions and Variables for Differentiation.
                                                             (line  315)
* dependencies <1>:                      Functions and Variables for Differentiation.
                                                             (line  316)
* depends:                               Functions and Variables for Differentiation.
                                                             (line  353)
* derivabbrev:                           Functions and Variables for Differentiation.
                                                             (line  414)
* derivdegree:                           Functions and Variables for Differentiation.
                                                             (line  421)
* derivlist:                             Functions and Variables for Differentiation.
                                                             (line  438)
* derivsubst:                            Functions and Variables for Differentiation.
                                                             (line  443)
* describe:                              Functions and Variables for Help.
                                                             (line   80)
* desolve:                               Functions and Variables for Differential Equations.
                                                             (line   17)
* determinant:                           Functions and Variables for Matrices and Linear Algebra.
                                                             (line  163)
* detout:                                Functions and Variables for Matrices and Linear Algebra.
                                                             (line  174)
* dfloat:                                Functions and Variables for to_poly_solve.
                                                             (line  282)
* dgauss_a:                              Functions and Variables for contrib_ode.
                                                             (line   70)
* dgauss_b:                              Functions and Variables for contrib_ode.
                                                             (line   74)
* dgeev:                                 Functions and Variables for lapack.
                                                             (line    6)
* dgemm:                                 Functions and Variables for lapack.
                                                             (line  300)
* dgeqrf:                                Functions and Variables for lapack.
                                                             (line   73)
* dgesv:                                 Functions and Variables for lapack.
                                                             (line  104)
* dgesvd:                                Functions and Variables for lapack.
                                                             (line  176)
* diag:                                  Functions and Variables for diag.
                                                             (line    6)
* diagmatrix:                            Functions and Variables for Matrices and Linear Algebra.
                                                             (line  201)
* diagmatrixp:                           Functions and Variables for ctensor.
                                                             (line  824)
* diagmetric:                            Functions and Variables for ctensor.
                                                             (line 1075)
* diag_matrix:                           Functions and Variables for linearalgebra.
                                                             (line   59)
* diameter:                              Functions and Variables for graphs.
                                                             (line  429)
* diff:                                  Functions and Variables for Differentiation.
                                                             (line  531)
* diff <1>:                              Functions and Variables for Differentiation.
                                                             (line  449)
* diff <2>:                              Functions and Variables for itensor.
                                                             (line  611)
* digitcharp:                            Characters.         (line  193)
* dim:                                   Functions and Variables for ctensor.
                                                             (line 1068)
* dimacs_export:                         Functions and Variables for graphs.
                                                             (line 1294)
* dimacs_import:                         Functions and Variables for graphs.
                                                             (line 1301)
* dimension:                             Functions and Variables for Equations.
                                                             (line  323)
* dimensionless:                         Functions and Variables for ezunits.
                                                             (line  671)
* dimensions:                            Functions and Variables for draw.
                                                             (line  707)
* dimensions <1>:                        Functions and Variables for ezunits.
                                                             (line  591)
* dimensions_as_list:                    Functions and Variables for ezunits.
                                                             (line  592)
* direct:                                Functions and Variables for Symmetries.
                                                             (line  273)
* directory:                             Functions and Variables for File Input and Output.
                                                             (line  337)
* discrete_freq:                         Functions and Variables for data manipulation.
                                                             (line  145)
* disjoin:                               Functions and Variables for Sets.
                                                             (line  165)
* disjointp:                             Functions and Variables for Sets.
                                                             (line  184)
* disolate:                              Functions and Variables for Expressions.
                                                             (line  186)
* disp:                                  Functions and Variables for Display.
                                                             (line  258)
* dispcon:                               Functions and Variables for itensor.
                                                             (line    9)
* dispflag:                              Functions and Variables for Equations.
                                                             (line  331)
* dispform:                              Functions and Variables for Expressions.
                                                             (line  196)
* dispfun:                               Functions and Variables for Function Definition.
                                                             (line  406)
* dispJordan:                            Functions and Variables for diag.
                                                             (line  113)
* display:                               Functions and Variables for Display.
                                                             (line  281)
* display2d:                             Functions and Variables for Display.
                                                             (line  307)
* display_format_internal:               Functions and Variables for Display.
                                                             (line  348)
* display_index_separator:               Functions and Variables for Display.
                                                             (line  136)
* disprule:                              Functions and Variables for Rules and Patterns.
                                                             (line  186)
* dispsym:                               Functions and Variables for itensor.
                                                             (line  584)
* dispterms:                             Functions and Variables for Display.
                                                             (line  381)
* distrib:                               Functions and Variables for Simplification.
                                                             (line  113)
* distribute_over:                       Functions and Variables for Simplification.
                                                             (line  135)
* divide:                                Functions and Variables for Polynomials.
                                                             (line  180)
* Division:                              Arithmetic operators.
                                                             (line    6)
* divisors:                              Functions and Variables for Sets.
                                                             (line  196)
* divsum:                                Functions and Variables for Number Theory.
                                                             (line  213)
* dkummer_m:                             Functions and Variables for contrib_ode.
                                                             (line   96)
* dkummer_u:                             Functions and Variables for contrib_ode.
                                                             (line   99)
* dlange:                                Functions and Variables for lapack.
                                                             (line  278)
* dlsode_init:                           Functions and Variables for odepack.
                                                             (line    6)
* dlsode_step:                           Functions and Variables for odepack.
                                                             (line   49)
* do:                                    Functions and Variables for Program Flow.
                                                             (line   54)
* doallmxops:                            Functions and Variables for Matrices and Linear Algebra.
                                                             (line  214)
* dodecahedron_graph:                    Functions and Variables for graphs.
                                                             (line  116)
* domain:                                Functions and Variables for Simplification.
                                                             (line  195)
* domxexpt:                              Functions and Variables for Matrices and Linear Algebra.
                                                             (line  221)
* domxmxops:                             Functions and Variables for Matrices and Linear Algebra.
                                                             (line  253)
* domxnctimes:                           Functions and Variables for Matrices and Linear Algebra.
                                                             (line  260)
* dontfactor:                            Functions and Variables for Matrices and Linear Algebra.
                                                             (line  266)
* doscmxops:                             Functions and Variables for Matrices and Linear Algebra.
                                                             (line  276)
* doscmxplus:                            Functions and Variables for Matrices and Linear Algebra.
                                                             (line  282)
* dot0nscsimp:                           Functions and Variables for Matrices and Linear Algebra.
                                                             (line  288)
* dot0simp:                              Functions and Variables for Matrices and Linear Algebra.
                                                             (line  294)
* dot1simp:                              Functions and Variables for Matrices and Linear Algebra.
                                                             (line  300)
* dotassoc:                              Functions and Variables for Matrices and Linear Algebra.
                                                             (line  306)
* dotconstrules:                         Functions and Variables for Matrices and Linear Algebra.
                                                             (line  312)
* dotdistrib:                            Functions and Variables for Matrices and Linear Algebra.
                                                             (line  320)
* dotexptsimp:                           Functions and Variables for Matrices and Linear Algebra.
                                                             (line  326)
* dotident:                              Functions and Variables for Matrices and Linear Algebra.
                                                             (line  332)
* dotproduct:                            Functions and Variables for linearalgebra.
                                                             (line   81)
* dotscrules:                            Functions and Variables for Matrices and Linear Algebra.
                                                             (line  337)
* dotsimp:                               Functions and Variables for Affine.
                                                             (line   69)
* Double factorial:                      Combinatorial Functions.
                                                             (line    7)
* dpart:                                 Functions and Variables for Expressions.
                                                             (line  250)
* draw:                                  Functions and Variables for draw.
                                                             (line   67)
* draw2d:                                Functions and Variables for draw.
                                                             (line  120)
* draw3d:                                Functions and Variables for draw.
                                                             (line  130)
* drawdf:                                Functions and Variables for drawdf.
                                                             (line    9)
* draw_file:                             Functions and Variables for draw.
                                                             (line  140)
* draw_graph:                            Functions and Variables for graphs.
                                                             (line 1344)
* draw_graph_program:                    Functions and Variables for graphs.
                                                             (line 1450)
* draw_realpart:                         Functions and Variables for draw.
                                                             (line  749)
* draw_renderer:                         Functions and Variables for draw.
                                                             (line 3737)
* dscalar:                               Functions and Variables for ctensor.
                                                             (line  755)
* e:                                     Functions and Variables for Constants.
                                                             (line    7)
* echelon:                               Functions and Variables for Matrices and Linear Algebra.
                                                             (line  343)
* edges:                                 Functions and Variables for graphs.
                                                             (line  469)
* edge_color:                            Functions and Variables for graphs.
                                                             (line 1516)
* edge_coloring:                         Functions and Variables for graphs.
                                                             (line 1545)
* edge_coloring <1>:                     Functions and Variables for graphs.
                                                             (line  437)
* edge_connectivity:                     Functions and Variables for graphs.
                                                             (line  464)
* edge_partition:                        Functions and Variables for graphs.
                                                             (line 1540)
* edge_type:                             Functions and Variables for graphs.
                                                             (line 1522)
* edge_width:                            Functions and Variables for graphs.
                                                             (line 1519)
* eigens_by_jacobi:                      Functions and Variables for linearalgebra.
                                                             (line   87)
* eigenvalues:                           Functions and Variables for Matrices and Linear Algebra.
                                                             (line  374)
* eigenvectors:                          Functions and Variables for Matrices and Linear Algebra.
                                                             (line  406)
* eighth:                                Functions and Variables for Lists.
                                                             (line  231)
* einstein:                              Functions and Variables for ctensor.
                                                             (line  234)
* eivals:                                Functions and Variables for Matrices and Linear Algebra.
                                                             (line  375)
* eivects:                               Functions and Variables for Matrices and Linear Algebra.
                                                             (line  407)
* elapsed_real_time:                     Functions and Variables for Runtime Environment.
                                                             (line  368)
* elapsed_run_time:                      Functions and Variables for Runtime Environment.
                                                             (line  384)
* ele2comp:                              Functions and Variables for Symmetries.
                                                             (line   27)
* ele2polynome:                          Functions and Variables for Symmetries.
                                                             (line  495)
* ele2pui:                               Functions and Variables for Symmetries.
                                                             (line   21)
* elem:                                  Functions and Variables for Symmetries.
                                                             (line   33)
* elementp:                              Functions and Variables for Sets.
                                                             (line  239)
* elevation:                             Plotting Options.   (line  108)
* elevation <1>:                         Visualization with VTK.
                                                             (line   77)
* elevation_grid:                        Functions and Variables for draw.
                                                             (line 2877)
* elim:                                  Functions and Variables for to_poly_solve.
                                                             (line  312)
* eliminate:                             Functions and Variables for Polynomials.
                                                             (line  197)
* eliminate_using:                       Functions and Variables for to_poly_solve.
                                                             (line  397)
* elim_allbut:                           Functions and Variables for to_poly_solve.
                                                             (line  376)
* ellipse:                               Functions and Variables for draw.
                                                             (line 2904)
* elliptic_e:                            Functions and Variables for Elliptic Integrals.
                                                             (line   13)
* elliptic_ec:                           Functions and Variables for Elliptic Integrals.
                                                             (line   47)
* elliptic_eu:                           Functions and Variables for Elliptic Integrals.
                                                             (line   20)
* elliptic_f:                            Functions and Variables for Elliptic Integrals.
                                                             (line    6)
* elliptic_kc:                           Functions and Variables for Elliptic Integrals.
                                                             (line   39)
* elliptic_pi:                           Functions and Variables for Elliptic Integrals.
                                                             (line   34)
* ematrix:                               Functions and Variables for Matrices and Linear Algebra.
                                                             (line  523)
* emptyp:                                Functions and Variables for Sets.
                                                             (line  251)
* empty_graph:                           Functions and Variables for graphs.
                                                             (line  119)
* encode_time:                           Functions and Variables for Runtime Environment.
                                                             (line  252)
* endcons:                               Functions and Variables for Lists.
                                                             (line  236)
* endphi:                                Visualization with VTK.
                                                             (line  203)
* endtheta:                              Visualization with VTK.
                                                             (line  214)
* engineering_format_floats:             Functions and Variables for engineering-format.
                                                             (line    6)
* engineering_format_max:                Functions and Variables for engineering-format.
                                                             (line   40)
* engineering_format_min:                Functions and Variables for engineering-format.
                                                             (line   21)
* enhanced3d:                            Functions and Variables for draw.
                                                             (line  768)
* entermatrix:                           Functions and Variables for Matrices and Linear Algebra.
                                                             (line  528)
* entertensor:                           Functions and Variables for itensor.
                                                             (line   17)
* entier:                                Functions for Numbers.
                                                             (line  186)
* epsilon_lp:                            Functions and Variables for simplex.
                                                             (line    6)
* equal:                                 Functions and Variables for Predicates.
                                                             (line   54)
* Equal (syntactic equality):            Operators for Equations.
                                                             (line   31)
* equalp:                                Functions and Variables for Fourier series.
                                                             (line    6)
* Equation operator:                     Operators for Equations.
                                                             (line   31)
* equiv_classes:                         Functions and Variables for Sets.
                                                             (line  262)
* erf:                                   Error Function.     (line   11)
* erfc:                                  Error Function.     (line   23)
* erfflag:                               Functions and Variables for Integration.
                                                             (line  119)
* erfi:                                  Error Function.     (line   33)
* erf_generalized:                       Error Function.     (line   36)
* erf_representation:                    Error Function.     (line   75)
* errcatch:                              Functions and Variables for Program Flow.
                                                             (line  253)
* error:                                 Functions and Variables for Program Flow.
                                                             (line  267)
* error <1>:                             Functions and Variables for Program Flow.
                                                             (line  268)
* errormsg:                              Functions and Variables for Program Flow.
                                                             (line  354)
* errormsg <1>:                          Functions and Variables for Program Flow.
                                                             (line  349)
* errors:                                Functions and Variables for draw.
                                                             (line 2935)
* error_size:                            Functions and Variables for Program Flow.
                                                             (line  290)
* error_syms:                            Functions and Variables for Program Flow.
                                                             (line  334)
* error_type:                            Functions and Variables for draw.
                                                             (line  907)
* euler:                                 Functions and Variables for Number Theory.
                                                             (line  231)
* Euler’s number:                        Functions and Variables for Constants.
                                                             (line    7)
* Euler-Mascheroni constant:             Functions and Variables for Constants.
                                                             (line   24)
* ev:                                    Functions and Variables for Evaluation.
                                                             (line  268)
* eval:                                  Functions and Variables for Evaluation.
                                                             (line  438)
* eval <1>:                              Gentran Evaluation Forms.
                                                             (line   12)
* eval_string:                           String Processing.  (line   26)
* eval_string_lisp:                      Functions and Variables for Command Line.
                                                             (line  644)
* even:                                  Functions and Variables for Properties.
                                                             (line  254)
* evenfun:                               Functions and Variables for Simplification.
                                                             (line  201)
* evenp:                                 Functions and Variables for Numbers.
                                                             (line  153)
* every:                                 Functions and Variables for Sets.
                                                             (line  297)
* evflag:                                Functions and Variables for Evaluation.
                                                             (line  456)
* evfun:                                 Functions and Variables for Evaluation.
                                                             (line  520)
* evolution:                             Graphical analysis of discrete dynamical systems.
                                                             (line   22)
* evolution2d:                           Graphical analysis of discrete dynamical systems.
                                                             (line   40)
* evundiff:                              Functions and Variables for itensor.
                                                             (line  684)
* ev_point:                              Functions and Variables for zeilberger.
                                                             (line  147)
* example:                               Functions and Variables for Help.
                                                             (line  203)
* exp:                                   Root Exponential and Logarithmic Functions.
                                                             (line   86)
* expand:                                Functions and Variables for Simplification.
                                                             (line  222)
* expandwrt:                             Functions and Variables for Simplification.
                                                             (line  315)
* expandwrt_denom:                       Functions and Variables for Simplification.
                                                             (line  328)
* expandwrt_factored:                    Functions and Variables for Simplification.
                                                             (line  337)
* expintegral_chi:                       Exponential Integrals.
                                                             (line   89)
* expintegral_ci:                        Exponential Integrals.
                                                             (line   67)
* expintegral_e:                         Exponential Integrals.
                                                             (line   46)
* expintegral_e1:                        Exponential Integrals.
                                                             (line   10)
* expintegral_ei:                        Exponential Integrals.
                                                             (line   22)
* expintegral_e_simplify:                Functions and Variables for contrib_ode.
                                                             (line  125)
* expintegral_li:                        Exponential Integrals.
                                                             (line   34)
* expintegral_shi:                       Exponential Integrals.
                                                             (line   79)
* expintegral_si:                        Exponential Integrals.
                                                             (line   57)
* expintexpand:                          Exponential Integrals.
                                                             (line  294)
* expintrep:                             Exponential Integrals.
                                                             (line  101)
* explicit:                              Functions and Variables for draw.
                                                             (line 2974)
* explose:                               Functions and Variables for Symmetries.
                                                             (line  237)
* expon:                                 Functions and Variables for Simplification.
                                                             (line  345)
* exponentialize:                        Functions and Variables for Simplification.
                                                             (line  353)
* exponentialize <1>:                    Functions and Variables for Simplification.
                                                             (line  354)
* Exponentiation:                        Arithmetic operators.
                                                             (line    6)
* expop:                                 Functions and Variables for Simplification.
                                                             (line  368)
* express:                               Functions and Variables for Differentiation.
                                                             (line  536)
* expt:                                  Functions and Variables for Display.
                                                             (line  408)
* exptdispflag:                          Functions and Variables for Display.
                                                             (line  417)
* exptisolate:                           Functions and Variables for Expressions.
                                                             (line  265)
* exptsubst:                             Functions and Variables for Expressions.
                                                             (line  271)
* exsec:                                 Package functs.     (line  166)
* extdiff:                               Functions and Variables for itensor.
                                                             (line 1473)
* extract_linear_equations:              Functions and Variables for Affine.
                                                             (line  113)
* extremal_subset:                       Functions and Variables for Sets.
                                                             (line  365)
* ezgcd:                                 Functions and Variables for Polynomials.
                                                             (line  225)
* f90:                                   Package f90.        (line   43)
* f90_output_line_length_max:            Package f90.        (line    6)
* facexpand:                             Functions and Variables for Polynomials.
                                                             (line  257)
* facsum:                                Package facexp.     (line   27)
* facsum_combine:                        Package facexp.     (line   78)
* factcomb:                              Combinatorial Functions.
                                                             (line   47)
* factlim:                               Combinatorial Functions.
                                                             (line  157)
* factor:                                Functions and Variables for Polynomials.
                                                             (line  264)
* factorfacsum:                          Package facexp.     (line   93)
* factorflag:                            Functions and Variables for Polynomials.
                                                             (line  446)
* factorial:                             Combinatorial Functions.
                                                             (line   73)
* factorial_expand:                      Combinatorial Functions.
                                                             (line  163)
* factorout:                             Functions and Variables for Polynomials.
                                                             (line  452)
* factorsum:                             Functions and Variables for Polynomials.
                                                             (line  471)
* factors_only:                          Functions and Variables for Number Theory.
                                                             (line  245)
* factor_max_degree:                     Functions and Variables for Polynomials.
                                                             (line  403)
* factor_max_degree_print_warning:       Functions and Variables for Polynomials.
                                                             (line  436)
* facts:                                 Functions and Variables for Facts.
                                                             (line  284)
* false:                                 Functions and Variables for Constants.
                                                             (line   18)
* fasttimes:                             Functions and Variables for Polynomials.
                                                             (line  491)
* fast_central_elements:                 Functions and Variables for Affine.
                                                             (line   76)
* fast_linsolve:                         Functions and Variables for Affine.
                                                             (line    6)
* fb:                                    Functions and Variables for ctensor.
                                                             (line 1212)
* feature:                               Functions and Variables for Properties.
                                                             (line  275)
* featurep:                              Functions and Variables for Properties.
                                                             (line  285)
* features:                              Functions and Variables for Properties.
                                                             (line  302)
* fernfale:                              Definitions for IFS fractals.
                                                             (line   42)
* Fetch documentation:                   Functions and Variables for Command Line.
                                                             (line  183)
* Fetch documentation (inexact search):  Functions and Variables for Command Line.
                                                             (line  196)
* fft:                                   Functions and Variables for fast Fourier transform.
                                                             (line  108)
* fftpack5_fft:                          Functions and Variables for FFTPACK5.
                                                             (line   15)
* fftpack5_inverse_fft:                  Functions and Variables for FFTPACK5.
                                                             (line   66)
* fftpack5_inverse_real_fft:             Functions and Variables for FFTPACK5.
                                                             (line   93)
* fftpack5_real_fft:                     Functions and Variables for FFTPACK5.
                                                             (line   71)
* fib:                                   Functions and Variables for Number Theory.
                                                             (line  255)
* fibtophi:                              Functions and Variables for Number Theory.
                                                             (line  264)
* fifth:                                 Functions and Variables for Lists.
                                                             (line  267)
* filename_merge:                        Functions and Variables for File Input and Output.
                                                             (line  125)
* file_name:                             Functions and Variables for draw.
                                                             (line  917)
* file_name <1>:                         Functions and Variables for graphs.
                                                             (line 1575)
* file_output_append:                    Functions and Variables for File Input and Output.
                                                             (line  111)
* file_search:                           Functions and Variables for File Input and Output.
                                                             (line  134)
* file_search_demo:                      Functions and Variables for File Input and Output.
                                                             (line  177)
* file_search_lisp:                      Functions and Variables for File Input and Output.
                                                             (line  176)
* file_search_maxima:                    Functions and Variables for File Input and Output.
                                                             (line  175)
* file_search_tests:                     Functions and Variables for File Input and Output.
                                                             (line  179)
* file_search_usage:                     Functions and Variables for File Input and Output.
                                                             (line  178)
* file_type:                             Functions and Variables for File Input and Output.
                                                             (line  213)
* file_type_lisp:                        Functions and Variables for File Input and Output.
                                                             (line  235)
* file_type_maxima:                      Functions and Variables for File Input and Output.
                                                             (line  243)
* fillarray:                             Functions and Variables for Arrays.
                                                             (line  224)
* filled_func:                           Functions and Variables for draw.
                                                             (line  952)
* fill_color:                            Functions and Variables for draw.
                                                             (line  936)
* fill_density:                          Functions and Variables for draw.
                                                             (line  944)
* findde:                                Functions and Variables for ctensor.
                                                             (line  676)
* find_root:                             Functions for numerical solution of equations.
                                                             (line   34)
* find_root <1>:                         Functions for numerical solution of equations.
                                                             (line   35)
* find_root_abs:                         Functions for numerical solution of equations.
                                                             (line   39)
* find_root_error:                       Functions for numerical solution of equations.
                                                             (line   38)
* find_root_rel:                         Functions for numerical solution of equations.
                                                             (line   40)
* first:                                 Functions and Variables for Lists.
                                                             (line  272)
* firstn:                                Functions and Variables for Lists.
                                                             (line  312)
* fix:                                   Functions for Numbers.
                                                             (line  239)
* fixed_vertices:                        Functions and Variables for graphs.
                                                             (line 1586)
* flatten:                               Functions and Variables for Sets.
                                                             (line  387)
* flength:                               String Input and Output.
                                                             (line   29)
* flipflag:                              Functions and Variables for itensor.
                                                             (line  140)
* float:                                 Functions and Variables for Numbers.
                                                             (line  161)
* float2bf:                              Functions and Variables for Numbers.
                                                             (line  168)
* floatnump:                             Functions and Variables for Numbers.
                                                             (line  190)
* float_bits:                            Functions and Variables for Numbers.
                                                             (line  175)
* float_eps:                             Functions and Variables for Numbers.
                                                             (line  178)
* float_precision:                       Functions and Variables for Numbers.
                                                             (line  182)
* floor:                                 Functions for Numbers.
                                                             (line  192)
* flower_snark:                          Functions and Variables for graphs.
                                                             (line  122)
* flush:                                 Functions and Variables for itensor.
                                                             (line  740)
* flush1deriv:                           Functions and Variables for itensor.
                                                             (line  888)
* flushd:                                Functions and Variables for itensor.
                                                             (line  744)
* flushnd:                               Functions and Variables for itensor.
                                                             (line  748)
* flush_output:                          String Input and Output.
                                                             (line   37)
* fmin_cobyla:                           Functions and Variables for cobyla.
                                                             (line    6)
* font:                                  Functions and Variables for draw.
                                                             (line  985)
* font_size:                             Functions and Variables for draw.
                                                             (line 1067)
* for:                                   Functions and Variables for Program Flow.
                                                             (line   57)
* forget:                                Functions and Variables for Facts.
                                                             (line  297)
* fortcurrind:                           Gentran Option Variables.
                                                             (line   26)
* fortindent:                            Functions and Variables for Fortran Output.
                                                             (line    6)
* fortlinelen:                           Gentran Option Variables.
                                                             (line   14)
* fortran:                               Functions and Variables for Fortran Output.
                                                             (line   14)
* fortran <1>:                           Gentran Mode Switches.
                                                             (line    6)
* fortspaces:                            Functions and Variables for Fortran Output.
                                                             (line   70)
* fourcos:                               Functions and Variables for Fourier series.
                                                             (line   75)
* fourexpand:                            Functions and Variables for Fourier series.
                                                             (line   69)
* fourier:                               Functions and Variables for Fourier series.
                                                             (line   49)
* fourier_elim:                          Functions and Variables for to_poly_solve.
                                                             (line  429)
* fourint:                               Functions and Variables for Fourier series.
                                                             (line   90)
* fourintcos:                            Functions and Variables for Fourier series.
                                                             (line   95)
* fourintsin:                            Functions and Variables for Fourier series.
                                                             (line  100)
* foursimp:                              Functions and Variables for Fourier series.
                                                             (line   54)
* foursin:                               Functions and Variables for Fourier series.
                                                             (line   80)
* fourth:                                Functions and Variables for Lists.
                                                             (line  391)
* fposition:                             String Input and Output.
                                                             (line   44)
* fpprec:                                Functions and Variables for Numbers.
                                                             (line  195)
* fpprintprec:                           Functions and Variables for Numbers.
                                                             (line  204)
* frame_bracket:                         Functions and Variables for ctensor.
                                                             (line  465)
* freeof:                                Functions and Variables for Expressions.
                                                             (line  291)
* freshline:                             String Input and Output.
                                                             (line   56)
* fresnel_c:                             Error Function.     (line   43)
* fresnel_s:                             Error Function.     (line   60)
* from:                                  Functions and Variables for Program Flow.
                                                             (line   58)
* from_adjacency_matrix:                 Functions and Variables for graphs.
                                                             (line  131)
* frucht_graph:                          Functions and Variables for graphs.
                                                             (line  134)
* fullmap:                               Functions and Variables for Function Definition.
                                                             (line  492)
* fullmapl:                              Functions and Variables for Function Definition.
                                                             (line  511)
* fullratsimp:                           Functions and Variables for Polynomials.
                                                             (line  500)
* fullratsubst:                          Functions and Variables for Polynomials.
                                                             (line  539)
* fullratsubstflag:                      Functions and Variables for Polynomials.
                                                             (line  588)
* fullsetify:                            Functions and Variables for Sets.
                                                             (line  468)
* full_listify:                          Functions and Variables for Sets.
                                                             (line  454)
* funcsolve:                             Functions and Variables for Equations.
                                                             (line  339)
* Function definition operator:          Assignment operators.
                                                             (line  190)
* functions:                             Functions and Variables for Function Definition.
                                                             (line  521)
* fundamental_dimensions:                Functions and Variables for ezunits.
                                                             (line  521)
* fundamental_units:                     Functions and Variables for ezunits.
                                                             (line  635)
* fundef:                                Functions and Variables for Function Definition.
                                                             (line  566)
* funmake:                               Functions and Variables for Function Definition.
                                                             (line  589)
* funp:                                  Functions and Variables for Fourier series.
                                                             (line   22)
* fv:                                    Functions and Variables for finance.
                                                             (line   17)
* gamma:                                 Gamma and Factorial Functions.
                                                             (line   57)
* gammalim:                              Gamma and Factorial Functions.
                                                             (line  254)
* gamma_expand:                          Gamma and Factorial Functions.
                                                             (line  220)
* gamma_incomplete:                      Gamma and Factorial Functions.
                                                             (line  170)
* gamma_incomplete_generalized:          Gamma and Factorial Functions.
                                                             (line  205)
* gamma_incomplete_lower:                Gamma and Factorial Functions.
                                                             (line  154)
* gamma_incomplete_regularized:          Gamma and Factorial Functions.
                                                             (line  190)
* garbage_collect:                       Garbage Collection. (line   14)
* gate:                                  Functions and Variables for Quantum_Computing.
                                                             (line   42)
* gate_matrix:                           Functions and Variables for Quantum_Computing.
                                                             (line   66)
* gaussprob:                             Package functs.     (line  139)
* gauss_a:                               Functions and Variables for contrib_ode.
                                                             (line   54)
* gauss_b:                               Functions and Variables for contrib_ode.
                                                             (line   67)
* gcd:                                   Functions and Variables for Polynomials.
                                                             (line  593)
* gcdex:                                 Functions and Variables for Polynomials.
                                                             (line  640)
* gcdivide:                              Package functs.     (line   66)
* gcfac:                                 Package scifac.     (line    6)
* gcfactor:                              Functions and Variables for Polynomials.
                                                             (line  682)
* gd:                                    Package functs.     (line  145)
* gdet:                                  Functions and Variables for ctensor.
                                                             (line 1135)
* gendecs:                               Gentran Mode Switches.
                                                             (line   28)
* gendecs <1>:                           Functions for Gentran.
                                                             (line  147)
* generalized_lambert_w:                 Functions and Variables for Special Functions.
                                                             (line   10)
* genfact:                               Combinatorial Functions.
                                                             (line  170)
* genfloat:                              Gentran Option Variables.
                                                             (line   63)
* genindex:                              Functions and Variables for Miscellaneous Options.
                                                             (line   14)
* genmatrix:                             Functions and Variables for Matrices and Linear Algebra.
                                                             (line  567)
* genstmtincr:                           Gentran Option Variables.
                                                             (line  180)
* genstmtno:                             Gentran Option Variables.
                                                             (line  173)
* gensumnum:                             Functions and Variables for Miscellaneous Options.
                                                             (line   20)
* gensym:                                Functions and Variables for Miscellaneous Options.
                                                             (line   27)
* gentran:                               Functions for Gentran.
                                                             (line    6)
* gentranin:                             Functions for Gentran.
                                                             (line   79)
* gentraninshut:                         Functions for Gentran.
                                                             (line  117)
* gentranlang:                           Gentran Option Variables.
                                                             (line    6)
* gentranopt:                            Gentran Option Variables.
                                                             (line  111)
* gentranout:                            Functions for Gentran.
                                                             (line   42)
* gentranparser:                         Gentran Option Variables.
                                                             (line  164)
* gentranpop:                            Functions for Gentran.
                                                             (line   69)
* gentranpush:                           Functions for Gentran.
                                                             (line   62)
* gentranseg:                            Gentran Option Variables.
                                                             (line   81)
* gentranshut:                           Functions for Gentran.
                                                             (line   52)
* gentran_off:                           Functions for Gentran.
                                                             (line  158)
* gentran_on:                            Functions for Gentran.
                                                             (line  154)
* gen_laguerre:                          Functions and Variables for orthogonal polynomials.
                                                             (line  162)
* geomap:                                Functions and Variables for worldmap.
                                                             (line  150)
* geometric:                             Package functs.     (line  115)
* geometric_mean:                        Functions and Variables for descriptive statistics.
                                                             (line  393)
* geomview_command:                      Functions and Variables for Plotting.
                                                             (line    6)
* geosum:                                Package functs.     (line  132)
* geo_amortization:                      Functions and Variables for finance.
                                                             (line  159)
* geo_annuity_fv:                        Functions and Variables for finance.
                                                             (line   92)
* geo_annuity_pv:                        Functions and Variables for finance.
                                                             (line   79)
* get:                                   Functions and Variables for Properties.
                                                             (line  342)
* getcurrentdirectory:                   Directory operations.
                                                             (line   15)
* getenv:                                Environment operations.
                                                             (line    6)
* get_all_vertices_by_label:             Functions and Variables for graphs.
                                                             (line  531)
* get_edge_weight:                       Functions and Variables for graphs.
                                                             (line  477)
* get_index_properties:                  Functions and Variables for Display.
                                                             (line  121)
* get_lu_factors:                        Functions and Variables for linearalgebra.
                                                             (line  147)
* get_output_stream_string:              String Input and Output.
                                                             (line   68)
* get_pixel:                             Functions and Variables for pictures.
                                                             (line    6)
* get_plot_option:                       Functions and Variables for Plotting.
                                                             (line   17)
* get_tex_environment:                   Functions and Variables for TeX Output.
                                                             (line  220)
* get_tex_environment_default:           Functions and Variables for TeX Output.
                                                             (line  260)
* get_unique_vertex_by_label:            Functions and Variables for graphs.
                                                             (line  511)
* get_vertex_label:                      Functions and Variables for graphs.
                                                             (line  497)
* gfactor:                               Functions and Variables for Polynomials.
                                                             (line  689)
* gfactorsum:                            Functions and Variables for Polynomials.
                                                             (line  700)
* ggf:                                   Functions and Variables for ggf.
                                                             (line   35)
* GGFCFMAX:                              Functions and Variables for ggf.
                                                             (line   21)
* GGFINFINITY:                           Functions and Variables for ggf.
                                                             (line    6)
* girth:                                 Functions and Variables for graphs.
                                                             (line  605)
* globalsolve:                           Functions and Variables for Equations.
                                                             (line  361)
* global_variances:                      Functions and Variables for descriptive statistics.
                                                             (line  650)
* gnuplot_close:                         Gnuplot_pipes Format Functions.
                                                             (line   12)
* gnuplot_command:                       Functions and Variables for Plotting.
                                                             (line   27)
* gnuplot_curve_styles:                  Gnuplot Options.    (line  223)
* gnuplot_curve_titles:                  Gnuplot Options.    (line  218)
* gnuplot_default_term_command:          Gnuplot Options.    (line  141)
* gnuplot_dumb_term_command:             Gnuplot Options.    (line  148)
* gnuplot_file_args:                     Functions and Variables for Plotting.
                                                             (line   38)
* gnuplot_file_name:                     Functions and Variables for draw.
                                                             (line 1080)
* gnuplot_out_file:                      Gnuplot Options.    (line   59)
* gnuplot_pdf_term_command:              Gnuplot Options.    (line  156)
* gnuplot_pm3d:                          Gnuplot Options.    (line  122)
* gnuplot_png_term_command:              Gnuplot Options.    (line  164)
* gnuplot_postamble:                     Gnuplot Options.    (line  134)
* gnuplot_preamble:                      Gnuplot Options.    (line  127)
* gnuplot_ps_term_command:               Gnuplot Options.    (line  172)
* gnuplot_replot:                        Gnuplot_pipes Format Functions.
                                                             (line   28)
* gnuplot_reset:                         Gnuplot_pipes Format Functions.
                                                             (line   36)
* gnuplot_restart:                       Gnuplot_pipes Format Functions.
                                                             (line   23)
* gnuplot_script_file:                   Gnuplot Options.    (line   78)
* gnuplot_send:                          Gnuplot_pipes Format Functions.
                                                             (line   17)
* gnuplot_start:                         Gnuplot_pipes Format Functions.
                                                             (line    6)
* gnuplot_strings:                       Gnuplot Options.    (line  181)
* gnuplot_svg_background:                Gnuplot Options.    (line  192)
* gnuplot_svg_term_command:              Gnuplot Options.    (line  210)
* gnuplot_term:                          Gnuplot Options.    (line   13)
* gnuplot_view_args:                     Functions and Variables for Plotting.
                                                             (line   50)
* go:                                    Functions and Variables for Program Flow.
                                                             (line  388)
* Golden mean:                           Functions and Variables for Constants.
                                                             (line   96)
* Gosper:                                Functions and Variables for zeilberger.
                                                             (line   11)
* GosperSum:                             Functions and Variables for zeilberger.
                                                             (line   16)
* Gosper_in_Zeilberger:                  Functions and Variables for zeilberger.
                                                             (line  118)
* gr2d:                                  Functions and Variables for draw.
                                                             (line    9)
* gr3d:                                  Functions and Variables for draw.
                                                             (line   45)
* gradef:                                Functions and Variables for Differentiation.
                                                             (line  596)
* gradefs:                               Functions and Variables for Differentiation.
                                                             (line  643)
* gramschmidt:                           Functions and Variables for Matrices and Linear Algebra.
                                                             (line  628)
* graph6_decode:                         Functions and Variables for graphs.
                                                             (line 1305)
* graph6_encode:                         Functions and Variables for graphs.
                                                             (line 1309)
* graph6_export:                         Functions and Variables for graphs.
                                                             (line 1313)
* graph6_import:                         Functions and Variables for graphs.
                                                             (line 1318)
* graph_center:                          Functions and Variables for graphs.
                                                             (line  559)
* graph_charpoly:                        Functions and Variables for graphs.
                                                             (line  548)
* graph_eigenvalues:                     Functions and Variables for graphs.
                                                             (line  568)
* graph_flow:                            Functions and Variables for finance.
                                                             (line   41)
* graph_order:                           Functions and Variables for graphs.
                                                             (line  596)
* graph_periphery:                       Functions and Variables for graphs.
                                                             (line  578)
* graph_product:                         Functions and Variables for graphs.
                                                             (line  137)
* graph_size:                            Functions and Variables for graphs.
                                                             (line  587)
* graph_union:                           Functions and Variables for graphs.
                                                             (line  145)
* Greater than:                          Relational operators.
                                                             (line    6)
* Greater than or equal:                 Relational operators.
                                                             (line    6)
* great_rhombicosidodecahedron_graph:    Functions and Variables for graphs.
                                                             (line  151)
* great_rhombicuboctahedron_graph:       Functions and Variables for graphs.
                                                             (line  154)
* grid:                                  Plotting Options.   (line  121)
* grid <1>:                              Functions and Variables for draw.
                                                             (line 1102)
* grid2d:                                Plotting Options.   (line  130)
* grid_graph:                            Functions and Variables for graphs.
                                                             (line  148)
* grind:                                 Functions and Variables for Display.
                                                             (line  528)
* grind <1>:                             Functions and Variables for Display.
                                                             (line  438)
* grobner_basis:                         Functions and Variables for Affine.
                                                             (line   22)
* grotzch_graph:                         Functions and Variables for graphs.
                                                             (line  157)
* gruntz:                                Functions and Variables for Limits.
                                                             (line   83)
* guess_exact_value:                     Functions and Variables for pslq.
                                                             (line    6)
* halfangles:                            Options Controlling Simplification.
                                                             (line   81)
* hamilton_cycle:                        Functions and Variables for graphs.
                                                             (line  614)
* hamilton_path:                         Functions and Variables for graphs.
                                                             (line  625)
* hankel:                                Functions and Variables for linearalgebra.
                                                             (line  154)
* hankel_1:                              Bessel Functions.   (line   89)
* hankel_2:                              Bessel Functions.   (line  138)
* harmonic:                              Package functs.     (line  121)
* harmonic_mean:                         Functions and Variables for descriptive statistics.
                                                             (line  365)
* harmonic_number:                       Functions and Variables for solve_rec.
                                                             (line    6)
* harmonic_to_psi:                       Functions and Variables for solve_rec.
                                                             (line   25)
* hav:                                   Package functs.     (line  171)
* head_angle:                            Functions and Variables for draw.
                                                             (line 1124)
* head_angle <1>:                        Functions and Variables for graphs.
                                                             (line 1555)
* head_both:                             Functions and Variables for draw.
                                                             (line 1159)
* head_length:                           Functions and Variables for draw.
                                                             (line 1179)
* head_length <1>:                       Functions and Variables for graphs.
                                                             (line 1560)
* head_type:                             Functions and Variables for draw.
                                                             (line 1202)
* heawood_graph:                         Functions and Variables for graphs.
                                                             (line  160)
* height:                                Visualization with VTK.
                                                             (line   85)
* height <1>:                            Visualization with VTK.
                                                             (line  225)
* Help:                                  Functions and Variables for Help.
                                                             (line   80)
* hermite:                               Functions and Variables for orthogonal polynomials.
                                                             (line  210)
* hessian:                               Functions and Variables for linearalgebra.
                                                             (line  162)
* hgfred:                                Hypergeometric Functions.
                                                             (line  109)
* hilbertmap:                            Definitions for Peano maps.
                                                             (line    9)
* hilbert_matrix:                        Functions and Variables for linearalgebra.
                                                             (line  189)
* hipow:                                 Functions and Variables for Polynomials.
                                                             (line  705)
* histogram:                             Functions and Variables for statistical graphs.
                                                             (line  239)
* histogram_description:                 Functions and Variables for statistical graphs.
                                                             (line  361)
* histogram_skyline:                     Functions and Variables for statistical graphs.
                                                             (line  389)
* hodge:                                 Functions and Variables for itensor.
                                                             (line 1505)
* hompack_polsys:                        Functions and Variables for hompack.
                                                             (line    6)
* horner:                                Functions for numerical solution of equations.
                                                             (line    6)
* hstep:                                 Functions for Numbers.
                                                             (line  243)
* hypergeometric:                        Hypergeometric Functions.
                                                             (line   40)
* hypergeometric_representation:         Error Function.     (line  160)
* hypergeometric_simp:                   Hypergeometric Functions.
                                                             (line   77)
* i:                                     Functions and Variables for Constants.
                                                             (line   15)
* ibase:                                 Functions and Variables for Display.
                                                             (line  540)
* ic1:                                   Functions and Variables for Differential Equations.
                                                             (line   67)
* ic2:                                   Functions and Variables for Differential Equations.
                                                             (line   76)
* icc1:                                  Functions and Variables for itensor.
                                                             (line 1136)
* icc2:                                  Functions and Variables for itensor.
                                                             (line 1153)
* ichr1:                                 Functions and Variables for itensor.
                                                             (line  910)
* ichr2:                                 Functions and Variables for itensor.
                                                             (line  918)
* icosahedron_graph:                     Functions and Variables for graphs.
                                                             (line  163)
* icosidodecahedron_graph:               Functions and Variables for graphs.
                                                             (line  166)
* icounter:                              Functions and Variables for itensor.
                                                             (line  351)
* icurvature:                            Functions and Variables for itensor.
                                                             (line  925)
* ic_convert:                            Functions and Variables for itensor.
                                                             (line 1598)
* ident:                                 Functions and Variables for Matrices and Linear Algebra.
                                                             (line  684)
* identfor:                              Functions and Variables for linearalgebra.
                                                             (line  194)
* identity:                              Functions and Variables for Sets.
                                                             (line  485)
* idiff:                                 Functions and Variables for itensor.
                                                             (line  635)
* idim:                                  Functions and Variables for itensor.
                                                             (line  905)
* idummy:                                Functions and Variables for itensor.
                                                             (line  339)
* idummyx:                               Functions and Variables for itensor.
                                                             (line  346)
* ieqn:                                  Functions and Variables for Equations.
                                                             (line  416)
* ieqnprint:                             Functions and Variables for Equations.
                                                             (line  506)
* if:                                    Functions and Variables for Program Flow.
                                                             (line  401)
* ifactors:                              Functions and Variables for Number Theory.
                                                             (line  290)
* ifb:                                   Functions and Variables for itensor.
                                                             (line 1104)
* ifc1:                                  Functions and Variables for itensor.
                                                             (line 1171)
* ifc2:                                  Functions and Variables for itensor.
                                                             (line 1186)
* ifg:                                   Functions and Variables for itensor.
                                                             (line 1211)
* ifgi:                                  Functions and Variables for itensor.
                                                             (line 1216)
* ifr:                                   Functions and Variables for itensor.
                                                             (line 1200)
* iframes:                               Functions and Variables for itensor.
                                                             (line 1098)
* iframe_bracket_form:                   Functions and Variables for itensor.
                                                             (line 1221)
* ifri:                                  Functions and Variables for itensor.
                                                             (line 1205)
* ifs:                                   Graphical analysis of discrete dynamical systems.
                                                             (line   65)
* igcdex:                                Functions and Variables for Number Theory.
                                                             (line  316)
* igeodesic_coords:                      Functions and Variables for itensor.
                                                             (line  986)
* igeowedge_flag:                        Functions and Variables for itensor.
                                                             (line 1544)
* ikt1:                                  Functions and Variables for itensor.
                                                             (line 1276)
* ikt2:                                  Functions and Variables for itensor.
                                                             (line 1291)
* ilt:                                   Functions and Variables for Integration.
                                                             (line  126)
* image:                                 Functions and Variables for draw.
                                                             (line 3030)
* imaginary:                             Functions and Variables for Properties.
                                                             (line  539)
* Imaginary unit:                        Functions and Variables for Constants.
                                                             (line   15)
* imagpart:                              Functions for Complex Numbers.
                                                             (line  163)
* imetric:                               Functions and Variables for itensor.
                                                             (line  896)
* imetric <1>:                           Functions and Variables for itensor.
                                                             (line  897)
* implicit:                              Gentran Option Variables.
                                                             (line  156)
* implicit <1>:                          Functions and Variables for draw.
                                                             (line 3120)
* implicit_derivative:                   Functions and Variables for impdiff.
                                                             (line    6)
* in:                                    Functions and Variables for Program Flow.
                                                             (line   62)
* inchar:                                Functions and Variables for Command Line.
                                                             (line  229)
* increasing:                            Functions and Variables for Properties.
                                                             (line  235)
* ind:                                   Functions and Variables for Constants.
                                                             (line   38)
* Indeterminate:                         Functions and Variables for Constants.
                                                             (line   39)
* indexed_tensor:                        Functions and Variables for itensor.
                                                             (line  190)
* indices:                               Functions and Variables for itensor.
                                                             (line   56)
* induced_subgraph:                      Functions and Variables for graphs.
                                                             (line  169)
* inf:                                   Functions and Variables for Constants.
                                                             (line   49)
* inferencep:                            Functions and Variables for inference_result.
                                                             (line   48)
* inference_result:                      Functions and Variables for inference_result.
                                                             (line    6)
* infeval:                               Functions and Variables for Evaluation.
                                                             (line  589)
* infinity:                              Functions and Variables for Constants.
                                                             (line   53)
* infix:                                 User defined operators.
                                                             (line    6)
* inflag:                                Functions and Variables for Expressions.
                                                             (line  381)
* infolists:                             Functions and Variables for Command Line.
                                                             (line  253)
* info_display:                          Functions and Variables for alt-display.
                                                             (line   92)
* init_atensor:                          Functions and Variables for atensor.
                                                             (line    6)
* init_cartan:                           Functions and Variables for Differentiation.
                                                             (line  260)
* init_ctensor:                          Functions and Variables for ctensor.
                                                             (line  155)
* inm:                                   Functions and Variables for itensor.
                                                             (line 1234)
* inmc1:                                 Functions and Variables for itensor.
                                                             (line 1246)
* inmc2:                                 Functions and Variables for itensor.
                                                             (line 1260)
* innerproduct:                          Functions and Variables for Matrices and Linear Algebra.
                                                             (line  688)
* inpart:                                Functions and Variables for Expressions.
                                                             (line  398)
* inprod:                                Functions and Variables for Matrices and Linear Algebra.
                                                             (line  689)
* Input terminator (with display):       Functions and Variables for Command Line.
                                                             (line  219)
* Input terminator (without display):    Functions and Variables for Command Line.
                                                             (line  204)
* inrt:                                  Functions and Variables for Number Theory.
                                                             (line  337)
* intanalysis:                           Functions and Variables for Integration.
                                                             (line  173)
* integer:                               Functions and Variables for Properties.
                                                             (line  369)
* integerp:                              Functions and Variables for Numbers.
                                                             (line  227)
* integervalued:                         Functions and Variables for Properties.
                                                             (line  386)
* integer_decode_float:                  Functions and Variables for Numbers.
                                                             (line  256)
* integer_partitions:                    Functions and Variables for Sets.
                                                             (line  497)
* integrate:                             Functions and Variables for Integration.
                                                             (line  211)
* integrate_use_rootsof:                 Functions and Variables for Integration.
                                                             (line  446)
* integration_constant:                  Functions and Variables for Integration.
                                                             (line  385)
* integration_constant_counter:          Functions and Variables for Integration.
                                                             (line  410)
* interpolate_color:                     Functions and Variables for draw.
                                                             (line 1226)
* intersect:                             Functions and Variables for Sets.
                                                             (line  543)
* intersection:                          Functions and Variables for Sets.
                                                             (line  547)
* intervalp:                             Functions and Variables for orthogonal polynomials.
                                                             (line  255)
* intfaclim:                             Functions and Variables for Polynomials.
                                                             (line  729)
* intopois:                              Functions and Variables for Poisson series.
                                                             (line    6)
* intosum:                               Functions and Variables for Sums and Products.
                                                             (line   35)
* invariant1:                            Functions and Variables for ctensor.
                                                             (line  800)
* invariant2:                            Functions and Variables for ctensor.
                                                             (line  806)
* inverse_fft:                           Functions and Variables for fast Fourier transform.
                                                             (line   44)
* inverse_jacobi_cd:                     Functions and Variables for Elliptic Functions.
                                                             (line  142)
* inverse_jacobi_cn:                     Functions and Variables for Elliptic Functions.
                                                             (line   58)
* inverse_jacobi_cs:                     Functions and Variables for Elliptic Functions.
                                                             (line  130)
* inverse_jacobi_dc:                     Functions and Variables for Elliptic Functions.
                                                             (line  178)
* inverse_jacobi_dn:                     Functions and Variables for Elliptic Functions.
                                                             (line   70)
* inverse_jacobi_ds:                     Functions and Variables for Elliptic Functions.
                                                             (line  166)
* inverse_jacobi_nc:                     Functions and Variables for Elliptic Functions.
                                                             (line  118)
* inverse_jacobi_nd:                     Functions and Variables for Elliptic Functions.
                                                             (line  154)
* inverse_jacobi_ns:                     Functions and Variables for Elliptic Functions.
                                                             (line   82)
* inverse_jacobi_sc:                     Functions and Variables for Elliptic Functions.
                                                             (line   94)
* inverse_jacobi_sd:                     Functions and Variables for Elliptic Functions.
                                                             (line  106)
* inverse_jacobi_sn:                     Functions and Variables for Elliptic Functions.
                                                             (line   46)
* inverse_real_fft:                      Functions and Variables for fast Fourier transform.
                                                             (line  239)
* invert:                                Functions and Variables for Matrices and Linear Algebra.
                                                             (line  708)
* invert_by_adjoint:                     Functions and Variables for Matrices and Linear Algebra.
                                                             (line  701)
* invert_by_lu:                          Functions and Variables for linearalgebra.
                                                             (line  210)
* inv_mod:                               Functions and Variables for Number Theory.
                                                             (line  345)
* in_neighbors:                          Functions and Variables for graphs.
                                                             (line  648)
* ip_grid:                               Functions and Variables for draw.
                                                             (line 1295)
* ip_grid_in:                            Functions and Variables for draw.
                                                             (line 1302)
* irr:                                   Functions and Variables for finance.
                                                             (line  226)
* irrational:                            Functions and Variables for Properties.
                                                             (line  531)
* is:                                    Functions and Variables for Facts.
                                                             (line  308)
* ishow:                                 Functions and Variables for itensor.
                                                             (line   48)
* isolate:                               Functions and Variables for Expressions.
                                                             (line  426)
* isolate_wrt_times:                     Functions and Variables for Expressions.
                                                             (line  446)
* isomorphism:                           Functions and Variables for graphs.
                                                             (line  636)
* isqrt:                                 Functions and Variables for Number Theory.
                                                             (line  357)
* isreal_p:                              Functions and Variables for to_poly_solve.
                                                             (line  502)
* is_biconnected:                        Functions and Variables for graphs.
                                                             (line  660)
* is_bipartite:                          Functions and Variables for graphs.
                                                             (line  670)
* is_connected:                          Functions and Variables for graphs.
                                                             (line  681)
* is_digraph:                            Functions and Variables for graphs.
                                                             (line  690)
* is_edge_in_graph:                      Functions and Variables for graphs.
                                                             (line  700)
* is_graph:                              Functions and Variables for graphs.
                                                             (line  716)
* is_graph_or_digraph:                   Functions and Variables for graphs.
                                                             (line  726)
* is_isomorphic:                         Functions and Variables for graphs.
                                                             (line  737)
* is_planar:                             Functions and Variables for graphs.
                                                             (line  750)
* is_power_of_two:                       Functions and Variables for Numbers.
                                                             (line  306)
* is_sconnected:                         Functions and Variables for graphs.
                                                             (line  766)
* is_tree:                               Functions and Variables for graphs.
                                                             (line  789)
* is_vertex_in_graph:                    Functions and Variables for graphs.
                                                             (line  777)
* items_inference:                       Functions and Variables for inference_result.
                                                             (line   53)
* iterations:                            Plotting Options.   (line  142)
* itr:                                   Functions and Variables for itensor.
                                                             (line 1304)
* jacobi:                                Functions and Variables for Number Theory.
                                                             (line  362)
* jacobian:                              Functions and Variables for linearalgebra.
                                                             (line  215)
* jacobi_cd:                             Functions and Variables for Elliptic Functions.
                                                             (line   34)
* jacobi_cn:                             Functions and Variables for Elliptic Functions.
                                                             (line   13)
* jacobi_cs:                             Functions and Variables for Elliptic Functions.
                                                             (line   31)
* jacobi_dc:                             Functions and Variables for Elliptic Functions.
                                                             (line   43)
* jacobi_dn:                             Functions and Variables for Elliptic Functions.
                                                             (line   16)
* jacobi_ds:                             Functions and Variables for Elliptic Functions.
                                                             (line   40)
* jacobi_nc:                             Functions and Variables for Elliptic Functions.
                                                             (line   28)
* jacobi_nd:                             Functions and Variables for Elliptic Functions.
                                                             (line   37)
* jacobi_ns:                             Functions and Variables for Elliptic Functions.
                                                             (line   19)
* jacobi_p:                              Functions and Variables for orthogonal polynomials.
                                                             (line  259)
* jacobi_sc:                             Functions and Variables for Elliptic Functions.
                                                             (line   22)
* jacobi_sd:                             Functions and Variables for Elliptic Functions.
                                                             (line   25)
* jacobi_sn:                             Functions and Variables for Elliptic Functions.
                                                             (line   10)
* JF:                                    Functions and Variables for diag.
                                                             (line   40)
* join:                                  Functions and Variables for Lists.
                                                             (line  396)
* jordan:                                Functions and Variables for diag.
                                                             (line   63)
* julia:                                 Functions and Variables for Plotting.
                                                             (line   79)
* julia_parameter:                       Definitions for complex fractals.
                                                             (line   40)
* julia_set:                             Definitions for complex fractals.
                                                             (line   22)
* julia_sin:                             Definitions for complex fractals.
                                                             (line   47)
* kbateman:                              Functions and Variables for Special Functions.
                                                             (line   21)
* kdels:                                 Functions and Variables for itensor.
                                                             (line  373)
* kdelta:                                Functions and Variables for itensor.
                                                             (line  358)
* keepfloat:                             Functions and Variables for Polynomials.
                                                             (line  745)
* key:                                   Functions and Variables for draw.
                                                             (line 1310)
* key_pos:                               Functions and Variables for draw.
                                                             (line 1332)
* kill:                                  Functions and Variables for Command Line.
                                                             (line  300)
* killcontext:                           Functions and Variables for Facts.
                                                             (line  361)
* kinvariant:                            Functions and Variables for ctensor.
                                                             (line 1216)
* km:                                    Functions and Variables for descriptive statistics.
                                                             (line  520)
* kostka:                                Functions and Variables for Symmetries.
                                                             (line  447)
* kronecker_product:                     Functions and Variables for linearalgebra.
                                                             (line  238)
* kron_delta:                            Functions and Variables for Sets.
                                                             (line  572)
* kt:                                    Functions and Variables for ctensor.
                                                             (line 1244)
* kummer_m:                              Functions and Variables for contrib_ode.
                                                             (line   78)
* kummer_u:                              Functions and Variables for contrib_ode.
                                                             (line   89)
* kurtosis:                              Functions and Variables for descriptive statistics.
                                                             (line  419)
* kurtosis_bernoulli:                    Bernoulli Random Variable.
                                                             (line  109)
* kurtosis_beta:                         Beta Random Variable.
                                                             (line   94)
* kurtosis_binomial:                     Binomial Random Variable.
                                                             (line   89)
* kurtosis_chi2:                         Chi-squared Random Variable.
                                                             (line  132)
* kurtosis_continuous_uniform:           Continuous Uniform Random Variable.
                                                             (line   84)
* kurtosis_discrete_uniform:             Discrete Uniform Random Variable.
                                                             (line   88)
* kurtosis_exp:                          Exponential Random Variable.
                                                             (line  135)
* kurtosis_f:                            F Random Variable.  (line  103)
* kurtosis_gamma:                        Gamma Random Variable.
                                                             (line   87)
* kurtosis_general_finite_discrete:      General Finite Discrete Random Variable.
                                                             (line   74)
* kurtosis_geometric:                    Geometric Random Variable.
                                                             (line  101)
* kurtosis_gumbel:                       Gumbel Random Variable.
                                                             (line   97)
* kurtosis_hypergeometric:               Hypergeometric Random Variable.
                                                             (line  116)
* kurtosis_laplace:                      Laplace Random Variable.
                                                             (line   80)
* kurtosis_logistic:                     Logistic Random Variable.
                                                             (line   88)
* kurtosis_lognormal:                    Lognormal Random Variable.
                                                             (line  111)
* kurtosis_negative_binomial:            Negative Binomial Random Variable.
                                                             (line   94)
* kurtosis_noncentral_chi2:              Noncentral Chi-squared Random Variable.
                                                             (line   88)
* kurtosis_noncentral_student_t:         Noncentral Student's t Random Variable.
                                                             (line  192)
* kurtosis_normal:                       Normal Random Variable.
                                                             (line   97)
* kurtosis_pareto:                       Pareto Random Variable.
                                                             (line   77)
* kurtosis_poisson:                      Poisson Random Variable.
                                                             (line   79)
* kurtosis_rayleigh:                     Rayleigh Random Variable.
                                                             (line  155)
* kurtosis_student_t:                    Student's t Random Variable.
                                                             (line  104)
* kurtosis_weibull:                      Weibull Random Variable.
                                                             (line   85)
* label:                                 Plotting Options.   (line  148)
* label <1>:                             Functions and Variables for draw.
                                                             (line 3172)
* labels:                                Functions and Variables for Command Line.
                                                             (line  387)
* labels <1>:                            Functions and Variables for Command Line.
                                                             (line  364)
* label_alignment:                       Functions and Variables for draw.
                                                             (line 1362)
* label_alignment <1>:                   Functions and Variables for graphs.
                                                             (line 1466)
* label_orientation:                     Functions and Variables for draw.
                                                             (line 1387)
* lagrange:                              Functions and Variables for interpol.
                                                             (line    6)
* laguerre:                              Functions and Variables for orthogonal polynomials.
                                                             (line  292)
* lambda:                                Functions and Variables for Function Definition.
                                                             (line  677)
* lambert_w:                             Functions and Variables for Special Functions.
                                                             (line    6)
* laplace:                               Functions and Variables for Integration.
                                                             (line  496)
* laplacian_matrix:                      Functions and Variables for graphs.
                                                             (line  799)
* lassociative:                          Functions and Variables for Simplification.
                                                             (line  378)
* last:                                  Functions and Variables for Lists.
                                                             (line  419)
* lastn:                                 Functions and Variables for Lists.
                                                             (line  425)
* lbfgs:                                 Functions and Variables for lbfgs.
                                                             (line    6)
* lbfgs_ncorrections:                    Functions and Variables for lbfgs.
                                                             (line  276)
* lbfgs_nfeval_max:                      Functions and Variables for lbfgs.
                                                             (line  268)
* lc2kdt:                                Functions and Variables for itensor.
                                                             (line  401)
* lcm:                                   Functions and Variables for Number Theory.
                                                             (line  370)
* lc_l:                                  Functions and Variables for itensor.
                                                             (line  472)
* lc_u:                                  Functions and Variables for itensor.
                                                             (line  495)
* ldefint:                               Functions and Variables for Integration.
                                                             (line  594)
* ldisp:                                 Functions and Variables for Display.
                                                             (line  599)
* ldisplay:                              Functions and Variables for Display.
                                                             (line  630)
* least_negative_float:                  Functions and Variables for Constants.
                                                             (line   57)
* least_negative_normalized_float:       Functions and Variables for Constants.
                                                             (line   65)
* least_positive_float:                  Functions and Variables for Constants.
                                                             (line   70)
* least_positive_normalized_float:       Functions and Variables for Constants.
                                                             (line   78)
* leftjust:                              Functions and Variables for Display.
                                                             (line  664)
* legend:                                Plotting Options.   (line  153)
* legendre_p:                            Functions and Variables for orthogonal polynomials.
                                                             (line  326)
* legendre_q:                            Functions and Variables for orthogonal polynomials.
                                                             (line  372)
* leinstein:                             Functions and Variables for ctensor.
                                                             (line  244)
* length:                                Functions and Variables for Lists.
                                                             (line  504)
* Less than:                             Relational operators.
                                                             (line    6)
* Less than or equal:                    Relational operators.
                                                             (line    6)
* let:                                   Functions and Variables for Rules and Patterns.
                                                             (line  223)
* letrat:                                Functions and Variables for Rules and Patterns.
                                                             (line  304)
* letrules:                              Functions and Variables for Rules and Patterns.
                                                             (line  328)
* letsimp:                               Functions and Variables for Rules and Patterns.
                                                             (line  343)
* let_rule_packages:                     Functions and Variables for Rules and Patterns.
                                                             (line  389)
* levels:                                Plotting Options.   (line  165)
* levi_civita:                           Functions and Variables for itensor.
                                                             (line  395)
* lfg:                                   Functions and Variables for ctensor.
                                                             (line 1166)
* lfreeof:                               Functions and Variables for Expressions.
                                                             (line  515)
* lg:                                    Functions and Variables for ctensor.
                                                             (line 1199)
* lgtreillis:                            Functions and Variables for Symmetries.
                                                             (line  454)
* lhospitallim:                          Functions and Variables for Limits.
                                                             (line    6)
* lhs:                                   Functions and Variables for Equations.
                                                             (line  523)
* li:                                    Root Exponential and Logarithmic Functions.
                                                             (line  112)
* liediff:                               Functions and Variables for itensor.
                                                             (line  649)
* limit:                                 Functions and Variables for Limits.
                                                             (line   13)
* limsubst:                              Functions and Variables for Limits.
                                                             (line   58)
* linalg_rank:                           Functions and Variables for linearalgebra.
                                                             (line  597)
* Lindstedt:                             Functions and Variables for lindstedt.
                                                             (line    6)
* linear:                                Functions and Variables for Simplification.
                                                             (line  386)
* linear <1>:                            Package functs.     (line   48)
* linearinterpol:                        Functions and Variables for interpol.
                                                             (line  144)
* linear_program:                        Functions and Variables for simplex.
                                                             (line   27)
* linear_regression:                     Functions and Variables for stats.
                                                             (line  814)
* linear_solver:                         Functions and Variables for zeilberger.
                                                             (line  106)
* linechar:                              Functions and Variables for Command Line.
                                                             (line  393)
* linel:                                 Functions and Variables for Display.
                                                             (line  682)
* linenum:                               Functions and Variables for Command Line.
                                                             (line  411)
* linewidth:                             Visualization with VTK.
                                                             (line  231)
* line_graph:                            Functions and Variables for graphs.
                                                             (line  187)
* line_type:                             Functions and Variables for draw.
                                                             (line 1412)
* line_width:                            Functions and Variables for draw.
                                                             (line 1438)
* linsert:                               Functions and Variables for Quantum_Computing.
                                                             (line   80)
* linsolve:                              Functions and Variables for Equations.
                                                             (line  565)
* linsolvewarn:                          Functions and Variables for Equations.
                                                             (line  640)
* linsolve_params:                       Functions and Variables for Equations.
                                                             (line  646)
* lispdisp:                              Functions and Variables for Display.
                                                             (line  692)
* List delimiters:                       Functions and Variables for Lists.
                                                             (line    6)
* listarith:                             Functions and Variables for Lists.
                                                             (line  522)
* listarray:                             Functions and Variables for Arrays.
                                                             (line  276)
* listconstvars:                         Functions and Variables for Expressions.
                                                             (line  471)
* listdummyvars:                         Functions and Variables for Expressions.
                                                             (line  481)
* listify:                               Functions and Variables for Sets.
                                                             (line  595)
* listoftens:                            Functions and Variables for itensor.
                                                             (line   32)
* listofvars:                            Functions and Variables for Expressions.
                                                             (line  500)
* listp:                                 Functions and Variables for Lists.
                                                             (line  531)
* listp <1>:                             Functions and Variables for linearalgebra.
                                                             (line  242)
* list_correlations:                     Functions and Variables for descriptive statistics.
                                                             (line  742)
* list_matrix_entries:                   Functions and Variables for Matrices and Linear Algebra.
                                                             (line  734)
* list_nc_monomials:                     Functions and Variables for Affine.
                                                             (line  123)
* literal:                               Gentran Evaluation Forms.
                                                             (line   54)
* lmax:                                  Functions for Numbers.
                                                             (line  251)
* lmin:                                  Functions for Numbers.
                                                             (line  257)
* lmxchar:                               Functions and Variables for Matrices and Linear Algebra.
                                                             (line  743)
* load:                                  Functions and Variables for File Input and Output.
                                                             (line  251)
* loadfile:                              Functions and Variables for File Input and Output.
                                                             (line  315)
* loadprint:                             Functions and Variables for File Input and Output.
                                                             (line  325)
* load_pathname:                         Functions and Variables for File Input and Output.
                                                             (line  290)
* local:                                 Functions and Variables for Function Definition.
                                                             (line  807)
* locate_matrix_entry:                   Functions and Variables for linearalgebra.
                                                             (line  251)
* log:                                   Root Exponential and Logarithmic Functions.
                                                             (line  171)
* logabs:                                Root Exponential and Logarithmic Functions.
                                                             (line  207)
* logarc:                                Root Exponential and Logarithmic Functions.
                                                             (line  224)
* logarc <1>:                            Root Exponential and Logarithmic Functions.
                                                             (line  217)
* logcb:                                 Functions and Variables for draw.
                                                             (line 1461)
* logconcoeffp:                          Root Exponential and Logarithmic Functions.
                                                             (line  230)
* logcontract:                           Root Exponential and Logarithmic Functions.
                                                             (line  240)
* logexpand:                             Root Exponential and Logarithmic Functions.
                                                             (line  262)
* Logical conjunction:                   Logical operators.  (line    7)
* Logical conjunction <1>:               Functions and Variables for to_poly_solve.
                                                             (line   16)
* Logical disjunction:                   Logical operators.  (line   43)
* Logical disjunction <1>:               Functions and Variables for to_poly_solve.
                                                             (line  133)
* Logical negation:                      Logical operators.  (line   30)
* lognegint:                             Root Exponential and Logarithmic Functions.
                                                             (line  341)
* logsimp:                               Root Exponential and Logarithmic Functions.
                                                             (line  347)
* logx:                                  Plotting Options.   (line  181)
* logx <1>:                              Functions and Variables for draw.
                                                             (line 1486)
* logx_secondary:                        Functions and Variables for draw.
                                                             (line 1504)
* logy:                                  Plotting Options.   (line  189)
* logy <1>:                              Functions and Variables for draw.
                                                             (line 1532)
* logy_secondary:                        Functions and Variables for draw.
                                                             (line 1549)
* logz:                                  Functions and Variables for draw.
                                                             (line 1576)
* log_gamma:                             Gamma and Factorial Functions.
                                                             (line  143)
* lopow:                                 Functions and Variables for Polynomials.
                                                             (line  774)
* lorentz_gauge:                         Functions and Variables for itensor.
                                                             (line  981)
* lowercasep:                            Characters.         (line  198)
* lpart:                                 Functions and Variables for Expressions.
                                                             (line  529)
* lratsubst:                             Functions and Variables for Polynomials.
                                                             (line  782)
* lrats_max_iter:                        Functions and Variables for Polynomials.
                                                             (line  825)
* lreduce:                               Functions and Variables for Lists.
                                                             (line  535)
* lreplace:                              Functions and Variables for Quantum_Computing.
                                                             (line   86)
* lriem:                                 Functions and Variables for ctensor.
                                                             (line 1183)
* lriemann:                              Functions and Variables for ctensor.
                                                             (line  276)
* lrsetq:                                Gentran Evaluation Forms.
                                                             (line   37)
* lsetq:                                 Gentran Evaluation Forms.
                                                             (line   28)
* lsquares_estimates:                    Functions and Variables for lsquares.
                                                             (line    6)
* lsquares_estimates_approximate:        Functions and Variables for lsquares.
                                                             (line  188)
* lsquares_estimates_exact:              Functions and Variables for lsquares.
                                                             (line  139)
* lsquares_mse:                          Functions and Variables for lsquares.
                                                             (line  253)
* lsquares_residuals:                    Functions and Variables for lsquares.
                                                             (line  352)
* lsquares_residual_mse:                 Functions and Variables for lsquares.
                                                             (line  402)
* lsum:                                  Functions and Variables for Sums and Products.
                                                             (line   15)
* ltreillis:                             Functions and Variables for Symmetries.
                                                             (line  461)
* lucas:                                 Functions and Variables for Number Theory.
                                                             (line  377)
* lu_backsub:                            Functions and Variables for linearalgebra.
                                                             (line  277)
* lu_factor:                             Functions and Variables for linearalgebra.
                                                             (line  354)
* m1pbranch:                             Functions and Variables for Numbers.
                                                             (line  341)
* Macro function definition operator:    Assignment operators.
                                                             (line  117)
* macroexpand:                           Macros.             (line  101)
* macroexpand1:                          Macros.             (line  135)
* macroexpansion:                        Functions and Variables for Function Definition.
                                                             (line  840)
* macros:                                Macros.             (line  167)
* mainvar:                               Functions and Variables for Expressions.
                                                             (line  535)
* makebox:                               Functions and Variables for itensor.
                                                             (line  780)
* makefact:                              Gamma and Factorial Functions.
                                                             (line  934)
* makegamma:                             Gamma and Factorial Functions.
                                                             (line  263)
* makelist:                              Functions and Variables for Lists.
                                                             (line  576)
* makeOrders:                            Functions and Variables for makeOrders.
                                                             (line    6)
* makeset:                               Functions and Variables for Sets.
                                                             (line  609)
* make_array:                            Functions and Variables for Arrays.
                                                             (line  367)
* make_graph:                            Functions and Variables for graphs.
                                                             (line  190)
* make_level_picture:                    Functions and Variables for pictures.
                                                             (line   10)
* make_polygon:                          Functions and Variables for worldmap.
                                                             (line   64)
* make_poly_continent:                   Functions and Variables for worldmap.
                                                             (line   34)
* make_poly_country:                     Functions and Variables for worldmap.
                                                             (line   53)
* make_random_state:                     Random Numbers.     (line    6)
* make_rgb_picture:                      Functions and Variables for pictures.
                                                             (line   40)
* make_string_input_stream:              String Input and Output.
                                                             (line   76)
* make_string_output_stream:             String Input and Output.
                                                             (line   93)
* make_transform:                        Functions and Variables for Plotting.
                                                             (line  112)
* mandelbrot:                            Functions and Variables for Plotting.
                                                             (line  126)
* mandelbrot_set:                        Definitions for complex fractals.
                                                             (line    6)
* manual_demo:                           Functions and Variables for Help.
                                                             (line  238)
* map:                                   Functions and Variables for Program Flow.
                                                             (line  455)
* mapatom:                               Functions and Variables for Program Flow.
                                                             (line  494)
* maperror:                              Functions and Variables for Program Flow.
                                                             (line  500)
* maplist:                               Functions and Variables for Program Flow.
                                                             (line  526)
* mapprint:                              Functions and Variables for Program Flow.
                                                             (line  516)
* markedvarp:                            Functions for Gentran.
                                                             (line  142)
* markvar:                               Functions for Gentran.
                                                             (line  132)
* matchdeclare:                          Functions and Variables for Rules and Patterns.
                                                             (line  395)
* matchfix:                              User defined operators.
                                                             (line  103)
* mathml_display:                        Functions and Variables for alt-display.
                                                             (line  105)
* matrix:                                Functions and Variables for Matrices and Linear Algebra.
                                                             (line  759)
* matrixexp:                             Functions and Variables for Matrices and Linear Algebra.
                                                             (line  886)
* matrixmap:                             Functions and Variables for Matrices and Linear Algebra.
                                                             (line  902)
* matrixp:                               Functions and Variables for Matrices and Linear Algebra.
                                                             (line  908)
* matrixp <1>:                           Functions and Variables for linearalgebra.
                                                             (line  489)
* matrix_element_add:                    Functions and Variables for Matrices and Linear Algebra.
                                                             (line  912)
* matrix_element_mult:                   Functions and Variables for Matrices and Linear Algebra.
                                                             (line  943)
* matrix_element_transpose:              Functions and Variables for Matrices and Linear Algebra.
                                                             (line  984)
* matrix_size:                           Functions and Variables for linearalgebra.
                                                             (line  500)
* mattrace:                              Functions and Variables for Matrices and Linear Algebra.
                                                             (line 1033)
* mat_cond:                              Functions and Variables for linearalgebra.
                                                             (line  468)
* mat_fullunblocker:                     Functions and Variables for linearalgebra.
                                                             (line  505)
* mat_function:                          Functions and Variables for diag.
                                                             (line  204)
* mat_norm:                              Functions and Variables for linearalgebra.
                                                             (line  480)
* mat_trace:                             Functions and Variables for linearalgebra.
                                                             (line  510)
* mat_unblocker:                         Functions and Variables for linearalgebra.
                                                             (line  516)
* max:                                   Functions for Numbers.
                                                             (line  263)
* maxapplydepth:                         Functions and Variables for Rules and Patterns.
                                                             (line  548)
* maxapplyheight:                        Functions and Variables for Rules and Patterns.
                                                             (line  554)
* maxexpprintlen:                        Gentran Option Variables.
                                                             (line   84)
* maxima_tempdir:                        Functions and Variables for Runtime Environment.
                                                             (line    6)
* maxima_userdir:                        Functions and Variables for Runtime Environment.
                                                             (line   18)
* maximize_lp:                           Functions and Variables for simplex.
                                                             (line   54)
* maxnegex:                              Functions and Variables for Simplification.
                                                             (line  430)
* maxposex:                              Functions and Variables for Simplification.
                                                             (line  436)
* maxpsifracdenom:                       Gamma and Factorial Functions.
                                                             (line  908)
* maxpsifracnum:                         Gamma and Factorial Functions.
                                                             (line  882)
* maxpsinegint:                          Gamma and Factorial Functions.
                                                             (line  853)
* maxpsiposint:                          Gamma and Factorial Functions.
                                                             (line  831)
* maxtayorder:                           Functions and Variables for Series.
                                                             (line   70)
* max_clique:                            Functions and Variables for graphs.
                                                             (line  815)
* max_degree:                            Functions and Variables for graphs.
                                                             (line  824)
* max_flow:                              Functions and Variables for graphs.
                                                             (line  836)
* max_independent_set:                   Functions and Variables for graphs.
                                                             (line  866)
* max_matching:                          Functions and Variables for graphs.
                                                             (line  876)
* MAX_ORD:                               Functions and Variables for zeilberger.
                                                             (line   94)
* maybe:                                 Functions and Variables for Facts.
                                                             (line  379)
* md5sum:                                Octets and Utilities for Cryptography.
                                                             (line   83)
* mean:                                  Functions and Variables for descriptive statistics.
                                                             (line    6)
* mean_bernoulli:                        Bernoulli Random Variable.
                                                             (line   45)
* mean_beta:                             Beta Random Variable.
                                                             (line   49)
* mean_binomial:                         Binomial Random Variable.
                                                             (line   51)
* mean_chi2:                             Chi-squared Random Variable.
                                                             (line   70)
* mean_continuous_uniform:               Continuous Uniform Random Variable.
                                                             (line   40)
* mean_deviation:                        Functions and Variables for descriptive statistics.
                                                             (line  309)
* mean_discrete_uniform:                 Discrete Uniform Random Variable.
                                                             (line   44)
* mean_exp:                              Exponential Random Variable.
                                                             (line   62)
* mean_f:                                F Random Variable.  (line   57)
* mean_gamma:                            Gamma Random Variable.
                                                             (line   50)
* mean_general_finite_discrete:          General Finite Discrete Random Variable.
                                                             (line   50)
* mean_geometric:                        Geometric Random Variable.
                                                             (line   50)
* mean_gumbel:                           Gumbel Random Variable.
                                                             (line   41)
* mean_hypergeometric:                   Hypergeometric Random Variable.
                                                             (line   61)
* mean_laplace:                          Laplace Random Variable.
                                                             (line   45)
* mean_logistic:                         Logistic Random Variable.
                                                             (line   48)
* mean_lognormal:                        Lognormal Random Variable.
                                                             (line   63)
* mean_negative_binomial:                Negative Binomial Random Variable.
                                                             (line   49)
* mean_noncentral_chi2:                  Noncentral Chi-squared Random Variable.
                                                             (line   47)
* mean_noncentral_student_t:             Noncentral Student's t Random Variable.
                                                             (line  102)
* mean_normal:                           Normal Random Variable.
                                                             (line   62)
* mean_pareto:                           Pareto Random Variable.
                                                             (line   34)
* mean_poisson:                          Poisson Random Variable.
                                                             (line   43)
* mean_rayleigh:                         Rayleigh Random Variable.
                                                             (line   61)
* mean_student_t:                        Student's t Random Variable.
                                                             (line   61)
* mean_weibull:                          Weibull Random Variable.
                                                             (line   39)
* median:                                Functions and Variables for descriptive statistics.
                                                             (line  265)
* median_deviation:                      Functions and Variables for descriptive statistics.
                                                             (line  337)
* member:                                Functions and Variables for Lists.
                                                             (line  619)
* mesh:                                  Functions and Variables for draw.
                                                             (line 3214)
* mesh_lines_color:                      Plotting Options.   (line  197)
* method:                                Functions and Variables for Differential Equations.
                                                             (line  168)
* metricexpandall:                       Functions and Variables for Units.
                                                             (line  389)
* mgf1_sha1:                             Octets and Utilities for Cryptography.
                                                             (line  127)
* min:                                   Functions for Numbers.
                                                             (line  308)
* minclinelen:                           Gentran Option Variables.
                                                             (line   44)
* minf:                                  Functions and Variables for Constants.
                                                             (line   83)
* minfactorial:                          Combinatorial Functions.
                                                             (line  176)
* minfortlinelen:                        Gentran Option Variables.
                                                             (line   20)
* minimalPoly:                           Functions and Variables for diag.
                                                             (line  144)
* minimize_lp:                           Functions and Variables for simplex.
                                                             (line   62)
* minimum_spanning_tree:                 Functions and Variables for graphs.
                                                             (line  912)
* minor:                                 Functions and Variables for Matrices and Linear Algebra.
                                                             (line 1043)
* minpack_lsquares:                      Functions and Variables for minpack.
                                                             (line    6)
* minpack_solve:                         Functions and Variables for minpack.
                                                             (line   66)
* Minus infinity:                        Functions and Variables for Constants.
                                                             (line   84)
* min_degree:                            Functions and Variables for graphs.
                                                             (line  887)
* min_edge_cut:                          Functions and Variables for graphs.
                                                             (line  899)
* min_vertex_cover:                      Functions and Variables for graphs.
                                                             (line  904)
* min_vertex_cut:                        Functions and Variables for graphs.
                                                             (line  907)
* mkdir:                                 Directory operations.
                                                             (line    9)
* mnewton:                               Functions and Variables for mnewton.
                                                             (line   31)
* mod:                                   Functions and Variables for Number Theory.
                                                             (line  387)
* modedeclare:                           Functions and Variables for Function Definition.
                                                             (line  976)
* ModeMatrix:                            Functions and Variables for diag.
                                                             (line  166)
* mode_checkp:                           Functions and Variables for Function Definition.
                                                             (line 1051)
* mode_check_errorp:                     Functions and Variables for Function Definition.
                                                             (line 1083)
* mode_check_warnp:                      Functions and Variables for Function Definition.
                                                             (line 1088)
* mode_declare:                          Functions and Variables for Function Definition.
                                                             (line  975)
* mode_identity:                         Functions and Variables for Function Definition.
                                                             (line 1093)
* modular_linear_solver:                 Functions and Variables for zeilberger.
                                                             (line  141)
* modulus:                               Functions and Variables for Polynomials.
                                                             (line  832)
* mod_big_prime:                         Functions and Variables for zeilberger.
                                                             (line  153)
* mod_test:                              Functions and Variables for zeilberger.
                                                             (line  135)
* mod_threshold:                         Functions and Variables for zeilberger.
                                                             (line  159)
* moebius:                               Functions and Variables for Sets.
                                                             (line  643)
* mon2schur:                             Functions and Variables for Symmetries.
                                                             (line   62)
* mono:                                  Functions and Variables for Affine.
                                                             (line  100)
* monomial_dimensions:                   Functions and Variables for Affine.
                                                             (line  107)
* most_negative_float:                   Functions and Variables for Constants.
                                                             (line   87)
* most_positive_float:                   Functions and Variables for Constants.
                                                             (line   91)
* multibernstein_poly:                   Functions and Variables for Bernstein.
                                                             (line   64)
* multinomial:                           Functions and Variables for Symmetries.
                                                             (line  836)
* multinomial_coeff:                     Functions and Variables for Sets.
                                                             (line  676)
* Multiplication:                        Arithmetic operators.
                                                             (line    6)
* multiplicative:                        Functions and Variables for Simplification.
                                                             (line  442)
* multiplicities:                        Functions and Variables for Equations.
                                                             (line  655)
* multiplot_mode:                        Functions and Variables for draw.
                                                             (line  153)
* multi_display_for_texinfo:             Functions and Variables for alt-display.
                                                             (line  123)
* multi_elem:                            Functions and Variables for Symmetries.
                                                             (line   89)
* multi_orbit:                           Functions and Variables for Symmetries.
                                                             (line  353)
* multi_pui:                             Functions and Variables for Symmetries.
                                                             (line  105)
* multsym:                               Functions and Variables for Symmetries.
                                                             (line  367)
* multthru:                              Functions and Variables for Simplification.
                                                             (line  488)
* mycielski_graph:                       Functions and Variables for graphs.
                                                             (line  226)
* myoptions:                             Functions and Variables for Command Line.
                                                             (line  416)
* N'th previous output:                  Functions and Variables for Command Line.
                                                             (line  153)
* nary:                                  Functions and Variables for Simplification.
                                                             (line  535)
* nary <1>:                              User defined operators.
                                                             (line  208)
* natural_unit:                          Functions and Variables for ezunits.
                                                             (line  702)
* ncexpt:                                Functions and Variables for Display.
                                                             (line  409)
* ncharpoly:                             Functions and Variables for Matrices and Linear Algebra.
                                                             (line 1048)
* nc_degree:                             Functions and Variables for Affine.
                                                             (line   63)
* Negative infinity:                     Functions and Variables for Constants.
                                                             (line   84)
* negative_picture:                      Functions and Variables for pictures.
                                                             (line   65)
* negdistrib:                            Functions and Variables for Simplification.
                                                             (line  555)
* negsumdispflag:                        Functions and Variables for Display.
                                                             (line  709)
* neighbors:                             Functions and Variables for graphs.
                                                             (line  921)
* new:                                   Functions and Variables for Structures.
                                                             (line   50)
* newcontext:                            Functions and Variables for Facts.
                                                             (line  403)
* newdet:                                Functions and Variables for Matrices and Linear Algebra.
                                                             (line 1065)
* newline:                               Characters.         (line  204)
* newline <1>:                           String Input and Output.
                                                             (line  113)
* newton:                                Functions for numerical solution of equations.
                                                             (line  121)
* newtondebug:                           Functions and Variables for mnewton.
                                                             (line   25)
* newtonepsilon:                         Functions and Variables for mnewton.
                                                             (line    6)
* newtonmaxiter:                         Functions and Variables for mnewton.
                                                             (line   17)
* new_graph:                             Functions and Variables for graphs.
                                                             (line  229)
* new_variable:                          Functions and Variables for to_poly_solve.
                                                             (line  541)
* next:                                  Functions and Variables for Program Flow.
                                                             (line   61)
* nextlayerfactor:                       Package facexp.     (line   62)
* next_prime:                            Functions and Variables for Number Theory.
                                                             (line  415)
* nicedummies:                           Functions and Variables for to_poly_solve.
                                                             (line  585)
* niceindices:                           Functions and Variables for Series.
                                                             (line   77)
* niceindicespref:                       Functions and Variables for Series.
                                                             (line  112)
* ninth:                                 Functions and Variables for Lists.
                                                             (line  655)
* nm:                                    Functions and Variables for ctensor.
                                                             (line 1248)
* nmc:                                   Functions and Variables for ctensor.
                                                             (line 1252)
* noeval:                                Functions and Variables for Evaluation.
                                                             (line  597)
* nofix:                                 User defined operators.
                                                             (line  222)
* nolabels:                              Functions and Variables for Command Line.
                                                             (line  422)
* nonarray:                              Functions and Variables for Properties.
                                                             (line  404)
* noncentral_moment:                     Functions and Variables for descriptive statistics.
                                                             (line  121)
* Noncommutative exponentiation:         Arithmetic operators.
                                                             (line  189)
* Noncommutative multiplication:         Arithmetic operators.
                                                             (line  208)
* nonegative_lp:                         Functions and Variables for simplex.
                                                             (line  139)
* noninteger:                            Functions and Variables for Properties.
                                                             (line  370)
* nonmetricity:                          Functions and Variables for ctensor.
                                                             (line  660)
* nonnegative_lp:                        Functions and Variables for simplex.
                                                             (line  138)
* nonnegintegerp:                        Functions and Variables for Numbers.
                                                             (line  359)
* nonscalar:                             Functions and Variables for Properties.
                                                             (line  425)
* nonscalarp:                            Functions and Variables for Properties.
                                                             (line  432)
* nonzeroandfreeof:                      Package functs.     (line   42)
* normalize:                             Functions and Variables for Quantum_Computing.
                                                             (line   95)
* not:                                   Logical operators.  (line   29)
* Not equal (syntactic inequality):      Operators for Equations.
                                                             (line    7)
* notequal:                              Functions and Variables for Predicates.
                                                             (line  155)
* noun:                                  Functions and Variables for Expressions.
                                                             (line  548)
* noundisp:                              Functions and Variables for Expressions.
                                                             (line  567)
* nounify:                               Functions and Variables for Expressions.
                                                             (line  573)
* nouns:                                 Functions and Variables for Evaluation.
                                                             (line  603)
* np:                                    Functions and Variables for ctensor.
                                                             (line 1220)
* npi:                                   Functions and Variables for ctensor.
                                                             (line 1224)
* nptetrad:                              Functions and Variables for ctensor.
                                                             (line  481)
* npv:                                   Functions and Variables for finance.
                                                             (line  215)
* nroots:                                Functions and Variables for Equations.
                                                             (line  661)
* nterms:                                Functions and Variables for Expressions.
                                                             (line  583)
* ntermst:                               Functions and Variables for ctensor.
                                                             (line  838)
* nthroot:                               Functions and Variables for Equations.
                                                             (line  673)
* nticks:                                Plotting Options.   (line  211)
* nticks <1>:                            Functions and Variables for draw.
                                                             (line 1592)
* ntrig:                                 Additional Functions.
                                                             (line   16)
* nullity:                               Functions and Variables for linearalgebra.
                                                             (line  557)
* nullspace:                             Functions and Variables for linearalgebra.
                                                             (line  550)
* num:                                   Functions and Variables for Polynomials.
                                                             (line  875)
* numbered_boundaries:                   Functions and Variables for worldmap.
                                                             (line   20)
* numberp:                               Functions and Variables for Numbers.
                                                             (line  363)
* number_to_octets:                      Octets and Utilities for Cryptography.
                                                             (line  151)
* numer:                                 Functions and Variables for Numbers.
                                                             (line  391)
* numerval:                              Functions and Variables for Numbers.
                                                             (line  437)
* numer_pbranch:                         Functions and Variables for Numbers.
                                                             (line  410)
* numfactor:                             Gamma and Factorial Functions.
                                                             (line  951)
* num_distinct_partitions:               Functions and Variables for Sets.
                                                             (line  710)
* num_partitions:                        Functions and Variables for Sets.
                                                             (line  733)
* nusum:                                 Functions and Variables for Series.
                                                             (line  141)
* nzeta:                                 Functions and Variables for Special Functions.
                                                             (line   31)
* nzetai:                                Functions and Variables for Special Functions.
                                                             (line   38)
* nzetar:                                Functions and Variables for Special Functions.
                                                             (line   35)
* obase:                                 Functions and Variables for Display.
                                                             (line  718)
* octets_to_number:                      Octets and Utilities for Cryptography.
                                                             (line  165)
* octets_to_oid:                         Octets and Utilities for Cryptography.
                                                             (line  172)
* octets_to_string:                      Octets and Utilities for Cryptography.
                                                             (line  184)
* odd:                                   Functions and Variables for Properties.
                                                             (line  255)
* oddfun:                                Functions and Variables for Simplification.
                                                             (line  202)
* oddp:                                  Functions and Variables for Numbers.
                                                             (line  447)
* odd_girth:                             Functions and Variables for graphs.
                                                             (line  930)
* ode2:                                  Functions and Variables for Differential Equations.
                                                             (line   88)
* odelin:                                Functions and Variables for contrib_ode.
                                                             (line   11)
* ode_check:                             Functions and Variables for contrib_ode.
                                                             (line   28)
* oid_to_octets:                         Octets and Utilities for Cryptography.
                                                             (line  230)
* op:                                    Functions and Variables for Expressions.
                                                             (line  591)
* opacity:                               Visualization with VTK.
                                                             (line  237)
* opena:                                 String Input and Output.
                                                             (line  123)
* opena_binary:                          Functions and Variables for binary input and output.
                                                             (line   28)
* openr:                                 String Input and Output.
                                                             (line  131)
* openr_binary:                          Functions and Variables for binary input and output.
                                                             (line   16)
* openw:                                 String Input and Output.
                                                             (line  150)
* openw_binary:                          Functions and Variables for binary input and output.
                                                             (line   22)
* operatorp:                             Functions and Variables for Expressions.
                                                             (line  639)
* opproperties:                          Functions and Variables for Simplification.
                                                             (line  576)
* opsubst:                               Functions and Variables for Expressions.
                                                             (line  649)
* opsubst <1>:                           Functions and Variables for opsubst.
                                                             (line    6)
* optimize:                              Functions and Variables for Expressions.
                                                             (line  672)
* optimprefix:                           Functions and Variables for Expressions.
                                                             (line  680)
* optimvarname:                          Gentran Option Variables.
                                                             (line  127)
* optionset:                             Functions and Variables for Command Line.
                                                             (line  440)
* or:                                    Logical operators.  (line   42)
* orbit:                                 Functions and Variables for Symmetries.
                                                             (line  386)
* orbits:                                Graphical analysis of discrete dynamical systems.
                                                             (line   95)
* ordergreat:                            Functions and Variables for Expressions.
                                                             (line  686)
* ordergreatp:                           Functions and Variables for Expressions.
                                                             (line  704)
* orderless:                             Functions and Variables for Expressions.
                                                             (line  687)
* orderlessp:                            Functions and Variables for Expressions.
                                                             (line  705)
* orientation:                           Visualization with VTK.
                                                             (line  244)
* origin:                                Visualization with VTK.
                                                             (line  252)
* orthogonal_complement:                 Functions and Variables for linearalgebra.
                                                             (line  561)
* orthopoly_recur:                       Functions and Variables for orthogonal polynomials.
                                                             (line  402)
* orthopoly_returns_intervals:           Functions and Variables for orthogonal polynomials.
                                                             (line  430)
* orthopoly_weight:                      Functions and Variables for orthogonal polynomials.
                                                             (line  439)
* outative:                              Functions and Variables for Simplification.
                                                             (line  630)
* outchar:                               Functions and Variables for Command Line.
                                                             (line  457)
* outermap:                              Functions and Variables for Program Flow.
                                                             (line  633)
* outofpois:                             Functions and Variables for Poisson series.
                                                             (line    9)
* output_format_for_help:                Functions and Variables for Help.
                                                             (line  149)
* out_neighbors:                         Functions and Variables for graphs.
                                                             (line  941)
* packagefile:                           Functions and Variables for Miscellaneous Options.
                                                             (line   56)
* pade:                                  Functions and Variables for Series.
                                                             (line  191)
* palette:                               Plotting Options.   (line  220)
* palette <1>:                           Functions and Variables for draw.
                                                             (line 1614)
* parabolic_cylinder_d:                  Parabolic Cylinder Functions.
                                                             (line   13)
* parametric:                            Functions and Variables for draw.
                                                             (line 3260)
* parametric_surface:                    Functions and Variables for draw.
                                                             (line 3301)
* parg:                                  Functions and Variables for to_poly_solve.
                                                             (line  605)
* parGosper:                             Functions and Variables for zeilberger.
                                                             (line   60)
* parse_string:                          String Processing.  (line   44)
* parse_timedate:                        Functions and Variables for Runtime Environment.
                                                             (line  165)
* part:                                  Functions and Variables for Expressions.
                                                             (line  788)
* part2cont:                             Functions and Variables for Symmetries.
                                                             (line  244)
* partfrac:                              Functions and Variables for Number Theory.
                                                             (line  422)
* partition:                             Functions and Variables for Expressions.
                                                             (line  825)
* partition_set:                         Functions and Variables for Sets.
                                                             (line  758)
* partpol:                               Functions and Variables for Symmetries.
                                                             (line  253)
* partswitch:                            Functions and Variables for Expressions.
                                                             (line  841)
* pathname_directory:                    Functions and Variables for File Input and Output.
                                                             (line  350)
* pathname_name:                         Functions and Variables for File Input and Output.
                                                             (line  351)
* pathname_type:                         Functions and Variables for File Input and Output.
                                                             (line  352)
* path_digraph:                          Functions and Variables for graphs.
                                                             (line  232)
* path_graph:                            Functions and Variables for graphs.
                                                             (line  235)
* pdf_bernoulli:                         Bernoulli Random Variable.
                                                             (line   13)
* pdf_beta:                              Beta Random Variable.
                                                             (line    9)
* pdf_binomial:                          Binomial Random Variable.
                                                             (line   15)
* pdf_cauchy:                            Cauchy Random Variable.
                                                             (line   14)
* pdf_chi2:                              Chi-squared Random Variable.
                                                             (line   12)
* pdf_continuous_uniform:                Continuous Uniform Random Variable.
                                                             (line    9)
* pdf_discrete_uniform:                  Discrete Uniform Random Variable.
                                                             (line   13)
* pdf_exp:                               Exponential Random Variable.
                                                             (line   10)
* pdf_f:                                 F Random Variable.  (line   10)
* pdf_file:                              Plotting Options.   (line  307)
* pdf_gamma:                             Gamma Random Variable.
                                                             (line   10)
* pdf_general_finite_discrete:           General Finite Discrete Random Variable.
                                                             (line    6)
* pdf_geometric:                         Geometric Random Variable.
                                                             (line   14)
* pdf_gumbel:                            Gumbel Random Variable.
                                                             (line    6)
* pdf_hypergeometric:                    Hypergeometric Random Variable.
                                                             (line   14)
* pdf_laplace:                           Laplace Random Variable.
                                                             (line   10)
* pdf_logistic:                          Logistic Random Variable.
                                                             (line    9)
* pdf_lognormal:                         Lognormal Random Variable.
                                                             (line    9)
* pdf_negative_binomial:                 Negative Binomial Random Variable.
                                                             (line   14)
* pdf_noncentral_chi2:                   Noncentral Chi-squared Random Variable.
                                                             (line   16)
* pdf_noncentral_student_t:              Noncentral Student's t Random Variable.
                                                             (line   16)
* pdf_normal:                            Normal Random Variable.
                                                             (line    9)
* pdf_pareto:                            Pareto Random Variable.
                                                             (line    6)
* pdf_poisson:                           Poisson Random Variable.
                                                             (line   11)
* pdf_rank_sum:                          Functions and Variables for special distributions.
                                                             (line   20)
* pdf_rayleigh:                          Rayleigh Random Variable.
                                                             (line    9)
* pdf_signed_rank:                       Functions and Variables for special distributions.
                                                             (line    6)
* pdf_student_t:                         Student's t Random Variable.
                                                             (line   14)
* pdf_weibull:                           Weibull Random Variable.
                                                             (line    6)
* pearson_skewness:                      Functions and Variables for descriptive statistics.
                                                             (line  471)
* permanent:                             Functions and Variables for Matrices and Linear Algebra.
                                                             (line 1070)
* permp:                                 Functions and Variables for Combinatorics.
                                                             (line  209)
* perms:                                 Functions and Variables for Combinatorics.
                                                             (line  223)
* perms_lex:                             Functions and Variables for Combinatorics.
                                                             (line  260)
* permult:                               Functions and Variables for Combinatorics.
                                                             (line  301)
* permut:                                Functions and Variables for Symmetries.
                                                             (line  842)
* permutation:                           Package functs.     (line  182)
* permutations:                          Functions and Variables for Sets.
                                                             (line  779)
* permute:                               Functions and Variables for Combinatorics.
                                                             (line  311)
* perm_cycles:                           Functions and Variables for Combinatorics.
                                                             (line   46)
* perm_decomp:                           Functions and Variables for Combinatorics.
                                                             (line   60)
* perm_inverse:                          Functions and Variables for Combinatorics.
                                                             (line   74)
* perm_length:                           Functions and Variables for Combinatorics.
                                                             (line   88)
* perm_lex_next:                         Functions and Variables for Combinatorics.
                                                             (line  103)
* perm_lex_rank:                         Functions and Variables for Combinatorics.
                                                             (line  114)
* perm_lex_unrank:                       Functions and Variables for Combinatorics.
                                                             (line  128)
* perm_next:                             Functions and Variables for Combinatorics.
                                                             (line  141)
* perm_parity:                           Functions and Variables for Combinatorics.
                                                             (line  154)
* perm_rank:                             Functions and Variables for Combinatorics.
                                                             (line  169)
* perm_undecomp:                         Functions and Variables for Combinatorics.
                                                             (line  183)
* perm_unrank:                           Functions and Variables for Combinatorics.
                                                             (line  196)
* petersen_graph:                        Functions and Variables for graphs.
                                                             (line  238)
* petrov:                                Functions and Variables for ctensor.
                                                             (line  526)
* pfeformat:                             Functions and Variables for Display.
                                                             (line  752)
* phi:                                   Functions and Variables for Constants.
                                                             (line   96)
* phiresolution:                         Visualization with VTK.
                                                             (line  259)
* pi:                                    Functions and Variables for Constants.
                                                             (line  151)
* pickapart:                             Functions and Variables for Expressions.
                                                             (line  848)
* picturep:                              Functions and Variables for pictures.
                                                             (line   71)
* picture_equalp:                        Functions and Variables for pictures.
                                                             (line   68)
* piece:                                 Functions and Variables for Expressions.
                                                             (line  933)
* piechart:                              Functions and Variables for statistical graphs.
                                                             (line  426)
* piechart_description:                  Functions and Variables for statistical graphs.
                                                             (line  470)
* pivot_count_sx:                        Functions and Variables for simplex.
                                                             (line  154)
* pivot_max_sx:                          Functions and Variables for simplex.
                                                             (line  159)
* planar_embedding:                      Functions and Variables for graphs.
                                                             (line  953)
* playback:                              Functions and Variables for Command Line.
                                                             (line  480)
* plog:                                  Root Exponential and Logarithmic Functions.
                                                             (line  353)
* plot2d:                                Functions and Variables for Plotting.
                                                             (line  163)
* plot3d:                                Functions and Variables for Plotting.
                                                             (line  341)
* plotdf:                                Functions for numerical solution of differential equations.
                                                             (line    6)
* plotepsilon:                           Plotting Options.   (line  253)
* ploteq:                                Functions for numerical solution of differential equations.
                                                             (line  187)
* plot_format:                           Plotting Options.   (line  269)
* plot_options:                          Functions and Variables for Plotting.
                                                             (line  438)
* plot_realpart:                         Plotting Options.   (line  280)
* plsquares:                             Functions and Variables for lsquares.
                                                             (line  452)
* png_file:                              Plotting Options.   (line  321)
* pochhammer:                            Functions and Variables for orthogonal polynomials.
                                                             (line  457)
* pochhammer_max_index:                  Functions and Variables for orthogonal polynomials.
                                                             (line  494)
* points:                                Visualization with VTK.
                                                             (line  268)
* points <1>:                            Functions and Variables for draw.
                                                             (line 3330)
* pointsize:                             Visualization with VTK.
                                                             (line  275)
* points_joined:                         Functions and Variables for draw.
                                                             (line 1752)
* point_size:                            Functions and Variables for draw.
                                                             (line 1689)
* point_type:                            Plotting Options.   (line  297)
* point_type <1>:                        Functions and Variables for draw.
                                                             (line 1710)
* poisdiff:                              Functions and Variables for Poisson series.
                                                             (line   17)
* poisexpt:                              Functions and Variables for Poisson series.
                                                             (line   22)
* poisint:                               Functions and Variables for Poisson series.
                                                             (line   27)
* poislim:                               Functions and Variables for Poisson series.
                                                             (line   33)
* poismap:                               Functions and Variables for Poisson series.
                                                             (line   41)
* poisplus:                              Functions and Variables for Poisson series.
                                                             (line   48)
* poissimp:                              Functions and Variables for Poisson series.
                                                             (line   52)
* poisson:                               Functions and Variables for Poisson series.
                                                             (line   57)
* poissubst:                             Functions and Variables for Poisson series.
                                                             (line   62)
* poistimes:                             Functions and Variables for Poisson series.
                                                             (line   82)
* poistrim:                              Functions and Variables for Poisson series.
                                                             (line   86)
* polar:                                 Functions and Variables for draw.
                                                             (line 3491)
* polarform:                             Functions for Complex Numbers.
                                                             (line  182)
* polartorect:                           Functions and Variables for fast Fourier transform.
                                                             (line    6)
* polar_to_xy:                           Functions and Variables for Plotting.
                                                             (line  156)
* polydecomp:                            Functions and Variables for Polynomials.
                                                             (line  898)
* polyfactor:                            Functions and Variables for Equations.
                                                             (line  681)
* polygon:                               Functions and Variables for draw.
                                                             (line 3515)
* polymod:                               Functions and Variables for Polynomials.
                                                             (line  948)
* polynome2ele:                          Functions and Variables for Symmetries.
                                                             (line  513)
* polynomialp:                           Functions and Variables for Polynomials.
                                                             (line  961)
* polytocompanion:                       Functions and Variables for linearalgebra.
                                                             (line  568)
* poly_add:                              Functions and Variables for grobner.
                                                             (line   83)
* poly_buchberger:                       Functions and Variables for grobner.
                                                             (line  191)
* poly_buchberger_criterion:             Functions and Variables for grobner.
                                                             (line  185)
* poly_coefficient_ring:                 Functions and Variables for grobner.
                                                             (line   16)
* poly_colon_ideal:                      Functions and Variables for grobner.
                                                             (line  241)
* poly_content:                          Functions and Variables for grobner.
                                                             (line  158)
* poly_depends_p:                        Functions and Variables for grobner.
                                                             (line  231)
* poly_elimination_ideal:                Functions and Variables for grobner.
                                                             (line  235)
* poly_elimination_order:                Functions and Variables for grobner.
                                                             (line   36)
* poly_exact_divide:                     Functions and Variables for grobner.
                                                             (line  176)
* poly_expand:                           Functions and Variables for grobner.
                                                             (line  122)
* poly_expt:                             Functions and Variables for grobner.
                                                             (line  151)
* poly_gcd:                              Functions and Variables for grobner.
                                                             (line  257)
* poly_grobner:                          Functions and Variables for grobner.
                                                             (line  223)
* poly_grobner_algorithm:                Functions and Variables for grobner.
                                                             (line   58)
* poly_grobner_debug:                    Functions and Variables for grobner.
                                                             (line   53)
* poly_grobner_equal:                    Functions and Variables for grobner.
                                                             (line  275)
* poly_grobner_member:                   Functions and Variables for grobner.
                                                             (line  294)
* poly_grobner_subsetp:                  Functions and Variables for grobner.
                                                             (line  287)
* poly_ideal_intersection:               Functions and Variables for grobner.
                                                             (line  249)
* poly_ideal_polysaturation:             Functions and Variables for grobner.
                                                             (line  334)
* poly_ideal_polysaturation1:            Functions and Variables for grobner.
                                                             (line  323)
* poly_ideal_saturation:                 Functions and Variables for grobner.
                                                             (line  313)
* poly_ideal_saturation1:                Functions and Variables for grobner.
                                                             (line  304)
* poly_lcm:                              Functions and Variables for grobner.
                                                             (line  254)
* poly_minimization:                     Functions and Variables for grobner.
                                                             (line  212)
* poly_monomial_order:                   Functions and Variables for grobner.
                                                             (line    9)
* poly_multiply:                         Functions and Variables for grobner.
                                                             (line   97)
* poly_normalize:                        Functions and Variables for grobner.
                                                             (line  114)
* poly_normalize_list:                   Functions and Variables for grobner.
                                                             (line  218)
* poly_normal_form:                      Functions and Variables for grobner.
                                                             (line  181)
* poly_polysaturation_extension:         Functions and Variables for grobner.
                                                             (line  347)
* poly_primary_elimination_order:        Functions and Variables for grobner.
                                                             (line   24)
* poly_primitive_part:                   Functions and Variables for grobner.
                                                             (line  107)
* poly_pseudo_divide:                    Functions and Variables for grobner.
                                                             (line  164)
* poly_reduced_grobner:                  Functions and Variables for grobner.
                                                             (line  227)
* poly_reduction:                        Functions and Variables for grobner.
                                                             (line  207)
* poly_return_term_list:                 Functions and Variables for grobner.
                                                             (line   46)
* poly_saturation_extension:             Functions and Variables for grobner.
                                                             (line  342)
* poly_secondary_elimination_order:      Functions and Variables for grobner.
                                                             (line   30)
* poly_subtract:                         Functions and Variables for grobner.
                                                             (line   90)
* poly_s_polynomial:                     Functions and Variables for grobner.
                                                             (line  103)
* poly_top_reduction_only:               Functions and Variables for grobner.
                                                             (line   68)
* pop:                                   Functions and Variables for Lists.
                                                             (line  660)
* posfun:                                Functions and Variables for Properties.
                                                             (line  439)
* position:                              Visualization with VTK.
                                                             (line  281)
* postfix:                               User defined operators.
                                                             (line  236)
* postsubscript:                         Functions and Variables for Display.
                                                             (line   40)
* postsuperscript:                       Functions and Variables for Display.
                                                             (line   41)
* potential:                             Functions and Variables for Integration.
                                                             (line  628)
* powerdisp:                             Functions and Variables for Display.
                                                             (line  776)
* powerseries:                           Functions and Variables for Series.
                                                             (line  255)
* powerset:                              Functions and Variables for Sets.
                                                             (line  798)
* power_mod:                             Functions and Variables for Number Theory.
                                                             (line  451)
* pred:                                  Functions and Variables for Evaluation.
                                                             (line  610)
* prederror:                             Functions and Variables for Program Flow.
                                                             (line  537)
* prefer_d:                              Functions and Variables for Integration.
                                                             (line  641)
* prefix:                                User defined operators.
                                                             (line  248)
* presubscript:                          Functions and Variables for Display.
                                                             (line   43)
* presuperscript:                        Functions and Variables for Display.
                                                             (line   42)
* Previous input:                        Functions and Variables for Command Line.
                                                             (line   47)
* Previous output:                       Functions and Variables for Command Line.
                                                             (line   92)
* Previous result in compound expression: Functions and Variables for Command Line.
                                                             (line  106)
* prev_prime:                            Functions and Variables for Number Theory.
                                                             (line  495)
* primelmt:                              Functions and Variables for algebraic extensions.
                                                             (line   67)
* primep:                                Functions and Variables for Number Theory.
                                                             (line  466)
* primep_number_of_tests:                Functions and Variables for Number Theory.
                                                             (line  483)
* primes:                                Functions and Variables for Number Theory.
                                                             (line  488)
* principal_components:                  Functions and Variables for descriptive statistics.
                                                             (line  811)
* print:                                 Functions and Variables for Display.
                                                             (line  800)
* printf:                                String Input and Output.
                                                             (line  161)
* printfile:                             Functions and Variables for File Input and Output.
                                                             (line  365)
* printpois:                             Functions and Variables for Poisson series.
                                                             (line   94)
* printprops:                            Functions and Variables for Properties.
                                                             (line  446)
* print_graph:                           Functions and Variables for graphs.
                                                             (line  969)
* prodrac:                               Functions and Variables for Symmetries.
                                                             (line  525)
* product:                               Functions and Variables for Sums and Products.
                                                             (line   56)
* product_use_gamma:                     Functions and Variables for solve_rec.
                                                             (line  199)
* program:                               Functions and Variables for graphs.
                                                             (line 1578)
* programmode:                           Functions and Variables for Equations.
                                                             (line  691)
* prompt:                                Functions and Variables for Command Line.
                                                             (line  531)
* properties:                            Functions and Variables for Properties.
                                                             (line  458)
* proportional_axes:                     Functions and Variables for draw.
                                                             (line 1783)
* props:                                 Functions and Variables for Properties.
                                                             (line  463)
* propvars:                              Functions and Variables for Properties.
                                                             (line  471)
* psexpand:                              Functions and Variables for Series.
                                                             (line  300)
* psi:                                   Gamma and Factorial Functions.
                                                             (line  789)
* psi <1>:                               Functions and Variables for ctensor.
                                                             (line  504)
* pslq_depth:                            Functions and Variables for pslq.
                                                             (line   89)
* pslq_integer_relation:                 Functions and Variables for pslq.
                                                             (line   46)
* pslq_precision:                        Functions and Variables for pslq.
                                                             (line   76)
* pslq_status:                           Functions and Variables for pslq.
                                                             (line   97)
* pslq_threshold:                        Functions and Variables for pslq.
                                                             (line   83)
* psubst:                                Functions and Variables for Expressions.
                                                             (line  939)
* ps_file:                               Plotting Options.   (line  334)
* ptriangularize:                        Functions and Variables for linearalgebra.
                                                             (line  576)
* pui:                                   Functions and Variables for Symmetries.
                                                             (line  116)
* pui2comp:                              Functions and Variables for Symmetries.
                                                             (line  142)
* pui2ele:                               Functions and Variables for Symmetries.
                                                             (line  168)
* pui2polynome:                          Functions and Variables for Symmetries.
                                                             (line  532)
* puireduc:                              Functions and Variables for Symmetries.
                                                             (line  177)
* pui_direct:                            Functions and Variables for Symmetries.
                                                             (line  399)
* push:                                  Functions and Variables for Lists.
                                                             (line  667)
* put:                                   Functions and Variables for Properties.
                                                             (line  477)
* pv:                                    Functions and Variables for finance.
                                                             (line   29)
* pwilt:                                 Functions and Variables for Integration.
                                                             (line  608)
* pytranslate:                           Functions in pytranslate.
                                                             (line    6)
* qdisplay:                              Functions and Variables for Quantum_Computing.
                                                             (line  100)
* qmatrix:                               Functions and Variables for Quantum_Computing.
                                                             (line  106)
* qmeasure:                              Functions and Variables for Quantum_Computing.
                                                             (line  116)
* qput:                                  Functions and Variables for Properties.
                                                             (line  504)
* qrange:                                Functions and Variables for descriptive statistics.
                                                             (line  289)
* qswap:                                 Functions and Variables for Quantum_Computing.
                                                             (line  141)
* qty:                                   Functions and Variables for ezunits.
                                                             (line  359)
* quadrilateral:                         Functions and Variables for draw.
                                                             (line 3541)
* quad_control:                          Functions and Variables for QUADPACK.
                                                             (line  628)
* quad_qag:                              Functions and Variables for QUADPACK.
                                                             (line    6)
* quad_qagi:                             Functions and Variables for QUADPACK.
                                                             (line  146)
* quad_qagp:                             Functions and Variables for QUADPACK.
                                                             (line  555)
* quad_qags:                             Functions and Variables for QUADPACK.
                                                             (line   80)
* quad_qawc:                             Functions and Variables for QUADPACK.
                                                             (line  220)
* quad_qawf:                             Functions and Variables for QUADPACK.
                                                             (line  303)
* quad_qawo:                             Functions and Variables for QUADPACK.
                                                             (line  383)
* quad_qaws:                             Functions and Variables for QUADPACK.
                                                             (line  466)
* quantile:                              Functions and Variables for descriptive statistics.
                                                             (line  243)
* quantile_bernoulli:                    Bernoulli Random Variable.
                                                             (line   39)
* quantile_beta:                         Beta Random Variable.
                                                             (line   43)
* quantile_binomial:                     Binomial Random Variable.
                                                             (line   44)
* quantile_cauchy:                       Cauchy Random Variable.
                                                             (line   39)
* quantile_chi2:                         Chi-squared Random Variable.
                                                             (line   59)
* quantile_continuous_uniform:           Continuous Uniform Random Variable.
                                                             (line   33)
* quantile_discrete_uniform:             Discrete Uniform Random Variable.
                                                             (line   37)
* quantile_exp:                          Exponential Random Variable.
                                                             (line   46)
* quantile_f:                            F Random Variable.  (line   48)
* quantile_gamma:                        Gamma Random Variable.
                                                             (line   44)
* quantile_general_finite_discrete:      General Finite Discrete Random Variable.
                                                             (line   44)
* quantile_geometric:                    Geometric Random Variable.
                                                             (line   39)
* quantile_gumbel:                       Gumbel Random Variable.
                                                             (line   35)
* quantile_hypergeometric:               Hypergeometric Random Variable.
                                                             (line   54)
* quantile_laplace:                      Laplace Random Variable.
                                                             (line   39)
* quantile_logistic:                     Logistic Random Variable.
                                                             (line   42)
* quantile_lognormal:                    Lognormal Random Variable.
                                                             (line   50)
* quantile_negative_binomial:            Negative Binomial Random Variable.
                                                             (line   42)
* quantile_noncentral_chi2:              Noncentral Chi-squared Random Variable.
                                                             (line   39)
* quantile_noncentral_student_t:         Noncentral Student's t Random Variable.
                                                             (line   94)
* quantile_normal:                       Normal Random Variable.
                                                             (line   48)
* quantile_pareto:                       Pareto Random Variable.
                                                             (line   28)
* quantile_poisson:                      Poisson Random Variable.
                                                             (line   37)
* quantile_rayleigh:                     Rayleigh Random Variable.
                                                             (line   47)
* quantile_student_t:                    Student's t Random Variable.
                                                             (line   55)
* quantile_weibull:                      Weibull Random Variable.
                                                             (line   33)
* quartile_skewness:                     Functions and Variables for descriptive statistics.
                                                             (line  495)
* qubits:                                Functions and Variables for Quantum_Computing.
                                                             (line  131)
* quit:                                  Functions and Variables for Command Line.
                                                             (line  537)
* qunit:                                 Functions and Variables for Number Theory.
                                                             (line  502)
* Quote operator:                        Functions and Variables for Evaluation.
                                                             (line    7)
* Quote-quote operator:                  Functions and Variables for Evaluation.
                                                             (line  133)
* quotient:                              Functions and Variables for Polynomials.
                                                             (line 1008)
* racah_v:                               Functions and Variables for clebsch_gordan.
                                                             (line   10)
* racah_w:                               Functions and Variables for clebsch_gordan.
                                                             (line   15)
* radcan:                                Functions and Variables for Simplification.
                                                             (line  661)
* radexpand:                             Functions and Variables for Simplification.
                                                             (line  688)
* radius:                                Visualization with VTK.
                                                             (line  287)
* radius <1>:                            Functions and Variables for graphs.
                                                             (line  995)
* radsubstflag:                          Functions and Variables for Polynomials.
                                                             (line 1378)
* random:                                Random Numbers.     (line   33)
* random_bernoulli:                      Bernoulli Random Variable.
                                                             (line  128)
* random_beta:                           Beta Random Variable.
                                                             (line  106)
* random_binomial:                       Binomial Random Variable.
                                                             (line  100)
* random_bipartite_graph:                Functions and Variables for graphs.
                                                             (line  245)
* random_cauchy:                         Cauchy Random Variable.
                                                             (line   45)
* random_chi2:                           Chi-squared Random Variable.
                                                             (line  150)
* random_continuous_uniform:             Continuous Uniform Random Variable.
                                                             (line   93)
* random_digraph:                        Functions and Variables for graphs.
                                                             (line  249)
* random_discrete_uniform:               Discrete Uniform Random Variable.
                                                             (line  101)
* random_exp:                            Exponential Random Variable.
                                                             (line  150)
* random_f:                              F Random Variable.  (line  115)
* random_gamma:                          Gamma Random Variable.
                                                             (line   99)
* random_general_finite_discrete:        General Finite Discrete Random Variable.
                                                             (line   80)
* random_geometric:                      Geometric Random Variable.
                                                             (line  114)
* random_graph:                          Functions and Variables for graphs.
                                                             (line  260)
* random_graph1:                         Functions and Variables for graphs.
                                                             (line  264)
* random_gumbel:                         Gumbel Random Variable.
                                                             (line  108)
* random_hypergeometric:                 Hypergeometric Random Variable.
                                                             (line  134)
* random_laplace:                        Laplace Random Variable.
                                                             (line   89)
* random_logistic:                       Logistic Random Variable.
                                                             (line   99)
* random_lognormal:                      Lognormal Random Variable.
                                                             (line  123)
* random_negative_binomial:              Negative Binomial Random Variable.
                                                             (line  106)
* random_network:                        Functions and Variables for graphs.
                                                             (line  267)
* random_noncentral_chi2:                Noncentral Chi-squared Random Variable.
                                                             (line  100)
* random_noncentral_student_t:           Noncentral Student's t Random Variable.
                                                             (line  221)
* random_normal:                         Normal Random Variable.
                                                             (line  106)
* random_pareto:                         Pareto Random Variable.
                                                             (line   90)
* random_perm:                           Functions and Variables for Combinatorics.
                                                             (line  328)
* random_permutation:                    Functions and Variables for Sets.
                                                             (line  828)
* random_poisson:                        Poisson Random Variable.
                                                             (line   90)
* random_rayleigh:                       Rayleigh Random Variable.
                                                             (line  184)
* random_regular_graph:                  Functions and Variables for graphs.
                                                             (line  253)
* random_student_t:                      Student's t Random Variable.
                                                             (line  115)
* random_tournament:                     Functions and Variables for graphs.
                                                             (line  280)
* random_tree:                           Functions and Variables for graphs.
                                                             (line  283)
* random_weibull:                        Weibull Random Variable.
                                                             (line  102)
* range:                                 Functions and Variables for descriptive statistics.
                                                             (line  227)
* rank:                                  Functions and Variables for Matrices and Linear Algebra.
                                                             (line 1078)
* rassociative:                          Functions and Variables for Simplification.
                                                             (line  707)
* rat:                                   Functions and Variables for Polynomials.
                                                             (line 1018)
* ratalgdenom:                           Functions and Variables for Polynomials.
                                                             (line 1072)
* ratchristof:                           Functions and Variables for ctensor.
                                                             (line 1140)
* ratcoef:                               Functions and Variables for Polynomials.
                                                             (line 1080)
* ratdenom:                              Functions and Variables for Polynomials.
                                                             (line 1109)
* ratdenomdivide:                        Functions and Variables for Polynomials.
                                                             (line 1123)
* ratdiff:                               Functions and Variables for Polynomials.
                                                             (line 1167)
* ratdisrep:                             Functions and Variables for Polynomials.
                                                             (line 1210)
* rateinstein:                           Functions and Variables for ctensor.
                                                             (line 1144)
* ratepsilon:                            Functions and Variables for Numbers.
                                                             (line  455)
* ratexpand:                             Functions and Variables for Polynomials.
                                                             (line 1222)
* ratexpand <1>:                         Functions and Variables for Polynomials.
                                                             (line 1223)
* ratfac:                                Functions and Variables for Polynomials.
                                                             (line 1271)
* ratfor:                                Gentran Mode Switches.
                                                             (line    7)
* ratinterpol:                           Functions and Variables for interpol.
                                                             (line  314)
* rational:                              Functions and Variables for Properties.
                                                             (line  530)
* rational <1>:                          Package functs.     (line   34)
* rationalize:                           Functions and Variables for Numbers.
                                                             (line  462)
* ratlinelen:                            Gentran Option Variables.
                                                             (line   32)
* ratmx:                                 Functions and Variables for Matrices and Linear Algebra.
                                                             (line 1086)
* ratnumer:                              Functions and Variables for Polynomials.
                                                             (line 1293)
* ratnump:                               Functions and Variables for Numbers.
                                                             (line  494)
* ratp:                                  Functions and Variables for Polynomials.
                                                             (line 1307)
* ratprint:                              Functions and Variables for Polynomials.
                                                             (line 1315)
* ratp_coeffs:                           Functions and Variables for ratpow.
                                                             (line   44)
* ratp_dense_coeffs:                     Functions and Variables for ratpow.
                                                             (line   55)
* ratp_hipow:                            Functions and Variables for ratpow.
                                                             (line    6)
* ratp_lopow:                            Functions and Variables for ratpow.
                                                             (line   16)
* ratriemann:                            Functions and Variables for ctensor.
                                                             (line 1151)
* ratsimp:                               Functions and Variables for Polynomials.
                                                             (line 1322)
* ratsimp <1>:                           Functions and Variables for Polynomials.
                                                             (line 1323)
* ratsimpexpons:                         Functions and Variables for Polynomials.
                                                             (line 1372)
* ratsubst:                              Functions and Variables for Polynomials.
                                                             (line 1384)
* ratvars:                               Functions and Variables for Polynomials.
                                                             (line 1422)
* ratvars <1>:                           Functions and Variables for Polynomials.
                                                             (line 1423)
* ratvars <2>:                           Functions and Variables for Polynomials.
                                                             (line 1424)
* ratvarswitch:                          Functions and Variables for Polynomials.
                                                             (line 1443)
* ratweight:                             Functions and Variables for Polynomials.
                                                             (line 1494)
* ratweights:                            Functions and Variables for Polynomials.
                                                             (line 1524)
* ratweyl:                               Functions and Variables for ctensor.
                                                             (line 1159)
* ratwtlvl:                              Functions and Variables for Polynomials.
                                                             (line 1533)
* read:                                  Functions and Variables for Command Line.
                                                             (line  553)
* readbyte:                              String Input and Output.
                                                             (line  283)
* readchar:                              String Input and Output.
                                                             (line  306)
* readline:                              String Input and Output.
                                                             (line  313)
* readonly:                              Functions and Variables for Command Line.
                                                             (line  571)
* read_array:                            Functions and Variables for plain-text input and output.
                                                             (line   41)
* read_binary_array:                     Functions and Variables for binary input and output.
                                                             (line   44)
* read_binary_list:                      Functions and Variables for binary input and output.
                                                             (line   57)
* read_binary_matrix:                    Functions and Variables for binary input and output.
                                                             (line   32)
* read_hashed_array:                     Functions and Variables for plain-text input and output.
                                                             (line   62)
* read_list:                             Functions and Variables for plain-text input and output.
                                                             (line  106)
* read_matrix:                           Functions and Variables for plain-text input and output.
                                                             (line    6)
* read_nested_list:                      Functions and Variables for plain-text input and output.
                                                             (line   85)
* read_xpm:                              Functions and Variables for pictures.
                                                             (line   75)
* real:                                  Functions and Variables for Properties.
                                                             (line  538)
* Real infinity:                         Functions and Variables for Constants.
                                                             (line   50)
* realonly:                              Functions and Variables for Equations.
                                                             (line  703)
* realpart:                              Functions for Complex Numbers.
                                                             (line  201)
* realroots:                             Functions and Variables for Equations.
                                                             (line  709)
* real_fft:                              Functions and Variables for fast Fourier transform.
                                                             (line  222)
* real_imagpart_to_conjugate:            Functions and Variables for to_poly_solve.
                                                             (line  648)
* rearray:                               Functions and Variables for Arrays.
                                                             (line  415)
* rectangle:                             Functions and Variables for draw.
                                                             (line 3573)
* rectform:                              Functions for Complex Numbers.
                                                             (line  218)
* rectform_log_if_constant:              Functions and Variables for to_poly_solve.
                                                             (line  667)
* recttopolar:                           Functions and Variables for fast Fourier transform.
                                                             (line   24)
* rediff:                                Functions and Variables for itensor.
                                                             (line  669)
* redraw:                                Functions and Variables for graphs.
                                                             (line 1549)
* reduce_consts:                         Package rducon.     (line    6)
* reduce_order:                          Functions and Variables for solve_rec.
                                                             (line   34)
* refcheck:                              Functions and Variables for Debugging.
                                                             (line   20)
* region:                                Functions and Variables for draw.
                                                             (line 3601)
* region_boundaries:                     Functions and Variables for worldmap.
                                                             (line  119)
* region_boundaries_plus:                Functions and Variables for worldmap.
                                                             (line  133)
* rem:                                   Functions and Variables for Properties.
                                                             (line  548)
* remainder:                             Functions and Variables for Polynomials.
                                                             (line 1540)
* remarray:                              Functions and Variables for Arrays.
                                                             (line  423)
* rembox:                                Functions and Variables for Expressions.
                                                             (line  962)
* remcomps:                              Functions and Variables for itensor.
                                                             (line  289)
* remcon:                                Functions and Variables for itensor.
                                                             (line  172)
* remcoord:                              Functions and Variables for itensor.
                                                             (line  772)
* remfun:                                Functions and Variables for Fourier series.
                                                             (line   11)
* remfunction:                           Functions and Variables for Function Definition.
                                                             (line 1122)
* remlet:                                Functions and Variables for Rules and Patterns.
                                                             (line  560)
* remove:                                Functions and Variables for Properties.
                                                             (line  556)
* remove_constvalue:                     Functions and Variables for ezunits.
                                                             (line  293)
* remove_dimensions:                     Functions and Variables for ezunits.
                                                             (line  514)
* remove_edge:                           Functions and Variables for graphs.
                                                             (line 1274)
* remove_fundamental_dimensions:         Functions and Variables for ezunits.
                                                             (line  520)
* remove_fundamental_units:              Functions and Variables for ezunits.
                                                             (line  552)
* remove_index_properties:               Functions and Variables for Display.
                                                             (line  128)
* remove_plot_option:                    Functions and Variables for Plotting.
                                                             (line  445)
* remove_vertex:                         Functions and Variables for graphs.
                                                             (line 1288)
* rempart:                               Package functs.     (line    6)
* remrule:                               Functions and Variables for Rules and Patterns.
                                                             (line  584)
* remsym:                                Functions and Variables for itensor.
                                                             (line  580)
* remvalue:                              Functions and Variables for Miscellaneous Options.
                                                             (line   70)
* rename:                                Functions and Variables for itensor.
                                                             (line   80)
* rename_file:                           File operations.    (line    9)
* reset:                                 Functions and Variables for Command Line.
                                                             (line  593)
* reset_displays:                        Functions and Variables for alt-display.
                                                             (line  151)
* residue:                               Functions and Variables for Integration.
                                                             (line  668)
* resolution:                            Visualization with VTK.
                                                             (line  294)
* resolvante:                            Functions and Variables for Symmetries.
                                                             (line  559)
* resolvante_alternee1:                  Functions and Variables for Symmetries.
                                                             (line  731)
* resolvante_bipartite:                  Functions and Variables for Symmetries.
                                                             (line  740)
* resolvante_diedrale:                   Functions and Variables for Symmetries.
                                                             (line  753)
* resolvante_klein:                      Functions and Variables for Symmetries.
                                                             (line  771)
* resolvante_klein3:                     Functions and Variables for Symmetries.
                                                             (line  780)
* resolvante_produit_sym:                Functions and Variables for Symmetries.
                                                             (line  789)
* resolvante_unitaire:                   Functions and Variables for Symmetries.
                                                             (line  815)
* resolvante_vierer:                     Functions and Variables for Symmetries.
                                                             (line  824)
* rest:                                  Functions and Variables for Lists.
                                                             (line  702)
* restart:                               Visualization with VTK.
                                                             (line   91)
* resultant:                             Functions and Variables for Polynomials.
                                                             (line 1589)
* resultant <1>:                         Functions and Variables for Polynomials.
                                                             (line 1551)
* return:                                Functions and Variables for Program Flow.
                                                             (line  550)
* reveal:                                Functions and Variables for Expressions.
                                                             (line 1020)
* reverse:                               Functions and Variables for Lists.
                                                             (line  729)
* revert:                                Functions and Variables for Series.
                                                             (line  313)
* revert2:                               Functions and Variables for Series.
                                                             (line  314)
* rgb2level:                             Functions and Variables for pictures.
                                                             (line   78)
* rhs:                                   Functions and Variables for Equations.
                                                             (line  760)
* ric:                                   Functions and Variables for ctensor.
                                                             (line 1191)
* ricci:                                 Functions and Variables for ctensor.
                                                             (line  214)
* riem:                                  Functions and Variables for ctensor.
                                                             (line 1175)
* riemann:                               Functions and Variables for ctensor.
                                                             (line  252)
* rinvariant:                            Functions and Variables for ctensor.
                                                             (line  293)
* risch:                                 Functions and Variables for Integration.
                                                             (line  685)
* rk:                                    Functions for numerical solution of differential equations.
                                                             (line  213)
* rmdir:                                 Directory operations.
                                                             (line   12)
* rmxchar:                               Functions and Variables for Matrices and Linear Algebra.
                                                             (line 1105)
* rncombine:                             Functions and Variables for Miscellaneous Options.
                                                             (line   83)
* romberg:                               Functions and Variables for romberg.
                                                             (line    6)
* rombergabs:                            Functions and Variables for romberg.
                                                             (line  102)
* rombergit:                             Functions and Variables for romberg.
                                                             (line  115)
* rombergmin:                            Functions and Variables for romberg.
                                                             (line  126)
* rombergtol:                            Functions and Variables for romberg.
                                                             (line  135)
* room:                                  Functions and Variables for Runtime Environment.
                                                             (line   34)
* rootsconmode:                          Functions and Variables for Equations.
                                                             (line  802)
* rootscontract:                         Functions and Variables for Equations.
                                                             (line  808)
* rootsepsilon:                          Functions and Variables for Equations.
                                                             (line  870)
* round:                                 Functions for Numbers.
                                                             (line  353)
* row:                                   Functions and Variables for Matrices and Linear Algebra.
                                                             (line 1100)
* rowop:                                 Functions and Variables for linearalgebra.
                                                             (line  591)
* rowswap:                               Functions and Variables for linearalgebra.
                                                             (line  609)
* rreduce:                               Functions and Variables for Lists.
                                                             (line  737)
* rsetq:                                 Gentran Evaluation Forms.
                                                             (line   21)
* run_testsuite:                         Functions and Variables for Bug Detection and Reporting.
                                                             (line    6)
* run_viewer:                            Plotting Options.   (line  348)
* Rx:                                    Functions and Variables for Quantum_Computing.
                                                             (line  147)
* Ry:                                    Functions and Variables for Quantum_Computing.
                                                             (line  152)
* Rz:                                    Functions and Variables for Quantum_Computing.
                                                             (line  157)
* same_xy:                               Plotting Options.   (line  375)
* same_xyz:                              Plotting Options.   (line  382)
* sample:                                Plotting Options.   (line  388)
* save:                                  Functions and Variables for File Input and Output.
                                                             (line  378)
* savedef:                               Functions and Variables for Function Definition.
                                                             (line 1142)
* savefactors:                           Functions and Variables for Polynomials.
                                                             (line 1606)
* saving:                                Functions and Variables for finance.
                                                             (line  187)
* scalar:                                Functions and Variables for Properties.
                                                             (line  595)
* scalarmatrixp:                         Functions and Variables for Matrices and Linear Algebra.
                                                             (line 1113)
* scalarp:                               Functions and Variables for Properties.
                                                             (line  602)
* scale:                                 Visualization with VTK.
                                                             (line  300)
* scaled_bessel_i:                       Bessel Functions.   (line  204)
* scaled_bessel_i0:                      Bessel Functions.   (line  217)
* scaled_bessel_i1:                      Bessel Functions.   (line  221)
* scalefactors:                          Functions and Variables for Matrices and Linear Algebra.
                                                             (line 1126)
* scale_float:                           Functions and Variables for Numbers.
                                                             (line  499)
* scale_lp:                              Functions and Variables for simplex.
                                                             (line  148)
* scanmap:                               Functions and Variables for Program Flow.
                                                             (line  585)
* scatterplot:                           Functions and Variables for statistical graphs.
                                                             (line  475)
* scatterplot_description:               Functions and Variables for statistical graphs.
                                                             (line  533)
* scene:                                 Visualization with VTK.
                                                             (line   11)
* schur2comp:                            Functions and Variables for Symmetries.
                                                             (line  192)
* sconcat:                               Functions and Variables for Strings.
                                                             (line   49)
* scopy:                                 String Processing.  (line   63)
* scsimp:                                Functions and Variables for Simplification.
                                                             (line  715)
* scurvature:                            Functions and Variables for ctensor.
                                                             (line  230)
* sdowncase:                             String Processing.  (line   67)
* sec:                                   Trigonometric and Hyperbolic Functions.
                                                             (line   87)
* sech:                                  Trigonometric and Hyperbolic Functions.
                                                             (line   91)
* second:                                Functions and Variables for Lists.
                                                             (line  780)
* sequal:                                String Processing.  (line   75)
* sequalignore:                          String Processing.  (line   80)
* setcheck:                              Functions and Variables for Debugging.
                                                             (line   26)
* setcheckbreak:                         Functions and Variables for Debugging.
                                                             (line   55)
* setdifference:                         Functions and Variables for Sets.
                                                             (line  848)
* setelmx:                               Functions and Variables for Matrices and Linear Algebra.
                                                             (line 1144)
* setequalp:                             Functions and Variables for Sets.
                                                             (line  873)
* setify:                                Functions and Variables for Sets.
                                                             (line  889)
* setp:                                  Functions and Variables for Sets.
                                                             (line  906)
* setunits:                              Functions and Variables for Units.
                                                             (line    6)
* setup_autoload:                        Functions and Variables for Miscellaneous Options.
                                                             (line   99)
* setval:                                Functions and Variables for Debugging.
                                                             (line   67)
* set_alt_display:                       Functions and Variables for alt-display.
                                                             (line  155)
* set_draw_defaults:                     Functions and Variables for draw.
                                                             (line  186)
* set_edge_weight:                       Functions and Variables for graphs.
                                                             (line 1003)
* set_partitions:                        Functions and Variables for Sets.
                                                             (line  925)
* set_plot_option:                       Functions and Variables for Plotting.
                                                             (line  453)
* set_prompt:                            Functions and Variables for alt-display.
                                                             (line  174)
* set_random_state:                      Random Numbers.     (line   27)
* set_tex_environment:                   Functions and Variables for TeX Output.
                                                             (line  221)
* set_tex_environment_default:           Functions and Variables for TeX Output.
                                                             (line  261)
* set_up_dot_simplifications:            Functions and Variables for Affine.
                                                             (line   37)
* set_vertex_label:                      Functions and Variables for graphs.
                                                             (line 1016)
* seventh:                               Functions and Variables for Lists.
                                                             (line  785)
* sexplode:                              String Processing.  (line   87)
* sf:                                    Functions and Variables for atensor.
                                                             (line   93)
* sha1sum:                               Octets and Utilities for Cryptography.
                                                             (line  236)
* sha256sum:                             Octets and Utilities for Cryptography.
                                                             (line  265)
* share_testsuite_files:                 Functions and Variables for Bug Detection and Reporting.
                                                             (line   68)
* shortest_path:                         Functions and Variables for graphs.
                                                             (line 1035)
* shortest_weighted_path:                Functions and Variables for graphs.
                                                             (line 1045)
* showcomps:                             Functions and Variables for itensor.
                                                             (line  294)
* showratvars:                           Functions and Variables for Polynomials.
                                                             (line 1614)
* showtime:                              Functions and Variables for Command Line.
                                                             (line  604)
* show_edges:                            Functions and Variables for graphs.
                                                             (line 1526)
* show_edge_color:                       Functions and Variables for graphs.
                                                             (line 1530)
* show_edge_type:                        Functions and Variables for graphs.
                                                             (line 1536)
* show_edge_width:                       Functions and Variables for graphs.
                                                             (line 1533)
* show_form:                             Functions in pytranslate.
                                                             (line   58)
* show_id:                               Functions and Variables for graphs.
                                                             (line 1456)
* show_label:                            Functions and Variables for graphs.
                                                             (line 1461)
* show_vertex_color:                     Functions and Variables for graphs.
                                                             (line 1502)
* show_vertex_size:                      Functions and Variables for graphs.
                                                             (line 1499)
* show_vertex_type:                      Functions and Variables for graphs.
                                                             (line 1494)
* show_vertices:                         Functions and Variables for graphs.
                                                             (line 1489)
* show_weight:                           Functions and Variables for graphs.
                                                             (line 1472)
* sierpinskiale:                         Definitions for IFS fractals.
                                                             (line   19)
* sierpinskimap:                         Definitions for Peano maps.
                                                             (line   19)
* sign:                                  Functions and Variables for Facts.
                                                             (line  417)
* signum:                                Functions for Numbers.
                                                             (line  362)
* similaritytransform:                   Functions and Variables for Matrices and Linear Algebra.
                                                             (line 1152)
* simp:                                  Functions and Variables for Simplification.
                                                             (line  725)
* simplified_output:                     Functions and Variables for zeilberger.
                                                             (line  100)
* simplify_products:                     Functions and Variables for solve_rec.
                                                             (line   82)
* simplify_sum:                          Functions and Variables for solve_rec.
                                                             (line   90)
* simplode:                              String Processing.  (line   91)
* simpmetderiv:                          Functions and Variables for itensor.
                                                             (line  806)
* simpproduct:                           Functions and Variables for Sums and Products.
                                                             (line   47)
* simpsum:                               Functions and Variables for Sums and Products.
                                                             (line  115)
* simp_inequality:                       Functions and Variables for to_poly_solve.
                                                             (line  691)
* simtran:                               Functions and Variables for Matrices and Linear Algebra.
                                                             (line 1153)
* sin:                                   Trigonometric and Hyperbolic Functions.
                                                             (line   95)
* sinh:                                  Trigonometric and Hyperbolic Functions.
                                                             (line   99)
* sinnpiflag:                            Functions and Variables for Fourier series.
                                                             (line   59)
* sinsert:                               String Processing.  (line  110)
* sinvertcase:                           String Processing.  (line  123)
* sixth:                                 Functions and Variables for Lists.
                                                             (line  790)
* skewness:                              Functions and Variables for descriptive statistics.
                                                             (line  445)
* skewness_bernoulli:                    Bernoulli Random Variable.
                                                             (line   90)
* skewness_beta:                         Beta Random Variable.
                                                             (line   83)
* skewness_binomial:                     Binomial Random Variable.
                                                             (line   78)
* skewness_chi2:                         Chi-squared Random Variable.
                                                             (line  112)
* skewness_continuous_uniform:           Continuous Uniform Random Variable.
                                                             (line   75)
* skewness_discrete_uniform:             Discrete Uniform Random Variable.
                                                             (line   79)
* skewness_exp:                          Exponential Random Variable.
                                                             (line  120)
* skewness_f:                            F Random Variable.  (line   90)
* skewness_gamma:                        Gamma Random Variable.
                                                             (line   76)
* skewness_general_finite_discrete:      General Finite Discrete Random Variable.
                                                             (line   68)
* skewness_geometric:                    Geometric Random Variable.
                                                             (line   89)
* skewness_gumbel:                       Gumbel Random Variable.
                                                             (line   76)
* skewness_hypergeometric:               Hypergeometric Random Variable.
                                                             (line  101)
* skewness_laplace:                      Laplace Random Variable.
                                                             (line   71)
* skewness_logistic:                     Logistic Random Variable.
                                                             (line   79)
* skewness_lognormal:                    Lognormal Random Variable.
                                                             (line  100)
* skewness_negative_binomial:            Negative Binomial Random Variable.
                                                             (line   83)
* skewness_noncentral_chi2:              Noncentral Chi-squared Random Variable.
                                                             (line   74)
* skewness_noncentral_student_t:         Noncentral Student's t Random Variable.
                                                             (line  163)
* skewness_normal:                       Normal Random Variable.
                                                             (line   88)
* skewness_pareto:                       Pareto Random Variable.
                                                             (line   66)
* skewness_poisson:                      Poisson Random Variable.
                                                             (line   68)
* skewness_rayleigh:                     Rayleigh Random Variable.
                                                             (line  126)
* skewness_student_t:                    Student's t Random Variable.
                                                             (line   95)
* skewness_weibull:                      Weibull Random Variable.
                                                             (line   70)
* slength:                               String Processing.  (line  137)
* slommel:                               Bessel Functions.   (line  243)
* smake:                                 String Processing.  (line  141)
* small_rhombicosidodecahedron_graph:    Functions and Variables for graphs.
                                                             (line  286)
* small_rhombicuboctahedron_graph:       Functions and Variables for graphs.
                                                             (line  289)
* smax:                                  Functions and Variables for descriptive statistics.
                                                             (line  209)
* smin:                                  Functions and Variables for descriptive statistics.
                                                             (line  191)
* smismatch:                             String Processing.  (line  150)
* snowmap:                               Definitions for Koch snowflakes.
                                                             (line    6)
* snub_cube_graph:                       Functions and Variables for graphs.
                                                             (line  292)
* snub_dodecahedron_graph:               Functions and Variables for graphs.
                                                             (line  295)
* solve:                                 Functions and Variables for Equations.
                                                             (line  876)
* solvedecomposes:                       Functions and Variables for Equations.
                                                             (line 1035)
* solveexplicit:                         Functions and Variables for Equations.
                                                             (line 1041)
* solvefactors:                          Functions and Variables for Equations.
                                                             (line 1048)
* solvenullwarn:                         Functions and Variables for Equations.
                                                             (line 1055)
* solveradcan:                           Functions and Variables for Equations.
                                                             (line 1063)
* solvetrigwarn:                         Functions and Variables for Equations.
                                                             (line 1070)
* solve_rec:                             Functions and Variables for solve_rec.
                                                             (line  112)
* solve_rec_rat:                         Functions and Variables for solve_rec.
                                                             (line  176)
* some:                                  Functions and Variables for Sets.
                                                             (line  976)
* somrac:                                Functions and Variables for Symmetries.
                                                             (line  549)
* sort:                                  Functions and Variables for Lists.
                                                             (line  795)
* space:                                 Characters.         (line  208)
* sparse:                                Functions and Variables for Matrices and Linear Algebra.
                                                             (line 1178)
* sparse6_decode:                        Functions and Variables for graphs.
                                                             (line 1322)
* sparse6_encode:                        Functions and Variables for graphs.
                                                             (line 1327)
* sparse6_export:                        Functions and Variables for graphs.
                                                             (line 1332)
* sparse6_import:                        Functions and Variables for graphs.
                                                             (line 1337)
* specint:                               Functions and Variables for Integration.
                                                             (line  708)
* sphere:                                Visualization with VTK.
                                                             (line  162)
* spherical:                             Functions and Variables for draw.
                                                             (line 3622)
* spherical_bessel_j:                    Functions and Variables for orthogonal polynomials.
                                                             (line  511)
* spherical_bessel_y:                    Functions and Variables for orthogonal polynomials.
                                                             (line  548)
* spherical_hankel1:                     Functions and Variables for orthogonal polynomials.
                                                             (line  584)
* spherical_hankel2:                     Functions and Variables for orthogonal polynomials.
                                                             (line  596)
* spherical_harmonic:                    Functions and Variables for orthogonal polynomials.
                                                             (line  608)
* spherical_to_xyz:                      Functions and Variables for Plotting.
                                                             (line  482)
* splice:                                Macros.             (line  177)
* split:                                 String Processing.  (line  164)
* splitfield:                            Functions and Variables for algebraic extensions.
                                                             (line  111)
* sposition:                             String Processing.  (line  184)
* spring_embedding_depth:                Functions and Variables for graphs.
                                                             (line 1565)
* sprint:                                String Input and Output.
                                                             (line  319)
* sqfr:                                  Functions and Variables for Polynomials.
                                                             (line 1621)
* sqrt:                                  Root Exponential and Logarithmic Functions.
                                                             (line  358)
* sqrtdenest:                            Functions and Variables for Expressions.
                                                             (line 1078)
* sqrtdispflag:                          Functions and Variables for Display.
                                                             (line  836)
* sremove:                               String Processing.  (line  189)
* sremovefirst:                          String Processing.  (line  208)
* sreverse:                              String Processing.  (line  217)
* ssearch:                               String Processing.  (line  224)
* ssort:                                 String Processing.  (line  241)
* sstatus:                               Functions and Variables for Runtime Environment.
                                                             (line   47)
* ssubst:                                String Processing.  (line  259)
* ssubstfirst:                           String Processing.  (line  279)
* staircase:                             Graphical analysis of discrete dynamical systems.
                                                             (line  125)
* standardize:                           Functions and Variables for data manipulation.
                                                             (line  175)
* standardize_inverse_trig:              Functions and Variables for to_poly_solve.
                                                             (line  758)
* stardisp:                              Functions and Variables for Display.
                                                             (line  842)
* starplot:                              Functions and Variables for statistical graphs.
                                                             (line  539)
* starplot_description:                  Functions and Variables for statistical graphs.
                                                             (line  599)
* startphi:                              Visualization with VTK.
                                                             (line  310)
* starttheta:                            Visualization with VTK.
                                                             (line  321)
* stats_numer:                           Functions and Variables for stats.
                                                             (line    6)
* status:                                Functions and Variables for Runtime Environment.
                                                             (line   58)
* std:                                   Functions and Variables for descriptive statistics.
                                                             (line   81)
* std1:                                  Functions and Variables for descriptive statistics.
                                                             (line  101)
* std_bernoulli:                         Bernoulli Random Variable.
                                                             (line   75)
* std_beta:                              Beta Random Variable.
                                                             (line   70)
* std_binomial:                          Binomial Random Variable.
                                                             (line   69)
* std_chi2:                              Chi-squared Random Variable.
                                                             (line   98)
* std_continuous_uniform:                Continuous Uniform Random Variable.
                                                             (line   63)
* std_discrete_uniform:                  Discrete Uniform Random Variable.
                                                             (line   67)
* std_exp:                               Exponential Random Variable.
                                                             (line  101)
* std_f:                                 F Random Variable.  (line   79)
* std_gamma:                             Gamma Random Variable.
                                                             (line   67)
* std_general_finite_discrete:           General Finite Discrete Random Variable.
                                                             (line   62)
* std_geometric:                         Geometric Random Variable.
                                                             (line   79)
* std_gumbel:                            Gumbel Random Variable.
                                                             (line   65)
* std_hypergeometric:                    Hypergeometric Random Variable.
                                                             (line   87)
* std_laplace:                           Laplace Random Variable.
                                                             (line   62)
* std_logistic:                          Logistic Random Variable.
                                                             (line   68)
* std_lognormal:                         Lognormal Random Variable.
                                                             (line   86)
* std_negative_binomial:                 Negative Binomial Random Variable.
                                                             (line   72)
* std_noncentral_chi2:                   Noncentral Chi-squared Random Variable.
                                                             (line   65)
* std_noncentral_student_t:              Noncentral Student's t Random Variable.
                                                             (line  147)
* std_normal:                            Normal Random Variable.
                                                             (line   79)
* std_pareto:                            Pareto Random Variable.
                                                             (line   53)
* std_poisson:                           Poisson Random Variable.
                                                             (line   59)
* std_rayleigh:                          Rayleigh Random Variable.
                                                             (line  103)
* std_student_t:                         Student's t Random Variable.
                                                             (line   84)
* std_weibull:                           Weibull Random Variable.
                                                             (line   59)
* stemplot:                              Functions and Variables for statistical graphs.
                                                             (line  604)
* step:                                  Functions and Variables for Program Flow.
                                                             (line   60)
* stirling:                              Functions and Variables for stirling.
                                                             (line    6)
* stirling1:                             Functions and Variables for Sets.
                                                             (line 1048)
* stirling2:                             Functions and Variables for Sets.
                                                             (line 1084)
* strim:                                 String Processing.  (line  288)
* striml:                                String Processing.  (line  301)
* strimr:                                String Processing.  (line  305)
* string:                                Functions and Variables for Strings.
                                                             (line   67)
* stringdisp:                            Functions and Variables for Strings.
                                                             (line   77)
* stringout:                             Functions and Variables for File Input and Output.
                                                             (line  435)
* stringp:                               String Processing.  (line  309)
* string_to_octets:                      Octets and Utilities for Cryptography.
                                                             (line  286)
* strong_components:                     Functions and Variables for graphs.
                                                             (line 1061)
* structures:                            Functions and Variables for Structures.
                                                             (line    6)
* struve_h:                              Struve Functions.   (line   16)
* struve_l:                              Struve Functions.   (line   31)
* style:                                 Plotting Options.   (line  404)
* sublis:                                Functions and Variables for Expressions.
                                                             (line 1099)
* sublist:                               Functions and Variables for Lists.
                                                             (line  929)
* sublist_indices:                       Functions and Variables for Lists.
                                                             (line  941)
* sublis_apply_lambda:                   Functions and Variables for Expressions.
                                                             (line 1115)
* submatrix:                             Functions and Variables for Matrices and Linear Algebra.
                                                             (line 1185)
* subnumsimp:                            Functions and Variables for Expressions.
                                                             (line 1122)
* subsample:                             Functions and Variables for data manipulation.
                                                             (line  184)
* Subscript operator:                    Functions and Variables for Lists.
                                                             (line    6)
* subset:                                Functions and Variables for Sets.
                                                             (line 1124)
* subsetp:                               Functions and Variables for Sets.
                                                             (line 1143)
* subst:                                 Functions and Variables for Expressions.
                                                             (line 1140)
* substinpart:                           Functions and Variables for Expressions.
                                                             (line 1216)
* substpart:                             Functions and Variables for Expressions.
                                                             (line 1272)
* substring:                             String Processing.  (line  313)
* subst_parallel:                        Functions and Variables for to_poly_solve.
                                                             (line  771)
* Subtraction:                           Arithmetic operators.
                                                             (line    6)
* subvar:                                Functions and Variables for Arrays.
                                                             (line  440)
* subvarp:                               Functions and Variables for Arrays.
                                                             (line  465)
* sum:                                   Functions and Variables for Sums and Products.
                                                             (line  124)
* sumcontract:                           Functions and Variables for Sums and Products.
                                                             (line  225)
* sumexpand:                             Functions and Variables for Sums and Products.
                                                             (line  238)
* summand_to_rec:                        Functions and Variables for solve_rec.
                                                             (line  207)
* sumsplitfact:                          Combinatorial Functions.
                                                             (line  191)
* supcase:                               String Processing.  (line  330)
* supcontext:                            Functions and Variables for Facts.
                                                             (line  427)
* surface:                               Visualization with VTK.
                                                             (line  332)
* surface_hide:                          Functions and Variables for draw.
                                                             (line 1822)
* svg_file:                              Plotting Options.   (line  439)
* symbolp:                               Functions and Variables for Expressions.
                                                             (line 1300)
* symmdifference:                        Functions and Variables for Sets.
                                                             (line 1156)
* symmetric:                             Functions and Variables for Simplification.
                                                             (line  768)
* symmetricp:                            Functions and Variables for ctensor.
                                                             (line  829)
* system:                                Functions and Variables for Runtime Environment.
                                                             (line   83)
* t:                                     Plotting Options.   (line  452)
* tab:                                   Characters.         (line  212)
* tablen:                                Gentran Option Variables.
                                                             (line   56)
* take_channel:                          Functions and Variables for pictures.
                                                             (line   82)
* take_inference:                        Functions and Variables for inference_result.
                                                             (line   73)
* tan:                                   Trigonometric and Hyperbolic Functions.
                                                             (line  103)
* tanh:                                  Trigonometric and Hyperbolic Functions.
                                                             (line  107)
* taylor:                                Functions and Variables for Series.
                                                             (line  355)
* taylordepth:                           Functions and Variables for Series.
                                                             (line  514)
* taylorinfo:                            Functions and Variables for Series.
                                                             (line  521)
* taylorp:                               Functions and Variables for Series.
                                                             (line  546)
* taylor_logexpand:                      Functions and Variables for Series.
                                                             (line  550)
* taylor_order_coefficients:             Functions and Variables for Series.
                                                             (line  566)
* taylor_simplifier:                     Functions and Variables for Series.
                                                             (line  575)
* taylor_truncate_polynomials:           Functions and Variables for Series.
                                                             (line  580)
* taytorat:                              Functions and Variables for Series.
                                                             (line  589)
* tcl_output:                            Functions and Variables for Miscellaneous Options.
                                                             (line  133)
* tcontract:                             Functions and Variables for Symmetries.
                                                             (line  260)
* tellrat:                               Functions and Variables for Polynomials.
                                                             (line 1638)
* tellsimp:                              Functions and Variables for Rules and Patterns.
                                                             (line  631)
* tellsimpafter:                         Functions and Variables for Rules and Patterns.
                                                             (line  689)
* tempvar:                               Functions for Gentran.
                                                             (line  122)
* tempvarname:                           Gentran Option Variables.
                                                             (line  122)
* tempvarnum:                            Gentran Option Variables.
                                                             (line  136)
* tempvartype:                           Gentran Option Variables.
                                                             (line  147)
* tensorkill:                            Functions and Variables for ctensor.
                                                             (line 1257)
* tentex:                                Functions and Variables for itensor.
                                                             (line 1562)
* tenth:                                 Functions and Variables for Lists.
                                                             (line  965)
* terminal:                              Functions and Variables for draw.
                                                             (line 1839)
* terminal <1>:                          Functions and Variables for graphs.
                                                             (line 1571)
* testsuite_files:                       Functions and Variables for Bug Detection and Reporting.
                                                             (line   52)
* test_mean:                             Functions and Variables for stats.
                                                             (line   13)
* test_means_difference:                 Functions and Variables for stats.
                                                             (line  122)
* test_normality:                        Functions and Variables for stats.
                                                             (line  781)
* test_proportion:                       Functions and Variables for stats.
                                                             (line  382)
* test_proportions_difference:           Functions and Variables for stats.
                                                             (line  482)
* test_rank_sum:                         Functions and Variables for stats.
                                                             (line  709)
* test_sign:                             Functions and Variables for stats.
                                                             (line  574)
* test_signed_rank:                      Functions and Variables for stats.
                                                             (line  629)
* test_variance:                         Functions and Variables for stats.
                                                             (line  238)
* test_variance_ratio:                   Functions and Variables for stats.
                                                             (line  310)
* tex:                                   Functions and Variables for TeX Output.
                                                             (line    9)
* tex1:                                  Functions and Variables for TeX Output.
                                                             (line   69)
* texput:                                Functions and Variables for TeX Output.
                                                             (line   82)
* tex_display:                           Functions and Variables for alt-display.
                                                             (line  115)
* thetaresolution:                       Visualization with VTK.
                                                             (line  339)
* third:                                 Functions and Variables for Lists.
                                                             (line  970)
* throw:                                 Functions and Variables for Program Flow.
                                                             (line  627)
* thru:                                  Functions and Variables for Program Flow.
                                                             (line   59)
* time:                                  Functions and Variables for Runtime Environment.
                                                             (line  104)
* timedate:                              Functions and Variables for Runtime Environment.
                                                             (line  115)
* timer:                                 Functions and Variables for Debugging.
                                                             (line   75)
* timer_devalue:                         Functions and Variables for Debugging.
                                                             (line  118)
* timer_info:                            Functions and Variables for Debugging.
                                                             (line  129)
* title:                                 Plotting Options.   (line  456)
* title <1>:                             Functions and Variables for draw.
                                                             (line 1916)
* tldefint:                              Functions and Variables for Integration.
                                                             (line  805)
* tlimit:                                Functions and Variables for Limits.
                                                             (line   65)
* tlimswitch:                            Functions and Variables for Limits.
                                                             (line   73)
* todd_coxeter:                          Functions and Variables for Groups.
                                                             (line    6)
* toeplitz:                              Functions and Variables for linearalgebra.
                                                             (line  614)
* toffoli:                               Functions and Variables for Quantum_Computing.
                                                             (line  167)
* tokens:                                String Processing.  (line  345)
* topological_sort:                      Functions and Variables for graphs.
                                                             (line 1072)
* totaldisrep:                           Functions and Variables for Polynomials.
                                                             (line 1692)
* totalfourier:                          Functions and Variables for Fourier series.
                                                             (line   85)
* totient:                               Functions and Variables for Number Theory.
                                                             (line  514)
* to_lisp:                               Functions and Variables for Command Line.
                                                             (line  615)
* to_poly:                               Functions and Variables for to_poly_solve.
                                                             (line  826)
* to_poly_solve:                         Functions and Variables for to_poly_solve.
                                                             (line  885)
* tpartpol:                              Functions and Variables for Symmetries.
                                                             (line  265)
* tprod:                                 Functions and Variables for Quantum_Computing.
                                                             (line  162)
* tr:                                    Functions and Variables for ctensor.
                                                             (line 1239)
* trace:                                 Functions and Variables for Debugging.
                                                             (line  149)
* tracematrix:                           Package functs.     (line   29)
* trace_options:                         Functions and Variables for Debugging.
                                                             (line  177)
* track:                                 Visualization with VTK.
                                                             (line  348)
* transform:                             Functions and Variables for draw.
                                                             (line 1931)
* transform_sample:                      Functions and Variables for data manipulation.
                                                             (line  299)
* transform_xy:                          Plotting Options.   (line  460)
* translate:                             Functions and Variables for Function Definition.
                                                             (line 1153)
* translate_fast_arrays:                 Functions and Variables for Arrays.
                                                             (line  487)
* translate_file:                        Functions and Variables for Function Definition.
                                                             (line 1209)
* transparent:                           Functions and Variables for draw.
                                                             (line 1970)
* transpose:                             Functions and Variables for Matrices and Linear Algebra.
                                                             (line 1193)
* transrun:                              Functions and Variables for Function Definition.
                                                             (line 1267)
* treefale:                              Definitions for IFS fractals.
                                                             (line   31)
* tree_reduce:                           Functions and Variables for Lists.
                                                             (line  975)
* treillis:                              Functions and Variables for Symmetries.
                                                             (line  469)
* treinat:                               Functions and Variables for Symmetries.
                                                             (line  477)
* triangle:                              Functions and Variables for draw.
                                                             (line 3643)
* triangularize:                         Functions and Variables for Matrices and Linear Algebra.
                                                             (line 1206)
* trigeval:                              Evaluation of Trignometric Functions.
                                                             (line   10)
* trigexpand:                            Explicit Simplifications Using Identities.
                                                             (line    6)
* trigexpandplus:                        Explicit Simplifications Using Identities.
                                                             (line   40)
* trigexpandtimes:                       Explicit Simplifications Using Identities.
                                                             (line   48)
* trigfactor:                            Factor Sums of sin and cos Functions.
                                                             (line    6)
* triginverses:                          Explicit Simplifications Using Identities.
                                                             (line   56)
* trigrat:                               Explicit Simplifications Using Identities.
                                                             (line   98)
* trigreduce:                            Explicit Simplifications Using Identities.
                                                             (line   71)
* trigsign:                              Options Controlling Simplification.
                                                             (line  126)
* trigsimp:                              Explicit Simplifications Using Identities.
                                                             (line   87)
* trigsolve:                             Solve Trignometric Equations.
                                                             (line    6)
* trigvalue:                             Evaluation of Trignometric Functions.
                                                             (line    6)
* trivial_solutions:                     Functions and Variables for zeilberger.
                                                             (line  125)
* true:                                  Functions and Variables for Constants.
                                                             (line  156)
* trunc:                                 Functions and Variables for Series.
                                                             (line  595)
* truncate:                              Functions for Numbers.
                                                             (line  379)
* truncated_cube_graph:                  Functions and Variables for graphs.
                                                             (line  298)
* truncated_dodecahedron_graph:          Functions and Variables for graphs.
                                                             (line  301)
* truncated_icosahedron_graph:           Functions and Variables for graphs.
                                                             (line  304)
* truncated_tetrahedron_graph:           Functions and Variables for graphs.
                                                             (line  307)
* tr_array_as_ref:                       Functions and Variables for Function Definition.
                                                             (line 1274)
* tr_bound_function_applyp:              Functions and Variables for Function Definition.
                                                             (line 1285)
* tr_file_tty_messagesp:                 Functions and Variables for Function Definition.
                                                             (line 1311)
* tr_float_can_branch_complex:           Functions and Variables for Function Definition.
                                                             (line 1320)
* tr_function_call_default:              Functions and Variables for Function Definition.
                                                             (line 1331)
* tr_numer:                              Functions and Variables for Function Definition.
                                                             (line 1344)
* tr_optimize_max_loop:                  Functions and Variables for Function Definition.
                                                             (line 1350)
* tr_state_vars:                         Functions and Variables for Function Definition.
                                                             (line 1358)
* tr_warnings_get:                       Functions and Variables for Function Definition.
                                                             (line 1369)
* tr_warn_bad_function_calls:            Functions and Variables for Function Definition.
                                                             (line 1374)
* tr_warn_fexpr:                         Functions and Variables for Function Definition.
                                                             (line 1381)
* tr_warn_meval:                         Functions and Variables for Function Definition.
                                                             (line 1388)
* tr_warn_mode:                          Functions and Variables for Function Definition.
                                                             (line 1394)
* tr_warn_undeclared:                    Functions and Variables for Function Definition.
                                                             (line 1400)
* tr_warn_undefined_variable:            Functions and Variables for Function Definition.
                                                             (line 1406)
* tstep:                                 Visualization with VTK.
                                                             (line   98)
* ttyoff:                                Functions and Variables for Display.
                                                             (line  848)
* tube:                                  Functions and Variables for draw.
                                                             (line 3672)
* tutte_graph:                           Functions and Variables for graphs.
                                                             (line  310)
* type:                                  Gentran Evaluation Forms.
                                                             (line   46)
* ueivects:                              Functions and Variables for Matrices and Linear Algebra.
                                                             (line 1230)
* ufg:                                   Functions and Variables for ctensor.
                                                             (line 1171)
* uforget:                               Functions and Variables for Units.
                                                             (line  112)
* ug:                                    Functions and Variables for ctensor.
                                                             (line 1204)
* ultraspherical:                        Functions and Variables for orthogonal polynomials.
                                                             (line  670)
* und:                                   Functions and Variables for Constants.
                                                             (line  161)
* Undefined:                             Functions and Variables for Constants.
                                                             (line  162)
* underlying_graph:                      Functions and Variables for graphs.
                                                             (line  313)
* undiff:                                Functions and Variables for itensor.
                                                             (line  674)
* unicode:                               Characters.         (line  216)
* unicode_to_utf8:                       Characters.         (line  263)
* union:                                 Functions and Variables for Sets.
                                                             (line 1184)
* unique:                                Functions and Variables for Lists.
                                                             (line 1011)
* uniteigenvectors:                      Functions and Variables for Matrices and Linear Algebra.
                                                             (line 1229)
* unitp:                                 Functions and Variables for ezunits.
                                                             (line  407)
* units:                                 Functions and Variables for ezunits.
                                                             (line  298)
* unitvector:                            Functions and Variables for Matrices and Linear Algebra.
                                                             (line 1257)
* unit_in_last_plase:                    Functions and Variables for Numbers.
                                                             (line  531)
* unit_step:                             Functions and Variables for orthogonal polynomials.
                                                             (line  663)
* unit_vectors:                          Functions and Variables for draw.
                                                             (line 1987)
* unknown:                               Functions and Variables for Predicates.
                                                             (line  182)
* unless:                                Functions and Variables for Program Flow.
                                                             (line   56)
* unmarkvar:                             Functions for Gentran.
                                                             (line  137)
* unorder:                               Functions and Variables for Expressions.
                                                             (line 1306)
* unsum:                                 Functions and Variables for Series.
                                                             (line  612)
* untellrat:                             Functions and Variables for Polynomials.
                                                             (line 1703)
* untimer:                               Functions and Variables for Debugging.
                                                             (line  103)
* untrace:                               Functions and Variables for Debugging.
                                                             (line  230)
* uppercasep:                            Characters.         (line  278)
* uric:                                  Functions and Variables for ctensor.
                                                             (line 1195)
* uricci:                                Functions and Variables for ctensor.
                                                             (line  220)
* uriem:                                 Functions and Variables for ctensor.
                                                             (line 1187)
* uriemann:                              Functions and Variables for ctensor.
                                                             (line  288)
* url_base:                              Functions and Variables for Help.
                                                             (line  191)
* usefortcomplex:                        Gentran Option Variables.
                                                             (line  186)
* usersetunits:                          Functions and Variables for Units.
                                                             (line  211)
* user_preamble:                         Functions and Variables for draw.
                                                             (line 2007)
* use_fast_arrays:                       Functions and Variables for Arrays.
                                                             (line  470)
* us_ascii_only:                         Characters.         (line  284)
* utf8_to_unicode:                       Characters.         (line  304)
* uvect:                                 Functions and Variables for Matrices and Linear Algebra.
                                                             (line 1258)
* values:                                Functions and Variables for Command Line.
                                                             (line  669)
* vandermonde_matrix:                    Functions and Variables for linearalgebra.
                                                             (line  634)
* var:                                   Functions and Variables for descriptive statistics.
                                                             (line   33)
* var1:                                  Functions and Variables for descriptive statistics.
                                                             (line   55)
* var_bernoulli:                         Bernoulli Random Variable.
                                                             (line   60)
* var_beta:                              Beta Random Variable.
                                                             (line   59)
* var_binomial:                          Binomial Random Variable.
                                                             (line   60)
* var_chi2:                              Chi-squared Random Variable.
                                                             (line   84)
* var_continuous_uniform:                Continuous Uniform Random Variable.
                                                             (line   51)
* var_discrete_uniform:                  Discrete Uniform Random Variable.
                                                             (line   55)
* var_exp:                               Exponential Random Variable.
                                                             (line   80)
* var_f:                                 F Random Variable.  (line   67)
* var_gamma:                             Gamma Random Variable.
                                                             (line   58)
* var_general_finite_discrete:           General Finite Discrete Random Variable.
                                                             (line   56)
* var_geometric:                         Geometric Random Variable.
                                                             (line   66)
* var_gumbel:                            Gumbel Random Variable.
                                                             (line   54)
* var_hypergeometric:                    Hypergeometric Random Variable.
                                                             (line   74)
* var_laplace:                           Laplace Random Variable.
                                                             (line   53)
* var_logistic:                          Logistic Random Variable.
                                                             (line   56)
* var_lognormal:                         Lognormal Random Variable.
                                                             (line   75)
* var_negative_binomial:                 Negative Binomial Random Variable.
                                                             (line   60)
* var_noncentral_chi2:                   Noncentral Chi-squared Random Variable.
                                                             (line   56)
* var_noncentral_student_t:              Noncentral Student's t Random Variable.
                                                             (line  129)
* var_normal:                            Normal Random Variable.
                                                             (line   70)
* var_pareto:                            Pareto Random Variable.
                                                             (line   40)
* var_poisson:                           Poisson Random Variable.
                                                             (line   51)
* var_rayleigh:                          Rayleigh Random Variable.
                                                             (line   79)
* var_student_t:                         Student's t Random Variable.
                                                             (line   69)
* var_weibull:                           Weibull Random Variable.
                                                             (line   49)
* vector:                                Functions and Variables for draw.
                                                             (line 3695)
* vectorpotential:                       Functions and Variables for Matrices and Linear Algebra.
                                                             (line 1267)
* vectorsimp:                            Functions and Variables for Matrices and Linear Algebra.
                                                             (line 1274)
* vect_cross:                            Functions and Variables for Matrices and Linear Algebra.
                                                             (line 1307)
* verbify:                               Functions and Variables for Expressions.
                                                             (line 1342)
* verbose:                               Functions and Variables for Series.
                                                             (line  642)
* vers:                                  Package functs.     (line  156)
* vertex_color:                          Functions and Variables for graphs.
                                                             (line 1486)
* vertex_coloring:                       Functions and Variables for graphs.
                                                             (line 1512)
* vertex_coloring <1>:                   Functions and Variables for graphs.
                                                             (line 1158)
* vertex_connectivity:                   Functions and Variables for graphs.
                                                             (line 1089)
* vertex_degree:                         Functions and Variables for graphs.
                                                             (line 1094)
* vertex_distance:                       Functions and Variables for graphs.
                                                             (line 1097)
* vertex_eccentricity:                   Functions and Variables for graphs.
                                                             (line 1109)
* vertex_in_degree:                      Functions and Variables for graphs.
                                                             (line 1119)
* vertex_out_degree:                     Functions and Variables for graphs.
                                                             (line 1138)
* vertex_partition:                      Functions and Variables for graphs.
                                                             (line 1505)
* vertex_size:                           Functions and Variables for graphs.
                                                             (line 1483)
* vertex_type:                           Functions and Variables for graphs.
                                                             (line 1477)
* vertices:                              Functions and Variables for graphs.
                                                             (line 1150)
* vertices_to_cycle:                     Functions and Variables for graphs.
                                                             (line 1594)
* vertices_to_path:                      Functions and Variables for graphs.
                                                             (line 1590)
* view:                                  Functions and Variables for draw.
                                                             (line 2041)
* warning:                               Functions and Variables for Program Flow.
                                                             (line  282)
* warnings:                              Functions and Variables for zeilberger.
                                                             (line  112)
* wc_inputvalueranges:                   Functions and Variables for wrstcse.
                                                             (line   30)
* wc_mintypmax:                          Functions and Variables for wrstcse.
                                                             (line  107)
* wc_mintypmax2tol:                      Functions and Variables for wrstcse.
                                                             (line  166)
* wc_montecarlo:                         Functions and Variables for wrstcse.
                                                             (line   79)
* wc_systematic:                         Functions and Variables for wrstcse.
                                                             (line   50)
* wc_tolappend:                          Functions and Variables for wrstcse.
                                                             (line  135)
* wc_typicalvalues:                      Functions and Variables for wrstcse.
                                                             (line    6)
* Wedge product:                         Functions and Variables for itensor.
                                                             (line 1409)
* weyl:                                  Functions and Variables for ctensor.
                                                             (line 1208)
* weyl <1>:                              Functions and Variables for ctensor.
                                                             (line  302)
* wheel_graph:                           Functions and Variables for graphs.
                                                             (line  316)
* while:                                 Functions and Variables for Program Flow.
                                                             (line   55)
* width:                                 Visualization with VTK.
                                                             (line  104)
* wiener_index:                          Functions and Variables for graphs.
                                                             (line 1171)
* wigner_3j:                             Functions and Variables for clebsch_gordan.
                                                             (line   20)
* wigner_6j:                             Functions and Variables for clebsch_gordan.
                                                             (line   25)
* wigner_9j:                             Functions and Variables for clebsch_gordan.
                                                             (line   29)
* window:                                Plotting Options.   (line  469)
* windowname:                            Visualization with VTK.
                                                             (line  110)
* windowtitle:                           Visualization with VTK.
                                                             (line  117)
* wired_surface:                         Functions and Variables for draw.
                                                             (line 2066)
* wireframe:                             Visualization with VTK.
                                                             (line  391)
* with_default_2d_display:               Functions and Variables for Display.
                                                             (line  371)
* with_stdout:                           Functions and Variables for File Input and Output.
                                                             (line  482)
* writebyte:                             String Input and Output.
                                                             (line  339)
* writefile:                             Functions and Variables for File Input and Output.
                                                             (line  512)
* write_binary_data:                     Functions and Variables for binary input and output.
                                                             (line   74)
* write_data:                            Functions and Variables for plain-text input and output.
                                                             (line  130)
* wronskian:                             Package functs.     (line   14)
* x:                                     Plotting Options.   (line  475)
* xaxis:                                 Functions and Variables for draw.
                                                             (line 2090)
* xaxis_color:                           Functions and Variables for draw.
                                                             (line 2107)
* xaxis_secondary:                       Functions and Variables for draw.
                                                             (line 2124)
* xaxis_type:                            Functions and Variables for draw.
                                                             (line 2150)
* xaxis_width:                           Functions and Variables for draw.
                                                             (line 2167)
* xlabel:                                Plotting Options.   (line  484)
* xlabel <1>:                            Functions and Variables for draw.
                                                             (line 2184)
* xlabel_secondary:                      Functions and Variables for draw.
                                                             (line 2202)
* xlength:                               Visualization with VTK.
                                                             (line  373)
* xrange:                                Functions and Variables for draw.
                                                             (line 2224)
* xrange_secondary:                      Functions and Variables for draw.
                                                             (line 2243)
* xreduce:                               Functions and Variables for Lists.
                                                             (line 1025)
* xthru:                                 Functions and Variables for Simplification.
                                                             (line  776)
* xtics:                                 Plotting Options.   (line  492)
* xtics <1>:                             Functions and Variables for draw.
                                                             (line 2257)
* xtics_axis:                            Functions and Variables for draw.
                                                             (line 2312)
* xtics_rotate:                          Functions and Variables for draw.
                                                             (line 2322)
* xtics_rotate_secondary:                Functions and Variables for draw.
                                                             (line 2331)
* xtics_secondary:                       Functions and Variables for draw.
                                                             (line 2340)
* xtics_secondary_axis:                  Functions and Variables for draw.
                                                             (line 2348)
* xu_grid:                               Functions and Variables for draw.
                                                             (line 2358)
* xyplane:                               Functions and Variables for draw.
                                                             (line 2386)
* xy_file:                               Functions and Variables for draw.
                                                             (line 2376)
* xy_scale:                              Plotting Options.   (line  507)
* x_voxel:                               Functions and Variables for draw.
                                                             (line 2083)
* y:                                     Plotting Options.   (line  518)
* yaxis:                                 Functions and Variables for draw.
                                                             (line 2409)
* yaxis_color:                           Functions and Variables for draw.
                                                             (line 2425)
* yaxis_secondary:                       Functions and Variables for draw.
                                                             (line 2442)
* yaxis_type:                            Functions and Variables for draw.
                                                             (line 2464)
* yaxis_width:                           Functions and Variables for draw.
                                                             (line 2481)
* ylabel:                                Plotting Options.   (line  525)
* ylabel <1>:                            Functions and Variables for draw.
                                                             (line 2498)
* ylabel_secondary:                      Functions and Variables for draw.
                                                             (line 2516)
* ylength:                               Visualization with VTK.
                                                             (line  379)
* yp:                                    Functions and Variables for Differential Equations.
                                                             (line  188)
* yrange:                                Functions and Variables for draw.
                                                             (line 2542)
* yrange_secondary:                      Functions and Variables for draw.
                                                             (line 2562)
* ytics:                                 Plotting Options.   (line  533)
* ytics <1>:                             Functions and Variables for draw.
                                                             (line 2587)
* ytics_axis:                            Functions and Variables for draw.
                                                             (line 2595)
* ytics_rotate:                          Functions and Variables for draw.
                                                             (line 2605)
* ytics_rotate_secondary:                Functions and Variables for draw.
                                                             (line 2614)
* ytics_secondary:                       Functions and Variables for draw.
                                                             (line 2623)
* ytics_secondary_axis:                  Functions and Variables for draw.
                                                             (line 2631)
* yv_grid:                               Functions and Variables for draw.
                                                             (line 2641)
* yx_ratio:                              Plotting Options.   (line  548)
* y_voxel:                               Functions and Variables for draw.
                                                             (line 2402)
* z:                                     Plotting Options.   (line  553)
* zaxis:                                 Functions and Variables for draw.
                                                             (line 2667)
* zaxis_color:                           Functions and Variables for draw.
                                                             (line 2685)
* zaxis_type:                            Functions and Variables for draw.
                                                             (line 2704)
* zaxis_width:                           Functions and Variables for draw.
                                                             (line 2722)
* Zeilberger:                            Functions and Variables for zeilberger.
                                                             (line   71)
* zeroa:                                 Functions and Variables for Constants.
                                                             (line  172)
* zerob:                                 Functions and Variables for Constants.
                                                             (line  189)
* zerobern:                              Functions and Variables for Number Theory.
                                                             (line  519)
* zeroequiv:                             Functions and Variables for Predicates.
                                                             (line  187)
* zerofor:                               Functions and Variables for linearalgebra.
                                                             (line  639)
* zeromatrix:                            Functions and Variables for Matrices and Linear Algebra.
                                                             (line 1314)
* zeromatrixp:                           Functions and Variables for linearalgebra.
                                                             (line  654)
* zeta:                                  Functions and Variables for Number Theory.
                                                             (line  526)
* zeta%pi:                               Functions and Variables for Number Theory.
                                                             (line  559)
* zgeev:                                 Functions and Variables for lapack.
                                                             (line  405)
* zheev:                                 Functions and Variables for lapack.
                                                             (line  411)
* zlabel:                                Plotting Options.   (line  558)
* zlabel <1>:                            Functions and Variables for draw.
                                                             (line 2740)
* zlabel_rotate:                         Functions and Variables for draw.
                                                             (line 2758)
* zlange:                                Functions and Variables for lapack.
                                                             (line  279)
* zlength:                               Visualization with VTK.
                                                             (line  385)
* zmin:                                  Plotting Options.   (line  566)
* zn_add_table:                          Functions and Variables for Number Theory.
                                                             (line  578)
* zn_carmichael_lambda:                  Functions and Variables for Number Theory.
                                                             (line  659)
* zn_characteristic_factors:             Functions and Variables for Number Theory.
                                                             (line  584)
* zn_determinant:                        Functions and Variables for Number Theory.
                                                             (line  666)
* zn_factor_generators:                  Functions and Variables for Number Theory.
                                                             (line  694)
* zn_invert_by_lu:                       Functions and Variables for Number Theory.
                                                             (line  701)
* zn_log:                                Functions and Variables for Number Theory.
                                                             (line  727)
* zn_mult_table:                         Functions and Variables for Number Theory.
                                                             (line  798)
* zn_nth_root:                           Functions and Variables for Number Theory.
                                                             (line  905)
* zn_order:                              Functions and Variables for Number Theory.
                                                             (line 1013)
* zn_power_table:                        Functions and Variables for Number Theory.
                                                             (line 1063)
* zn_primroot:                           Functions and Variables for Number Theory.
                                                             (line 1154)
* zn_primroot_limit:                     Functions and Variables for Number Theory.
                                                             (line 1212)
* zn_primroot_p:                         Functions and Variables for Number Theory.
                                                             (line 1220)
* zn_primroot_pretest:                   Functions and Variables for Number Theory.
                                                             (line 1262)
* zn_primroot_verbose:                   Functions and Variables for Number Theory.
                                                             (line 1274)
* zrange:                                Functions and Variables for draw.
                                                             (line 2778)
* ztics:                                 Plotting Options.   (line  574)
* ztics <1>:                             Functions and Variables for draw.
                                                             (line 2799)
* ztics_axis:                            Functions and Variables for draw.
                                                             (line 2807)
* ztics_rotate:                          Functions and Variables for draw.
                                                             (line 2817)
* z_voxel:                               Functions and Variables for draw.
                                                             (line 2660)

